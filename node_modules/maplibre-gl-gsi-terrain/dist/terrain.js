const u = `
function gsidem2terrarium(r, g, b) {
	let rgb = (r << 16) + (g << 8) + b;
	let h = 0;
	if (rgb < 0x800000) h = rgb * 0.01;
	else if (rgb > 0x800000) h = (rgb - Math.pow(2, 24)) * 0.01;
	const value = h + 32768;
	const tR = Math.floor(value / 256);
	const tG = Math.floor(value) % 256;
	const tB = Math.floor((value - Math.floor(value)) * 256);
	return [tR, tG, tB];
}

self.onmessage = async (e) => {
	const { imageBitmap, id } = e.data;
	const canvas = new OffscreenCanvas(imageBitmap.width, imageBitmap.height);
	const context = canvas.getContext('2d', { willReadFrequently: true });

	// \u7121\u52B9\u5024\u306E\u30D5\u30A9\u30FC\u30EB\u30D0\u30C3\u30AF\u7528\u306B\u80CC\u666F\u3092\u5857\u308A\u3064\u3076\u3059
	context.fillStyle = 'rgb(128,0,0)';
	context.fillRect(0, 0, canvas.width, canvas.height);

	context.drawImage(imageBitmap, 0, 0);
	imageBitmap.close();

	const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
	for (let i = 0; i < imageData.data.length / 4; i++) {
		const tRGB = gsidem2terrarium(
			imageData.data[i * 4],
			imageData.data[i * 4 + 1],
			imageData.data[i * 4 + 2],
		);
		imageData.data[i * 4] = tRGB[0];
		imageData.data[i * 4 + 1] = tRGB[1];
		imageData.data[i * 4 + 2] = tRGB[2];
	}
	context.putImageData(imageData, 0, 0);

	const blob = await canvas.convertToBlob({ type: 'image/png' });
	const arrayBuffer = await blob.arrayBuffer();
	const png = new Uint8Array(arrayBuffer);
	self.postMessage({ png, id }, [png.buffer]);
};
`;
let s = null, m = 0;
const c = /* @__PURE__ */ new Map();
function f() {
  if (!s) {
    const n = new Blob([u], { type: "application/javascript" });
    s = new Worker(URL.createObjectURL(n)), s.onmessage = (t) => {
      const { png: e, id: a } = t.data, r = c.get(a);
      r && (r.resolve(e), c.delete(a));
    }, s.onerror = (t) => {
      c.forEach(
        (e) => e.reject(new Error(t.message))
      ), c.clear();
    };
  }
  return s;
}
async function d(n) {
  const t = await fetch(n);
  if (!t.ok)
    throw new Error(`Failed to fetch: ${t.status}`);
  const e = await t.blob(), a = await createImageBitmap(e);
  return new Promise((r, o) => {
    const i = m++;
    c.set(i, { resolve: r, reject: o }), f().postMessage({ imageBitmap: a, id: i }, [a]);
  });
}
function h(n, t, e) {
  let a = (n << 16) + (t << 8) + e, r = 0;
  a < 8388608 ? r = a * 0.01 : a > 8388608 && (r = (a - Math.pow(2, 24)) * 0.01);
  const o = r + 32768, i = Math.floor(o / 256), g = Math.floor(o) % 256, l = Math.floor((o - Math.floor(o)) * 256);
  return [i, g, l];
}
const b = (n, t = {}) => {
  var o, i, g, l;
  const e = "gsidem", a = p(e);
  return n(e, a), {
    type: "raster-dem",
    encoding: "terrarium",
    tiles: [`gsidem://${(o = t.tileUrl) != null ? o : "https://cyberjapandata.gsi.go.jp/xyz/dem_png/{z}/{x}/{y}.png"}`],
    tileSize: 256,
    minzoom: (i = t.minzoom) != null ? i : 1,
    maxzoom: (g = t.maxzoom) != null ? g : 14,
    attribution: (l = t.attribution) != null ? l : ""
  };
}, p = (n) => async (t, e) => {
  const a = t.url.replace(`${n}://`, "");
  return { data: await d(a).catch((o) => {
    throw e.abort(), o.message;
  }) };
};
export {
  p as getGsiDemProtocolAction,
  h as gsidem2terrarium,
  b as useGsiTerrainSource
};
