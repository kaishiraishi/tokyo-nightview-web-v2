import {
  COORDINATE_SYSTEM,
  CubeGeometry,
  Geometry,
  GlobeViewport,
  GroupNode,
  LayersPass,
  Model,
  ModelNode,
  OrthographicViewport,
  PickLayersPass,
  ScenegraphNode,
  Tesselator,
  UNIT,
  color_default,
  composite_layer_default,
  createIterable,
  deepEqual,
  flatten,
  fp64,
  fp64LowPart,
  gouraudMaterial,
  layer_default,
  layer_extension_default,
  lngLatToWorld,
  log_default,
  memoize,
  mergeShaders,
  pbrMaterial,
  phongMaterial,
  picking_default,
  project32_default,
  project_default,
  web_mercator_viewport_default,
  worldToLngLat
} from "./chunk-POPK76MQ.js";
import {
  Texture,
  log as log2
} from "./chunk-6TPAVNL4.js";
import {
  AxisAlignedBoundingBox,
  CullingVolume,
  GLTFLoader,
  Plane,
  TILE_TYPE,
  Tiles3DLoader,
  Tileset3D,
  makeOrientedBoundingBoxFromPoints,
  postProcessGLTF
} from "./chunk-XKDVC4GW.js";
import {
  ImageLoader,
  ImageSource,
  Matrix4,
  Quaternion,
  RequestScheduler,
  concatenateTypedArrays,
  deduceTableSchema,
  equals,
  getMeshBoundingBox,
  lerp,
  load,
  log,
  mergeLoaderOptions,
  parseFromContext,
  vec3_exports
} from "./chunk-DHFOCZMC.js";
import {
  Stat,
  Stats
} from "./chunk-4THHDC3Z.js";
import {
  __commonJS,
  __publicField,
  __require,
  __toESM
} from "./chunk-2TUXWMP5.js";

// node_modules/@deck.gl/layers/node_modules/earcut/src/earcut.js
var require_earcut = __commonJS({
  "node_modules/@deck.gl/layers/node_modules/earcut/src/earcut.js"(exports, module) {
    "use strict";
    module.exports = earcut3;
    module.exports.default = earcut3;
    function earcut3(data, holeIndices, dim) {
      dim = dim || 2;
      var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList2(data, 0, outerLen, dim, true), triangles = [];
      if (!outerNode || outerNode.next === outerNode.prev) return triangles;
      var minX, minY, maxX, maxY, x, y, invSize;
      if (hasHoles) outerNode = eliminateHoles2(data, holeIndices, outerNode, dim);
      if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for (var i = dim; i < outerLen; i += dim) {
          x = data[i];
          y = data[i + 1];
          if (x < minX) minX = x;
          if (y < minY) minY = y;
          if (x > maxX) maxX = x;
          if (y > maxY) maxY = y;
        }
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
      }
      earcutLinked2(outerNode, triangles, dim, minX, minY, invSize, 0);
      return triangles;
    }
    function linkedList2(data, start, end, dim, clockwise) {
      var i, last;
      if (clockwise === signedArea2(data, start, end, dim) > 0) {
        for (i = start; i < end; i += dim) last = insertNode2(i, data[i], data[i + 1], last);
      } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode2(i, data[i], data[i + 1], last);
      }
      if (last && equals7(last, last.next)) {
        removeNode2(last);
        last = last.next;
      }
      return last;
    }
    function filterPoints2(start, end) {
      if (!start) return start;
      if (!end) end = start;
      var p = start, again;
      do {
        again = false;
        if (!p.steiner && (equals7(p, p.next) || area2(p.prev, p, p.next) === 0)) {
          removeNode2(p);
          p = end = p.prev;
          if (p === p.next) break;
          again = true;
        } else {
          p = p.next;
        }
      } while (again || p !== end);
      return end;
    }
    function earcutLinked2(ear, triangles, dim, minX, minY, invSize, pass) {
      if (!ear) return;
      if (!pass && invSize) indexCurve2(ear, minX, minY, invSize);
      var stop = ear, prev, next;
      while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed2(ear, minX, minY, invSize) : isEar2(ear)) {
          triangles.push(prev.i / dim | 0);
          triangles.push(ear.i / dim | 0);
          triangles.push(next.i / dim | 0);
          removeNode2(ear);
          ear = next.next;
          stop = next.next;
          continue;
        }
        ear = next;
        if (ear === stop) {
          if (!pass) {
            earcutLinked2(filterPoints2(ear), triangles, dim, minX, minY, invSize, 1);
          } else if (pass === 1) {
            ear = cureLocalIntersections2(filterPoints2(ear), triangles, dim);
            earcutLinked2(ear, triangles, dim, minX, minY, invSize, 2);
          } else if (pass === 2) {
            splitEarcut2(ear, triangles, dim, minX, minY, invSize);
          }
          break;
        }
      }
    }
    function isEar2(ear) {
      var a2 = ear.prev, b2 = ear, c2 = ear.next;
      if (area2(a2, b2, c2) >= 0) return false;
      var ax = a2.x, bx = b2.x, cx = c2.x, ay = a2.y, by = b2.y, cy = c2.y;
      var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
      var p = c2.next;
      while (p !== a2) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle2(ax, ay, bx, by, cx, cy, p.x, p.y) && area2(p.prev, p, p.next) >= 0) return false;
        p = p.next;
      }
      return true;
    }
    function isEarHashed2(ear, minX, minY, invSize) {
      var a2 = ear.prev, b2 = ear, c2 = ear.next;
      if (area2(a2, b2, c2) >= 0) return false;
      var ax = a2.x, bx = b2.x, cx = c2.x, ay = a2.y, by = b2.y, cy = c2.y;
      var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
      var minZ = zOrder2(x0, y0, minX, minY, invSize), maxZ = zOrder2(x1, y1, minX, minY, invSize);
      var p = ear.prevZ, n = ear.nextZ;
      while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a2 && p !== c2 && pointInTriangle2(ax, ay, bx, by, cx, cy, p.x, p.y) && area2(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a2 && n !== c2 && pointInTriangle2(ax, ay, bx, by, cx, cy, n.x, n.y) && area2(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
      }
      while (p && p.z >= minZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a2 && p !== c2 && pointInTriangle2(ax, ay, bx, by, cx, cy, p.x, p.y) && area2(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
      }
      while (n && n.z <= maxZ) {
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a2 && n !== c2 && pointInTriangle2(ax, ay, bx, by, cx, cy, n.x, n.y) && area2(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
      }
      return true;
    }
    function cureLocalIntersections2(start, triangles, dim) {
      var p = start;
      do {
        var a2 = p.prev, b2 = p.next.next;
        if (!equals7(a2, b2) && intersects2(a2, p, p.next, b2) && locallyInside2(a2, b2) && locallyInside2(b2, a2)) {
          triangles.push(a2.i / dim | 0);
          triangles.push(p.i / dim | 0);
          triangles.push(b2.i / dim | 0);
          removeNode2(p);
          removeNode2(p.next);
          p = start = b2;
        }
        p = p.next;
      } while (p !== start);
      return filterPoints2(p);
    }
    function splitEarcut2(start, triangles, dim, minX, minY, invSize) {
      var a2 = start;
      do {
        var b2 = a2.next.next;
        while (b2 !== a2.prev) {
          if (a2.i !== b2.i && isValidDiagonal2(a2, b2)) {
            var c2 = splitPolygon2(a2, b2);
            a2 = filterPoints2(a2, a2.next);
            c2 = filterPoints2(c2, c2.next);
            earcutLinked2(a2, triangles, dim, minX, minY, invSize, 0);
            earcutLinked2(c2, triangles, dim, minX, minY, invSize, 0);
            return;
          }
          b2 = b2.next;
        }
        a2 = a2.next;
      } while (a2 !== start);
    }
    function eliminateHoles2(data, holeIndices, outerNode, dim) {
      var queue = [], i, len4, start, end, list;
      for (i = 0, len4 = holeIndices.length; i < len4; i++) {
        start = holeIndices[i] * dim;
        end = i < len4 - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList2(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost2(list));
      }
      queue.sort(compareX2);
      for (i = 0; i < queue.length; i++) {
        outerNode = eliminateHole2(queue[i], outerNode);
      }
      return outerNode;
    }
    function compareX2(a2, b2) {
      return a2.x - b2.x;
    }
    function eliminateHole2(hole, outerNode) {
      var bridge = findHoleBridge2(hole, outerNode);
      if (!bridge) {
        return outerNode;
      }
      var bridgeReverse = splitPolygon2(bridge, hole);
      filterPoints2(bridgeReverse, bridgeReverse.next);
      return filterPoints2(bridge, bridge.next);
    }
    function findHoleBridge2(hole, outerNode) {
      var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
      do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
          var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
          if (x <= hx && x > qx) {
            qx = x;
            m = p.x < p.next.x ? p : p.next;
            if (x === hx) return m;
          }
        }
        p = p.next;
      } while (p !== outerNode);
      if (!m) return null;
      var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
      p = m;
      do {
        if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle2(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
          tan = Math.abs(hy - p.y) / (hx - p.x);
          if (locallyInside2(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector2(m, p)))) {
            m = p;
            tanMin = tan;
          }
        }
        p = p.next;
      } while (p !== stop);
      return m;
    }
    function sectorContainsSector2(m, p) {
      return area2(m.prev, m, p.prev) < 0 && area2(p.next, m, m.next) < 0;
    }
    function indexCurve2(start, minX, minY, invSize) {
      var p = start;
      do {
        if (p.z === 0) p.z = zOrder2(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
      } while (p !== start);
      p.prevZ.nextZ = null;
      p.prevZ = null;
      sortLinked2(p);
    }
    function sortLinked2(list) {
      var i, p, q, e2, tail, numMerges, pSize, qSize, inSize = 1;
      do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;
        while (p) {
          numMerges++;
          q = p;
          pSize = 0;
          for (i = 0; i < inSize; i++) {
            pSize++;
            q = q.nextZ;
            if (!q) break;
          }
          qSize = inSize;
          while (pSize > 0 || qSize > 0 && q) {
            if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
              e2 = p;
              p = p.nextZ;
              pSize--;
            } else {
              e2 = q;
              q = q.nextZ;
              qSize--;
            }
            if (tail) tail.nextZ = e2;
            else list = e2;
            e2.prevZ = tail;
            tail = e2;
          }
          p = q;
        }
        tail.nextZ = null;
        inSize *= 2;
      } while (numMerges > 1);
      return list;
    }
    function zOrder2(x, y, minX, minY, invSize) {
      x = (x - minX) * invSize | 0;
      y = (y - minY) * invSize | 0;
      x = (x | x << 8) & 16711935;
      x = (x | x << 4) & 252645135;
      x = (x | x << 2) & 858993459;
      x = (x | x << 1) & 1431655765;
      y = (y | y << 8) & 16711935;
      y = (y | y << 4) & 252645135;
      y = (y | y << 2) & 858993459;
      y = (y | y << 1) & 1431655765;
      return x | y << 1;
    }
    function getLeftmost2(start) {
      var p = start, leftmost = start;
      do {
        if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
        p = p.next;
      } while (p !== start);
      return leftmost;
    }
    function pointInTriangle2(ax, ay, bx, by, cx, cy, px, py) {
      return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
    }
    function isValidDiagonal2(a2, b2) {
      return a2.next.i !== b2.i && a2.prev.i !== b2.i && !intersectsPolygon2(a2, b2) && // dones't intersect other edges
      (locallyInside2(a2, b2) && locallyInside2(b2, a2) && middleInside2(a2, b2) && // locally visible
      (area2(a2.prev, a2, b2.prev) || area2(a2, b2.prev, b2)) || // does not create opposite-facing sectors
      equals7(a2, b2) && area2(a2.prev, a2, a2.next) > 0 && area2(b2.prev, b2, b2.next) > 0);
    }
    function area2(p, q, r) {
      return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    }
    function equals7(p1, p2) {
      return p1.x === p2.x && p1.y === p2.y;
    }
    function intersects2(p1, q1, p2, q2) {
      var o1 = sign2(area2(p1, q1, p2));
      var o2 = sign2(area2(p1, q1, q2));
      var o3 = sign2(area2(p2, q2, p1));
      var o4 = sign2(area2(p2, q2, q1));
      if (o1 !== o2 && o3 !== o4) return true;
      if (o1 === 0 && onSegment2(p1, p2, q1)) return true;
      if (o2 === 0 && onSegment2(p1, q2, q1)) return true;
      if (o3 === 0 && onSegment2(p2, p1, q2)) return true;
      if (o4 === 0 && onSegment2(p2, q1, q2)) return true;
      return false;
    }
    function onSegment2(p, q, r) {
      return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
    }
    function sign2(num) {
      return num > 0 ? 1 : num < 0 ? -1 : 0;
    }
    function intersectsPolygon2(a2, b2) {
      var p = a2;
      do {
        if (p.i !== a2.i && p.next.i !== a2.i && p.i !== b2.i && p.next.i !== b2.i && intersects2(p, p.next, a2, b2)) return true;
        p = p.next;
      } while (p !== a2);
      return false;
    }
    function locallyInside2(a2, b2) {
      return area2(a2.prev, a2, a2.next) < 0 ? area2(a2, b2, a2.next) >= 0 && area2(a2, a2.prev, b2) >= 0 : area2(a2, b2, a2.prev) < 0 || area2(a2, a2.next, b2) < 0;
    }
    function middleInside2(a2, b2) {
      var p = a2, inside = false, px = (a2.x + b2.x) / 2, py = (a2.y + b2.y) / 2;
      do {
        if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
          inside = !inside;
        p = p.next;
      } while (p !== a2);
      return inside;
    }
    function splitPolygon2(a2, b2) {
      var a22 = new Node(a2.i, a2.x, a2.y), b22 = new Node(b2.i, b2.x, b2.y), an = a2.next, bp = b2.prev;
      a2.next = b2;
      b2.prev = a2;
      a22.next = an;
      an.prev = a22;
      b22.next = a22;
      a22.prev = b22;
      bp.next = b22;
      b22.prev = bp;
      return b22;
    }
    function insertNode2(i, x, y, last) {
      var p = new Node(i, x, y);
      if (!last) {
        p.prev = p;
        p.next = p;
      } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
      }
      return p;
    }
    function removeNode2(p) {
      p.next.prev = p.prev;
      p.prev.next = p.next;
      if (p.prevZ) p.prevZ.nextZ = p.nextZ;
      if (p.nextZ) p.nextZ.prevZ = p.prevZ;
    }
    function Node(i, x, y) {
      this.i = i;
      this.x = x;
      this.y = y;
      this.prev = null;
      this.next = null;
      this.z = 0;
      this.prevZ = null;
      this.nextZ = null;
      this.steiner = false;
    }
    earcut3.deviation = function(data, holeIndices, dim, triangles) {
      var hasHoles = holeIndices && holeIndices.length;
      var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
      var polygonArea = Math.abs(signedArea2(data, 0, outerLen, dim));
      if (hasHoles) {
        for (var i = 0, len4 = holeIndices.length; i < len4; i++) {
          var start = holeIndices[i] * dim;
          var end = i < len4 - 1 ? holeIndices[i + 1] * dim : data.length;
          polygonArea -= Math.abs(signedArea2(data, start, end, dim));
        }
      }
      var trianglesArea = 0;
      for (i = 0; i < triangles.length; i += 3) {
        var a2 = triangles[i] * dim;
        var b2 = triangles[i + 1] * dim;
        var c2 = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
          (data[a2] - data[c2]) * (data[b2 + 1] - data[a2 + 1]) - (data[a2] - data[b2]) * (data[c2 + 1] - data[a2 + 1])
        );
      }
      return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
    };
    function signedArea2(data, start, end, dim) {
      var sum = 0;
      for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
      }
      return sum;
    }
    earcut3.flatten = function(data) {
      var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
      for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
          for (var d2 = 0; d2 < dim; d2++) result.vertices.push(data[i][j][d2]);
        }
        if (i > 0) {
          holeIndex += data[i - 1].length;
          result.holes.push(holeIndex);
        }
      }
      return result;
    };
  }
});

// node_modules/fast-xml-parser/src/util.js
var require_util = __commonJS({
  "node_modules/fast-xml-parser/src/util.js"(exports) {
    "use strict";
    var nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
    var nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
    var nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
    var regexName = new RegExp("^" + nameRegexp + "$");
    var getAllMatches = function(string, regex) {
      const matches = [];
      let match = regex.exec(string);
      while (match) {
        const allmatches = [];
        allmatches.startIndex = regex.lastIndex - match[0].length;
        const len4 = match.length;
        for (let index = 0; index < len4; index++) {
          allmatches.push(match[index]);
        }
        matches.push(allmatches);
        match = regex.exec(string);
      }
      return matches;
    };
    var isName = function(string) {
      const match = regexName.exec(string);
      return !(match === null || typeof match === "undefined");
    };
    exports.isExist = function(v2) {
      return typeof v2 !== "undefined";
    };
    exports.isEmptyObject = function(obj) {
      return Object.keys(obj).length === 0;
    };
    exports.merge = function(target, a2, arrayMode) {
      if (a2) {
        const keys = Object.keys(a2);
        const len4 = keys.length;
        for (let i = 0; i < len4; i++) {
          if (arrayMode === "strict") {
            target[keys[i]] = [a2[keys[i]]];
          } else {
            target[keys[i]] = a2[keys[i]];
          }
        }
      }
    };
    exports.getValue = function(v2) {
      if (exports.isExist(v2)) {
        return v2;
      } else {
        return "";
      }
    };
    exports.isName = isName;
    exports.getAllMatches = getAllMatches;
    exports.nameRegexp = nameRegexp;
  }
});

// node_modules/fast-xml-parser/src/validator.js
var require_validator = __commonJS({
  "node_modules/fast-xml-parser/src/validator.js"(exports) {
    "use strict";
    var util = require_util();
    var defaultOptions3 = {
      allowBooleanAttributes: false,
      //A tag can have attributes without any value
      unpairedTags: []
    };
    exports.validate = function(xmlData, options) {
      options = Object.assign({}, defaultOptions3, options);
      const tags = [];
      let tagFound = false;
      let reachedRoot = false;
      if (xmlData[0] === "\uFEFF") {
        xmlData = xmlData.substr(1);
      }
      for (let i = 0; i < xmlData.length; i++) {
        if (xmlData[i] === "<" && xmlData[i + 1] === "?") {
          i += 2;
          i = readPI(xmlData, i);
          if (i.err) return i;
        } else if (xmlData[i] === "<") {
          let tagStartPos = i;
          i++;
          if (xmlData[i] === "!") {
            i = readCommentAndCDATA(xmlData, i);
            continue;
          } else {
            let closingTag = false;
            if (xmlData[i] === "/") {
              closingTag = true;
              i++;
            }
            let tagName = "";
            for (; i < xmlData.length && xmlData[i] !== ">" && xmlData[i] !== " " && xmlData[i] !== "	" && xmlData[i] !== "\n" && xmlData[i] !== "\r"; i++) {
              tagName += xmlData[i];
            }
            tagName = tagName.trim();
            if (tagName[tagName.length - 1] === "/") {
              tagName = tagName.substring(0, tagName.length - 1);
              i--;
            }
            if (!validateTagName(tagName)) {
              let msg;
              if (tagName.trim().length === 0) {
                msg = "Invalid space after '<'.";
              } else {
                msg = "Tag '" + tagName + "' is an invalid name.";
              }
              return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i));
            }
            const result = readAttributeStr(xmlData, i);
            if (result === false) {
              return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i));
            }
            let attrStr = result.value;
            i = result.index;
            if (attrStr[attrStr.length - 1] === "/") {
              const attrStrStart = i - attrStr.length;
              attrStr = attrStr.substring(0, attrStr.length - 1);
              const isValid = validateAttributeString(attrStr, options);
              if (isValid === true) {
                tagFound = true;
              } else {
                return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
              }
            } else if (closingTag) {
              if (!result.tagClosed) {
                return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i));
              } else if (attrStr.trim().length > 0) {
                return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
              } else if (tags.length === 0) {
                return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' has not been opened.", getLineNumberForPosition(xmlData, tagStartPos));
              } else {
                const otg = tags.pop();
                if (tagName !== otg.tagName) {
                  let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
                  return getErrorObject(
                    "InvalidTag",
                    "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.",
                    getLineNumberForPosition(xmlData, tagStartPos)
                  );
                }
                if (tags.length == 0) {
                  reachedRoot = true;
                }
              }
            } else {
              const isValid = validateAttributeString(attrStr, options);
              if (isValid !== true) {
                return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));
              }
              if (reachedRoot === true) {
                return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i));
              } else if (options.unpairedTags.indexOf(tagName) !== -1) {
              } else {
                tags.push({ tagName, tagStartPos });
              }
              tagFound = true;
            }
            for (i++; i < xmlData.length; i++) {
              if (xmlData[i] === "<") {
                if (xmlData[i + 1] === "!") {
                  i++;
                  i = readCommentAndCDATA(xmlData, i);
                  continue;
                } else if (xmlData[i + 1] === "?") {
                  i = readPI(xmlData, ++i);
                  if (i.err) return i;
                } else {
                  break;
                }
              } else if (xmlData[i] === "&") {
                const afterAmp = validateAmpersand(xmlData, i);
                if (afterAmp == -1)
                  return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i));
                i = afterAmp;
              } else {
                if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {
                  return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i));
                }
              }
            }
            if (xmlData[i] === "<") {
              i--;
            }
          }
        } else {
          if (isWhiteSpace(xmlData[i])) {
            continue;
          }
          return getErrorObject("InvalidChar", "char '" + xmlData[i] + "' is not expected.", getLineNumberForPosition(xmlData, i));
        }
      }
      if (!tagFound) {
        return getErrorObject("InvalidXml", "Start tag expected.", 1);
      } else if (tags.length == 1) {
        return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
      } else if (tags.length > 0) {
        return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t) => t.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
      }
      return true;
    };
    function isWhiteSpace(char) {
      return char === " " || char === "	" || char === "\n" || char === "\r";
    }
    function readPI(xmlData, i) {
      const start = i;
      for (; i < xmlData.length; i++) {
        if (xmlData[i] == "?" || xmlData[i] == " ") {
          const tagname = xmlData.substr(start, i - start);
          if (i > 5 && tagname === "xml") {
            return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i));
          } else if (xmlData[i] == "?" && xmlData[i + 1] == ">") {
            i++;
            break;
          } else {
            continue;
          }
        }
      }
      return i;
    }
    function readCommentAndCDATA(xmlData, i) {
      if (xmlData.length > i + 5 && xmlData[i + 1] === "-" && xmlData[i + 2] === "-") {
        for (i += 3; i < xmlData.length; i++) {
          if (xmlData[i] === "-" && xmlData[i + 1] === "-" && xmlData[i + 2] === ">") {
            i += 2;
            break;
          }
        }
      } else if (xmlData.length > i + 8 && xmlData[i + 1] === "D" && xmlData[i + 2] === "O" && xmlData[i + 3] === "C" && xmlData[i + 4] === "T" && xmlData[i + 5] === "Y" && xmlData[i + 6] === "P" && xmlData[i + 7] === "E") {
        let angleBracketsCount = 1;
        for (i += 8; i < xmlData.length; i++) {
          if (xmlData[i] === "<") {
            angleBracketsCount++;
          } else if (xmlData[i] === ">") {
            angleBracketsCount--;
            if (angleBracketsCount === 0) {
              break;
            }
          }
        }
      } else if (xmlData.length > i + 9 && xmlData[i + 1] === "[" && xmlData[i + 2] === "C" && xmlData[i + 3] === "D" && xmlData[i + 4] === "A" && xmlData[i + 5] === "T" && xmlData[i + 6] === "A" && xmlData[i + 7] === "[") {
        for (i += 8; i < xmlData.length; i++) {
          if (xmlData[i] === "]" && xmlData[i + 1] === "]" && xmlData[i + 2] === ">") {
            i += 2;
            break;
          }
        }
      }
      return i;
    }
    var doubleQuote = '"';
    var singleQuote = "'";
    function readAttributeStr(xmlData, i) {
      let attrStr = "";
      let startChar = "";
      let tagClosed = false;
      for (; i < xmlData.length; i++) {
        if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {
          if (startChar === "") {
            startChar = xmlData[i];
          } else if (startChar !== xmlData[i]) {
          } else {
            startChar = "";
          }
        } else if (xmlData[i] === ">") {
          if (startChar === "") {
            tagClosed = true;
            break;
          }
        }
        attrStr += xmlData[i];
      }
      if (startChar !== "") {
        return false;
      }
      return {
        value: attrStr,
        index: i,
        tagClosed
      };
    }
    var validAttrStrRegxp = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
    function validateAttributeString(attrStr, options) {
      const matches = util.getAllMatches(attrStr, validAttrStrRegxp);
      const attrNames = {};
      for (let i = 0; i < matches.length; i++) {
        if (matches[i][1].length === 0) {
          return getErrorObject("InvalidAttr", "Attribute '" + matches[i][2] + "' has no space in starting.", getPositionFromMatch(matches[i]));
        } else if (matches[i][3] !== void 0 && matches[i][4] === void 0) {
          return getErrorObject("InvalidAttr", "Attribute '" + matches[i][2] + "' is without value.", getPositionFromMatch(matches[i]));
        } else if (matches[i][3] === void 0 && !options.allowBooleanAttributes) {
          return getErrorObject("InvalidAttr", "boolean attribute '" + matches[i][2] + "' is not allowed.", getPositionFromMatch(matches[i]));
        }
        const attrName = matches[i][2];
        if (!validateAttrName(attrName)) {
          return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches[i]));
        }
        if (!attrNames.hasOwnProperty(attrName)) {
          attrNames[attrName] = 1;
        } else {
          return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches[i]));
        }
      }
      return true;
    }
    function validateNumberAmpersand(xmlData, i) {
      let re = /\d/;
      if (xmlData[i] === "x") {
        i++;
        re = /[\da-fA-F]/;
      }
      for (; i < xmlData.length; i++) {
        if (xmlData[i] === ";")
          return i;
        if (!xmlData[i].match(re))
          break;
      }
      return -1;
    }
    function validateAmpersand(xmlData, i) {
      i++;
      if (xmlData[i] === ";")
        return -1;
      if (xmlData[i] === "#") {
        i++;
        return validateNumberAmpersand(xmlData, i);
      }
      let count = 0;
      for (; i < xmlData.length; i++, count++) {
        if (xmlData[i].match(/\w/) && count < 20)
          continue;
        if (xmlData[i] === ";")
          break;
        return -1;
      }
      return i;
    }
    function getErrorObject(code, message, lineNumber) {
      return {
        err: {
          code,
          msg: message,
          line: lineNumber.line || lineNumber,
          col: lineNumber.col
        }
      };
    }
    function validateAttrName(attrName) {
      return util.isName(attrName);
    }
    function validateTagName(tagname) {
      return util.isName(tagname);
    }
    function getLineNumberForPosition(xmlData, index) {
      const lines = xmlData.substring(0, index).split(/\r?\n/);
      return {
        line: lines.length,
        // column number is last line's length + 1, because column numbering starts at 1:
        col: lines[lines.length - 1].length + 1
      };
    }
    function getPositionFromMatch(match) {
      return match.startIndex + match[1].length;
    }
  }
});

// node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js
var require_OptionsBuilder = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js"(exports) {
    var defaultOptions3 = {
      preserveOrder: false,
      attributeNamePrefix: "@_",
      attributesGroupName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      removeNSPrefix: false,
      // remove NS from tag name or attribute name if true
      allowBooleanAttributes: false,
      //a tag can have attributes without any value
      //ignoreRootElement : false,
      parseTagValue: true,
      parseAttributeValue: false,
      trimValues: true,
      //Trim string values of tag and attributes
      cdataPropName: false,
      numberParseOptions: {
        hex: true,
        leadingZeros: true,
        eNotation: true
      },
      tagValueProcessor: function(tagName, val) {
        return val;
      },
      attributeValueProcessor: function(attrName, val) {
        return val;
      },
      stopNodes: [],
      //nested tags will not be parsed even for errors
      alwaysCreateTextNode: false,
      isArray: () => false,
      commentPropName: false,
      unpairedTags: [],
      processEntities: true,
      htmlEntities: false,
      ignoreDeclaration: false,
      ignorePiTags: false,
      transformTagName: false,
      transformAttributeName: false,
      updateTag: function(tagName, jPath, attrs) {
        return tagName;
      }
      // skipEmptyListItem: false
    };
    var buildOptions = function(options) {
      return Object.assign({}, defaultOptions3, options);
    };
    exports.buildOptions = buildOptions;
    exports.defaultOptions = defaultOptions3;
  }
});

// node_modules/fast-xml-parser/src/xmlparser/xmlNode.js
var require_xmlNode = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/xmlNode.js"(exports, module) {
    "use strict";
    var XmlNode = class {
      constructor(tagname) {
        this.tagname = tagname;
        this.child = [];
        this[":@"] = {};
      }
      add(key, val) {
        if (key === "__proto__") key = "#__proto__";
        this.child.push({ [key]: val });
      }
      addChild(node) {
        if (node.tagname === "__proto__") node.tagname = "#__proto__";
        if (node[":@"] && Object.keys(node[":@"]).length > 0) {
          this.child.push({ [node.tagname]: node.child, [":@"]: node[":@"] });
        } else {
          this.child.push({ [node.tagname]: node.child });
        }
      }
    };
    module.exports = XmlNode;
  }
});

// node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js
var require_DocTypeReader = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js"(exports, module) {
    var util = require_util();
    function readDocType(xmlData, i) {
      const entities = {};
      if (xmlData[i + 3] === "O" && xmlData[i + 4] === "C" && xmlData[i + 5] === "T" && xmlData[i + 6] === "Y" && xmlData[i + 7] === "P" && xmlData[i + 8] === "E") {
        i = i + 9;
        let angleBracketsCount = 1;
        let hasBody = false, comment = false;
        let exp2 = "";
        for (; i < xmlData.length; i++) {
          if (xmlData[i] === "<" && !comment) {
            if (hasBody && isEntity(xmlData, i)) {
              i += 7;
              let entityName, val;
              [entityName, val, i] = readEntityExp(xmlData, i + 1);
              if (val.indexOf("&") === -1)
                entities[validateEntityName(entityName)] = {
                  regx: RegExp(`&${entityName};`, "g"),
                  val
                };
            } else if (hasBody && isElement(xmlData, i)) i += 8;
            else if (hasBody && isAttlist(xmlData, i)) i += 8;
            else if (hasBody && isNotation(xmlData, i)) i += 9;
            else if (isComment) comment = true;
            else throw new Error("Invalid DOCTYPE");
            angleBracketsCount++;
            exp2 = "";
          } else if (xmlData[i] === ">") {
            if (comment) {
              if (xmlData[i - 1] === "-" && xmlData[i - 2] === "-") {
                comment = false;
                angleBracketsCount--;
              }
            } else {
              angleBracketsCount--;
            }
            if (angleBracketsCount === 0) {
              break;
            }
          } else if (xmlData[i] === "[") {
            hasBody = true;
          } else {
            exp2 += xmlData[i];
          }
        }
        if (angleBracketsCount !== 0) {
          throw new Error(`Unclosed DOCTYPE`);
        }
      } else {
        throw new Error(`Invalid Tag instead of DOCTYPE`);
      }
      return { entities, i };
    }
    function readEntityExp(xmlData, i) {
      let entityName = "";
      for (; i < xmlData.length && (xmlData[i] !== "'" && xmlData[i] !== '"'); i++) {
        entityName += xmlData[i];
      }
      entityName = entityName.trim();
      if (entityName.indexOf(" ") !== -1) throw new Error("External entites are not supported");
      const startChar = xmlData[i++];
      let val = "";
      for (; i < xmlData.length && xmlData[i] !== startChar; i++) {
        val += xmlData[i];
      }
      return [entityName, val, i];
    }
    function isComment(xmlData, i) {
      if (xmlData[i + 1] === "!" && xmlData[i + 2] === "-" && xmlData[i + 3] === "-") return true;
      return false;
    }
    function isEntity(xmlData, i) {
      if (xmlData[i + 1] === "!" && xmlData[i + 2] === "E" && xmlData[i + 3] === "N" && xmlData[i + 4] === "T" && xmlData[i + 5] === "I" && xmlData[i + 6] === "T" && xmlData[i + 7] === "Y") return true;
      return false;
    }
    function isElement(xmlData, i) {
      if (xmlData[i + 1] === "!" && xmlData[i + 2] === "E" && xmlData[i + 3] === "L" && xmlData[i + 4] === "E" && xmlData[i + 5] === "M" && xmlData[i + 6] === "E" && xmlData[i + 7] === "N" && xmlData[i + 8] === "T") return true;
      return false;
    }
    function isAttlist(xmlData, i) {
      if (xmlData[i + 1] === "!" && xmlData[i + 2] === "A" && xmlData[i + 3] === "T" && xmlData[i + 4] === "T" && xmlData[i + 5] === "L" && xmlData[i + 6] === "I" && xmlData[i + 7] === "S" && xmlData[i + 8] === "T") return true;
      return false;
    }
    function isNotation(xmlData, i) {
      if (xmlData[i + 1] === "!" && xmlData[i + 2] === "N" && xmlData[i + 3] === "O" && xmlData[i + 4] === "T" && xmlData[i + 5] === "A" && xmlData[i + 6] === "T" && xmlData[i + 7] === "I" && xmlData[i + 8] === "O" && xmlData[i + 9] === "N") return true;
      return false;
    }
    function validateEntityName(name) {
      if (util.isName(name))
        return name;
      else
        throw new Error(`Invalid entity name ${name}`);
    }
    module.exports = readDocType;
  }
});

// node_modules/strnum/strnum.js
var require_strnum = __commonJS({
  "node_modules/strnum/strnum.js"(exports, module) {
    var hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
    var numRegex = /^([\-\+])?(0*)([0-9]*(\.[0-9]*)?)$/;
    var consider = {
      hex: true,
      // oct: false,
      leadingZeros: true,
      decimalPoint: ".",
      eNotation: true
      //skipLike: /regex/
    };
    function toNumber(str5, options = {}) {
      options = Object.assign({}, consider, options);
      if (!str5 || typeof str5 !== "string") return str5;
      let trimmedStr = str5.trim();
      if (options.skipLike !== void 0 && options.skipLike.test(trimmedStr)) return str5;
      else if (str5 === "0") return 0;
      else if (options.hex && hexRegex.test(trimmedStr)) {
        return parse_int(trimmedStr, 16);
      } else if (trimmedStr.search(/[eE]/) !== -1) {
        const notation = trimmedStr.match(/^([-\+])?(0*)([0-9]*(\.[0-9]*)?[eE][-\+]?[0-9]+)$/);
        if (notation) {
          if (options.leadingZeros) {
            trimmedStr = (notation[1] || "") + notation[3];
          } else {
            if (notation[2] === "0" && notation[3][0] === ".") {
            } else {
              return str5;
            }
          }
          return options.eNotation ? Number(trimmedStr) : str5;
        } else {
          return str5;
        }
      } else {
        const match = numRegex.exec(trimmedStr);
        if (match) {
          const sign2 = match[1];
          const leadingZeros = match[2];
          let numTrimmedByZeros = trimZeros(match[3]);
          if (!options.leadingZeros && leadingZeros.length > 0 && sign2 && trimmedStr[2] !== ".") return str5;
          else if (!options.leadingZeros && leadingZeros.length > 0 && !sign2 && trimmedStr[1] !== ".") return str5;
          else if (options.leadingZeros && leadingZeros === str5) return 0;
          else {
            const num = Number(trimmedStr);
            const numStr = "" + num;
            if (numStr.search(/[eE]/) !== -1) {
              if (options.eNotation) return num;
              else return str5;
            } else if (trimmedStr.indexOf(".") !== -1) {
              if (numStr === "0" && numTrimmedByZeros === "") return num;
              else if (numStr === numTrimmedByZeros) return num;
              else if (sign2 && numStr === "-" + numTrimmedByZeros) return num;
              else return str5;
            }
            if (leadingZeros) {
              return numTrimmedByZeros === numStr || sign2 + numTrimmedByZeros === numStr ? num : str5;
            } else {
              return trimmedStr === numStr || trimmedStr === sign2 + numStr ? num : str5;
            }
          }
        } else {
          return str5;
        }
      }
    }
    function trimZeros(numStr) {
      if (numStr && numStr.indexOf(".") !== -1) {
        numStr = numStr.replace(/0+$/, "");
        if (numStr === ".") numStr = "0";
        else if (numStr[0] === ".") numStr = "0" + numStr;
        else if (numStr[numStr.length - 1] === ".") numStr = numStr.substr(0, numStr.length - 1);
        return numStr;
      }
      return numStr;
    }
    function parse_int(numStr, base) {
      if (parseInt) return parseInt(numStr, base);
      else if (Number.parseInt) return Number.parseInt(numStr, base);
      else if (window && window.parseInt) return window.parseInt(numStr, base);
      else throw new Error("parseInt, Number.parseInt, window.parseInt are not supported");
    }
    module.exports = toNumber;
  }
});

// node_modules/fast-xml-parser/src/ignoreAttributes.js
var require_ignoreAttributes = __commonJS({
  "node_modules/fast-xml-parser/src/ignoreAttributes.js"(exports, module) {
    function getIgnoreAttributesFn(ignoreAttributes) {
      if (typeof ignoreAttributes === "function") {
        return ignoreAttributes;
      }
      if (Array.isArray(ignoreAttributes)) {
        return (attrName) => {
          for (const pattern of ignoreAttributes) {
            if (typeof pattern === "string" && attrName === pattern) {
              return true;
            }
            if (pattern instanceof RegExp && pattern.test(attrName)) {
              return true;
            }
          }
        };
      }
      return () => false;
    }
    module.exports = getIgnoreAttributesFn;
  }
});

// node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js
var require_OrderedObjParser = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js"(exports, module) {
    "use strict";
    var util = require_util();
    var xmlNode = require_xmlNode();
    var readDocType = require_DocTypeReader();
    var toNumber = require_strnum();
    var getIgnoreAttributesFn = require_ignoreAttributes();
    var OrderedObjParser = class {
      constructor(options) {
        this.options = options;
        this.currentNode = null;
        this.tagsNodeStack = [];
        this.docTypeEntities = {};
        this.lastEntities = {
          "apos": { regex: /&(apos|#39|#x27);/g, val: "'" },
          "gt": { regex: /&(gt|#62|#x3E);/g, val: ">" },
          "lt": { regex: /&(lt|#60|#x3C);/g, val: "<" },
          "quot": { regex: /&(quot|#34|#x22);/g, val: '"' }
        };
        this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };
        this.htmlEntities = {
          "space": { regex: /&(nbsp|#160);/g, val: " " },
          // "lt" : { regex: /&(lt|#60);/g, val: "<" },
          // "gt" : { regex: /&(gt|#62);/g, val: ">" },
          // "amp" : { regex: /&(amp|#38);/g, val: "&" },
          // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
          // "apos" : { regex: /&(apos|#39);/g, val: "'" },
          "cent": { regex: /&(cent|#162);/g, val: "¢" },
          "pound": { regex: /&(pound|#163);/g, val: "£" },
          "yen": { regex: /&(yen|#165);/g, val: "¥" },
          "euro": { regex: /&(euro|#8364);/g, val: "€" },
          "copyright": { regex: /&(copy|#169);/g, val: "©" },
          "reg": { regex: /&(reg|#174);/g, val: "®" },
          "inr": { regex: /&(inr|#8377);/g, val: "₹" },
          "num_dec": { regex: /&#([0-9]{1,7});/g, val: (_, str5) => String.fromCharCode(Number.parseInt(str5, 10)) },
          "num_hex": { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (_, str5) => String.fromCharCode(Number.parseInt(str5, 16)) }
        };
        this.addExternalEntities = addExternalEntities;
        this.parseXml = parseXml;
        this.parseTextData = parseTextData;
        this.resolveNameSpace = resolveNameSpace;
        this.buildAttributesMap = buildAttributesMap;
        this.isItStopNode = isItStopNode;
        this.replaceEntitiesValue = replaceEntitiesValue;
        this.readStopNodeData = readStopNodeData;
        this.saveTextToParentTag = saveTextToParentTag;
        this.addChild = addChild;
        this.ignoreAttributesFn = getIgnoreAttributesFn(this.options.ignoreAttributes);
      }
    };
    function addExternalEntities(externalEntities) {
      const entKeys = Object.keys(externalEntities);
      for (let i = 0; i < entKeys.length; i++) {
        const ent = entKeys[i];
        this.lastEntities[ent] = {
          regex: new RegExp("&" + ent + ";", "g"),
          val: externalEntities[ent]
        };
      }
    }
    function parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
      if (val !== void 0) {
        if (this.options.trimValues && !dontTrim) {
          val = val.trim();
        }
        if (val.length > 0) {
          if (!escapeEntities) val = this.replaceEntitiesValue(val);
          const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);
          if (newval === null || newval === void 0) {
            return val;
          } else if (typeof newval !== typeof val || newval !== val) {
            return newval;
          } else if (this.options.trimValues) {
            return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
          } else {
            const trimmedVal = val.trim();
            if (trimmedVal === val) {
              return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
            } else {
              return val;
            }
          }
        }
      }
    }
    function resolveNameSpace(tagname) {
      if (this.options.removeNSPrefix) {
        const tags = tagname.split(":");
        const prefix = tagname.charAt(0) === "/" ? "/" : "";
        if (tags[0] === "xmlns") {
          return "";
        }
        if (tags.length === 2) {
          tagname = prefix + tags[1];
        }
      }
      return tagname;
    }
    var attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
    function buildAttributesMap(attrStr, jPath, tagName) {
      if (this.options.ignoreAttributes !== true && typeof attrStr === "string") {
        const matches = util.getAllMatches(attrStr, attrsRegx);
        const len4 = matches.length;
        const attrs = {};
        for (let i = 0; i < len4; i++) {
          const attrName = this.resolveNameSpace(matches[i][1]);
          if (this.ignoreAttributesFn(attrName, jPath)) {
            continue;
          }
          let oldVal = matches[i][4];
          let aName = this.options.attributeNamePrefix + attrName;
          if (attrName.length) {
            if (this.options.transformAttributeName) {
              aName = this.options.transformAttributeName(aName);
            }
            if (aName === "__proto__") aName = "#__proto__";
            if (oldVal !== void 0) {
              if (this.options.trimValues) {
                oldVal = oldVal.trim();
              }
              oldVal = this.replaceEntitiesValue(oldVal);
              const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
              if (newVal === null || newVal === void 0) {
                attrs[aName] = oldVal;
              } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
                attrs[aName] = newVal;
              } else {
                attrs[aName] = parseValue(
                  oldVal,
                  this.options.parseAttributeValue,
                  this.options.numberParseOptions
                );
              }
            } else if (this.options.allowBooleanAttributes) {
              attrs[aName] = true;
            }
          }
        }
        if (!Object.keys(attrs).length) {
          return;
        }
        if (this.options.attributesGroupName) {
          const attrCollection = {};
          attrCollection[this.options.attributesGroupName] = attrs;
          return attrCollection;
        }
        return attrs;
      }
    }
    var parseXml = function(xmlData) {
      xmlData = xmlData.replace(/\r\n?/g, "\n");
      const xmlObj = new xmlNode("!xml");
      let currentNode = xmlObj;
      let textData = "";
      let jPath = "";
      for (let i = 0; i < xmlData.length; i++) {
        const ch = xmlData[i];
        if (ch === "<") {
          if (xmlData[i + 1] === "/") {
            const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed.");
            let tagName = xmlData.substring(i + 2, closeIndex).trim();
            if (this.options.removeNSPrefix) {
              const colonIndex = tagName.indexOf(":");
              if (colonIndex !== -1) {
                tagName = tagName.substr(colonIndex + 1);
              }
            }
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            if (currentNode) {
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
            }
            const lastTagName = jPath.substring(jPath.lastIndexOf(".") + 1);
            if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {
              throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
            }
            let propIndex = 0;
            if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {
              propIndex = jPath.lastIndexOf(".", jPath.lastIndexOf(".") - 1);
              this.tagsNodeStack.pop();
            } else {
              propIndex = jPath.lastIndexOf(".");
            }
            jPath = jPath.substring(0, propIndex);
            currentNode = this.tagsNodeStack.pop();
            textData = "";
            i = closeIndex;
          } else if (xmlData[i + 1] === "?") {
            let tagData = readTagExp(xmlData, i, false, "?>");
            if (!tagData) throw new Error("Pi Tag is not closed.");
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags) {
            } else {
              const childNode = new xmlNode(tagData.tagName);
              childNode.add(this.options.textNodeName, "");
              if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
              }
              this.addChild(currentNode, childNode, jPath);
            }
            i = tagData.closeIndex + 1;
          } else if (xmlData.substr(i + 1, 3) === "!--") {
            const endIndex = findClosingIndex(xmlData, "-->", i + 4, "Comment is not closed.");
            if (this.options.commentPropName) {
              const comment = xmlData.substring(i + 4, endIndex - 2);
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
              currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment }]);
            }
            i = endIndex;
          } else if (xmlData.substr(i + 1, 2) === "!D") {
            const result = readDocType(xmlData, i);
            this.docTypeEntities = result.entities;
            i = result.i;
          } else if (xmlData.substr(i + 1, 2) === "![") {
            const closeIndex = findClosingIndex(xmlData, "]]>", i, "CDATA is not closed.") - 2;
            const tagExp = xmlData.substring(i + 9, closeIndex);
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);
            if (val == void 0) val = "";
            if (this.options.cdataPropName) {
              currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);
            } else {
              currentNode.add(this.options.textNodeName, val);
            }
            i = closeIndex + 2;
          } else {
            let result = readTagExp(xmlData, i, this.options.removeNSPrefix);
            let tagName = result.tagName;
            const rawTagName = result.rawTagName;
            let tagExp = result.tagExp;
            let attrExpPresent = result.attrExpPresent;
            let closeIndex = result.closeIndex;
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            if (currentNode && textData) {
              if (currentNode.tagname !== "!xml") {
                textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
              }
            }
            const lastTag = currentNode;
            if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
              currentNode = this.tagsNodeStack.pop();
              jPath = jPath.substring(0, jPath.lastIndexOf("."));
            }
            if (tagName !== xmlObj.tagname) {
              jPath += jPath ? "." + tagName : tagName;
            }
            if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
              let tagContent = "";
              if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                if (tagName[tagName.length - 1] === "/") {
                  tagName = tagName.substr(0, tagName.length - 1);
                  jPath = jPath.substr(0, jPath.length - 1);
                  tagExp = tagName;
                } else {
                  tagExp = tagExp.substr(0, tagExp.length - 1);
                }
                i = result.closeIndex;
              } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
                i = result.closeIndex;
              } else {
                const result2 = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);
                if (!result2) throw new Error(`Unexpected end of ${rawTagName}`);
                i = result2.i;
                tagContent = result2.tagContent;
              }
              const childNode = new xmlNode(tagName);
              if (tagName !== tagExp && attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
              }
              if (tagContent) {
                tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
              }
              jPath = jPath.substr(0, jPath.lastIndexOf("."));
              childNode.add(this.options.textNodeName, tagContent);
              this.addChild(currentNode, childNode, jPath);
            } else {
              if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                if (tagName[tagName.length - 1] === "/") {
                  tagName = tagName.substr(0, tagName.length - 1);
                  jPath = jPath.substr(0, jPath.length - 1);
                  tagExp = tagName;
                } else {
                  tagExp = tagExp.substr(0, tagExp.length - 1);
                }
                if (this.options.transformTagName) {
                  tagName = this.options.transformTagName(tagName);
                }
                const childNode = new xmlNode(tagName);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                }
                this.addChild(currentNode, childNode, jPath);
                jPath = jPath.substr(0, jPath.lastIndexOf("."));
              } else {
                const childNode = new xmlNode(tagName);
                this.tagsNodeStack.push(currentNode);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                }
                this.addChild(currentNode, childNode, jPath);
                currentNode = childNode;
              }
              textData = "";
              i = closeIndex;
            }
          }
        } else {
          textData += xmlData[i];
        }
      }
      return xmlObj.child;
    };
    function addChild(currentNode, childNode, jPath) {
      const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
      if (result === false) {
      } else if (typeof result === "string") {
        childNode.tagname = result;
        currentNode.addChild(childNode);
      } else {
        currentNode.addChild(childNode);
      }
    }
    var replaceEntitiesValue = function(val) {
      if (this.options.processEntities) {
        for (let entityName in this.docTypeEntities) {
          const entity = this.docTypeEntities[entityName];
          val = val.replace(entity.regx, entity.val);
        }
        for (let entityName in this.lastEntities) {
          const entity = this.lastEntities[entityName];
          val = val.replace(entity.regex, entity.val);
        }
        if (this.options.htmlEntities) {
          for (let entityName in this.htmlEntities) {
            const entity = this.htmlEntities[entityName];
            val = val.replace(entity.regex, entity.val);
          }
        }
        val = val.replace(this.ampEntity.regex, this.ampEntity.val);
      }
      return val;
    };
    function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
      if (textData) {
        if (isLeafNode === void 0) isLeafNode = currentNode.child.length === 0;
        textData = this.parseTextData(
          textData,
          currentNode.tagname,
          jPath,
          false,
          currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,
          isLeafNode
        );
        if (textData !== void 0 && textData !== "")
          currentNode.add(this.options.textNodeName, textData);
        textData = "";
      }
      return textData;
    }
    function isItStopNode(stopNodes, jPath, currentTagName) {
      const allNodesExp = "*." + currentTagName;
      for (const stopNodePath in stopNodes) {
        const stopNodeExp = stopNodes[stopNodePath];
        if (allNodesExp === stopNodeExp || jPath === stopNodeExp) return true;
      }
      return false;
    }
    function tagExpWithClosingIndex(xmlData, i, closingChar = ">") {
      let attrBoundary;
      let tagExp = "";
      for (let index = i; index < xmlData.length; index++) {
        let ch = xmlData[index];
        if (attrBoundary) {
          if (ch === attrBoundary) attrBoundary = "";
        } else if (ch === '"' || ch === "'") {
          attrBoundary = ch;
        } else if (ch === closingChar[0]) {
          if (closingChar[1]) {
            if (xmlData[index + 1] === closingChar[1]) {
              return {
                data: tagExp,
                index
              };
            }
          } else {
            return {
              data: tagExp,
              index
            };
          }
        } else if (ch === "	") {
          ch = " ";
        }
        tagExp += ch;
      }
    }
    function findClosingIndex(xmlData, str5, i, errMsg) {
      const closingIndex = xmlData.indexOf(str5, i);
      if (closingIndex === -1) {
        throw new Error(errMsg);
      } else {
        return closingIndex + str5.length - 1;
      }
    }
    function readTagExp(xmlData, i, removeNSPrefix, closingChar = ">") {
      const result = tagExpWithClosingIndex(xmlData, i + 1, closingChar);
      if (!result) return;
      let tagExp = result.data;
      const closeIndex = result.index;
      const separatorIndex = tagExp.search(/\s/);
      let tagName = tagExp;
      let attrExpPresent = true;
      if (separatorIndex !== -1) {
        tagName = tagExp.substring(0, separatorIndex);
        tagExp = tagExp.substring(separatorIndex + 1).trimStart();
      }
      const rawTagName = tagName;
      if (removeNSPrefix) {
        const colonIndex = tagName.indexOf(":");
        if (colonIndex !== -1) {
          tagName = tagName.substr(colonIndex + 1);
          attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
        }
      }
      return {
        tagName,
        tagExp,
        closeIndex,
        attrExpPresent,
        rawTagName
      };
    }
    function readStopNodeData(xmlData, tagName, i) {
      const startIndex = i;
      let openTagCount = 1;
      for (; i < xmlData.length; i++) {
        if (xmlData[i] === "<") {
          if (xmlData[i + 1] === "/") {
            const closeIndex = findClosingIndex(xmlData, ">", i, `${tagName} is not closed`);
            let closeTagName = xmlData.substring(i + 2, closeIndex).trim();
            if (closeTagName === tagName) {
              openTagCount--;
              if (openTagCount === 0) {
                return {
                  tagContent: xmlData.substring(startIndex, i),
                  i: closeIndex
                };
              }
            }
            i = closeIndex;
          } else if (xmlData[i + 1] === "?") {
            const closeIndex = findClosingIndex(xmlData, "?>", i + 1, "StopNode is not closed.");
            i = closeIndex;
          } else if (xmlData.substr(i + 1, 3) === "!--") {
            const closeIndex = findClosingIndex(xmlData, "-->", i + 3, "StopNode is not closed.");
            i = closeIndex;
          } else if (xmlData.substr(i + 1, 2) === "![") {
            const closeIndex = findClosingIndex(xmlData, "]]>", i, "StopNode is not closed.") - 2;
            i = closeIndex;
          } else {
            const tagData = readTagExp(xmlData, i, ">");
            if (tagData) {
              const openTagName = tagData && tagData.tagName;
              if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
                openTagCount++;
              }
              i = tagData.closeIndex;
            }
          }
        }
      }
    }
    function parseValue(val, shouldParse, options) {
      if (shouldParse && typeof val === "string") {
        const newval = val.trim();
        if (newval === "true") return true;
        else if (newval === "false") return false;
        else return toNumber(val, options);
      } else {
        if (util.isExist(val)) {
          return val;
        } else {
          return "";
        }
      }
    }
    module.exports = OrderedObjParser;
  }
});

// node_modules/fast-xml-parser/src/xmlparser/node2json.js
var require_node2json = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/node2json.js"(exports) {
    "use strict";
    function prettify(node, options) {
      return compress(node, options);
    }
    function compress(arr, options, jPath) {
      let text;
      const compressedObj = {};
      for (let i = 0; i < arr.length; i++) {
        const tagObj = arr[i];
        const property = propName(tagObj);
        let newJpath = "";
        if (jPath === void 0) newJpath = property;
        else newJpath = jPath + "." + property;
        if (property === options.textNodeName) {
          if (text === void 0) text = tagObj[property];
          else text += "" + tagObj[property];
        } else if (property === void 0) {
          continue;
        } else if (tagObj[property]) {
          let val = compress(tagObj[property], options, newJpath);
          const isLeaf = isLeafTag(val, options);
          if (tagObj[":@"]) {
            assignAttributes(val, tagObj[":@"], newJpath, options);
          } else if (Object.keys(val).length === 1 && val[options.textNodeName] !== void 0 && !options.alwaysCreateTextNode) {
            val = val[options.textNodeName];
          } else if (Object.keys(val).length === 0) {
            if (options.alwaysCreateTextNode) val[options.textNodeName] = "";
            else val = "";
          }
          if (compressedObj[property] !== void 0 && compressedObj.hasOwnProperty(property)) {
            if (!Array.isArray(compressedObj[property])) {
              compressedObj[property] = [compressedObj[property]];
            }
            compressedObj[property].push(val);
          } else {
            if (options.isArray(property, newJpath, isLeaf)) {
              compressedObj[property] = [val];
            } else {
              compressedObj[property] = val;
            }
          }
        }
      }
      if (typeof text === "string") {
        if (text.length > 0) compressedObj[options.textNodeName] = text;
      } else if (text !== void 0) compressedObj[options.textNodeName] = text;
      return compressedObj;
    }
    function propName(obj) {
      const keys = Object.keys(obj);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        if (key !== ":@") return key;
      }
    }
    function assignAttributes(obj, attrMap, jpath, options) {
      if (attrMap) {
        const keys = Object.keys(attrMap);
        const len4 = keys.length;
        for (let i = 0; i < len4; i++) {
          const atrrName = keys[i];
          if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
            obj[atrrName] = [attrMap[atrrName]];
          } else {
            obj[atrrName] = attrMap[atrrName];
          }
        }
      }
    }
    function isLeafTag(obj, options) {
      const { textNodeName } = options;
      const propCount = Object.keys(obj).length;
      if (propCount === 0) {
        return true;
      }
      if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)) {
        return true;
      }
      return false;
    }
    exports.prettify = prettify;
  }
});

// node_modules/fast-xml-parser/src/xmlparser/XMLParser.js
var require_XMLParser = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/XMLParser.js"(exports, module) {
    var { buildOptions } = require_OptionsBuilder();
    var OrderedObjParser = require_OrderedObjParser();
    var { prettify } = require_node2json();
    var validator = require_validator();
    var XMLParser = class {
      constructor(options) {
        this.externalEntities = {};
        this.options = buildOptions(options);
      }
      /**
       * Parse XML dats to JS object 
       * @param {string|Buffer} xmlData 
       * @param {boolean|Object} validationOption 
       */
      parse(xmlData, validationOption) {
        if (typeof xmlData === "string") {
        } else if (xmlData.toString) {
          xmlData = xmlData.toString();
        } else {
          throw new Error("XML data is accepted in String or Bytes[] form.");
        }
        if (validationOption) {
          if (validationOption === true) validationOption = {};
          const result = validator.validate(xmlData, validationOption);
          if (result !== true) {
            throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);
          }
        }
        const orderedObjParser = new OrderedObjParser(this.options);
        orderedObjParser.addExternalEntities(this.externalEntities);
        const orderedResult = orderedObjParser.parseXml(xmlData);
        if (this.options.preserveOrder || orderedResult === void 0) return orderedResult;
        else return prettify(orderedResult, this.options);
      }
      /**
       * Add Entity which is not by default supported by this library
       * @param {string} key 
       * @param {string} value 
       */
      addEntity(key, value) {
        if (value.indexOf("&") !== -1) {
          throw new Error("Entity value can't have '&'");
        } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
          throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
        } else if (value === "&") {
          throw new Error("An entity with value '&' is not permitted");
        } else {
          this.externalEntities[key] = value;
        }
      }
    };
    module.exports = XMLParser;
  }
});

// node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js
var require_orderedJs2Xml = __commonJS({
  "node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js"(exports, module) {
    var EOL = "\n";
    function toXml(jArray, options) {
      let indentation = "";
      if (options.format && options.indentBy.length > 0) {
        indentation = EOL;
      }
      return arrToStr(jArray, options, "", indentation);
    }
    function arrToStr(arr, options, jPath, indentation) {
      let xmlStr = "";
      let isPreviousElementTag = false;
      for (let i = 0; i < arr.length; i++) {
        const tagObj = arr[i];
        const tagName = propName(tagObj);
        if (tagName === void 0) continue;
        let newJPath = "";
        if (jPath.length === 0) newJPath = tagName;
        else newJPath = `${jPath}.${tagName}`;
        if (tagName === options.textNodeName) {
          let tagText = tagObj[tagName];
          if (!isStopNode(newJPath, options)) {
            tagText = options.tagValueProcessor(tagName, tagText);
            tagText = replaceEntitiesValue(tagText, options);
          }
          if (isPreviousElementTag) {
            xmlStr += indentation;
          }
          xmlStr += tagText;
          isPreviousElementTag = false;
          continue;
        } else if (tagName === options.cdataPropName) {
          if (isPreviousElementTag) {
            xmlStr += indentation;
          }
          xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
          isPreviousElementTag = false;
          continue;
        } else if (tagName === options.commentPropName) {
          xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
          isPreviousElementTag = true;
          continue;
        } else if (tagName[0] === "?") {
          const attStr2 = attr_to_str(tagObj[":@"], options);
          const tempInd = tagName === "?xml" ? "" : indentation;
          let piTextNodeName = tagObj[tagName][0][options.textNodeName];
          piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : "";
          xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr2}?>`;
          isPreviousElementTag = true;
          continue;
        }
        let newIdentation = indentation;
        if (newIdentation !== "") {
          newIdentation += options.indentBy;
        }
        const attStr = attr_to_str(tagObj[":@"], options);
        const tagStart = indentation + `<${tagName}${attStr}`;
        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
        if (options.unpairedTags.indexOf(tagName) !== -1) {
          if (options.suppressUnpairedNode) xmlStr += tagStart + ">";
          else xmlStr += tagStart + "/>";
        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
          xmlStr += tagStart + "/>";
        } else if (tagValue && tagValue.endsWith(">")) {
          xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
        } else {
          xmlStr += tagStart + ">";
          if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
            xmlStr += indentation + options.indentBy + tagValue + indentation;
          } else {
            xmlStr += tagValue;
          }
          xmlStr += `</${tagName}>`;
        }
        isPreviousElementTag = true;
      }
      return xmlStr;
    }
    function propName(obj) {
      const keys = Object.keys(obj);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        if (!obj.hasOwnProperty(key)) continue;
        if (key !== ":@") return key;
      }
    }
    function attr_to_str(attrMap, options) {
      let attrStr = "";
      if (attrMap && !options.ignoreAttributes) {
        for (let attr in attrMap) {
          if (!attrMap.hasOwnProperty(attr)) continue;
          let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
          attrVal = replaceEntitiesValue(attrVal, options);
          if (attrVal === true && options.suppressBooleanAttributes) {
            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
          } else {
            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
          }
        }
      }
      return attrStr;
    }
    function isStopNode(jPath, options) {
      jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
      let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
      for (let index in options.stopNodes) {
        if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName) return true;
      }
      return false;
    }
    function replaceEntitiesValue(textValue, options) {
      if (textValue && textValue.length > 0 && options.processEntities) {
        for (let i = 0; i < options.entities.length; i++) {
          const entity = options.entities[i];
          textValue = textValue.replace(entity.regex, entity.val);
        }
      }
      return textValue;
    }
    module.exports = toXml;
  }
});

// node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js
var require_json2xml = __commonJS({
  "node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js"(exports, module) {
    "use strict";
    var buildFromOrderedJs = require_orderedJs2Xml();
    var getIgnoreAttributesFn = require_ignoreAttributes();
    var defaultOptions3 = {
      attributeNamePrefix: "@_",
      attributesGroupName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      cdataPropName: false,
      format: false,
      indentBy: "  ",
      suppressEmptyNode: false,
      suppressUnpairedNode: true,
      suppressBooleanAttributes: true,
      tagValueProcessor: function(key, a2) {
        return a2;
      },
      attributeValueProcessor: function(attrName, a2) {
        return a2;
      },
      preserveOrder: false,
      commentPropName: false,
      unpairedTags: [],
      entities: [
        { regex: new RegExp("&", "g"), val: "&amp;" },
        //it must be on top
        { regex: new RegExp(">", "g"), val: "&gt;" },
        { regex: new RegExp("<", "g"), val: "&lt;" },
        { regex: new RegExp("'", "g"), val: "&apos;" },
        { regex: new RegExp('"', "g"), val: "&quot;" }
      ],
      processEntities: true,
      stopNodes: [],
      // transformTagName: false,
      // transformAttributeName: false,
      oneListGroup: false
    };
    function Builder(options) {
      this.options = Object.assign({}, defaultOptions3, options);
      if (this.options.ignoreAttributes === true || this.options.attributesGroupName) {
        this.isAttribute = function() {
          return false;
        };
      } else {
        this.ignoreAttributesFn = getIgnoreAttributesFn(this.options.ignoreAttributes);
        this.attrPrefixLen = this.options.attributeNamePrefix.length;
        this.isAttribute = isAttribute;
      }
      this.processTextOrObjNode = processTextOrObjNode;
      if (this.options.format) {
        this.indentate = indentate;
        this.tagEndChar = ">\n";
        this.newLine = "\n";
      } else {
        this.indentate = function() {
          return "";
        };
        this.tagEndChar = ">";
        this.newLine = "";
      }
    }
    Builder.prototype.build = function(jObj) {
      if (this.options.preserveOrder) {
        return buildFromOrderedJs(jObj, this.options);
      } else {
        if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {
          jObj = {
            [this.options.arrayNodeName]: jObj
          };
        }
        return this.j2x(jObj, 0, []).val;
      }
    };
    Builder.prototype.j2x = function(jObj, level, ajPath) {
      let attrStr = "";
      let val = "";
      const jPath = ajPath.join(".");
      for (let key in jObj) {
        if (!Object.prototype.hasOwnProperty.call(jObj, key)) continue;
        if (typeof jObj[key] === "undefined") {
          if (this.isAttribute(key)) {
            val += "";
          }
        } else if (jObj[key] === null) {
          if (this.isAttribute(key)) {
            val += "";
          } else if (key === this.options.cdataPropName) {
            val += "";
          } else if (key[0] === "?") {
            val += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
          } else {
            val += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
          }
        } else if (jObj[key] instanceof Date) {
          val += this.buildTextValNode(jObj[key], key, "", level);
        } else if (typeof jObj[key] !== "object") {
          const attr = this.isAttribute(key);
          if (attr && !this.ignoreAttributesFn(attr, jPath)) {
            attrStr += this.buildAttrPairStr(attr, "" + jObj[key]);
          } else if (!attr) {
            if (key === this.options.textNodeName) {
              let newval = this.options.tagValueProcessor(key, "" + jObj[key]);
              val += this.replaceEntitiesValue(newval);
            } else {
              val += this.buildTextValNode(jObj[key], key, "", level);
            }
          }
        } else if (Array.isArray(jObj[key])) {
          const arrLen = jObj[key].length;
          let listTagVal = "";
          let listTagAttr = "";
          for (let j = 0; j < arrLen; j++) {
            const item = jObj[key][j];
            if (typeof item === "undefined") {
            } else if (item === null) {
              if (key[0] === "?") val += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
              else val += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
            } else if (typeof item === "object") {
              if (this.options.oneListGroup) {
                const result = this.j2x(item, level + 1, ajPath.concat(key));
                listTagVal += result.val;
                if (this.options.attributesGroupName && item.hasOwnProperty(this.options.attributesGroupName)) {
                  listTagAttr += result.attrStr;
                }
              } else {
                listTagVal += this.processTextOrObjNode(item, key, level, ajPath);
              }
            } else {
              if (this.options.oneListGroup) {
                let textValue = this.options.tagValueProcessor(key, item);
                textValue = this.replaceEntitiesValue(textValue);
                listTagVal += textValue;
              } else {
                listTagVal += this.buildTextValNode(item, key, "", level);
              }
            }
          }
          if (this.options.oneListGroup) {
            listTagVal = this.buildObjectNode(listTagVal, key, listTagAttr, level);
          }
          val += listTagVal;
        } else {
          if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
            const Ks = Object.keys(jObj[key]);
            const L2 = Ks.length;
            for (let j = 0; j < L2; j++) {
              attrStr += this.buildAttrPairStr(Ks[j], "" + jObj[key][Ks[j]]);
            }
          } else {
            val += this.processTextOrObjNode(jObj[key], key, level, ajPath);
          }
        }
      }
      return { attrStr, val };
    };
    Builder.prototype.buildAttrPairStr = function(attrName, val) {
      val = this.options.attributeValueProcessor(attrName, "" + val);
      val = this.replaceEntitiesValue(val);
      if (this.options.suppressBooleanAttributes && val === "true") {
        return " " + attrName;
      } else return " " + attrName + '="' + val + '"';
    };
    function processTextOrObjNode(object, key, level, ajPath) {
      const result = this.j2x(object, level + 1, ajPath.concat(key));
      if (object[this.options.textNodeName] !== void 0 && Object.keys(object).length === 1) {
        return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);
      } else {
        return this.buildObjectNode(result.val, key, result.attrStr, level);
      }
    }
    Builder.prototype.buildObjectNode = function(val, key, attrStr, level) {
      if (val === "") {
        if (key[0] === "?") return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
        else {
          return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
        }
      } else {
        let tagEndExp = "</" + key + this.tagEndChar;
        let piClosingChar = "";
        if (key[0] === "?") {
          piClosingChar = "?";
          tagEndExp = "";
        }
        if ((attrStr || attrStr === "") && val.indexOf("<") === -1) {
          return this.indentate(level) + "<" + key + attrStr + piClosingChar + ">" + val + tagEndExp;
        } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
          return this.indentate(level) + `<!--${val}-->` + this.newLine;
        } else {
          return this.indentate(level) + "<" + key + attrStr + piClosingChar + this.tagEndChar + val + this.indentate(level) + tagEndExp;
        }
      }
    };
    Builder.prototype.closeTag = function(key) {
      let closeTag = "";
      if (this.options.unpairedTags.indexOf(key) !== -1) {
        if (!this.options.suppressUnpairedNode) closeTag = "/";
      } else if (this.options.suppressEmptyNode) {
        closeTag = "/";
      } else {
        closeTag = `></${key}`;
      }
      return closeTag;
    };
    Builder.prototype.buildTextValNode = function(val, key, attrStr, level) {
      if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
        return this.indentate(level) + `<![CDATA[${val}]]>` + this.newLine;
      } else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
        return this.indentate(level) + `<!--${val}-->` + this.newLine;
      } else if (key[0] === "?") {
        return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
      } else {
        let textValue = this.options.tagValueProcessor(key, val);
        textValue = this.replaceEntitiesValue(textValue);
        if (textValue === "") {
          return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
        } else {
          return this.indentate(level) + "<" + key + attrStr + ">" + textValue + "</" + key + this.tagEndChar;
        }
      }
    };
    Builder.prototype.replaceEntitiesValue = function(textValue) {
      if (textValue && textValue.length > 0 && this.options.processEntities) {
        for (let i = 0; i < this.options.entities.length; i++) {
          const entity = this.options.entities[i];
          textValue = textValue.replace(entity.regex, entity.val);
        }
      }
      return textValue;
    };
    function indentate(level) {
      return this.options.indentBy.repeat(level);
    }
    function isAttribute(name) {
      if (name.startsWith(this.options.attributeNamePrefix) && name !== this.options.textNodeName) {
        return name.substr(this.attrPrefixLen);
      } else {
        return false;
      }
    }
    module.exports = Builder;
  }
});

// node_modules/fast-xml-parser/src/fxp.js
var require_fxp = __commonJS({
  "node_modules/fast-xml-parser/src/fxp.js"(exports, module) {
    "use strict";
    var validator = require_validator();
    var XMLParser = require_XMLParser();
    var XMLBuilder = require_json2xml();
    module.exports = {
      XMLParser,
      XMLValidator: validator,
      XMLBuilder
    };
  }
});

// node_modules/long/dist/long.js
var require_long = __commonJS({
  "node_modules/long/dist/long.js"(exports, module) {
    (function(global, factory) {
      if (typeof define === "function" && define["amd"])
        define([], factory);
      else if (typeof __require === "function" && typeof module === "object" && module && module["exports"])
        module["exports"] = factory();
      else
        (global["dcodeIO"] = global["dcodeIO"] || {})["Long"] = factory();
    })(exports, function() {
      "use strict";
      function Long3(low, high, unsigned) {
        this.low = low | 0;
        this.high = high | 0;
        this.unsigned = !!unsigned;
      }
      Long3.prototype.__isLong__;
      Object.defineProperty(Long3.prototype, "__isLong__", {
        value: true,
        enumerable: false,
        configurable: false
      });
      function isLong(obj) {
        return (obj && obj["__isLong__"]) === true;
      }
      Long3.isLong = isLong;
      var INT_CACHE = {};
      var UINT_CACHE = {};
      function fromInt(value, unsigned) {
        var obj, cachedObj, cache2;
        if (unsigned) {
          value >>>= 0;
          if (cache2 = 0 <= value && value < 256) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
              return cachedObj;
          }
          obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
          if (cache2)
            UINT_CACHE[value] = obj;
          return obj;
        } else {
          value |= 0;
          if (cache2 = -128 <= value && value < 128) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
              return cachedObj;
          }
          obj = fromBits(value, value < 0 ? -1 : 0, false);
          if (cache2)
            INT_CACHE[value] = obj;
          return obj;
        }
      }
      Long3.fromInt = fromInt;
      function fromNumber(value, unsigned) {
        if (isNaN(value) || !isFinite(value))
          return unsigned ? UZERO : ZERO2;
        if (unsigned) {
          if (value < 0)
            return UZERO;
          if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
        } else {
          if (value <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
          if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
        }
        if (value < 0)
          return fromNumber(-value, unsigned).neg();
        return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
      }
      Long3.fromNumber = fromNumber;
      function fromBits(lowBits, highBits, unsigned) {
        return new Long3(lowBits, highBits, unsigned);
      }
      Long3.fromBits = fromBits;
      var pow_dbl = Math.pow;
      function fromString(str5, unsigned, radix) {
        if (str5.length === 0)
          throw Error("empty string");
        if (str5 === "NaN" || str5 === "Infinity" || str5 === "+Infinity" || str5 === "-Infinity")
          return ZERO2;
        if (typeof unsigned === "number") {
          radix = unsigned, unsigned = false;
        } else {
          unsigned = !!unsigned;
        }
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
          throw RangeError("radix");
        var p;
        if ((p = str5.indexOf("-")) > 0)
          throw Error("interior hyphen");
        else if (p === 0) {
          return fromString(str5.substring(1), unsigned, radix).neg();
        }
        var radixToPower = fromNumber(pow_dbl(radix, 8));
        var result = ZERO2;
        for (var i = 0; i < str5.length; i += 8) {
          var size = Math.min(8, str5.length - i), value = parseInt(str5.substring(i, i + size), radix);
          if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
          } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
          }
        }
        result.unsigned = unsigned;
        return result;
      }
      Long3.fromString = fromString;
      function fromValue(val) {
        if (val instanceof Long3)
          return val;
        if (typeof val === "number")
          return fromNumber(val);
        if (typeof val === "string")
          return fromString(val);
        return fromBits(val.low, val.high, val.unsigned);
      }
      Long3.fromValue = fromValue;
      var TWO_PWR_16_DBL = 1 << 16;
      var TWO_PWR_24_DBL = 1 << 24;
      var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
      var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
      var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
      var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
      var ZERO2 = fromInt(0);
      Long3.ZERO = ZERO2;
      var UZERO = fromInt(0, true);
      Long3.UZERO = UZERO;
      var ONE = fromInt(1);
      Long3.ONE = ONE;
      var UONE = fromInt(1, true);
      Long3.UONE = UONE;
      var NEG_ONE = fromInt(-1);
      Long3.NEG_ONE = NEG_ONE;
      var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
      Long3.MAX_VALUE = MAX_VALUE;
      var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
      Long3.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
      var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
      Long3.MIN_VALUE = MIN_VALUE;
      var LongPrototype = Long3.prototype;
      LongPrototype.toInt = function toInt() {
        return this.unsigned ? this.low >>> 0 : this.low;
      };
      LongPrototype.toNumber = function toNumber() {
        if (this.unsigned)
          return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
      };
      LongPrototype.toString = function toString(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
          throw RangeError("radix");
        if (this.isZero())
          return "0";
        if (this.isNegative()) {
          if (this.eq(MIN_VALUE)) {
            var radixLong = fromNumber(radix), div3 = this.div(radixLong), rem1 = div3.mul(radixLong).sub(this);
            return div3.toString(radix) + rem1.toInt().toString(radix);
          } else
            return "-" + this.neg().toString(radix);
        }
        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
        var result = "";
        while (true) {
          var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
          rem = remDiv;
          if (rem.isZero())
            return digits + result;
          else {
            while (digits.length < 6)
              digits = "0" + digits;
            result = "" + digits + result;
          }
        }
      };
      LongPrototype.getHighBits = function getHighBits() {
        return this.high;
      };
      LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
        return this.high >>> 0;
      };
      LongPrototype.getLowBits = function getLowBits() {
        return this.low;
      };
      LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
        return this.low >>> 0;
      };
      LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
        if (this.isNegative())
          return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
        var val = this.high != 0 ? this.high : this.low;
        for (var bit = 31; bit > 0; bit--)
          if ((val & 1 << bit) != 0)
            break;
        return this.high != 0 ? bit + 33 : bit + 1;
      };
      LongPrototype.isZero = function isZero() {
        return this.high === 0 && this.low === 0;
      };
      LongPrototype.isNegative = function isNegative() {
        return !this.unsigned && this.high < 0;
      };
      LongPrototype.isPositive = function isPositive() {
        return this.unsigned || this.high >= 0;
      };
      LongPrototype.isOdd = function isOdd() {
        return (this.low & 1) === 1;
      };
      LongPrototype.isEven = function isEven() {
        return (this.low & 1) === 0;
      };
      LongPrototype.equals = function equals7(other) {
        if (!isLong(other))
          other = fromValue(other);
        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
          return false;
        return this.high === other.high && this.low === other.low;
      };
      LongPrototype.eq = LongPrototype.equals;
      LongPrototype.notEquals = function notEquals(other) {
        return !this.eq(
          /* validates */
          other
        );
      };
      LongPrototype.neq = LongPrototype.notEquals;
      LongPrototype.lessThan = function lessThan(other) {
        return this.comp(
          /* validates */
          other
        ) < 0;
      };
      LongPrototype.lt = LongPrototype.lessThan;
      LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
        return this.comp(
          /* validates */
          other
        ) <= 0;
      };
      LongPrototype.lte = LongPrototype.lessThanOrEqual;
      LongPrototype.greaterThan = function greaterThan(other) {
        return this.comp(
          /* validates */
          other
        ) > 0;
      };
      LongPrototype.gt = LongPrototype.greaterThan;
      LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
        return this.comp(
          /* validates */
          other
        ) >= 0;
      };
      LongPrototype.gte = LongPrototype.greaterThanOrEqual;
      LongPrototype.compare = function compare(other) {
        if (!isLong(other))
          other = fromValue(other);
        if (this.eq(other))
          return 0;
        var thisNeg = this.isNegative(), otherNeg = other.isNegative();
        if (thisNeg && !otherNeg)
          return -1;
        if (!thisNeg && otherNeg)
          return 1;
        if (!this.unsigned)
          return this.sub(other).isNegative() ? -1 : 1;
        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
      };
      LongPrototype.comp = LongPrototype.compare;
      LongPrototype.negate = function negate3() {
        if (!this.unsigned && this.eq(MIN_VALUE))
          return MIN_VALUE;
        return this.not().add(ONE);
      };
      LongPrototype.neg = LongPrototype.negate;
      LongPrototype.add = function add6(addend) {
        if (!isLong(addend))
          addend = fromValue(addend);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = addend.high >>> 16;
        var b32 = addend.high & 65535;
        var b16 = addend.low >>> 16;
        var b00 = addend.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 + b48;
        c48 &= 65535;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      LongPrototype.subtract = function subtract4(subtrahend) {
        if (!isLong(subtrahend))
          subtrahend = fromValue(subtrahend);
        return this.add(subtrahend.neg());
      };
      LongPrototype.sub = LongPrototype.subtract;
      LongPrototype.multiply = function multiply5(multiplier) {
        if (this.isZero())
          return ZERO2;
        if (!isLong(multiplier))
          multiplier = fromValue(multiplier);
        if (multiplier.isZero())
          return ZERO2;
        if (this.eq(MIN_VALUE))
          return multiplier.isOdd() ? MIN_VALUE : ZERO2;
        if (multiplier.eq(MIN_VALUE))
          return this.isOdd() ? MIN_VALUE : ZERO2;
        if (this.isNegative()) {
          if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
          else
            return this.neg().mul(multiplier).neg();
        } else if (multiplier.isNegative())
          return this.mul(multiplier.neg()).neg();
        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
          return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = multiplier.high >>> 16;
        var b32 = multiplier.high & 65535;
        var b16 = multiplier.low >>> 16;
        var b00 = multiplier.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 65535;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      LongPrototype.mul = LongPrototype.multiply;
      LongPrototype.divide = function divide3(divisor) {
        if (!isLong(divisor))
          divisor = fromValue(divisor);
        if (divisor.isZero())
          throw Error("division by zero");
        if (this.isZero())
          return this.unsigned ? UZERO : ZERO2;
        var approx, rem, res;
        if (!this.unsigned) {
          if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
              return MIN_VALUE;
            else if (divisor.eq(MIN_VALUE))
              return ONE;
            else {
              var halfThis = this.shr(1);
              approx = halfThis.div(divisor).shl(1);
              if (approx.eq(ZERO2)) {
                return divisor.isNegative() ? ONE : NEG_ONE;
              } else {
                rem = this.sub(divisor.mul(approx));
                res = approx.add(rem.div(divisor));
                return res;
              }
            }
          } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO2;
          if (this.isNegative()) {
            if (divisor.isNegative())
              return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
          } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
          res = ZERO2;
        } else {
          if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
          if (divisor.gt(this))
            return UZERO;
          if (divisor.gt(this.shru(1)))
            return UONE;
          res = UZERO;
        }
        rem = this;
        while (rem.gte(divisor)) {
          approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
          var log22 = Math.ceil(Math.log(approx) / Math.LN2), delta = log22 <= 48 ? 1 : pow_dbl(2, log22 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
          while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
          }
          if (approxRes.isZero())
            approxRes = ONE;
          res = res.add(approxRes);
          rem = rem.sub(approxRem);
        }
        return res;
      };
      LongPrototype.div = LongPrototype.divide;
      LongPrototype.modulo = function modulo(divisor) {
        if (!isLong(divisor))
          divisor = fromValue(divisor);
        return this.sub(this.div(divisor).mul(divisor));
      };
      LongPrototype.mod = LongPrototype.modulo;
      LongPrototype.not = function not() {
        return fromBits(~this.low, ~this.high, this.unsigned);
      };
      LongPrototype.and = function and(other) {
        if (!isLong(other))
          other = fromValue(other);
        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
      };
      LongPrototype.or = function or(other) {
        if (!isLong(other))
          other = fromValue(other);
        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
      };
      LongPrototype.xor = function xor(other) {
        if (!isLong(other))
          other = fromValue(other);
        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
      };
      LongPrototype.shiftLeft = function shiftLeft2(numBits) {
        if (isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        else if (numBits < 32)
          return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
        else
          return fromBits(0, this.low << numBits - 32, this.unsigned);
      };
      LongPrototype.shl = LongPrototype.shiftLeft;
      LongPrototype.shiftRight = function shiftRight2(numBits) {
        if (isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        else if (numBits < 32)
          return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
        else
          return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
      };
      LongPrototype.shr = LongPrototype.shiftRight;
      LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
        if (isLong(numBits))
          numBits = numBits.toInt();
        numBits &= 63;
        if (numBits === 0)
          return this;
        else {
          var high = this.high;
          if (numBits < 32) {
            var low = this.low;
            return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
          } else if (numBits === 32)
            return fromBits(high, 0, this.unsigned);
          else
            return fromBits(high >>> numBits - 32, 0, this.unsigned);
        }
      };
      LongPrototype.shru = LongPrototype.shiftRightUnsigned;
      LongPrototype.toSigned = function toSigned() {
        if (!this.unsigned)
          return this;
        return fromBits(this.low, this.high, false);
      };
      LongPrototype.toUnsigned = function toUnsigned() {
        if (this.unsigned)
          return this;
        return fromBits(this.low, this.high, true);
      };
      LongPrototype.toBytes = function(le) {
        return le ? this.toBytesLE() : this.toBytesBE();
      };
      LongPrototype.toBytesLE = function() {
        var hi = this.high, lo = this.low;
        return [
          lo & 255,
          lo >>> 8 & 255,
          lo >>> 16 & 255,
          lo >>> 24 & 255,
          hi & 255,
          hi >>> 8 & 255,
          hi >>> 16 & 255,
          hi >>> 24 & 255
        ];
      };
      LongPrototype.toBytesBE = function() {
        var hi = this.high, lo = this.low;
        return [
          hi >>> 24 & 255,
          hi >>> 16 & 255,
          hi >>> 8 & 255,
          hi & 255,
          lo >>> 24 & 255,
          lo >>> 16 & 255,
          lo >>> 8 & 255,
          lo & 255
        ];
      };
      return Long3;
    });
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e2, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d2 = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d2;
      e2 = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e2 = e2 * 256 + buffer[offset + i], i += d2, nBits -= 8) {
      }
      m = e2 & (1 << -nBits) - 1;
      e2 >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d2, nBits -= 8) {
      }
      if (e2 === 0) {
        e2 = 1 - eBias;
      } else if (e2 === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e2 = e2 - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e2 - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e2, m, c2;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d2 = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e2 = eMax;
      } else {
        e2 = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c2 = Math.pow(2, -e2)) < 1) {
          e2--;
          c2 *= 2;
        }
        if (e2 + eBias >= 1) {
          value += rt / c2;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c2 >= 2) {
          e2++;
          c2 /= 2;
        }
        if (e2 + eBias >= eMax) {
          m = 0;
          e2 = eMax;
        } else if (e2 + eBias >= 1) {
          m = (value * c2 - 1) * Math.pow(2, mLen);
          e2 = e2 + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e2 = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d2, m /= 256, mLen -= 8) {
      }
      e2 = e2 << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e2 & 255, i += d2, e2 /= 256, eLen -= 8) {
      }
      buffer[offset + i - d2] |= s * 128;
    };
  }
});

// node_modules/@loaders.gl/mvt/node_modules/pbf/index.js
var require_pbf = __commonJS({
  "node_modules/@loaders.gl/mvt/node_modules/pbf/index.js"(exports, module) {
    "use strict";
    module.exports = Pbf;
    var ieee754 = require_ieee754();
    function Pbf(buf) {
      this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
      this.pos = 0;
      this.type = 0;
      this.length = this.buf.length;
    }
    Pbf.Varint = 0;
    Pbf.Fixed64 = 1;
    Pbf.Bytes = 2;
    Pbf.Fixed32 = 5;
    var SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
    var SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
    var TEXT_DECODER_MIN_LENGTH = 12;
    var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8");
    Pbf.prototype = {
      destroy: function() {
        this.buf = null;
      },
      // === READING =================================================================
      readFields: function(readField, result, end) {
        end = end || this.length;
        while (this.pos < end) {
          var val = this.readVarint(), tag = val >> 3, startPos = this.pos;
          this.type = val & 7;
          readField(tag, result, this);
          if (this.pos === startPos) this.skip(val);
        }
        return result;
      },
      readMessage: function(readField, result) {
        return this.readFields(readField, result, this.readVarint() + this.pos);
      },
      readFixed32: function() {
        var val = readUInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
      },
      readSFixed32: function() {
        var val = readInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
      },
      // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)
      readFixed64: function() {
        var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
      },
      readSFixed64: function() {
        var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
      },
      readFloat: function() {
        var val = ieee754.read(this.buf, this.pos, true, 23, 4);
        this.pos += 4;
        return val;
      },
      readDouble: function() {
        var val = ieee754.read(this.buf, this.pos, true, 52, 8);
        this.pos += 8;
        return val;
      },
      readVarint: function(isSigned) {
        var buf = this.buf, val, b2;
        b2 = buf[this.pos++];
        val = b2 & 127;
        if (b2 < 128) return val;
        b2 = buf[this.pos++];
        val |= (b2 & 127) << 7;
        if (b2 < 128) return val;
        b2 = buf[this.pos++];
        val |= (b2 & 127) << 14;
        if (b2 < 128) return val;
        b2 = buf[this.pos++];
        val |= (b2 & 127) << 21;
        if (b2 < 128) return val;
        b2 = buf[this.pos];
        val |= (b2 & 15) << 28;
        return readVarintRemainder(val, isSigned, this);
      },
      readVarint64: function() {
        return this.readVarint(true);
      },
      readSVarint: function() {
        var num = this.readVarint();
        return num % 2 === 1 ? (num + 1) / -2 : num / 2;
      },
      readBoolean: function() {
        return Boolean(this.readVarint());
      },
      readString: function() {
        var end = this.readVarint() + this.pos;
        var pos = this.pos;
        this.pos = end;
        if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {
          return readUtf8TextDecoder(this.buf, pos, end);
        }
        return readUtf8(this.buf, pos, end);
      },
      readBytes: function() {
        var end = this.readVarint() + this.pos, buffer = this.buf.subarray(this.pos, end);
        this.pos = end;
        return buffer;
      },
      // verbose for performance reasons; doesn't affect gzipped size
      readPackedVarint: function(arr, isSigned) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readVarint(isSigned));
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readVarint(isSigned));
        return arr;
      },
      readPackedSVarint: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readSVarint());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readSVarint());
        return arr;
      },
      readPackedBoolean: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readBoolean());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readBoolean());
        return arr;
      },
      readPackedFloat: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readFloat());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readFloat());
        return arr;
      },
      readPackedDouble: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readDouble());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readDouble());
        return arr;
      },
      readPackedFixed32: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readFixed32());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readFixed32());
        return arr;
      },
      readPackedSFixed32: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readSFixed32());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readSFixed32());
        return arr;
      },
      readPackedFixed64: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readFixed64());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readFixed64());
        return arr;
      },
      readPackedSFixed64: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readSFixed64());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readSFixed64());
        return arr;
      },
      skip: function(val) {
        var type = val & 7;
        if (type === Pbf.Varint) while (this.buf[this.pos++] > 127) {
        }
        else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;
        else if (type === Pbf.Fixed32) this.pos += 4;
        else if (type === Pbf.Fixed64) this.pos += 8;
        else throw new Error("Unimplemented type: " + type);
      },
      // === WRITING =================================================================
      writeTag: function(tag, type) {
        this.writeVarint(tag << 3 | type);
      },
      realloc: function(min3) {
        var length5 = this.length || 16;
        while (length5 < this.pos + min3) length5 *= 2;
        if (length5 !== this.length) {
          var buf = new Uint8Array(length5);
          buf.set(this.buf);
          this.buf = buf;
          this.length = length5;
        }
      },
      finish: function() {
        this.length = this.pos;
        this.pos = 0;
        return this.buf.subarray(0, this.length);
      },
      writeFixed32: function(val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
      },
      writeSFixed32: function(val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
      },
      writeFixed64: function(val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
      },
      writeSFixed64: function(val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
      },
      writeVarint: function(val) {
        val = +val || 0;
        if (val > 268435455 || val < 0) {
          writeBigVarint(val, this);
          return;
        }
        this.realloc(4);
        this.buf[this.pos++] = val & 127 | (val > 127 ? 128 : 0);
        if (val <= 127) return;
        this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
        if (val <= 127) return;
        this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
        if (val <= 127) return;
        this.buf[this.pos++] = val >>> 7 & 127;
      },
      writeSVarint: function(val) {
        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
      },
      writeBoolean: function(val) {
        this.writeVarint(Boolean(val));
      },
      writeString: function(str5) {
        str5 = String(str5);
        this.realloc(str5.length * 4);
        this.pos++;
        var startPos = this.pos;
        this.pos = writeUtf8(this.buf, str5, this.pos);
        var len4 = this.pos - startPos;
        if (len4 >= 128) makeRoomForExtraLength(startPos, len4, this);
        this.pos = startPos - 1;
        this.writeVarint(len4);
        this.pos += len4;
      },
      writeFloat: function(val) {
        this.realloc(4);
        ieee754.write(this.buf, val, this.pos, true, 23, 4);
        this.pos += 4;
      },
      writeDouble: function(val) {
        this.realloc(8);
        ieee754.write(this.buf, val, this.pos, true, 52, 8);
        this.pos += 8;
      },
      writeBytes: function(buffer) {
        var len4 = buffer.length;
        this.writeVarint(len4);
        this.realloc(len4);
        for (var i = 0; i < len4; i++) this.buf[this.pos++] = buffer[i];
      },
      writeRawMessage: function(fn, obj) {
        this.pos++;
        var startPos = this.pos;
        fn(obj, this);
        var len4 = this.pos - startPos;
        if (len4 >= 128) makeRoomForExtraLength(startPos, len4, this);
        this.pos = startPos - 1;
        this.writeVarint(len4);
        this.pos += len4;
      },
      writeMessage: function(tag, fn, obj) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeRawMessage(fn, obj);
      },
      writePackedVarint: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedVarint, arr);
      },
      writePackedSVarint: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedSVarint, arr);
      },
      writePackedBoolean: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedBoolean, arr);
      },
      writePackedFloat: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedFloat, arr);
      },
      writePackedDouble: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedDouble, arr);
      },
      writePackedFixed32: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedFixed32, arr);
      },
      writePackedSFixed32: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedSFixed32, arr);
      },
      writePackedFixed64: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedFixed64, arr);
      },
      writePackedSFixed64: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedSFixed64, arr);
      },
      writeBytesField: function(tag, buffer) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeBytes(buffer);
      },
      writeFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFixed32(val);
      },
      writeSFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeSFixed32(val);
      },
      writeFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeFixed64(val);
      },
      writeSFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeSFixed64(val);
      },
      writeVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeVarint(val);
      },
      writeSVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeSVarint(val);
      },
      writeStringField: function(tag, str5) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeString(str5);
      },
      writeFloatField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFloat(val);
      },
      writeDoubleField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeDouble(val);
      },
      writeBooleanField: function(tag, val) {
        this.writeVarintField(tag, Boolean(val));
      }
    };
    function readVarintRemainder(l, s, p) {
      var buf = p.buf, h, b2;
      b2 = buf[p.pos++];
      h = (b2 & 112) >> 4;
      if (b2 < 128) return toNum(l, h, s);
      b2 = buf[p.pos++];
      h |= (b2 & 127) << 3;
      if (b2 < 128) return toNum(l, h, s);
      b2 = buf[p.pos++];
      h |= (b2 & 127) << 10;
      if (b2 < 128) return toNum(l, h, s);
      b2 = buf[p.pos++];
      h |= (b2 & 127) << 17;
      if (b2 < 128) return toNum(l, h, s);
      b2 = buf[p.pos++];
      h |= (b2 & 127) << 24;
      if (b2 < 128) return toNum(l, h, s);
      b2 = buf[p.pos++];
      h |= (b2 & 1) << 31;
      if (b2 < 128) return toNum(l, h, s);
      throw new Error("Expected varint not more than 10 bytes");
    }
    function readPackedEnd(pbf) {
      return pbf.type === Pbf.Bytes ? pbf.readVarint() + pbf.pos : pbf.pos + 1;
    }
    function toNum(low, high, isSigned) {
      if (isSigned) {
        return high * 4294967296 + (low >>> 0);
      }
      return (high >>> 0) * 4294967296 + (low >>> 0);
    }
    function writeBigVarint(val, pbf) {
      var low, high;
      if (val >= 0) {
        low = val % 4294967296 | 0;
        high = val / 4294967296 | 0;
      } else {
        low = ~(-val % 4294967296);
        high = ~(-val / 4294967296);
        if (low ^ 4294967295) {
          low = low + 1 | 0;
        } else {
          low = 0;
          high = high + 1 | 0;
        }
      }
      if (val >= 18446744073709552e3 || val < -18446744073709552e3) {
        throw new Error("Given varint doesn't fit into 10 bytes");
      }
      pbf.realloc(10);
      writeBigVarintLow(low, high, pbf);
      writeBigVarintHigh(high, pbf);
    }
    function writeBigVarintLow(low, high, pbf) {
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos] = low & 127;
    }
    function writeBigVarintHigh(high, pbf) {
      var lsb = (high & 7) << 4;
      pbf.buf[pbf.pos++] |= lsb | ((high >>>= 3) ? 128 : 0);
      if (!high) return;
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high) return;
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high) return;
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high) return;
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high) return;
      pbf.buf[pbf.pos++] = high & 127;
    }
    function makeRoomForExtraLength(startPos, len4, pbf) {
      var extraLen = len4 <= 16383 ? 1 : len4 <= 2097151 ? 2 : len4 <= 268435455 ? 3 : Math.floor(Math.log(len4) / (Math.LN2 * 7));
      pbf.realloc(extraLen);
      for (var i = pbf.pos - 1; i >= startPos; i--) pbf.buf[i + extraLen] = pbf.buf[i];
    }
    function writePackedVarint(arr, pbf) {
      for (var i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);
    }
    function writePackedSVarint(arr, pbf) {
      for (var i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);
    }
    function writePackedFloat(arr, pbf) {
      for (var i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);
    }
    function writePackedDouble(arr, pbf) {
      for (var i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);
    }
    function writePackedBoolean(arr, pbf) {
      for (var i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);
    }
    function writePackedFixed32(arr, pbf) {
      for (var i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);
    }
    function writePackedSFixed32(arr, pbf) {
      for (var i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]);
    }
    function writePackedFixed64(arr, pbf) {
      for (var i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);
    }
    function writePackedSFixed64(arr, pbf) {
      for (var i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]);
    }
    function readUInt32(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + buf[pos + 3] * 16777216;
    }
    function writeInt32(buf, val, pos) {
      buf[pos] = val;
      buf[pos + 1] = val >>> 8;
      buf[pos + 2] = val >>> 16;
      buf[pos + 3] = val >>> 24;
    }
    function readInt32(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + (buf[pos + 3] << 24);
    }
    function readUtf8(buf, pos, end) {
      var str5 = "";
      var i = pos;
      while (i < end) {
        var b0 = buf[i];
        var c2 = null;
        var bytesPerSequence = b0 > 239 ? 4 : b0 > 223 ? 3 : b0 > 191 ? 2 : 1;
        if (i + bytesPerSequence > end) break;
        var b1, b2, b3;
        if (bytesPerSequence === 1) {
          if (b0 < 128) {
            c2 = b0;
          }
        } else if (bytesPerSequence === 2) {
          b1 = buf[i + 1];
          if ((b1 & 192) === 128) {
            c2 = (b0 & 31) << 6 | b1 & 63;
            if (c2 <= 127) {
              c2 = null;
            }
          }
        } else if (bytesPerSequence === 3) {
          b1 = buf[i + 1];
          b2 = buf[i + 2];
          if ((b1 & 192) === 128 && (b2 & 192) === 128) {
            c2 = (b0 & 15) << 12 | (b1 & 63) << 6 | b2 & 63;
            if (c2 <= 2047 || c2 >= 55296 && c2 <= 57343) {
              c2 = null;
            }
          }
        } else if (bytesPerSequence === 4) {
          b1 = buf[i + 1];
          b2 = buf[i + 2];
          b3 = buf[i + 3];
          if ((b1 & 192) === 128 && (b2 & 192) === 128 && (b3 & 192) === 128) {
            c2 = (b0 & 15) << 18 | (b1 & 63) << 12 | (b2 & 63) << 6 | b3 & 63;
            if (c2 <= 65535 || c2 >= 1114112) {
              c2 = null;
            }
          }
        }
        if (c2 === null) {
          c2 = 65533;
          bytesPerSequence = 1;
        } else if (c2 > 65535) {
          c2 -= 65536;
          str5 += String.fromCharCode(c2 >>> 10 & 1023 | 55296);
          c2 = 56320 | c2 & 1023;
        }
        str5 += String.fromCharCode(c2);
        i += bytesPerSequence;
      }
      return str5;
    }
    function readUtf8TextDecoder(buf, pos, end) {
      return utf8TextDecoder.decode(buf.subarray(pos, end));
    }
    function writeUtf8(buf, str5, pos) {
      for (var i = 0, c2, lead; i < str5.length; i++) {
        c2 = str5.charCodeAt(i);
        if (c2 > 55295 && c2 < 57344) {
          if (lead) {
            if (c2 < 56320) {
              buf[pos++] = 239;
              buf[pos++] = 191;
              buf[pos++] = 189;
              lead = c2;
              continue;
            } else {
              c2 = lead - 55296 << 10 | c2 - 56320 | 65536;
              lead = null;
            }
          } else {
            if (c2 > 56319 || i + 1 === str5.length) {
              buf[pos++] = 239;
              buf[pos++] = 191;
              buf[pos++] = 189;
            } else {
              lead = c2;
            }
            continue;
          }
        } else if (lead) {
          buf[pos++] = 239;
          buf[pos++] = 191;
          buf[pos++] = 189;
          lead = null;
        }
        if (c2 < 128) {
          buf[pos++] = c2;
        } else {
          if (c2 < 2048) {
            buf[pos++] = c2 >> 6 | 192;
          } else {
            if (c2 < 65536) {
              buf[pos++] = c2 >> 12 | 224;
            } else {
              buf[pos++] = c2 >> 18 | 240;
              buf[pos++] = c2 >> 12 & 63 | 128;
            }
            buf[pos++] = c2 >> 6 & 63 | 128;
          }
          buf[pos++] = c2 & 63 | 128;
        }
      }
      return pos;
    }
  }
});

// node_modules/@deck.gl/layers/dist/arc-layer/arc-layer-uniforms.js
var uniformBlock = `uniform arcUniforms {
  bool greatCircle;
  bool useShortestPath;
  float numSegments;
  float widthScale;
  float widthMinPixels;
  float widthMaxPixels;
  highp int widthUnits;
} arc;
`;
var arcUniforms = {
  name: "arc",
  vs: uniformBlock,
  fs: uniformBlock,
  uniformTypes: {
    greatCircle: "f32",
    useShortestPath: "f32",
    numSegments: "f32",
    widthScale: "f32",
    widthMinPixels: "f32",
    widthMaxPixels: "f32",
    widthUnits: "i32"
  }
};

// node_modules/@deck.gl/layers/dist/arc-layer/arc-layer-vertex.glsl.js
var arc_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME arc-layer-vertex-shader
in vec4 instanceSourceColors;
in vec4 instanceTargetColors;
in vec3 instanceSourcePositions;
in vec3 instanceSourcePositions64Low;
in vec3 instanceTargetPositions;
in vec3 instanceTargetPositions64Low;
in vec3 instancePickingColors;
in float instanceWidths;
in float instanceHeights;
in float instanceTilts;
out vec4 vColor;
out vec2 uv;
out float isValid;
float paraboloid(float distance, float sourceZ, float targetZ, float ratio) {
float deltaZ = targetZ - sourceZ;
float dh = distance * instanceHeights;
if (dh == 0.0) {
return sourceZ + deltaZ * ratio;
}
float unitZ = deltaZ / dh;
float p2 = unitZ * unitZ + 1.0;
float dir = step(deltaZ, 0.0);
float z0 = mix(sourceZ, targetZ, dir);
float r = mix(ratio, 1.0 - ratio, dir);
return sqrt(r * (p2 - r)) * dh + z0;
}
vec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {
vec2 dir_screenspace = normalize(line_clipspace * project.viewportSize);
dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);
return dir_screenspace * offset_direction * width / 2.0;
}
float getSegmentRatio(float index) {
return smoothstep(0.0, 1.0, index / (arc.numSegments - 1.0));
}
vec3 interpolateFlat(vec3 source, vec3 target, float segmentRatio) {
float distance = length(source.xy - target.xy);
float z = paraboloid(distance, source.z, target.z, segmentRatio);
float tiltAngle = radians(instanceTilts);
vec2 tiltDirection = normalize(target.xy - source.xy);
vec2 tilt = vec2(-tiltDirection.y, tiltDirection.x) * z * sin(tiltAngle);
return vec3(
mix(source.xy, target.xy, segmentRatio) + tilt,
z * cos(tiltAngle)
);
}
float getAngularDist (vec2 source, vec2 target) {
vec2 sourceRadians = radians(source);
vec2 targetRadians = radians(target);
vec2 sin_half_delta = sin((sourceRadians - targetRadians) / 2.0);
vec2 shd_sq = sin_half_delta * sin_half_delta;
float a = shd_sq.y + cos(sourceRadians.y) * cos(targetRadians.y) * shd_sq.x;
return 2.0 * asin(sqrt(a));
}
vec3 interpolateGreatCircle(vec3 source, vec3 target, vec3 source3D, vec3 target3D, float angularDist, float t) {
vec2 lngLat;
if(abs(angularDist - PI) < 0.001) {
lngLat = (1.0 - t) * source.xy + t * target.xy;
} else {
float a = sin((1.0 - t) * angularDist);
float b = sin(t * angularDist);
vec3 p = source3D.yxz * a + target3D.yxz * b;
lngLat = degrees(vec2(atan(p.y, -p.x), atan(p.z, length(p.xy))));
}
float z = paraboloid(angularDist * EARTH_RADIUS, source.z, target.z, t);
return vec3(lngLat, z);
}
void main(void) {
geometry.worldPosition = instanceSourcePositions;
geometry.worldPositionAlt = instanceTargetPositions;
float segmentIndex = float(gl_VertexID / 2);
float segmentSide = mod(float(gl_VertexID), 2.) == 0. ? -1. : 1.;
float segmentRatio = getSegmentRatio(segmentIndex);
float prevSegmentRatio = getSegmentRatio(max(0.0, segmentIndex - 1.0));
float nextSegmentRatio = getSegmentRatio(min(arc.numSegments - 1.0, segmentIndex + 1.0));
float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));
isValid = 1.0;
uv = vec2(segmentRatio, segmentSide);
geometry.uv = uv;
geometry.pickingColor = instancePickingColors;
vec4 curr;
vec4 next;
vec3 source;
vec3 target;
if ((arc.greatCircle || project.projectionMode == PROJECTION_MODE_GLOBE) && project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
source = project_globe_(vec3(instanceSourcePositions.xy, 0.0));
target = project_globe_(vec3(instanceTargetPositions.xy, 0.0));
float angularDist = getAngularDist(instanceSourcePositions.xy, instanceTargetPositions.xy);
vec3 prevPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, prevSegmentRatio);
vec3 currPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, segmentRatio);
vec3 nextPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, nextSegmentRatio);
if (abs(currPos.x - prevPos.x) > 180.0) {
indexDir = -1.0;
isValid = 0.0;
} else if (abs(currPos.x - nextPos.x) > 180.0) {
indexDir = 1.0;
isValid = 0.0;
}
nextPos = indexDir < 0.0 ? prevPos : nextPos;
nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;
if (isValid == 0.0) {
nextPos.x += nextPos.x > 0.0 ? -360.0 : 360.0;
float t = ((currPos.x > 0.0 ? 180.0 : -180.0) - currPos.x) / (nextPos.x - currPos.x);
currPos = mix(currPos, nextPos, t);
segmentRatio = mix(segmentRatio, nextSegmentRatio, t);
}
vec3 currPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, segmentRatio);
vec3 nextPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, nextSegmentRatio);
curr = project_position_to_clipspace(currPos, currPos64Low, vec3(0.0), geometry.position);
next = project_position_to_clipspace(nextPos, nextPos64Low, vec3(0.0));
} else {
vec3 source_world = instanceSourcePositions;
vec3 target_world = instanceTargetPositions;
if (arc.useShortestPath) {
source_world.x = mod(source_world.x + 180., 360.0) - 180.;
target_world.x = mod(target_world.x + 180., 360.0) - 180.;
float deltaLng = target_world.x - source_world.x;
if (deltaLng > 180.) target_world.x -= 360.;
if (deltaLng < -180.) source_world.x -= 360.;
}
source = project_position(source_world, instanceSourcePositions64Low);
target = project_position(target_world, instanceTargetPositions64Low);
float antiMeridianX = 0.0;
if (arc.useShortestPath) {
if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
antiMeridianX = -(project.coordinateOrigin.x + 180.) / 360. * TILE_SIZE;
}
float thresholdRatio = (antiMeridianX - source.x) / (target.x - source.x);
if (prevSegmentRatio <= thresholdRatio && nextSegmentRatio > thresholdRatio) {
isValid = 0.0;
indexDir = sign(segmentRatio - thresholdRatio);
segmentRatio = thresholdRatio;
}
}
nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;
vec3 currPos = interpolateFlat(source, target, segmentRatio);
vec3 nextPos = interpolateFlat(source, target, nextSegmentRatio);
if (arc.useShortestPath) {
if (nextPos.x < antiMeridianX) {
currPos.x += TILE_SIZE;
nextPos.x += TILE_SIZE;
}
}
curr = project_common_position_to_clipspace(vec4(currPos, 1.0));
next = project_common_position_to_clipspace(vec4(nextPos, 1.0));
geometry.position = vec4(currPos, 1.0);
}
float widthPixels = clamp(
project_size_to_pixel(instanceWidths * arc.widthScale, arc.widthUnits),
arc.widthMinPixels, arc.widthMaxPixels
);
vec3 offset = vec3(
getExtrusionOffset((next.xy - curr.xy) * indexDir, segmentSide, widthPixels),
0.0);
DECKGL_FILTER_SIZE(offset, geometry);
DECKGL_FILTER_GL_POSITION(curr, geometry);
gl_Position = curr + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);
vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio);
vColor = vec4(color.rgb, color.a * layer.opacity);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/arc-layer/arc-layer-fragment.glsl.js
var arc_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME arc-layer-fragment-shader
precision highp float;
in vec4 vColor;
in vec2 uv;
in float isValid;
out vec4 fragColor;
void main(void) {
if (isValid == 0.0) {
discard;
}
fragColor = vColor;
geometry.uv = uv;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/arc-layer/arc-layer.js
var DEFAULT_COLOR = [0, 0, 0, 255];
var defaultProps = {
  getSourcePosition: { type: "accessor", value: (x) => x.sourcePosition },
  getTargetPosition: { type: "accessor", value: (x) => x.targetPosition },
  getSourceColor: { type: "accessor", value: DEFAULT_COLOR },
  getTargetColor: { type: "accessor", value: DEFAULT_COLOR },
  getWidth: { type: "accessor", value: 1 },
  getHeight: { type: "accessor", value: 1 },
  getTilt: { type: "accessor", value: 0 },
  greatCircle: false,
  numSegments: { type: "number", value: 50, min: 1 },
  widthUnits: "pixels",
  widthScale: { type: "number", value: 1, min: 0 },
  widthMinPixels: { type: "number", value: 0, min: 0 },
  widthMaxPixels: { type: "number", value: Number.MAX_SAFE_INTEGER, min: 0 }
};
var ArcLayer = class extends layer_default {
  getBounds() {
    var _a;
    return (_a = this.getAttributeManager()) == null ? void 0 : _a.getBounds([
      "instanceSourcePositions",
      "instanceTargetPositions"
    ]);
  }
  getShaders() {
    return super.getShaders({ vs: arc_layer_vertex_glsl_default, fs: arc_layer_fragment_glsl_default, modules: [project32_default, picking_default, arcUniforms] });
  }
  // This layer has its own wrapLongitude logic
  get wrapLongitude() {
    return false;
  }
  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instanceSourcePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getSourcePosition"
      },
      instanceTargetPositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getTargetPosition"
      },
      instanceSourceColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: true,
        accessor: "getSourceColor",
        defaultValue: DEFAULT_COLOR
      },
      instanceTargetColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: true,
        accessor: "getTargetColor",
        defaultValue: DEFAULT_COLOR
      },
      instanceWidths: {
        size: 1,
        transition: true,
        accessor: "getWidth",
        defaultValue: 1
      },
      instanceHeights: {
        size: 1,
        transition: true,
        accessor: "getHeight",
        defaultValue: 1
      },
      instanceTilts: {
        size: 1,
        transition: true,
        accessor: "getTilt",
        defaultValue: 0
      }
    });
  }
  updateState(params) {
    var _a;
    super.updateState(params);
    if (params.changeFlags.extensionsChanged) {
      (_a = this.state.model) == null ? void 0 : _a.destroy();
      this.state.model = this._getModel();
      this.getAttributeManager().invalidateAll();
    }
  }
  draw({ uniforms }) {
    const { widthUnits, widthScale, widthMinPixels, widthMaxPixels, greatCircle, wrapLongitude, numSegments } = this.props;
    const arcProps = {
      numSegments,
      widthUnits: UNIT[widthUnits],
      widthScale,
      widthMinPixels,
      widthMaxPixels,
      greatCircle,
      useShortestPath: wrapLongitude
    };
    const model = this.state.model;
    model.shaderInputs.setProps({ arc: arcProps });
    model.setVertexCount(numSegments * 2);
    model.draw(this.context.renderPass);
  }
  _getModel() {
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      topology: "triangle-strip",
      isInstanced: true
    });
  }
};
ArcLayer.layerName = "ArcLayer";
ArcLayer.defaultProps = defaultProps;
var arc_layer_default = ArcLayer;

// node_modules/@deck.gl/layers/dist/bitmap-layer/create-mesh.js
var DEFAULT_INDICES = new Uint32Array([0, 2, 1, 0, 3, 2]);
var DEFAULT_TEX_COORDS = new Float32Array([0, 1, 0, 0, 1, 0, 1, 1]);
function createMesh(bounds, resolution) {
  if (!resolution) {
    return createQuad(bounds);
  }
  const maxXSpan = Math.max(Math.abs(bounds[0][0] - bounds[3][0]), Math.abs(bounds[1][0] - bounds[2][0]));
  const maxYSpan = Math.max(Math.abs(bounds[1][1] - bounds[0][1]), Math.abs(bounds[2][1] - bounds[3][1]));
  const uCount = Math.ceil(maxXSpan / resolution) + 1;
  const vCount = Math.ceil(maxYSpan / resolution) + 1;
  const vertexCount = (uCount - 1) * (vCount - 1) * 6;
  const indices = new Uint32Array(vertexCount);
  const texCoords = new Float32Array(uCount * vCount * 2);
  const positions = new Float64Array(uCount * vCount * 3);
  let vertex4 = 0;
  let index = 0;
  for (let u2 = 0; u2 < uCount; u2++) {
    const ut = u2 / (uCount - 1);
    for (let v2 = 0; v2 < vCount; v2++) {
      const vt = v2 / (vCount - 1);
      const p = interpolateQuad(bounds, ut, vt);
      positions[vertex4 * 3 + 0] = p[0];
      positions[vertex4 * 3 + 1] = p[1];
      positions[vertex4 * 3 + 2] = p[2] || 0;
      texCoords[vertex4 * 2 + 0] = ut;
      texCoords[vertex4 * 2 + 1] = 1 - vt;
      if (u2 > 0 && v2 > 0) {
        indices[index++] = vertex4 - vCount;
        indices[index++] = vertex4 - vCount - 1;
        indices[index++] = vertex4 - 1;
        indices[index++] = vertex4 - vCount;
        indices[index++] = vertex4 - 1;
        indices[index++] = vertex4;
      }
      vertex4++;
    }
  }
  return {
    vertexCount,
    positions,
    indices,
    texCoords
  };
}
function createQuad(bounds) {
  const positions = new Float64Array(12);
  for (let i = 0; i < bounds.length; i++) {
    positions[i * 3 + 0] = bounds[i][0];
    positions[i * 3 + 1] = bounds[i][1];
    positions[i * 3 + 2] = bounds[i][2] || 0;
  }
  return {
    vertexCount: 6,
    positions,
    indices: DEFAULT_INDICES,
    texCoords: DEFAULT_TEX_COORDS
  };
}
function interpolateQuad(quad, ut, vt) {
  return lerp(lerp(quad[0], quad[1], vt), lerp(quad[3], quad[2], vt), ut);
}

// node_modules/@deck.gl/layers/dist/bitmap-layer/bitmap-layer-uniforms.js
var uniformBlock2 = `uniform bitmapUniforms {
  vec4 bounds;
  float coordinateConversion;
  float desaturate;
  vec3 tintColor;
  vec4 transparentColor;
} bitmap;
`;
var bitmapUniforms = {
  name: "bitmap",
  vs: uniformBlock2,
  fs: uniformBlock2,
  uniformTypes: {
    bounds: "vec4<f32>",
    coordinateConversion: "f32",
    desaturate: "f32",
    tintColor: "vec3<f32>",
    transparentColor: "vec4<f32>"
  }
};

// node_modules/@deck.gl/layers/dist/bitmap-layer/bitmap-layer-vertex.js
var bitmap_layer_vertex_default = `#version 300 es
#define SHADER_NAME bitmap-layer-vertex-shader

in vec2 texCoords;
in vec3 positions;
in vec3 positions64Low;

out vec2 vTexCoord;
out vec2 vTexPos;

const vec3 pickingColor = vec3(1.0, 0.0, 0.0);

void main(void) {
  geometry.worldPosition = positions;
  geometry.uv = texCoords;
  geometry.pickingColor = pickingColor;

  gl_Position = project_position_to_clipspace(positions, positions64Low, vec3(0.0), geometry.position);
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  vTexCoord = texCoords;

  if (bitmap.coordinateConversion < -0.5) {
    vTexPos = geometry.position.xy + project.commonOrigin.xy;
  } else if (bitmap.coordinateConversion > 0.5) {
    vTexPos = geometry.worldPosition.xy;
  }

  vec4 color = vec4(0.0);
  DECKGL_FILTER_COLOR(color, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/bitmap-layer/bitmap-layer-fragment.js
var packUVsIntoRGB = `
vec3 packUVsIntoRGB(vec2 uv) {
  // Extract the top 8 bits. We want values to be truncated down so we can add a fraction
  vec2 uv8bit = floor(uv * 256.);

  // Calculate the normalized remainders of u and v parts that do not fit into 8 bits
  // Scale and clamp to 0-1 range
  vec2 uvFraction = fract(uv * 256.);
  vec2 uvFraction4bit = floor(uvFraction * 16.);

  // Remainder can be encoded in blue channel, encode as 4 bits for pixel coordinates
  float fractions = uvFraction4bit.x + uvFraction4bit.y * 16.;

  return vec3(uv8bit, fractions) / 255.;
}
`;
var bitmap_layer_fragment_default = `#version 300 es
#define SHADER_NAME bitmap-layer-fragment-shader

#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D bitmapTexture;

in vec2 vTexCoord;
in vec2 vTexPos;

out vec4 fragColor;

/* projection utils */
const float TILE_SIZE = 512.0;
const float PI = 3.1415926536;
const float WORLD_SCALE = TILE_SIZE / PI / 2.0;

// from degrees to Web Mercator
vec2 lnglat_to_mercator(vec2 lnglat) {
  float x = lnglat.x;
  float y = clamp(lnglat.y, -89.9, 89.9);
  return vec2(
    radians(x) + PI,
    PI + log(tan(PI * 0.25 + radians(y) * 0.5))
  ) * WORLD_SCALE;
}

// from Web Mercator to degrees
vec2 mercator_to_lnglat(vec2 xy) {
  xy /= WORLD_SCALE;
  return degrees(vec2(
    xy.x - PI,
    atan(exp(xy.y - PI)) * 2.0 - PI * 0.5
  ));
}
/* End projection utils */

// apply desaturation
vec3 color_desaturate(vec3 color) {
  float luminance = (color.r + color.g + color.b) * 0.333333333;
  return mix(color, vec3(luminance), bitmap.desaturate);
}

// apply tint
vec3 color_tint(vec3 color) {
  return color * bitmap.tintColor;
}

// blend with background color
vec4 apply_opacity(vec3 color, float alpha) {
  if (bitmap.transparentColor.a == 0.0) {
    return vec4(color, alpha);
  }
  float blendedAlpha = alpha + bitmap.transparentColor.a * (1.0 - alpha);
  float highLightRatio = alpha / blendedAlpha;
  vec3 blendedRGB = mix(bitmap.transparentColor.rgb, color, highLightRatio);
  return vec4(blendedRGB, blendedAlpha);
}

vec2 getUV(vec2 pos) {
  return vec2(
    (pos.x - bitmap.bounds[0]) / (bitmap.bounds[2] - bitmap.bounds[0]),
    (pos.y - bitmap.bounds[3]) / (bitmap.bounds[1] - bitmap.bounds[3])
  );
}

${packUVsIntoRGB}

void main(void) {
  vec2 uv = vTexCoord;
  if (bitmap.coordinateConversion < -0.5) {
    vec2 lnglat = mercator_to_lnglat(vTexPos);
    uv = getUV(lnglat);
  } else if (bitmap.coordinateConversion > 0.5) {
    vec2 commonPos = lnglat_to_mercator(vTexPos);
    uv = getUV(commonPos);
  }
  vec4 bitmapColor = texture(bitmapTexture, uv);

  fragColor = apply_opacity(color_tint(color_desaturate(bitmapColor.rgb)), bitmapColor.a * layer.opacity);

  geometry.uv = uv;
  DECKGL_FILTER_COLOR(fragColor, geometry);

  if (bool(picking.isActive) && !bool(picking.isAttribute)) {
    // Since instance information is not used, we can use picking color for pixel index
    fragColor.rgb = packUVsIntoRGB(uv);
  }
}
`;

// node_modules/@deck.gl/layers/dist/bitmap-layer/bitmap-layer.js
var defaultProps2 = {
  image: { type: "image", value: null, async: true },
  bounds: { type: "array", value: [1, 0, 0, 1], compare: true },
  _imageCoordinateSystem: COORDINATE_SYSTEM.DEFAULT,
  desaturate: { type: "number", min: 0, max: 1, value: 0 },
  // More context: because of the blending mode we're using for ground imagery,
  // alpha is not effective when blending the bitmap layers with the base map.
  // Instead we need to manually dim/blend rgb values with a background color.
  transparentColor: { type: "color", value: [0, 0, 0, 0] },
  tintColor: { type: "color", value: [255, 255, 255] },
  textureParameters: { type: "object", ignore: true, value: null }
};
var BitmapLayer = class extends layer_default {
  getShaders() {
    return super.getShaders({ vs: bitmap_layer_vertex_default, fs: bitmap_layer_fragment_default, modules: [project32_default, picking_default, bitmapUniforms] });
  }
  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.remove(["instancePickingColors"]);
    const noAlloc = true;
    attributeManager.add({
      indices: {
        size: 1,
        isIndexed: true,
        update: (attribute) => attribute.value = this.state.mesh.indices,
        noAlloc
      },
      positions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        update: (attribute) => attribute.value = this.state.mesh.positions,
        noAlloc
      },
      texCoords: {
        size: 2,
        update: (attribute) => attribute.value = this.state.mesh.texCoords,
        noAlloc
      }
    });
  }
  updateState({ props, oldProps, changeFlags }) {
    var _a;
    const attributeManager = this.getAttributeManager();
    if (changeFlags.extensionsChanged) {
      (_a = this.state.model) == null ? void 0 : _a.destroy();
      this.state.model = this._getModel();
      attributeManager.invalidateAll();
    }
    if (props.bounds !== oldProps.bounds) {
      const oldMesh = this.state.mesh;
      const mesh = this._createMesh();
      this.state.model.setVertexCount(mesh.vertexCount);
      for (const key in mesh) {
        if (oldMesh && oldMesh[key] !== mesh[key]) {
          attributeManager.invalidate(key);
        }
      }
      this.setState({ mesh, ...this._getCoordinateUniforms() });
    } else if (props._imageCoordinateSystem !== oldProps._imageCoordinateSystem) {
      this.setState(this._getCoordinateUniforms());
    }
  }
  getPickingInfo(params) {
    const { image } = this.props;
    const info = params.info;
    if (!info.color || !image) {
      info.bitmap = null;
      return info;
    }
    const { width, height } = image;
    info.index = 0;
    const uv = unpackUVsFromRGB(info.color);
    info.bitmap = {
      size: { width, height },
      uv,
      pixel: [Math.floor(uv[0] * width), Math.floor(uv[1] * height)]
    };
    return info;
  }
  // Override base Layer multi-depth picking logic
  disablePickingIndex() {
    this.setState({ disablePicking: true });
  }
  restorePickingColors() {
    this.setState({ disablePicking: false });
  }
  _updateAutoHighlight(info) {
    super._updateAutoHighlight({
      ...info,
      color: this.encodePickingColor(0)
    });
  }
  _createMesh() {
    const { bounds } = this.props;
    let normalizedBounds = bounds;
    if (isRectangularBounds(bounds)) {
      normalizedBounds = [
        [bounds[0], bounds[1]],
        [bounds[0], bounds[3]],
        [bounds[2], bounds[3]],
        [bounds[2], bounds[1]]
      ];
    }
    return createMesh(normalizedBounds, this.context.viewport.resolution);
  }
  _getModel() {
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      topology: "triangle-list",
      isInstanced: false
    });
  }
  draw(opts) {
    const { shaderModuleProps } = opts;
    const { model, coordinateConversion, bounds, disablePicking } = this.state;
    const { image, desaturate, transparentColor, tintColor } = this.props;
    if (shaderModuleProps.picking.isActive && disablePicking) {
      return;
    }
    if (image && model) {
      const bitmapProps = {
        bitmapTexture: image,
        bounds,
        coordinateConversion,
        desaturate,
        tintColor: tintColor.slice(0, 3).map((x) => x / 255),
        transparentColor: transparentColor.map((x) => x / 255)
      };
      model.shaderInputs.setProps({ bitmap: bitmapProps });
      model.draw(this.context.renderPass);
    }
  }
  _getCoordinateUniforms() {
    const { LNGLAT, CARTESIAN, DEFAULT } = COORDINATE_SYSTEM;
    let { _imageCoordinateSystem: imageCoordinateSystem } = this.props;
    if (imageCoordinateSystem !== DEFAULT) {
      const { bounds } = this.props;
      if (!isRectangularBounds(bounds)) {
        throw new Error("_imageCoordinateSystem only supports rectangular bounds");
      }
      const defaultImageCoordinateSystem = this.context.viewport.resolution ? LNGLAT : CARTESIAN;
      imageCoordinateSystem = imageCoordinateSystem === LNGLAT ? LNGLAT : CARTESIAN;
      if (imageCoordinateSystem === LNGLAT && defaultImageCoordinateSystem === CARTESIAN) {
        return { coordinateConversion: -1, bounds };
      }
      if (imageCoordinateSystem === CARTESIAN && defaultImageCoordinateSystem === LNGLAT) {
        const bottomLeft = lngLatToWorld([bounds[0], bounds[1]]);
        const topRight = lngLatToWorld([bounds[2], bounds[3]]);
        return {
          coordinateConversion: 1,
          bounds: [bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]]
        };
      }
    }
    return {
      coordinateConversion: 0,
      bounds: [0, 0, 0, 0]
    };
  }
};
BitmapLayer.layerName = "BitmapLayer";
BitmapLayer.defaultProps = defaultProps2;
var bitmap_layer_default = BitmapLayer;
function unpackUVsFromRGB(color) {
  const [u2, v2, fracUV] = color;
  const vFrac = (fracUV & 240) / 256;
  const uFrac = (fracUV & 15) / 16;
  return [(u2 + uFrac) / 256, (v2 + vFrac) / 256];
}
function isRectangularBounds(bounds) {
  return Number.isFinite(bounds[0]);
}

// node_modules/@deck.gl/layers/dist/icon-layer/icon-layer-uniforms.js
var uniformBlock3 = `uniform iconUniforms {
  float sizeScale;
  vec2 iconsTextureDim;
  float sizeBasis;
  float sizeMinPixels;
  float sizeMaxPixels;
  bool billboard;
  highp int sizeUnits;
  float alphaCutoff;
} icon;
`;
var iconUniforms = {
  name: "icon",
  vs: uniformBlock3,
  fs: uniformBlock3,
  uniformTypes: {
    sizeScale: "f32",
    iconsTextureDim: "vec2<f32>",
    sizeBasis: "f32",
    sizeMinPixels: "f32",
    sizeMaxPixels: "f32",
    billboard: "f32",
    sizeUnits: "i32",
    alphaCutoff: "f32"
  }
};

// node_modules/@deck.gl/layers/dist/icon-layer/icon-layer-vertex.glsl.js
var icon_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME icon-layer-vertex-shader
in vec2 positions;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in float instanceSizes;
in float instanceAngles;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec4 instanceIconFrames;
in float instanceColorModes;
in vec2 instanceOffsets;
in vec2 instancePixelOffset;
out float vColorMode;
out vec4 vColor;
out vec2 vTextureCoords;
out vec2 uv;
vec2 rotate_by_angle(vec2 vertex, float angle) {
float angle_radian = angle * PI / 180.0;
float cos_angle = cos(angle_radian);
float sin_angle = sin(angle_radian);
mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);
return rotationMatrix * vertex;
}
void main(void) {
geometry.worldPosition = instancePositions;
geometry.uv = positions;
geometry.pickingColor = instancePickingColors;
uv = positions;
vec2 iconSize = instanceIconFrames.zw;
float sizePixels = clamp(
project_size_to_pixel(instanceSizes * icon.sizeScale, icon.sizeUnits),
icon.sizeMinPixels, icon.sizeMaxPixels
);
float iconConstraint = icon.sizeBasis == 0.0 ? iconSize.x : iconSize.y;
float instanceScale = iconConstraint == 0.0 ? 0.0 : sizePixels / iconConstraint;
vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;
pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;
pixelOffset += instancePixelOffset;
pixelOffset.y *= -1.0;
if (icon.billboard)  {
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
vec3 offset = vec3(pixelOffset, 0.0);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
} else {
vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);
DECKGL_FILTER_SIZE(offset_common, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
vTextureCoords = mix(
instanceIconFrames.xy,
instanceIconFrames.xy + iconSize,
(positions.xy + 1.0) / 2.0
) / icon.iconsTextureDim;
vColor = instanceColors;
DECKGL_FILTER_COLOR(vColor, geometry);
vColorMode = instanceColorModes;
}
`;

// node_modules/@deck.gl/layers/dist/icon-layer/icon-layer-fragment.glsl.js
var icon_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME icon-layer-fragment-shader
precision highp float;
uniform sampler2D iconsTexture;
in float vColorMode;
in vec4 vColor;
in vec2 vTextureCoords;
in vec2 uv;
out vec4 fragColor;
void main(void) {
geometry.uv = uv;
vec4 texColor = texture(iconsTexture, vTextureCoords);
vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);
float a = texColor.a * layer.opacity * vColor.a;
if (a < icon.alphaCutoff) {
discard;
}
fragColor = vec4(color, a);
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/icon-layer/icon-manager.js
var DEFAULT_CANVAS_WIDTH = 1024;
var DEFAULT_BUFFER = 4;
var noop = () => {
};
var DEFAULT_SAMPLER_PARAMETERS = {
  minFilter: "linear",
  mipmapFilter: "linear",
  // LINEAR is the default value but explicitly set it here
  magFilter: "linear",
  // minimize texture boundary artifacts
  addressModeU: "clamp-to-edge",
  addressModeV: "clamp-to-edge"
};
var MISSING_ICON = {
  x: 0,
  y: 0,
  width: 0,
  height: 0
};
function nextPowOfTwo(number) {
  return Math.pow(2, Math.ceil(Math.log2(number)));
}
function resizeImage(ctx, imageData, maxWidth, maxHeight) {
  const resizeRatio = Math.min(maxWidth / imageData.width, maxHeight / imageData.height);
  const width = Math.floor(imageData.width * resizeRatio);
  const height = Math.floor(imageData.height * resizeRatio);
  if (resizeRatio === 1) {
    return { image: imageData, width, height };
  }
  ctx.canvas.height = height;
  ctx.canvas.width = width;
  ctx.clearRect(0, 0, width, height);
  ctx.drawImage(imageData, 0, 0, imageData.width, imageData.height, 0, 0, width, height);
  return { image: ctx.canvas, width, height };
}
function getIconId(icon) {
  return icon && (icon.id || icon.url);
}
function resizeTexture(texture, width, height, sampler) {
  const { width: oldWidth, height: oldHeight, device } = texture;
  const newTexture = device.createTexture({
    format: "rgba8unorm",
    width,
    height,
    sampler,
    mipLevels: device.getMipLevelCount(width, height)
  });
  const commandEncoder = device.createCommandEncoder();
  commandEncoder.copyTextureToTexture({
    sourceTexture: texture,
    destinationTexture: newTexture,
    width: oldWidth,
    height: oldHeight
  });
  commandEncoder.finish();
  newTexture.generateMipmapsWebGL();
  texture.destroy();
  return newTexture;
}
function buildRowMapping(mapping, columns, yOffset) {
  for (let i = 0; i < columns.length; i++) {
    const { icon, xOffset } = columns[i];
    const id = getIconId(icon);
    mapping[id] = {
      ...icon,
      x: xOffset,
      y: yOffset
    };
  }
}
function buildMapping({ icons, buffer, mapping = {}, xOffset = 0, yOffset = 0, rowHeight = 0, canvasWidth }) {
  let columns = [];
  for (let i = 0; i < icons.length; i++) {
    const icon = icons[i];
    const id = getIconId(icon);
    if (!mapping[id]) {
      const { height, width } = icon;
      if (xOffset + width + buffer > canvasWidth) {
        buildRowMapping(mapping, columns, yOffset);
        xOffset = 0;
        yOffset = rowHeight + yOffset + buffer;
        rowHeight = 0;
        columns = [];
      }
      columns.push({
        icon,
        xOffset
      });
      xOffset = xOffset + width + buffer;
      rowHeight = Math.max(rowHeight, height);
    }
  }
  if (columns.length > 0) {
    buildRowMapping(mapping, columns, yOffset);
  }
  return {
    mapping,
    rowHeight,
    xOffset,
    yOffset,
    canvasWidth,
    canvasHeight: nextPowOfTwo(rowHeight + yOffset + buffer)
  };
}
function getDiffIcons(data, getIcon, cachedIcons) {
  if (!data || !getIcon) {
    return null;
  }
  cachedIcons = cachedIcons || {};
  const icons = {};
  const { iterable, objectInfo } = createIterable(data);
  for (const object of iterable) {
    objectInfo.index++;
    const icon = getIcon(object, objectInfo);
    const id = getIconId(icon);
    if (!icon) {
      throw new Error("Icon is missing.");
    }
    if (!icon.url) {
      throw new Error("Icon url is missing.");
    }
    if (!icons[id] && (!cachedIcons[id] || icon.url !== cachedIcons[id].url)) {
      icons[id] = { ...icon, source: object, sourceIndex: objectInfo.index };
    }
  }
  return icons;
}
var IconManager = class {
  constructor(device, { onUpdate = noop, onError = noop }) {
    this._loadOptions = null;
    this._texture = null;
    this._externalTexture = null;
    this._mapping = {};
    this._samplerParameters = null;
    this._pendingCount = 0;
    this._autoPacking = false;
    this._xOffset = 0;
    this._yOffset = 0;
    this._rowHeight = 0;
    this._buffer = DEFAULT_BUFFER;
    this._canvasWidth = DEFAULT_CANVAS_WIDTH;
    this._canvasHeight = 0;
    this._canvas = null;
    this.device = device;
    this.onUpdate = onUpdate;
    this.onError = onError;
  }
  finalize() {
    var _a;
    (_a = this._texture) == null ? void 0 : _a.delete();
  }
  getTexture() {
    return this._texture || this._externalTexture;
  }
  getIconMapping(icon) {
    const id = this._autoPacking ? getIconId(icon) : icon;
    return this._mapping[id] || MISSING_ICON;
  }
  setProps({ loadOptions, autoPacking, iconAtlas, iconMapping, textureParameters }) {
    var _a;
    if (loadOptions) {
      this._loadOptions = loadOptions;
    }
    if (autoPacking !== void 0) {
      this._autoPacking = autoPacking;
    }
    if (iconMapping) {
      this._mapping = iconMapping;
    }
    if (iconAtlas) {
      (_a = this._texture) == null ? void 0 : _a.delete();
      this._texture = null;
      this._externalTexture = iconAtlas;
    }
    if (textureParameters) {
      this._samplerParameters = textureParameters;
    }
  }
  get isLoaded() {
    return this._pendingCount === 0;
  }
  packIcons(data, getIcon) {
    var _a;
    if (!this._autoPacking || typeof document === "undefined") {
      return;
    }
    const icons = Object.values(getDiffIcons(data, getIcon, this._mapping) || {});
    if (icons.length > 0) {
      const { mapping, xOffset, yOffset, rowHeight, canvasHeight } = buildMapping({
        icons,
        buffer: this._buffer,
        canvasWidth: this._canvasWidth,
        mapping: this._mapping,
        rowHeight: this._rowHeight,
        xOffset: this._xOffset,
        yOffset: this._yOffset
      });
      this._rowHeight = rowHeight;
      this._mapping = mapping;
      this._xOffset = xOffset;
      this._yOffset = yOffset;
      this._canvasHeight = canvasHeight;
      if (!this._texture) {
        this._texture = this.device.createTexture({
          format: "rgba8unorm",
          data: null,
          width: this._canvasWidth,
          height: this._canvasHeight,
          sampler: this._samplerParameters || DEFAULT_SAMPLER_PARAMETERS,
          mipLevels: this.device.getMipLevelCount(this._canvasWidth, this._canvasHeight)
        });
      }
      if (this._texture.height !== this._canvasHeight) {
        this._texture = resizeTexture(this._texture, this._canvasWidth, this._canvasHeight, this._samplerParameters || DEFAULT_SAMPLER_PARAMETERS);
      }
      this.onUpdate();
      this._canvas = this._canvas || document.createElement("canvas");
      this._loadIcons(icons);
      (_a = this._texture) == null ? void 0 : _a.generateMipmapsWebGL();
    }
  }
  _loadIcons(icons) {
    const ctx = this._canvas.getContext("2d", {
      willReadFrequently: true
    });
    for (const icon of icons) {
      this._pendingCount++;
      load(icon.url, this._loadOptions).then((imageData) => {
        var _a, _b;
        const id = getIconId(icon);
        const iconDef = this._mapping[id];
        const { x, y, width: maxWidth, height: maxHeight } = iconDef;
        const { image, width, height } = resizeImage(ctx, imageData, maxWidth, maxHeight);
        (_a = this._texture) == null ? void 0 : _a.copyExternalImage({
          image,
          x: x + (maxWidth - width) / 2,
          y: y + (maxHeight - height) / 2,
          width,
          height
        });
        iconDef.width = width;
        iconDef.height = height;
        (_b = this._texture) == null ? void 0 : _b.generateMipmapsWebGL();
        this.onUpdate();
      }).catch((error) => {
        this.onError({
          url: icon.url,
          source: icon.source,
          sourceIndex: icon.sourceIndex,
          loadOptions: this._loadOptions,
          error
        });
      }).finally(() => {
        this._pendingCount--;
      });
    }
  }
};

// node_modules/@deck.gl/layers/dist/icon-layer/icon-layer.js
var DEFAULT_COLOR2 = [0, 0, 0, 255];
var defaultProps3 = {
  iconAtlas: { type: "image", value: null, async: true },
  iconMapping: { type: "object", value: {}, async: true },
  sizeScale: { type: "number", value: 1, min: 0 },
  billboard: true,
  sizeUnits: "pixels",
  sizeBasis: "height",
  sizeMinPixels: { type: "number", min: 0, value: 0 },
  //  min point radius in pixels
  sizeMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
  // max point radius in pixels
  alphaCutoff: { type: "number", value: 0.05, min: 0, max: 1 },
  getPosition: { type: "accessor", value: (x) => x.position },
  getIcon: { type: "accessor", value: (x) => x.icon },
  getColor: { type: "accessor", value: DEFAULT_COLOR2 },
  getSize: { type: "accessor", value: 1 },
  getAngle: { type: "accessor", value: 0 },
  getPixelOffset: { type: "accessor", value: [0, 0] },
  onIconError: { type: "function", value: null, optional: true },
  textureParameters: { type: "object", ignore: true, value: null }
};
var IconLayer = class extends layer_default {
  getShaders() {
    return super.getShaders({ vs: icon_layer_vertex_glsl_default, fs: icon_layer_fragment_glsl_default, modules: [project32_default, picking_default, iconUniforms] });
  }
  initializeState() {
    this.state = {
      iconManager: new IconManager(this.context.device, {
        onUpdate: this._onUpdate.bind(this),
        onError: this._onError.bind(this)
      })
    };
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getPosition"
      },
      instanceSizes: {
        size: 1,
        transition: true,
        accessor: "getSize",
        defaultValue: 1
      },
      instanceOffsets: {
        size: 2,
        accessor: "getIcon",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        transform: this.getInstanceOffset
      },
      instanceIconFrames: {
        size: 4,
        accessor: "getIcon",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        transform: this.getInstanceIconFrame
      },
      instanceColorModes: {
        size: 1,
        type: "uint8",
        accessor: "getIcon",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        transform: this.getInstanceColorMode
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: true,
        accessor: "getColor",
        defaultValue: DEFAULT_COLOR2
      },
      instanceAngles: {
        size: 1,
        transition: true,
        accessor: "getAngle"
      },
      instancePixelOffset: {
        size: 2,
        transition: true,
        accessor: "getPixelOffset"
      }
    });
  }
  /* eslint-disable max-statements, complexity */
  updateState(params) {
    var _a;
    super.updateState(params);
    const { props, oldProps, changeFlags } = params;
    const attributeManager = this.getAttributeManager();
    const { iconAtlas, iconMapping, data, getIcon, textureParameters } = props;
    const { iconManager } = this.state;
    if (typeof iconAtlas === "string") {
      return;
    }
    const prePacked = iconAtlas || this.internalState.isAsyncPropLoading("iconAtlas");
    iconManager.setProps({
      loadOptions: props.loadOptions,
      autoPacking: !prePacked,
      iconAtlas,
      iconMapping: prePacked ? iconMapping : null,
      textureParameters
    });
    if (prePacked) {
      if (oldProps.iconMapping !== props.iconMapping) {
        attributeManager.invalidate("getIcon");
      }
    } else if (changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getIcon)) {
      iconManager.packIcons(data, getIcon);
    }
    if (changeFlags.extensionsChanged) {
      (_a = this.state.model) == null ? void 0 : _a.destroy();
      this.state.model = this._getModel();
      attributeManager.invalidateAll();
    }
  }
  /* eslint-enable max-statements, complexity */
  get isLoaded() {
    return super.isLoaded && this.state.iconManager.isLoaded;
  }
  finalizeState(context) {
    super.finalizeState(context);
    this.state.iconManager.finalize();
  }
  draw({ uniforms }) {
    const { sizeScale, sizeBasis, sizeMinPixels, sizeMaxPixels, sizeUnits, billboard, alphaCutoff } = this.props;
    const { iconManager } = this.state;
    const iconsTexture = iconManager.getTexture();
    if (iconsTexture) {
      const model = this.state.model;
      const iconProps = {
        iconsTexture,
        iconsTextureDim: [iconsTexture.width, iconsTexture.height],
        sizeUnits: UNIT[sizeUnits],
        sizeScale,
        sizeBasis: sizeBasis === "height" ? 1 : 0,
        sizeMinPixels,
        sizeMaxPixels,
        billboard,
        alphaCutoff
      };
      model.shaderInputs.setProps({ icon: iconProps });
      model.draw(this.context.renderPass);
    }
  }
  _getModel() {
    const positions = [-1, -1, 1, -1, -1, 1, 1, 1];
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new Geometry({
        topology: "triangle-strip",
        attributes: {
          // The size must be explicitly passed here otherwise luma.gl
          // will default to assuming that positions are 3D (x,y,z)
          positions: {
            size: 2,
            value: new Float32Array(positions)
          }
        }
      }),
      isInstanced: true
    });
  }
  _onUpdate() {
    this.setNeedsRedraw();
  }
  _onError(evt) {
    var _a;
    const onIconError = (_a = this.getCurrentLayer()) == null ? void 0 : _a.props.onIconError;
    if (onIconError) {
      onIconError(evt);
    } else {
      log_default.error(evt.error.message)();
    }
  }
  getInstanceOffset(icon) {
    const { width, height, anchorX = width / 2, anchorY = height / 2 } = this.state.iconManager.getIconMapping(icon);
    return [width / 2 - anchorX, height / 2 - anchorY];
  }
  getInstanceColorMode(icon) {
    const mapping = this.state.iconManager.getIconMapping(icon);
    return mapping.mask ? 1 : 0;
  }
  getInstanceIconFrame(icon) {
    const { x, y, width, height } = this.state.iconManager.getIconMapping(icon);
    return [x, y, width, height];
  }
};
IconLayer.defaultProps = defaultProps3;
IconLayer.layerName = "IconLayer";
var icon_layer_default = IconLayer;

// node_modules/@deck.gl/layers/dist/line-layer/line-layer-uniforms.js
var uniformBlockWGSL = (
  /* wgsl */
  `struct LineUniforms {
  widthScale: f32,
  widthMinPixels: f32,
  widthMaxPixels: f32,
  useShortestPath: f32,
  widthUnits: i32,
};

@group(0) @binding(1)
var<uniform> line: LineUniforms;
`
);
var uniformBlockGLSL = (
  /* glsl */
  `uniform lineUniforms {
  float widthScale;
  float widthMinPixels;
  float widthMaxPixels;
  float useShortestPath;
  highp int widthUnits;
} line;
`
);
var lineUniforms = {
  name: "line",
  source: uniformBlockWGSL,
  vs: uniformBlockGLSL,
  fs: uniformBlockGLSL,
  uniformTypes: {
    widthScale: "f32",
    widthMinPixels: "f32",
    widthMaxPixels: "f32",
    useShortestPath: "f32",
    widthUnits: "i32"
  }
};

// node_modules/@deck.gl/layers/dist/line-layer/line-layer.wgsl.js
var shaderWGSL = (
  /* wgsl */
  `// ---------- Helper Structures & Functions ----------

// Placeholder filter functions.
fn deckgl_filter_size(offset: vec3<f32>, geometry: Geometry) -> vec3<f32> {
  return offset;
}
fn deckgl_filter_gl_position(p: vec4<f32>, geometry: Geometry) -> vec4<f32> {
  return p;
}
fn deckgl_filter_color(color: vec4<f32>, geometry: Geometry) -> vec4<f32> {
  return color;
}

// Compute an extrusion offset given a line direction (in clipspace),
// an offset direction (-1 or 1), and a width in pixels.
// Assumes a uniform "project" with a viewportSize field is available.
fn getExtrusionOffset(line_clipspace: vec2<f32>, offset_direction: f32, width: f32) -> vec2<f32> {
  // project.viewportSize should be provided as a uniform (not shown here)
  let dir_screenspace = normalize(line_clipspace * project.viewportSize);
  // Rotate by 90°: (x,y) becomes (-y,x)
  let rotated = vec2<f32>(-dir_screenspace.y, dir_screenspace.x);
  return rotated * offset_direction * width / 2.0;
}

// Splits the line between two points at a given x coordinate.
// Interpolates the y and z components.
fn splitLine(a: vec3<f32>, b: vec3<f32>, x: f32) -> vec3<f32> {
  let t: f32 = (x - a.x) / (b.x - a.x);
  return vec3<f32>(x, a.yz + t * (b.yz - a.yz));
}

// ---------- Uniforms & Global Structures ----------

// Uniforms for line, color, and project are assumed to be defined elsewhere.
// For example:
//
// @group(0) @binding(0)
// var<uniform> line: LineUniform;
//
// struct ColorUniform {
//   opacity: f32,
// };
// @group(0) @binding(1)
// var<uniform> color: ColorUniform;
//
// struct ProjectUniform {
//   viewportSize: vec2<f32>,
// };
// @group(0) @binding(2)
// var<uniform> project: ProjectUniform;



// ---------- Vertex Output Structure ----------

struct Varyings {
  @builtin(position) gl_Position: vec4<f32>,
  @location(0) vColor: vec4<f32>,
  @location(1) uv: vec2<f32>,
};

// ---------- Vertex Shader Entry Point ----------

@vertex
fn vertexMain(
  @location(0) positions: vec3<f32>,
  @location(1) instanceSourcePositions: vec3<f32>,
  @location(2) instanceTargetPositions: vec3<f32>,
  @location(3) instanceSourcePositions64Low: vec3<f32>,
  @location(4) instanceTargetPositions64Low: vec3<f32>,
  @location(5) instanceColors: vec4<f32>,
  @location(6) instancePickingColors: vec3<f32>,
  @location(7) instanceWidths: f32
) -> Varyings {
  var geometry: Geometry;
  geometry.worldPosition = instanceSourcePositions;
  geometry.worldPositionAlt = instanceTargetPositions;

  var source_world: vec3<f32> = instanceSourcePositions;
  var target_world: vec3<f32> = instanceTargetPositions;
  var source_world_64low: vec3<f32> = instanceSourcePositions64Low;
  var target_world_64low: vec3<f32> = instanceTargetPositions64Low;

  // Apply shortest-path adjustments if needed.
  if (line.useShortestPath > 0.5 || line.useShortestPath < -0.5) {
    source_world.x = (source_world.x + 180.0 % 360.0) - 180.0;
    target_world.x = (target_world.x + 180.0 % 360.0) - 180.0;
    let deltaLng: f32 = target_world.x - source_world.x;

    if (deltaLng * line.useShortestPath > 180.0) {
      source_world.x = source_world.x + 360.0 * line.useShortestPath;
      source_world = splitLine(source_world, target_world, 180.0 * line.useShortestPath);
      source_world_64low = vec3<f32>(0.0, 0.0, 0.0);
    } else if (deltaLng * line.useShortestPath < -180.0) {
      target_world.x = target_world.x + 360.0 * line.useShortestPath;
      target_world = splitLine(source_world, target_world, 180.0 * line.useShortestPath);
      target_world_64low = vec3<f32>(0.0, 0.0, 0.0);
    } else if (line.useShortestPath < 0.0) {
      var abortOut: Varyings;
      abortOut.gl_Position = vec4<f32>(0.0);
      abortOut.vColor = vec4<f32>(0.0);
      abortOut.uv = vec2<f32>(0.0);
      return abortOut;
    }
  }

  // Project Pos and target positions to clip space.
  let sourceResult = project_position_to_clipspace_and_commonspace(source_world, source_world_64low, vec3<f32>(0.0));
  let targetResult = project_position_to_clipspace_and_commonspace(target_world, target_world_64low, vec3<f32>(0.0));
  let sourcePos: vec4<f32> = sourceResult.clipPosition;
  let targetPos: vec4<f32> = targetResult.clipPosition;
  let source_commonspace: vec4<f32> = sourceResult.commonPosition;
  let target_commonspace: vec4<f32> = targetResult.commonPosition;

  // Interpolate along the line segment.
  let segmentIndex: f32 = positions.x;
  let p: vec4<f32> = sourcePos + segmentIndex * (targetPos - sourcePos);
  geometry.position = source_commonspace + segmentIndex * (target_commonspace - source_commonspace);
  let uv: vec2<f32> = positions.xy;
  geometry.uv = uv;
  geometry.pickingColor = instancePickingColors;

  // Determine width in pixels.
  let widthPixels: f32 = clamp(
    project_unit_size_to_pixel(instanceWidths * line.widthScale, line.widthUnits),
    line.widthMinPixels, line.widthMaxPixels
  );

  // Compute extrusion offset.
  let extrusion: vec2<f32> = getExtrusionOffset(targetPos.xy - sourcePos.xy, positions.y, widthPixels);
  let offset: vec3<f32> = vec3<f32>(extrusion, 0.0);

  // Apply deck.gl filter functions.
  let filteredOffset = deckgl_filter_size(offset, geometry);
  let filteredP = deckgl_filter_gl_position(p, geometry);

  let clipOffset: vec2<f32> = project_pixel_size_to_clipspace(filteredOffset.xy);
  let finalPosition: vec4<f32> = filteredP + vec4<f32>(clipOffset, 0.0, 0.0);

  // Compute color.
  var vColor: vec4<f32> = vec4<f32>(instanceColors.rgb, instanceColors.a * color.opacity);
  // vColor = deckgl_filter_color(vColor, geometry);

  var output: Varyings;
  output.gl_Position = finalPosition;
  output.vColor = vColor;
  output.uv = uv;
  return output;
}

@fragment
fn fragmentMain(
  @location(0) vColor: vec4<f32>,
  @location(1) uv: vec2<f32>
) -> @location(0) vec4<f32> {
  // Create and initialize geometry with the provided uv.
  var geometry: Geometry;
  geometry.uv = uv;

  // Start with the input color.
  var fragColor: vec4<f32> = vColor;

  // Apply the deck.gl filter to the color.
  fragColor = deckgl_filter_color(fragColor, geometry);

  // Apply premultiplied alpha as required by transparent canvas
  fragColor = deckgl_premultiplied_alpha(fragColor);

  return fragColor;
}
`
);

// node_modules/@deck.gl/layers/dist/line-layer/line-layer-vertex.glsl.js
var line_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME line-layer-vertex-shader
in vec3 positions;
in vec3 instanceSourcePositions;
in vec3 instanceTargetPositions;
in vec3 instanceSourcePositions64Low;
in vec3 instanceTargetPositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in float instanceWidths;
out vec4 vColor;
out vec2 uv;
vec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {
vec2 dir_screenspace = normalize(line_clipspace * project.viewportSize);
dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);
return dir_screenspace * offset_direction * width / 2.0;
}
vec3 splitLine(vec3 a, vec3 b, float x) {
float t = (x - a.x) / (b.x - a.x);
return vec3(x, mix(a.yz, b.yz, t));
}
void main(void) {
geometry.worldPosition = instanceSourcePositions;
geometry.worldPositionAlt = instanceTargetPositions;
vec3 source_world = instanceSourcePositions;
vec3 target_world = instanceTargetPositions;
vec3 source_world_64low = instanceSourcePositions64Low;
vec3 target_world_64low = instanceTargetPositions64Low;
if (line.useShortestPath > 0.5 || line.useShortestPath < -0.5) {
source_world.x = mod(source_world.x + 180., 360.0) - 180.;
target_world.x = mod(target_world.x + 180., 360.0) - 180.;
float deltaLng = target_world.x - source_world.x;
if (deltaLng * line.useShortestPath > 180.) {
source_world.x += 360. * line.useShortestPath;
source_world = splitLine(source_world, target_world, 180. * line.useShortestPath);
source_world_64low = vec3(0.0);
} else if (deltaLng * line.useShortestPath < -180.) {
target_world.x += 360. * line.useShortestPath;
target_world = splitLine(source_world, target_world, 180. * line.useShortestPath);
target_world_64low = vec3(0.0);
} else if (line.useShortestPath < 0.) {
gl_Position = vec4(0.);
return;
}
}
vec4 source_commonspace;
vec4 target_commonspace;
vec4 source = project_position_to_clipspace(source_world, source_world_64low, vec3(0.), source_commonspace);
vec4 target = project_position_to_clipspace(target_world, target_world_64low, vec3(0.), target_commonspace);
float segmentIndex = positions.x;
vec4 p = mix(source, target, segmentIndex);
geometry.position = mix(source_commonspace, target_commonspace, segmentIndex);
uv = positions.xy;
geometry.uv = uv;
geometry.pickingColor = instancePickingColors;
float widthPixels = clamp(
project_size_to_pixel(instanceWidths * line.widthScale, line.widthUnits),
line.widthMinPixels, line.widthMaxPixels
);
vec3 offset = vec3(
getExtrusionOffset(target.xy - source.xy, positions.y, widthPixels),
0.0);
DECKGL_FILTER_SIZE(offset, geometry);
DECKGL_FILTER_GL_POSITION(p, geometry);
gl_Position = p + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);
vColor = vec4(instanceColors.rgb, instanceColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/line-layer/line-layer-fragment.glsl.js
var line_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME line-layer-fragment-shader
precision highp float;
in vec4 vColor;
in vec2 uv;
out vec4 fragColor;
void main(void) {
geometry.uv = uv;
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/line-layer/line-layer.js
var DEFAULT_COLOR3 = [0, 0, 0, 255];
var defaultProps4 = {
  getSourcePosition: { type: "accessor", value: (x) => x.sourcePosition },
  getTargetPosition: { type: "accessor", value: (x) => x.targetPosition },
  getColor: { type: "accessor", value: DEFAULT_COLOR3 },
  getWidth: { type: "accessor", value: 1 },
  widthUnits: "pixels",
  widthScale: { type: "number", value: 1, min: 0 },
  widthMinPixels: { type: "number", value: 0, min: 0 },
  widthMaxPixels: { type: "number", value: Number.MAX_SAFE_INTEGER, min: 0 }
};
var LineLayer = class extends layer_default {
  getBounds() {
    var _a;
    return (_a = this.getAttributeManager()) == null ? void 0 : _a.getBounds([
      "instanceSourcePositions",
      "instanceTargetPositions"
    ]);
  }
  getShaders() {
    return super.getShaders({ vs: line_layer_vertex_glsl_default, fs: line_layer_fragment_glsl_default, source: shaderWGSL, modules: [project32_default, color_default, picking_default, lineUniforms] });
  }
  // This layer has its own wrapLongitude logic
  get wrapLongitude() {
    return false;
  }
  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instanceSourcePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getSourcePosition"
      },
      instanceTargetPositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getTargetPosition"
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: true,
        accessor: "getColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceWidths: {
        size: 1,
        transition: true,
        accessor: "getWidth",
        defaultValue: 1
      }
    });
  }
  updateState(params) {
    var _a;
    super.updateState(params);
    if (params.changeFlags.extensionsChanged) {
      (_a = this.state.model) == null ? void 0 : _a.destroy();
      this.state.model = this._getModel();
      this.getAttributeManager().invalidateAll();
    }
  }
  draw({ uniforms }) {
    const { widthUnits, widthScale, widthMinPixels, widthMaxPixels, wrapLongitude } = this.props;
    const model = this.state.model;
    const lineProps = {
      widthUnits: UNIT[widthUnits],
      widthScale,
      widthMinPixels,
      widthMaxPixels,
      useShortestPath: wrapLongitude ? 1 : 0
    };
    model.shaderInputs.setProps({ line: lineProps });
    model.draw(this.context.renderPass);
    if (wrapLongitude) {
      model.shaderInputs.setProps({ line: { ...lineProps, useShortestPath: -1 } });
      model.draw(this.context.renderPass);
    }
  }
  _getModel() {
    const parameters2 = this.context.device.type === "webgpu" ? {
      depthWriteEnabled: true,
      depthCompare: "less-equal"
    } : void 0;
    const positions = [0, -1, 0, 0, 1, 0, 1, -1, 0, 1, 1, 0];
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new Geometry({
        topology: "triangle-strip",
        attributes: {
          positions: { size: 3, value: new Float32Array(positions) }
        }
      }),
      parameters: parameters2,
      isInstanced: true
    });
  }
};
LineLayer.layerName = "LineLayer";
LineLayer.defaultProps = defaultProps4;

// node_modules/@deck.gl/layers/dist/point-cloud-layer/point-cloud-layer-uniforms.js
var wgslUniformBlock = (
  /* wgsl */
  `struct PointCloudUniforms {
  radiusPixels: f32,
  sizeUnits: i32,
};

@group(0) @binding(3)
var<uniform> pointCloud: PointCloudUniforms;
`
);
var glslUniformBlock = `uniform pointCloudUniforms {
  float radiusPixels;
  highp int sizeUnits;
} pointCloud;
`;
var pointCloudUniforms = {
  name: "pointCloud",
  source: wgslUniformBlock,
  vs: glslUniformBlock,
  fs: glslUniformBlock,
  uniformTypes: {
    radiusPixels: "f32",
    sizeUnits: "i32"
  }
};

// node_modules/@deck.gl/layers/dist/point-cloud-layer/point-cloud-layer-vertex.glsl.js
var point_cloud_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME point-cloud-layer-vertex-shader
in vec3 positions;
in vec3 instanceNormals;
in vec4 instanceColors;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec3 instancePickingColors;
out vec4 vColor;
out vec2 unitPosition;
void main(void) {
geometry.worldPosition = instancePositions;
geometry.normal = project_normal(instanceNormals);
unitPosition = positions.xy;
geometry.uv = unitPosition;
geometry.pickingColor = instancePickingColors;
vec3 offset = vec3(positions.xy * project_size_to_pixel(pointCloud.radiusPixels, pointCloud.sizeUnits), 0.0);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
vec3 lightColor = lighting_getLightColor(instanceColors.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);
vColor = vec4(lightColor, instanceColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/point-cloud-layer/point-cloud-layer-fragment.glsl.js
var point_cloud_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME point-cloud-layer-fragment-shader
precision highp float;
in vec4 vColor;
in vec2 unitPosition;
out vec4 fragColor;
void main(void) {
geometry.uv = unitPosition.xy;
float distToCenter = length(unitPosition);
if (distToCenter > 1.0) {
discard;
}
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/point-cloud-layer/point-cloud-layer.wgsl.js
var point_cloud_layer_wgsl_default = (
  /* wgsl */
  `struct ConstantAttributes {
  instanceNormals: vec3<f32>,
  instanceColors: vec4<f32>,
  instancePositions: vec3<f32>,
  instancePositions64Low: vec3<f32>,
  instancePickingColors: vec3<f32>
};

const constants = ConstantAttributes(
  vec3<f32>(1.0, 0.0, 0.0),
  vec4<f32>(0.0, 0.0, 0.0, 1.0),
  vec3<f32>(0.0),
  vec3<f32>(0.0),
  vec3<f32>(0.0)
);

struct Attributes {
  @builtin(instance_index) instanceIndex : u32,
  @builtin(vertex_index) vertexIndex : u32,
  @location(0) positions: vec3<f32>,
  @location(1) instancePositions: vec3<f32>,
  @location(2) instancePositions64Low: vec3<f32>,
  @location(3) instanceNormals: vec3<f32>,
  @location(4) instanceColors: vec4<f32>,
  @location(5) instancePickingColors: vec3<f32>
};

struct Varyings {
  @builtin(position) position: vec4<f32>,
  @location(0) vColor: vec4<f32>,
  @location(1) unitPosition: vec2<f32>,
};

@vertex
fn vertexMain(attributes: Attributes) -> Varyings {
  var varyings: Varyings;
  
  // var geometry: Geometry;
  // geometry.worldPosition = instancePositions;
  // geometry.normal = project_normal(instanceNormals);

  // position on the containing square in [-1, 1] space
  varyings.unitPosition = attributes.positions.xy;
  geometry.uv = varyings.unitPosition;
  geometry.pickingColor = attributes.instancePickingColors;

  // Find the center of the point and add the current vertex
  let offset = vec3<f32>(attributes.positions.xy * project_unit_size_to_pixel(pointCloud.radiusPixels, pointCloud.sizeUnits), 0.0);
  // DECKGL_FILTER_SIZE(offset, geometry);

  varyings.position = project_position_to_clipspace(attributes.instancePositions, attributes.instancePositions64Low, vec3<f32>(0.0)); // TODO , geometry.position);
  // DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
  let clipPixels = project_pixel_size_to_clipspace(offset.xy);
  varyings.position.x += clipPixels.x;
  varyings.position.y += clipPixels.y;

  // Apply lighting
  let lightColor = lighting_getLightColor2(attributes.instanceColors.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);

  // Apply opacity to instance color, or return instance picking color
  varyings.vColor = vec4(lightColor, attributes.instanceColors.a * color.opacity);
  // DECKGL_FILTER_COLOR(vColor, geometry);

  return varyings;
}

@fragment
fn fragmentMain(varyings: Varyings) -> @location(0) vec4<f32> {
  // var geometry: Geometry;
  // geometry.uv = unitPosition.xy;

  let distToCenter = length(varyings.unitPosition);
  if (distToCenter > 1.0) {
    discard;
  }

  var fragColor: vec4<f32>;

  fragColor = varyings.vColor;
  // DECKGL_FILTER_COLOR(fragColor, geometry);

  // Apply premultiplied alpha as required by transparent canvas
  fragColor = deckgl_premultiplied_alpha(fragColor);

  return fragColor;
}
`
);

// node_modules/@deck.gl/layers/dist/point-cloud-layer/point-cloud-layer.js
var DEFAULT_COLOR4 = [0, 0, 0, 255];
var DEFAULT_NORMAL = [0, 0, 1];
var defaultProps5 = {
  sizeUnits: "pixels",
  pointSize: { type: "number", min: 0, value: 10 },
  //  point radius in pixels
  getPosition: { type: "accessor", value: (x) => x.position },
  getNormal: { type: "accessor", value: DEFAULT_NORMAL },
  getColor: { type: "accessor", value: DEFAULT_COLOR4 },
  material: true,
  // Depreated
  radiusPixels: { deprecatedFor: "pointSize" }
};
function normalizeData(data) {
  const { header, attributes } = data;
  if (!header || !attributes) {
    return;
  }
  data.length = header.vertexCount;
  if (attributes.POSITION) {
    attributes.instancePositions = attributes.POSITION;
  }
  if (attributes.NORMAL) {
    attributes.instanceNormals = attributes.NORMAL;
  }
  if (attributes.COLOR_0) {
    const { size, value } = attributes.COLOR_0;
    attributes.instanceColors = { size, type: "unorm8", value };
  }
}
var PointCloudLayer = class extends layer_default {
  getShaders() {
    return super.getShaders({
      vs: point_cloud_layer_vertex_glsl_default,
      fs: point_cloud_layer_fragment_glsl_default,
      source: point_cloud_layer_wgsl_default,
      modules: [project32_default, color_default, gouraudMaterial, picking_default, pointCloudUniforms]
    });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getPosition"
      },
      instanceNormals: {
        size: 3,
        transition: true,
        accessor: "getNormal",
        defaultValue: DEFAULT_NORMAL
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: true,
        accessor: "getColor",
        defaultValue: DEFAULT_COLOR4
      }
    });
  }
  updateState(params) {
    var _a;
    const { changeFlags, props } = params;
    super.updateState(params);
    if (changeFlags.extensionsChanged) {
      (_a = this.state.model) == null ? void 0 : _a.destroy();
      this.state.model = this._getModel();
      this.getAttributeManager().invalidateAll();
    }
    if (changeFlags.dataChanged) {
      normalizeData(props.data);
    }
  }
  draw({ uniforms }) {
    const { pointSize, sizeUnits } = this.props;
    const model = this.state.model;
    const pointCloudProps = {
      sizeUnits: UNIT[sizeUnits],
      radiusPixels: pointSize
    };
    model.shaderInputs.setProps({ pointCloud: pointCloudProps });
    if (this.context.device.type === "webgpu") {
      model.instanceCount = this.props.data.length;
    }
    model.draw(this.context.renderPass);
  }
  _getModel() {
    const parameters2 = this.context.device.type === "webgpu" ? {
      depthWriteEnabled: true,
      depthCompare: "less-equal"
    } : void 0;
    const positions = [];
    for (let i = 0; i < 3; i++) {
      const angle3 = i / 3 * Math.PI * 2;
      positions.push(Math.cos(angle3) * 2, Math.sin(angle3) * 2, 0);
    }
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new Geometry({
        topology: "triangle-list",
        attributes: {
          positions: new Float32Array(positions)
        }
      }),
      parameters: parameters2,
      isInstanced: true
    });
  }
};
PointCloudLayer.layerName = "PointCloudLayer";
PointCloudLayer.defaultProps = defaultProps5;
var point_cloud_layer_default = PointCloudLayer;

// node_modules/@deck.gl/layers/dist/scatterplot-layer/scatterplot-layer-uniforms.js
var glslUniformBlock2 = `uniform scatterplotUniforms {
  float radiusScale;
  float radiusMinPixels;
  float radiusMaxPixels;
  float lineWidthScale;
  float lineWidthMinPixels;
  float lineWidthMaxPixels;
  float stroked;
  float filled;
  bool antialiasing;
  bool billboard;
  highp int radiusUnits;
  highp int lineWidthUnits;
} scatterplot;
`;
var scatterplotUniforms = {
  name: "scatterplot",
  vs: glslUniformBlock2,
  fs: glslUniformBlock2,
  source: "",
  uniformTypes: {
    radiusScale: "f32",
    radiusMinPixels: "f32",
    radiusMaxPixels: "f32",
    lineWidthScale: "f32",
    lineWidthMinPixels: "f32",
    lineWidthMaxPixels: "f32",
    stroked: "f32",
    filled: "f32",
    antialiasing: "f32",
    billboard: "f32",
    radiusUnits: "i32",
    lineWidthUnits: "i32"
  }
};

// node_modules/@deck.gl/layers/dist/scatterplot-layer/scatterplot-layer-vertex.glsl.js
var scatterplot_layer_vertex_glsl_default = (
  /* glsl */
  `#version 300 es
#define SHADER_NAME scatterplot-layer-vertex-shader
in vec3 positions;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in float instanceRadius;
in float instanceLineWidths;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in vec3 instancePickingColors;
out vec4 vFillColor;
out vec4 vLineColor;
out vec2 unitPosition;
out float innerUnitRadius;
out float outerRadiusPixels;
void main(void) {
geometry.worldPosition = instancePositions;
outerRadiusPixels = clamp(
project_size_to_pixel(scatterplot.radiusScale * instanceRadius, scatterplot.radiusUnits),
scatterplot.radiusMinPixels, scatterplot.radiusMaxPixels
);
float lineWidthPixels = clamp(
project_size_to_pixel(scatterplot.lineWidthScale * instanceLineWidths, scatterplot.lineWidthUnits),
scatterplot.lineWidthMinPixels, scatterplot.lineWidthMaxPixels
);
outerRadiusPixels += scatterplot.stroked * lineWidthPixels / 2.0;
float edgePadding = scatterplot.antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;
unitPosition = edgePadding * positions.xy;
geometry.uv = unitPosition;
geometry.pickingColor = instancePickingColors;
innerUnitRadius = 1.0 - scatterplot.stroked * lineWidthPixels / outerRadiusPixels;
if (scatterplot.billboard) {
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
vec3 offset = edgePadding * positions * outerRadiusPixels;
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
} else {
vec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vFillColor, geometry);
vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vLineColor, geometry);
}
`
);

// node_modules/@deck.gl/layers/dist/scatterplot-layer/scatterplot-layer-fragment.glsl.js
var scatterplot_layer_fragment_glsl_default = (
  /* glsl */
  `#version 300 es
#define SHADER_NAME scatterplot-layer-fragment-shader
precision highp float;
in vec4 vFillColor;
in vec4 vLineColor;
in vec2 unitPosition;
in float innerUnitRadius;
in float outerRadiusPixels;
out vec4 fragColor;
void main(void) {
geometry.uv = unitPosition;
float distToCenter = length(unitPosition) * outerRadiusPixels;
float inCircle = scatterplot.antialiasing ?
smoothedge(distToCenter, outerRadiusPixels) :
step(distToCenter, outerRadiusPixels);
if (inCircle == 0.0) {
discard;
}
if (scatterplot.stroked > 0.5) {
float isLine = scatterplot.antialiasing ?
smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :
step(innerUnitRadius * outerRadiusPixels, distToCenter);
if (scatterplot.filled > 0.5) {
fragColor = mix(vFillColor, vLineColor, isLine);
} else {
if (isLine == 0.0) {
discard;
}
fragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);
}
} else if (scatterplot.filled < 0.5) {
discard;
} else {
fragColor = vFillColor;
}
fragColor.a *= inCircle;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`
);

// node_modules/@deck.gl/layers/dist/scatterplot-layer/scatterplot-layer.wgsl.js
var scatterplot_layer_wgsl_default = (
  /* wgsl */
  `// Main shaders

struct ScatterplotUniforms {
  radiusScale: f32,
  radiusMinPixels: f32,
  radiusMaxPixels: f32,
  lineWidthScale: f32,
  lineWidthMinPixels: f32,
  lineWidthMaxPixels: f32,
  stroked: f32,
  filled: i32,
  antialiasing: i32,
  billboard: i32,
  radiusUnits: i32,
  lineWidthUnits: i32,
};

struct ConstantAttributeUniforms {
 instancePositions: vec3<f32>,
 instancePositions64Low: vec3<f32>,
 instanceRadius: f32,
 instanceLineWidths: f32,
 instanceFillColors: vec4<f32>,
 instanceLineColors: vec4<f32>,
 instancePickingColors: vec3<f32>,

 instancePositionsConstant: i32,
 instancePositions64LowConstant: i32,
 instanceRadiusConstant: i32,
 instanceLineWidthsConstant: i32,
 instanceFillColorsConstant: i32,
 instanceLineColorsConstant: i32,
 instancePickingColorsConstant: i32
};

@group(0) @binding(2) var<uniform> scatterplot: ScatterplotUniforms;

struct ConstantAttributes {
  instancePositions: vec3<f32>,
  instancePositions64Low: vec3<f32>,
  instanceRadius: f32,
  instanceLineWidths: f32,
  instanceFillColors: vec4<f32>,
  instanceLineColors: vec4<f32>,
  instancePickingColors: vec3<f32>
};

const constants = ConstantAttributes(
  vec3<f32>(0.0),
  vec3<f32>(0.0),
  0.0,
  0.0,
  vec4<f32>(0.0, 0.0, 0.0, 1.0),
  vec4<f32>(0.0, 0.0, 0.0, 1.0),
  vec3<f32>(0.0)
);

struct Attributes {
  @builtin(instance_index) instanceIndex : u32,
  @builtin(vertex_index) vertexIndex : u32,
  @location(0) positions: vec3<f32>,
  @location(1) instancePositions: vec3<f32>,
  @location(2) instancePositions64Low: vec3<f32>,
  @location(3) instanceRadius: f32,
  @location(4) instanceLineWidths: f32,
  @location(5) instanceFillColors: vec4<f32>,
  @location(6) instanceLineColors: vec4<f32>,
  @location(7) instancePickingColors: vec3<f32>
};

struct Varyings {
  @builtin(position) position: vec4<f32>,
  @location(0) vFillColor: vec4<f32>,
  @location(1) vLineColor: vec4<f32>,
  @location(2) unitPosition: vec2<f32>,
  @location(3) innerUnitRadius: f32,
  @location(4) outerRadiusPixels: f32,
};

@vertex
fn vertexMain(attributes: Attributes) -> Varyings {
  var varyings: Varyings;

  // Draw an inline geometry constant array clip space triangle to verify that rendering works.
  // var positions = array<vec2<f32>, 3>(vec2(0.0, 0.5), vec2(-0.5, -0.5), vec2(0.5, -0.5));
  // if (attributes.instanceIndex == 0) {
  //   varyings.position = vec4<f32>(positions[attributes.vertexIndex], 0.0, 1.0);
  //   return varyings;
  // }

  // var geometry: Geometry;
  // geometry.worldPosition = instancePositions;

  // Multiply out radius and clamp to limits
  varyings.outerRadiusPixels = clamp(
    project_unit_size_to_pixel(scatterplot.radiusScale * attributes.instanceRadius, scatterplot.radiusUnits),
    scatterplot.radiusMinPixels, scatterplot.radiusMaxPixels
  );

  // Multiply out line width and clamp to limits
  let lineWidthPixels = clamp(
    project_unit_size_to_pixel(scatterplot.lineWidthScale * attributes.instanceLineWidths, scatterplot.lineWidthUnits),
    scatterplot.lineWidthMinPixels, scatterplot.lineWidthMaxPixels
  );

  // outer radius needs to offset by half stroke width
  varyings.outerRadiusPixels += scatterplot.stroked * lineWidthPixels / 2.0;
  // Expand geometry to accommodate edge smoothing
  let edgePadding = select(
    (varyings.outerRadiusPixels + SMOOTH_EDGE_RADIUS) / varyings.outerRadiusPixels,
    1.0,
    scatterplot.antialiasing != 0
  );

  // position on the containing square in [-1, 1] space
  varyings.unitPosition = edgePadding * attributes.positions.xy;
  geometry.uv = varyings.unitPosition;
  geometry.pickingColor = attributes.instancePickingColors;

  varyings.innerUnitRadius = 1.0 - scatterplot.stroked * lineWidthPixels / varyings.outerRadiusPixels;

  if (scatterplot.billboard != 0) {
    varyings.position = project_position_to_clipspace(attributes.instancePositions, attributes.instancePositions64Low, vec3<f32>(0.0)); // TODO , geometry.position);
    // DECKGL_FILTER_GL_POSITION(varyings.position, geometry);
    let offset = attributes.positions; // * edgePadding * varyings.outerRadiusPixels;
    // DECKGL_FILTER_SIZE(offset, geometry);
    let clipPixels = project_pixel_size_to_clipspace(offset.xy);
    varyings.position.x = clipPixels.x;
    varyings.position.y = clipPixels.y;
  } else {
    let offset = edgePadding * attributes.positions * project_pixel_size_float(varyings.outerRadiusPixels);
    // DECKGL_FILTER_SIZE(offset, geometry);
    varyings.position = project_position_to_clipspace(attributes.instancePositions, attributes.instancePositions64Low, offset); // TODO , geometry.position);
    // DECKGL_FILTER_GL_POSITION(varyings.position, geometry);
  }

  // Apply opacity to instance color, or return instance picking color
  varyings.vFillColor = vec4<f32>(attributes.instanceFillColors.rgb, attributes.instanceFillColors.a * color.opacity);
  // DECKGL_FILTER_COLOR(varyings.vFillColor, geometry);
  varyings.vLineColor = vec4<f32>(attributes.instanceLineColors.rgb, attributes.instanceLineColors.a * color.opacity);
  // DECKGL_FILTER_COLOR(varyings.vLineColor, geometry);

  return varyings;
}

@fragment
fn fragmentMain(varyings: Varyings) -> @location(0) vec4<f32> {
  // var geometry: Geometry;
  // geometry.uv = unitPosition;

  let distToCenter = length(varyings.unitPosition) * varyings.outerRadiusPixels;
  let inCircle = select(
    smoothedge(distToCenter, varyings.outerRadiusPixels),
    step(distToCenter, varyings.outerRadiusPixels),
    scatterplot.antialiasing != 0
  );

  if (inCircle == 0.0) {
    discard;
  }

  var fragColor: vec4<f32>;

  if (scatterplot.stroked != 0) {
    let isLine = select(
      smoothedge(varyings.innerUnitRadius * varyings.outerRadiusPixels, distToCenter),
      step(varyings.innerUnitRadius * varyings.outerRadiusPixels, distToCenter),
      scatterplot.antialiasing != 0
    );

    if (scatterplot.filled != 0) {
      fragColor = mix(varyings.vFillColor, varyings.vLineColor, isLine);
    } else {
      if (isLine == 0.0) {
        discard;
      }
      fragColor = vec4<f32>(varyings.vLineColor.rgb, varyings.vLineColor.a * isLine);
    }
  } else if (scatterplot.filled == 0) {
    discard;
  } else {
    fragColor = varyings.vFillColor;
  }

  fragColor.a *= inCircle;
  // DECKGL_FILTER_COLOR(fragColor, geometry);

  // Apply premultiplied alpha as required by transparent canvas
  fragColor = deckgl_premultiplied_alpha(fragColor);

  return fragColor;
  // return vec4<f32>(0, 0, 1, 1);
}
`
);

// node_modules/@deck.gl/layers/dist/scatterplot-layer/scatterplot-layer.js
var DEFAULT_COLOR5 = [0, 0, 0, 255];
var defaultProps6 = {
  radiusUnits: "meters",
  radiusScale: { type: "number", min: 0, value: 1 },
  radiusMinPixels: { type: "number", min: 0, value: 0 },
  //  min point radius in pixels
  radiusMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
  // max point radius in pixels
  lineWidthUnits: "meters",
  lineWidthScale: { type: "number", min: 0, value: 1 },
  lineWidthMinPixels: { type: "number", min: 0, value: 0 },
  lineWidthMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
  stroked: false,
  filled: true,
  billboard: false,
  antialiasing: true,
  getPosition: { type: "accessor", value: (x) => x.position },
  getRadius: { type: "accessor", value: 1 },
  getFillColor: { type: "accessor", value: DEFAULT_COLOR5 },
  getLineColor: { type: "accessor", value: DEFAULT_COLOR5 },
  getLineWidth: { type: "accessor", value: 1 },
  // deprecated
  strokeWidth: { deprecatedFor: "getLineWidth" },
  outline: { deprecatedFor: "stroked" },
  getColor: { deprecatedFor: ["getFillColor", "getLineColor"] }
};
var ScatterplotLayer = class extends layer_default {
  getShaders() {
    return super.getShaders({
      vs: scatterplot_layer_vertex_glsl_default,
      fs: scatterplot_layer_fragment_glsl_default,
      source: scatterplot_layer_wgsl_default,
      modules: [project32_default, color_default, picking_default, scatterplotUniforms]
    });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getPosition"
      },
      instanceRadius: {
        size: 1,
        transition: true,
        accessor: "getRadius",
        defaultValue: 1
      },
      instanceFillColors: {
        size: this.props.colorFormat.length,
        transition: true,
        type: "unorm8",
        accessor: "getFillColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineColors: {
        size: this.props.colorFormat.length,
        transition: true,
        type: "unorm8",
        accessor: "getLineColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineWidths: {
        size: 1,
        transition: true,
        accessor: "getLineWidth",
        defaultValue: 1
      }
    });
  }
  updateState(params) {
    var _a;
    super.updateState(params);
    if (params.changeFlags.extensionsChanged) {
      (_a = this.state.model) == null ? void 0 : _a.destroy();
      this.state.model = this._getModel();
      this.getAttributeManager().invalidateAll();
    }
  }
  draw({ uniforms }) {
    const { radiusUnits, radiusScale, radiusMinPixels, radiusMaxPixels, stroked, filled, billboard, antialiasing, lineWidthUnits, lineWidthScale, lineWidthMinPixels, lineWidthMaxPixels } = this.props;
    const scatterplotProps = {
      stroked,
      filled,
      billboard,
      antialiasing,
      radiusUnits: UNIT[radiusUnits],
      radiusScale,
      radiusMinPixels,
      radiusMaxPixels,
      lineWidthUnits: UNIT[lineWidthUnits],
      lineWidthScale,
      lineWidthMinPixels,
      lineWidthMaxPixels
    };
    const model = this.state.model;
    model.shaderInputs.setProps({ scatterplot: scatterplotProps });
    if (this.context.device.type === "webgpu") {
      model.instanceCount = this.props.data.length;
    }
    model.draw(this.context.renderPass);
  }
  _getModel() {
    const parameters2 = this.context.device.type === "webgpu" ? {
      depthWriteEnabled: true,
      depthCompare: "less-equal"
    } : void 0;
    const positions = [-1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0];
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new Geometry({
        topology: "triangle-strip",
        attributes: {
          positions: { size: 3, value: new Float32Array(positions) }
        }
      }),
      isInstanced: true,
      parameters: parameters2
    });
  }
};
ScatterplotLayer.defaultProps = defaultProps6;
ScatterplotLayer.layerName = "ScatterplotLayer";
var scatterplot_layer_default = ScatterplotLayer;

// node_modules/@math.gl/polygon/dist/polygon-utils.js
var WINDING = {
  CLOCKWISE: 1,
  COUNTER_CLOCKWISE: -1
};
function modifyPolygonWindingDirection(points, direction, options = {}) {
  const windingDirection = getPolygonWindingDirection(points, options);
  if (windingDirection !== direction) {
    reversePolygon(points, options);
    return true;
  }
  return false;
}
function getPolygonWindingDirection(points, options = {}) {
  return Math.sign(getPolygonSignedArea(points, options));
}
var DimIndex = {
  x: 0,
  y: 1,
  z: 2
};
function getPolygonSignedArea(points, options = {}) {
  const { start = 0, end = points.length, plane = "xy" } = options;
  const dim = options.size || 2;
  let area2 = 0;
  const i0 = DimIndex[plane[0]];
  const i1 = DimIndex[plane[1]];
  for (let i = start, j = end - dim; i < end; i += dim) {
    area2 += (points[i + i0] - points[j + i0]) * (points[i + i1] + points[j + i1]);
    j = i;
  }
  return area2 / 2;
}
function reversePolygon(points, options) {
  const { start = 0, end = points.length, size = 2 } = options;
  const numPoints = (end - start) / size;
  const numSwaps = Math.floor(numPoints / 2);
  for (let i = 0; i < numSwaps; ++i) {
    const b1 = start + i * size;
    const b2 = start + (numPoints - 1 - i) * size;
    for (let j = 0; j < size; ++j) {
      const tmp = points[b1 + j];
      points[b1 + j] = points[b2 + j];
      points[b2 + j] = tmp;
    }
  }
}

// node_modules/@math.gl/polygon/dist/earcut.js
function earcut(positions, holeIndices, dim = 2, areas, plane = "xy") {
  const hasHoles = holeIndices && holeIndices.length;
  const outerLen = hasHoles ? holeIndices[0] * dim : positions.length;
  let outerNode = linkedList(positions, 0, outerLen, dim, true, areas && areas[0], plane);
  const triangles = [];
  if (!outerNode || outerNode.next === outerNode.prev)
    return triangles;
  let invSize;
  let maxX;
  let maxY;
  let minX;
  let minY;
  let x;
  let y;
  if (hasHoles)
    outerNode = eliminateHoles(positions, holeIndices, outerNode, dim, areas, plane);
  if (positions.length > 80 * dim) {
    minX = maxX = positions[0];
    minY = maxY = positions[1];
    for (let i = dim; i < outerLen; i += dim) {
      x = positions[i];
      y = positions[i + 1];
      if (x < minX)
        minX = x;
      if (y < minY)
        minY = y;
      if (x > maxX)
        maxX = x;
      if (y > maxY)
        maxY = y;
    }
    invSize = Math.max(maxX - minX, maxY - minY);
    invSize = invSize !== 0 ? 32767 / invSize : 0;
  }
  earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
  return triangles;
}
function linkedList(data, start, end, dim, clockwise, area2, plane) {
  let i;
  let last;
  if (area2 === void 0) {
    area2 = getPolygonSignedArea(data, { start, end, size: dim, plane });
  }
  let i0 = DimIndex[plane[0]];
  let i1 = DimIndex[plane[1]];
  if (clockwise === area2 < 0) {
    for (i = start; i < end; i += dim)
      last = insertNode(i, data[i + i0], data[i + i1], last);
  } else {
    for (i = end - dim; i >= start; i -= dim)
      last = insertNode(i, data[i + i0], data[i + i1], last);
  }
  if (last && equals2(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}
function filterPoints(start, end) {
  if (!start)
    return start;
  if (!end)
    end = start;
  let p = start;
  let again;
  do {
    again = false;
    if (!p.steiner && (equals2(p, p.next) || area(p.prev, p, p.next) === 0)) {
      removeNode(p);
      p = end = p.prev;
      if (p === p.next)
        break;
      again = true;
    } else {
      p = p.next;
    }
  } while (again || p !== end);
  return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear)
    return;
  if (!pass && invSize)
    indexCurve(ear, minX, minY, invSize);
  let stop = ear;
  let prev;
  let next;
  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev.i / dim | 0);
      triangles.push(ear.i / dim | 0);
      triangles.push(next.i / dim | 0);
      removeNode(ear);
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;
    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  const a2 = ear.prev;
  const b2 = ear;
  const c2 = ear.next;
  if (area(a2, b2, c2) >= 0)
    return false;
  const ax = a2.x;
  const bx = b2.x;
  const cx = c2.x;
  const ay = a2.y;
  const by = b2.y;
  const cy = c2.y;
  const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx;
  const y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy;
  const x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx;
  const y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  let p = c2.next;
  while (p !== a2) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  const a2 = ear.prev;
  const b2 = ear;
  const c2 = ear.next;
  if (area(a2, b2, c2) >= 0)
    return false;
  const ax = a2.x;
  const bx = b2.x;
  const cx = c2.x;
  const ay = a2.y;
  const by = b2.y;
  const cy = c2.y;
  const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx;
  const y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy;
  const x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx;
  const y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  const minZ = zOrder(x0, y0, minX, minY, invSize);
  const maxZ = zOrder(x1, y1, minX, minY, invSize);
  let p = ear.prevZ;
  let n = ear.nextZ;
  while (p && p.z >= minZ && n && n.z <= maxZ) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a2 && p !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.prevZ;
    if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a2 && n !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
      return false;
    n = n.nextZ;
  }
  while (p && p.z >= minZ) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a2 && p !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.prevZ;
  }
  while (n && n.z <= maxZ) {
    if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a2 && n !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
      return false;
    n = n.nextZ;
  }
  return true;
}
function cureLocalIntersections(start, triangles, dim) {
  let p = start;
  do {
    const a2 = p.prev;
    const b2 = p.next.next;
    if (!equals2(a2, b2) && intersects(a2, p, p.next, b2) && locallyInside(a2, b2) && locallyInside(b2, a2)) {
      triangles.push(a2.i / dim | 0);
      triangles.push(p.i / dim | 0);
      triangles.push(b2.i / dim | 0);
      removeNode(p);
      removeNode(p.next);
      p = start = b2;
    }
    p = p.next;
  } while (p !== start);
  return filterPoints(p);
}
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  let a2 = start;
  do {
    let b2 = a2.next.next;
    while (b2 !== a2.prev) {
      if (a2.i !== b2.i && isValidDiagonal(a2, b2)) {
        let c2 = splitPolygon(a2, b2);
        a2 = filterPoints(a2, a2.next);
        c2 = filterPoints(c2, c2.next);
        earcutLinked(a2, triangles, dim, minX, minY, invSize, 0);
        earcutLinked(c2, triangles, dim, minX, minY, invSize, 0);
        return;
      }
      b2 = b2.next;
    }
    a2 = a2.next;
  } while (a2 !== start);
}
function eliminateHoles(data, holeIndices, outerNode, dim, areas, plane) {
  const queue = [];
  let i;
  let len4;
  let start;
  let end;
  let list;
  for (i = 0, len4 = holeIndices.length; i < len4; i++) {
    start = holeIndices[i] * dim;
    end = i < len4 - 1 ? holeIndices[i + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false, areas && areas[i + 1], plane);
    if (list === list.next)
      list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareX);
  for (i = 0; i < queue.length; i++) {
    outerNode = eliminateHole(queue[i], outerNode);
  }
  return outerNode;
}
function compareX(a2, b2) {
  return a2.x - b2.x;
}
function eliminateHole(hole, outerNode) {
  const bridge = findHoleBridge(hole, outerNode);
  if (!bridge) {
    return outerNode;
  }
  const bridgeReverse = splitPolygon(bridge, hole);
  filterPoints(bridgeReverse, bridgeReverse.next);
  return filterPoints(bridge, bridge.next);
}
function findHoleBridge(hole, outerNode) {
  let p = outerNode;
  const hx = hole.x;
  const hy = hole.y;
  let qx = -Infinity;
  let m;
  do {
    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
      const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
      if (x <= hx && x > qx) {
        qx = x;
        m = p.x < p.next.x ? p : p.next;
        if (x === hx)
          return m;
      }
    }
    p = p.next;
  } while (p !== outerNode);
  if (!m)
    return null;
  const stop = m;
  const mx = m.x;
  const my = m.y;
  let tanMin = Infinity;
  let tan;
  p = m;
  do {
    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
      tan = Math.abs(hy - p.y) / (hx - p.x);
      if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
        m = p;
        tanMin = tan;
      }
    }
    p = p.next;
  } while (p !== stop);
  return m;
}
function sectorContainsSector(m, p) {
  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}
function indexCurve(start, minX, minY, invSize) {
  let p = start;
  do {
    if (p.z === 0)
      p.z = zOrder(p.x, p.y, minX, minY, invSize);
    p.prevZ = p.prev;
    p.nextZ = p.next;
    p = p.next;
  } while (p !== start);
  p.prevZ.nextZ = null;
  p.prevZ = null;
  sortLinked(p);
}
function sortLinked(list) {
  let e2;
  let i;
  let inSize = 1;
  let numMerges;
  let p;
  let pSize;
  let q;
  let qSize;
  let tail;
  do {
    p = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p) {
      numMerges++;
      q = p;
      pSize = 0;
      for (i = 0; i < inSize; i++) {
        pSize++;
        q = q.nextZ;
        if (!q)
          break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
          e2 = p;
          p = p.nextZ;
          pSize--;
        } else {
          e2 = q;
          q = q.nextZ;
          qSize--;
        }
        if (tail)
          tail.nextZ = e2;
        else
          list = e2;
        e2.prevZ = tail;
        tail = e2;
      }
      p = q;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x, y, minX, minY, invSize) {
  x = (x - minX) * invSize | 0;
  y = (y - minY) * invSize | 0;
  x = (x | x << 8) & 16711935;
  x = (x | x << 4) & 252645135;
  x = (x | x << 2) & 858993459;
  x = (x | x << 1) & 1431655765;
  y = (y | y << 8) & 16711935;
  y = (y | y << 4) & 252645135;
  y = (y | y << 2) & 858993459;
  y = (y | y << 1) & 1431655765;
  return x | y << 1;
}
function getLeftmost(start) {
  let p = start;
  let leftmost = start;
  do {
    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
      leftmost = p;
    p = p.next;
  } while (p !== start);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
  return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
}
function isValidDiagonal(a2, b2) {
  return a2.next.i !== b2.i && a2.prev.i !== b2.i && !intersectsPolygon(a2, b2) && // dones't intersect other edges
  (locallyInside(a2, b2) && locallyInside(b2, a2) && middleInside(a2, b2) && // locally visible
  (area(a2.prev, a2, b2.prev) || area(a2, b2.prev, b2)) || // does not create opposite-facing sectors
  equals2(a2, b2) && area(a2.prev, a2, a2.next) > 0 && area(b2.prev, b2, b2.next) > 0);
}
function area(p, q, r) {
  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}
function equals2(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
function intersects(p1, q1, p2, q2) {
  const o1 = sign(area(p1, q1, p2));
  const o2 = sign(area(p1, q1, q2));
  const o3 = sign(area(p2, q2, p1));
  const o4 = sign(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4)
    return true;
  if (o1 === 0 && onSegment(p1, p2, q1))
    return true;
  if (o2 === 0 && onSegment(p1, q2, q1))
    return true;
  if (o3 === 0 && onSegment(p2, p1, q2))
    return true;
  if (o4 === 0 && onSegment(p2, q1, q2))
    return true;
  return false;
}
function onSegment(p, q, r) {
  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}
function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a2, b2) {
  let p = a2;
  do {
    if (p.i !== a2.i && p.next.i !== a2.i && p.i !== b2.i && p.next.i !== b2.i && intersects(p, p.next, a2, b2))
      return true;
    p = p.next;
  } while (p !== a2);
  return false;
}
function locallyInside(a2, b2) {
  return area(a2.prev, a2, a2.next) < 0 ? area(a2, b2, a2.next) >= 0 && area(a2, a2.prev, b2) >= 0 : area(a2, b2, a2.prev) < 0 || area(a2, a2.next, b2) < 0;
}
function middleInside(a2, b2) {
  let p = a2;
  let inside = false;
  const px = (a2.x + b2.x) / 2;
  const py = (a2.y + b2.y) / 2;
  do {
    if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
      inside = !inside;
    p = p.next;
  } while (p !== a2);
  return inside;
}
function splitPolygon(a2, b2) {
  const a22 = new Vertex(a2.i, a2.x, a2.y);
  const b22 = new Vertex(b2.i, b2.x, b2.y);
  const an = a2.next;
  const bp = b2.prev;
  a2.next = b2;
  b2.prev = a2;
  a22.next = an;
  an.prev = a22;
  b22.next = a22;
  a22.prev = b22;
  bp.next = b22;
  b22.prev = bp;
  return b22;
}
function insertNode(i, x, y, last) {
  const p = new Vertex(i, x, y);
  if (!last) {
    p.prev = p;
    p.next = p;
  } else {
    p.next = last.next;
    p.prev = last;
    last.next.prev = p;
    last.next = p;
  }
  return p;
}
function removeNode(p) {
  p.next.prev = p.prev;
  p.prev.next = p.next;
  if (p.prevZ)
    p.prevZ.nextZ = p.nextZ;
  if (p.nextZ)
    p.nextZ.prevZ = p.prevZ;
}
var Vertex = class {
  constructor(i, x, y) {
    this.prev = null;
    this.next = null;
    this.z = 0;
    this.prevZ = null;
    this.nextZ = null;
    this.steiner = false;
    this.i = i;
    this.x = x;
    this.y = y;
  }
};

// node_modules/@math.gl/polygon/dist/utils.js
function push(target, source) {
  const size = source.length;
  const startIndex = target.length;
  if (startIndex > 0) {
    let isDuplicate = true;
    for (let i = 0; i < size; i++) {
      if (target[startIndex - size + i] !== source[i]) {
        isDuplicate = false;
        break;
      }
    }
    if (isDuplicate) {
      return false;
    }
  }
  for (let i = 0; i < size; i++) {
    target[startIndex + i] = source[i];
  }
  return true;
}
function copy(target, source) {
  const size = source.length;
  for (let i = 0; i < size; i++) {
    target[i] = source[i];
  }
}
function getPointAtIndex(positions, index, size, offset, out = []) {
  const startI = offset + index * size;
  for (let i = 0; i < size; i++) {
    out[i] = positions[startI + i];
  }
  return out;
}

// node_modules/@math.gl/polygon/dist/lineclip.js
function intersect(a2, b2, edge, bbox, out = []) {
  let t;
  let snap;
  if (edge & 8) {
    t = (bbox[3] - a2[1]) / (b2[1] - a2[1]);
    snap = 3;
  } else if (edge & 4) {
    t = (bbox[1] - a2[1]) / (b2[1] - a2[1]);
    snap = 1;
  } else if (edge & 2) {
    t = (bbox[2] - a2[0]) / (b2[0] - a2[0]);
    snap = 2;
  } else if (edge & 1) {
    t = (bbox[0] - a2[0]) / (b2[0] - a2[0]);
    snap = 0;
  } else {
    return null;
  }
  for (let i = 0; i < a2.length; i++) {
    out[i] = (snap & 1) === i ? bbox[snap] : t * (b2[i] - a2[i]) + a2[i];
  }
  return out;
}
function bitCode(p, bbox) {
  let code = 0;
  if (p[0] < bbox[0])
    code |= 1;
  else if (p[0] > bbox[2])
    code |= 2;
  if (p[1] < bbox[1])
    code |= 4;
  else if (p[1] > bbox[3])
    code |= 8;
  return code;
}

// node_modules/@math.gl/polygon/dist/cut-by-grid.js
function cutPolylineByGrid(positions, options) {
  const { size = 2, broken = false, gridResolution = 10, gridOffset = [0, 0], startIndex = 0, endIndex = positions.length } = options || {};
  const numPoints = (endIndex - startIndex) / size;
  let part = [];
  const result = [part];
  const a2 = getPointAtIndex(positions, 0, size, startIndex);
  let b2;
  let codeB;
  const cell = getGridCell(a2, gridResolution, gridOffset, []);
  const scratchPoint = [];
  push(part, a2);
  for (let i = 1; i < numPoints; i++) {
    b2 = getPointAtIndex(positions, i, size, startIndex, b2);
    codeB = bitCode(b2, cell);
    while (codeB) {
      intersect(a2, b2, codeB, cell, scratchPoint);
      const codeAlt = bitCode(scratchPoint, cell);
      if (codeAlt) {
        intersect(a2, scratchPoint, codeAlt, cell, scratchPoint);
        codeB = codeAlt;
      }
      push(part, scratchPoint);
      copy(a2, scratchPoint);
      moveToNeighborCell(cell, gridResolution, codeB);
      if (broken && part.length > size) {
        part = [];
        result.push(part);
        push(part, a2);
      }
      codeB = bitCode(b2, cell);
    }
    push(part, b2);
    copy(a2, b2);
  }
  return broken ? result : result[0];
}
var TYPE_INSIDE = 0;
var TYPE_BORDER = 1;
function cutPolygonByGrid(positions, holeIndices = null, options) {
  if (!positions.length) {
    return [];
  }
  const { size = 2, gridResolution = 10, gridOffset = [0, 0], edgeTypes = false } = options || {};
  const result = [];
  const queue = [
    {
      pos: positions,
      types: edgeTypes ? new Array(positions.length / size).fill(TYPE_BORDER) : null,
      holes: holeIndices || []
    }
  ];
  const bbox = [[], []];
  let cell = [];
  while (queue.length) {
    const { pos, types, holes } = queue.shift();
    getBoundingBox(pos, size, holes[0] || pos.length, bbox);
    cell = getGridCell(bbox[0], gridResolution, gridOffset, cell);
    const code = bitCode(bbox[1], cell);
    if (code) {
      let parts = bisectPolygon(pos, types, size, 0, holes[0] || pos.length, cell, code);
      const polygonLow = { pos: parts[0].pos, types: parts[0].types, holes: [] };
      const polygonHigh = { pos: parts[1].pos, types: parts[1].types, holes: [] };
      queue.push(polygonLow, polygonHigh);
      for (let i = 0; i < holes.length; i++) {
        parts = bisectPolygon(pos, types, size, holes[i], holes[i + 1] || pos.length, cell, code);
        if (parts[0]) {
          polygonLow.holes.push(polygonLow.pos.length);
          polygonLow.pos = concatInPlace(polygonLow.pos, parts[0].pos);
          if (edgeTypes) {
            polygonLow.types = concatInPlace(polygonLow.types, parts[0].types);
          }
        }
        if (parts[1]) {
          polygonHigh.holes.push(polygonHigh.pos.length);
          polygonHigh.pos = concatInPlace(polygonHigh.pos, parts[1].pos);
          if (edgeTypes) {
            polygonHigh.types = concatInPlace(polygonHigh.types, parts[1].types);
          }
        }
      }
    } else {
      const polygon = { positions: pos };
      if (edgeTypes) {
        polygon.edgeTypes = types;
      }
      if (holes.length) {
        polygon.holeIndices = holes;
      }
      result.push(polygon);
    }
  }
  return result;
}
function bisectPolygon(positions, edgeTypes, size, startIndex, endIndex, bbox, edge) {
  const numPoints = (endIndex - startIndex) / size;
  const resultLow = [];
  const resultHigh = [];
  const typesLow = [];
  const typesHigh = [];
  const scratchPoint = [];
  let p;
  let side;
  let type;
  const prev = getPointAtIndex(positions, numPoints - 1, size, startIndex);
  let prevSide = Math.sign(edge & 8 ? prev[1] - bbox[3] : prev[0] - bbox[2]);
  let prevType = edgeTypes && edgeTypes[numPoints - 1];
  let lowPointCount = 0;
  let highPointCount = 0;
  for (let i = 0; i < numPoints; i++) {
    p = getPointAtIndex(positions, i, size, startIndex, p);
    side = Math.sign(edge & 8 ? p[1] - bbox[3] : p[0] - bbox[2]);
    type = edgeTypes && edgeTypes[startIndex / size + i];
    if (side && prevSide && prevSide !== side) {
      intersect(prev, p, edge, bbox, scratchPoint);
      push(resultLow, scratchPoint) && typesLow.push(prevType);
      push(resultHigh, scratchPoint) && typesHigh.push(prevType);
    }
    if (side <= 0) {
      push(resultLow, p) && typesLow.push(type);
      lowPointCount -= side;
    } else if (typesLow.length) {
      typesLow[typesLow.length - 1] = TYPE_INSIDE;
    }
    if (side >= 0) {
      push(resultHigh, p) && typesHigh.push(type);
      highPointCount += side;
    } else if (typesHigh.length) {
      typesHigh[typesHigh.length - 1] = TYPE_INSIDE;
    }
    copy(prev, p);
    prevSide = side;
    prevType = type;
  }
  return [
    lowPointCount ? { pos: resultLow, types: edgeTypes && typesLow } : null,
    highPointCount ? { pos: resultHigh, types: edgeTypes && typesHigh } : null
  ];
}
function getGridCell(p, gridResolution, gridOffset, out) {
  const left = Math.floor((p[0] - gridOffset[0]) / gridResolution) * gridResolution + gridOffset[0];
  const bottom = Math.floor((p[1] - gridOffset[1]) / gridResolution) * gridResolution + gridOffset[1];
  out[0] = left;
  out[1] = bottom;
  out[2] = left + gridResolution;
  out[3] = bottom + gridResolution;
  return out;
}
function moveToNeighborCell(cell, gridResolution, edge) {
  if (edge & 8) {
    cell[1] += gridResolution;
    cell[3] += gridResolution;
  } else if (edge & 4) {
    cell[1] -= gridResolution;
    cell[3] -= gridResolution;
  } else if (edge & 2) {
    cell[0] += gridResolution;
    cell[2] += gridResolution;
  } else if (edge & 1) {
    cell[0] -= gridResolution;
    cell[2] -= gridResolution;
  }
}
function getBoundingBox(positions, size, endIndex, out) {
  let minX = Infinity;
  let maxX = -Infinity;
  let minY = Infinity;
  let maxY = -Infinity;
  for (let i = 0; i < endIndex; i += size) {
    const x = positions[i];
    const y = positions[i + 1];
    minX = x < minX ? x : minX;
    maxX = x > maxX ? x : maxX;
    minY = y < minY ? y : minY;
    maxY = y > maxY ? y : maxY;
  }
  out[0][0] = minX;
  out[0][1] = minY;
  out[1][0] = maxX;
  out[1][1] = maxY;
  return out;
}
function concatInPlace(arr1, arr2) {
  for (let i = 0; i < arr2.length; i++) {
    arr1.push(arr2[i]);
  }
  return arr1;
}

// node_modules/@math.gl/polygon/dist/cut-by-mercator-bounds.js
var DEFAULT_MAX_LATITUDE = 85.051129;
function cutPolylineByMercatorBounds(positions, options) {
  const { size = 2, startIndex = 0, endIndex = positions.length, normalize: normalize5 = true } = options || {};
  const newPositions = positions.slice(startIndex, endIndex);
  wrapLongitudesForShortestPath(newPositions, size, 0, endIndex - startIndex);
  const parts = cutPolylineByGrid(newPositions, {
    size,
    broken: true,
    gridResolution: 360,
    gridOffset: [-180, -180]
  });
  if (normalize5) {
    for (const part of parts) {
      shiftLongitudesIntoRange(part, size);
    }
  }
  return parts;
}
function cutPolygonByMercatorBounds(positions, holeIndices = null, options) {
  const { size = 2, normalize: normalize5 = true, edgeTypes = false } = options || {};
  holeIndices = holeIndices || [];
  const newPositions = [];
  const newHoleIndices = [];
  let srcStartIndex = 0;
  let targetIndex = 0;
  for (let ringIndex = 0; ringIndex <= holeIndices.length; ringIndex++) {
    const srcEndIndex = holeIndices[ringIndex] || positions.length;
    const targetStartIndex = targetIndex;
    const splitIndex = findSplitIndex(positions, size, srcStartIndex, srcEndIndex);
    for (let i = splitIndex; i < srcEndIndex; i++) {
      newPositions[targetIndex++] = positions[i];
    }
    for (let i = srcStartIndex; i < splitIndex; i++) {
      newPositions[targetIndex++] = positions[i];
    }
    wrapLongitudesForShortestPath(newPositions, size, targetStartIndex, targetIndex);
    insertPoleVertices(newPositions, size, targetStartIndex, targetIndex, options == null ? void 0 : options.maxLatitude);
    srcStartIndex = srcEndIndex;
    newHoleIndices[ringIndex] = targetIndex;
  }
  newHoleIndices.pop();
  const parts = cutPolygonByGrid(newPositions, newHoleIndices, {
    size,
    gridResolution: 360,
    gridOffset: [-180, -180],
    edgeTypes
  });
  if (normalize5) {
    for (const part of parts) {
      shiftLongitudesIntoRange(part.positions, size);
    }
  }
  return parts;
}
function findSplitIndex(positions, size, startIndex, endIndex) {
  let maxLat = -1;
  let pointIndex = -1;
  for (let i = startIndex + 1; i < endIndex; i += size) {
    const lat = Math.abs(positions[i]);
    if (lat > maxLat) {
      maxLat = lat;
      pointIndex = i - 1;
    }
  }
  return pointIndex;
}
function insertPoleVertices(positions, size, startIndex, endIndex, maxLatitude = DEFAULT_MAX_LATITUDE) {
  const firstLng = positions[startIndex];
  const lastLng = positions[endIndex - size];
  if (Math.abs(firstLng - lastLng) > 180) {
    const p = getPointAtIndex(positions, 0, size, startIndex);
    p[0] += Math.round((lastLng - firstLng) / 360) * 360;
    push(positions, p);
    p[1] = Math.sign(p[1]) * maxLatitude;
    push(positions, p);
    p[0] = firstLng;
    push(positions, p);
  }
}
function wrapLongitudesForShortestPath(positions, size, startIndex, endIndex) {
  let prevLng = positions[0];
  let lng;
  for (let i = startIndex; i < endIndex; i += size) {
    lng = positions[i];
    const delta = lng - prevLng;
    if (delta > 180 || delta < -180) {
      lng -= Math.round(delta / 360) * 360;
    }
    positions[i] = prevLng = lng;
  }
}
function shiftLongitudesIntoRange(positions, size) {
  let refLng;
  const pointCount = positions.length / size;
  for (let i = 0; i < pointCount; i++) {
    refLng = positions[i * size];
    if ((refLng + 180) % 360 !== 0) {
      break;
    }
  }
  const delta = -Math.round(refLng / 360) * 360;
  if (delta === 0) {
    return;
  }
  for (let i = 0; i < pointCount; i++) {
    positions[i * size] += delta;
  }
}

// node_modules/@deck.gl/layers/dist/column-layer/column-geometry.js
var ColumnGeometry = class extends Geometry {
  constructor(props) {
    const { indices, attributes } = tesselateColumn(props);
    super({
      ...props,
      indices,
      // @ts-expect-error
      attributes
    });
  }
};
function tesselateColumn(props) {
  const { radius, height = 1, nradial = 10 } = props;
  let { vertices } = props;
  if (vertices) {
    log_default.assert(vertices.length >= nradial);
    vertices = vertices.flatMap((v2) => [v2[0], v2[1]]);
    modifyPolygonWindingDirection(vertices, WINDING.COUNTER_CLOCKWISE);
  }
  const isExtruded = height > 0;
  const vertsAroundEdge = nradial + 1;
  const numVertices = isExtruded ? vertsAroundEdge * 3 + 1 : nradial;
  const stepAngle = Math.PI * 2 / nradial;
  const indices = new Uint16Array(isExtruded ? nradial * 3 * 2 : 0);
  const positions = new Float32Array(numVertices * 3);
  const normals = new Float32Array(numVertices * 3);
  let i = 0;
  if (isExtruded) {
    for (let j = 0; j < vertsAroundEdge; j++) {
      const a2 = j * stepAngle;
      const vertexIndex = j % nradial;
      const sin = Math.sin(a2);
      const cos = Math.cos(a2);
      for (let k = 0; k < 2; k++) {
        positions[i + 0] = vertices ? vertices[vertexIndex * 2] : cos * radius;
        positions[i + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin * radius;
        positions[i + 2] = (1 / 2 - k) * height;
        normals[i + 0] = vertices ? vertices[vertexIndex * 2] : cos;
        normals[i + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin;
        i += 3;
      }
    }
    positions[i + 0] = positions[i - 3];
    positions[i + 1] = positions[i - 2];
    positions[i + 2] = positions[i - 1];
    i += 3;
  }
  for (let j = isExtruded ? 0 : 1; j < vertsAroundEdge; j++) {
    const v2 = Math.floor(j / 2) * Math.sign(0.5 - j % 2);
    const a2 = v2 * stepAngle;
    const vertexIndex = (v2 + nradial) % nradial;
    const sin = Math.sin(a2);
    const cos = Math.cos(a2);
    positions[i + 0] = vertices ? vertices[vertexIndex * 2] : cos * radius;
    positions[i + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin * radius;
    positions[i + 2] = height / 2;
    normals[i + 2] = 1;
    i += 3;
  }
  if (isExtruded) {
    let index = 0;
    for (let j = 0; j < nradial; j++) {
      indices[index++] = j * 2 + 0;
      indices[index++] = j * 2 + 2;
      indices[index++] = j * 2 + 0;
      indices[index++] = j * 2 + 1;
      indices[index++] = j * 2 + 1;
      indices[index++] = j * 2 + 3;
    }
  }
  return {
    indices,
    attributes: {
      POSITION: { size: 3, value: positions },
      NORMAL: { size: 3, value: normals }
    }
  };
}

// node_modules/@deck.gl/layers/dist/column-layer/column-layer-uniforms.js
var uniformBlock4 = `uniform columnUniforms {
  float radius;
  float angle;
  vec2 offset;
  bool extruded;
  bool stroked;
  bool isStroke;
  float coverage;
  float elevationScale;
  float edgeDistance;
  float widthScale;
  float widthMinPixels;
  float widthMaxPixels;
  highp int radiusUnits;
  highp int widthUnits;
} column;
`;
var columnUniforms = {
  name: "column",
  vs: uniformBlock4,
  fs: uniformBlock4,
  uniformTypes: {
    radius: "f32",
    angle: "f32",
    offset: "vec2<f32>",
    extruded: "f32",
    stroked: "f32",
    isStroke: "f32",
    coverage: "f32",
    elevationScale: "f32",
    edgeDistance: "f32",
    widthScale: "f32",
    widthMinPixels: "f32",
    widthMaxPixels: "f32",
    radiusUnits: "i32",
    widthUnits: "i32"
  }
};

// node_modules/@deck.gl/layers/dist/column-layer/column-layer-vertex.glsl.js
var column_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME column-layer-vertex-shader
in vec3 positions;
in vec3 normals;
in vec3 instancePositions;
in float instanceElevations;
in vec3 instancePositions64Low;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in float instanceStrokeWidths;
in vec3 instancePickingColors;
out vec4 vColor;
#ifdef FLAT_SHADING
out vec3 cameraPosition;
out vec4 position_commonspace;
#endif
void main(void) {
geometry.worldPosition = instancePositions;
vec4 color = column.isStroke ? instanceLineColors : instanceFillColors;
mat2 rotationMatrix = mat2(cos(column.angle), sin(column.angle), -sin(column.angle), cos(column.angle));
float elevation = 0.0;
float strokeOffsetRatio = 1.0;
if (column.extruded) {
elevation = instanceElevations * (positions.z + 1.0) / 2.0 * column.elevationScale;
} else if (column.stroked) {
float widthPixels = clamp(
project_size_to_pixel(instanceStrokeWidths * column.widthScale, column.widthUnits),
column.widthMinPixels, column.widthMaxPixels) / 2.0;
float halfOffset = project_pixel_size(widthPixels) / project_size(column.edgeDistance * column.coverage * column.radius);
if (column.isStroke) {
strokeOffsetRatio -= sign(positions.z) * halfOffset;
} else {
strokeOffsetRatio -= halfOffset;
}
}
float shouldRender = float(color.a > 0.0 && instanceElevations >= 0.0);
float dotRadius = column.radius * column.coverage * shouldRender;
geometry.pickingColor = instancePickingColors;
vec3 centroidPosition = vec3(instancePositions.xy, instancePositions.z + elevation);
vec3 centroidPosition64Low = instancePositions64Low;
vec2 offset = (rotationMatrix * positions.xy * strokeOffsetRatio + column.offset) * dotRadius;
if (column.radiusUnits == UNIT_METERS) {
offset = project_size(offset);
}
vec3 pos = vec3(offset, 0.);
DECKGL_FILTER_SIZE(pos, geometry);
gl_Position = project_position_to_clipspace(centroidPosition, centroidPosition64Low, pos, geometry.position);
geometry.normal = project_normal(vec3(rotationMatrix * normals.xy, normals.z));
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
if (column.extruded && !column.isStroke) {
#ifdef FLAT_SHADING
cameraPosition = project.cameraPosition;
position_commonspace = geometry.position;
vColor = vec4(color.rgb, color.a * layer.opacity);
#else
vec3 lightColor = lighting_getLightColor(color.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);
vColor = vec4(lightColor, color.a * layer.opacity);
#endif
} else {
vColor = vec4(color.rgb, color.a * layer.opacity);
}
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/column-layer/column-layer-fragment.glsl.js
var column_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME column-layer-fragment-shader
precision highp float;
out vec4 fragColor;
in vec4 vColor;
#ifdef FLAT_SHADING
in vec3 cameraPosition;
in vec4 position_commonspace;
#endif
void main(void) {
fragColor = vColor;
geometry.uv = vec2(0.);
#ifdef FLAT_SHADING
if (column.extruded && !column.isStroke && !bool(picking.isActive)) {
vec3 normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
fragColor.rgb = lighting_getLightColor(vColor.rgb, cameraPosition, position_commonspace.xyz, normal);
}
#endif
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/column-layer/column-layer.js
var DEFAULT_COLOR6 = [0, 0, 0, 255];
var defaultProps7 = {
  diskResolution: { type: "number", min: 4, value: 20 },
  vertices: null,
  radius: { type: "number", min: 0, value: 1e3 },
  angle: { type: "number", value: 0 },
  offset: { type: "array", value: [0, 0] },
  coverage: { type: "number", min: 0, max: 1, value: 1 },
  elevationScale: { type: "number", min: 0, value: 1 },
  radiusUnits: "meters",
  lineWidthUnits: "meters",
  lineWidthScale: 1,
  lineWidthMinPixels: 0,
  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
  extruded: true,
  wireframe: false,
  filled: true,
  stroked: false,
  flatShading: false,
  getPosition: { type: "accessor", value: (x) => x.position },
  getFillColor: { type: "accessor", value: DEFAULT_COLOR6 },
  getLineColor: { type: "accessor", value: DEFAULT_COLOR6 },
  getLineWidth: { type: "accessor", value: 1 },
  getElevation: { type: "accessor", value: 1e3 },
  material: true,
  getColor: { deprecatedFor: ["getFillColor", "getLineColor"] }
};
var ColumnLayer = class extends layer_default {
  getShaders() {
    const defines = {};
    const { flatShading } = this.props;
    if (flatShading) {
      defines.FLAT_SHADING = 1;
    }
    return super.getShaders({
      vs: column_layer_vertex_glsl_default,
      fs: column_layer_fragment_glsl_default,
      defines,
      modules: [project32_default, flatShading ? phongMaterial : gouraudMaterial, picking_default, columnUniforms]
    });
  }
  /**
   * DeckGL calls initializeState when GL context is available
   * Essentially a deferred constructor
   */
  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getPosition"
      },
      instanceElevations: {
        size: 1,
        transition: true,
        accessor: "getElevation"
      },
      instanceFillColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: true,
        accessor: "getFillColor",
        defaultValue: DEFAULT_COLOR6
      },
      instanceLineColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: true,
        accessor: "getLineColor",
        defaultValue: DEFAULT_COLOR6
      },
      instanceStrokeWidths: {
        size: 1,
        accessor: "getLineWidth",
        transition: true
      }
    });
  }
  updateState(params) {
    var _a;
    super.updateState(params);
    const { props, oldProps, changeFlags } = params;
    const regenerateModels = changeFlags.extensionsChanged || props.flatShading !== oldProps.flatShading;
    if (regenerateModels) {
      (_a = this.state.models) == null ? void 0 : _a.forEach((model) => model.destroy());
      this.setState(this._getModels());
      this.getAttributeManager().invalidateAll();
    }
    const instanceCount = this.getNumInstances();
    this.state.fillModel.setInstanceCount(instanceCount);
    this.state.wireframeModel.setInstanceCount(instanceCount);
    if (regenerateModels || props.diskResolution !== oldProps.diskResolution || props.vertices !== oldProps.vertices || (props.extruded || props.stroked) !== (oldProps.extruded || oldProps.stroked)) {
      this._updateGeometry(props);
    }
  }
  getGeometry(diskResolution, vertices, hasThinkness) {
    const geometry = new ColumnGeometry({
      radius: 1,
      height: hasThinkness ? 2 : 0,
      vertices,
      nradial: diskResolution
    });
    let meanVertexDistance = 0;
    if (vertices) {
      for (let i = 0; i < diskResolution; i++) {
        const p = vertices[i];
        const d2 = Math.sqrt(p[0] * p[0] + p[1] * p[1]);
        meanVertexDistance += d2 / diskResolution;
      }
    } else {
      meanVertexDistance = 1;
    }
    this.setState({
      edgeDistance: Math.cos(Math.PI / diskResolution) * meanVertexDistance
    });
    return geometry;
  }
  _getModels() {
    const shaders = this.getShaders();
    const bufferLayout = this.getAttributeManager().getBufferLayouts();
    const fillModel = new Model(this.context.device, {
      ...shaders,
      id: `${this.props.id}-fill`,
      bufferLayout,
      isInstanced: true
    });
    const wireframeModel = new Model(this.context.device, {
      ...shaders,
      id: `${this.props.id}-wireframe`,
      bufferLayout,
      isInstanced: true
    });
    return {
      fillModel,
      wireframeModel,
      models: [wireframeModel, fillModel]
    };
  }
  _updateGeometry({ diskResolution, vertices, extruded, stroked }) {
    const geometry = this.getGeometry(diskResolution, vertices, extruded || stroked);
    this.setState({
      fillVertexCount: geometry.attributes.POSITION.value.length / 3
    });
    const fillModel = this.state.fillModel;
    const wireframeModel = this.state.wireframeModel;
    fillModel.setGeometry(geometry);
    fillModel.setTopology("triangle-strip");
    fillModel.setIndexBuffer(null);
    wireframeModel.setGeometry(geometry);
    wireframeModel.setTopology("line-list");
  }
  draw({ uniforms }) {
    const { lineWidthUnits, lineWidthScale, lineWidthMinPixels, lineWidthMaxPixels, radiusUnits, elevationScale, extruded, filled, stroked, wireframe, offset, coverage, radius, angle: angle3 } = this.props;
    const fillModel = this.state.fillModel;
    const wireframeModel = this.state.wireframeModel;
    const { fillVertexCount, edgeDistance } = this.state;
    const columnProps = {
      radius,
      angle: angle3 / 180 * Math.PI,
      offset,
      extruded,
      stroked,
      coverage,
      elevationScale,
      edgeDistance,
      radiusUnits: UNIT[radiusUnits],
      widthUnits: UNIT[lineWidthUnits],
      widthScale: lineWidthScale,
      widthMinPixels: lineWidthMinPixels,
      widthMaxPixels: lineWidthMaxPixels
    };
    if (extruded && wireframe) {
      wireframeModel.shaderInputs.setProps({
        column: {
          ...columnProps,
          isStroke: true
        }
      });
      wireframeModel.draw(this.context.renderPass);
    }
    if (filled) {
      fillModel.setVertexCount(fillVertexCount);
      fillModel.shaderInputs.setProps({
        column: {
          ...columnProps,
          isStroke: false
        }
      });
      fillModel.draw(this.context.renderPass);
    }
    if (!extruded && stroked) {
      fillModel.setVertexCount(fillVertexCount * 2 / 3);
      fillModel.shaderInputs.setProps({
        column: {
          ...columnProps,
          isStroke: true
        }
      });
      fillModel.draw(this.context.renderPass);
    }
  }
};
ColumnLayer.layerName = "ColumnLayer";
ColumnLayer.defaultProps = defaultProps7;
var column_layer_default = ColumnLayer;

// node_modules/@deck.gl/layers/dist/column-layer/grid-cell-layer.js
var defaultProps8 = {
  cellSize: { type: "number", min: 0, value: 1e3 },
  offset: { type: "array", value: [1, 1] }
};
var GridCellLayer = class extends column_layer_default {
  _updateGeometry() {
    const geometry = new CubeGeometry();
    this.state.fillModel.setGeometry(geometry);
  }
  draw({ uniforms }) {
    const { elevationScale, extruded, offset, coverage, cellSize, angle: angle3, radiusUnits } = this.props;
    const fillModel = this.state.fillModel;
    const columnProps = {
      radius: cellSize / 2,
      radiusUnits: UNIT[radiusUnits],
      angle: angle3,
      offset,
      extruded,
      stroked: false,
      coverage,
      elevationScale,
      edgeDistance: 1,
      isStroke: false,
      widthUnits: 0,
      widthScale: 0,
      widthMinPixels: 0,
      widthMaxPixels: 0
    };
    fillModel.shaderInputs.setProps({ column: columnProps });
    fillModel.draw(this.context.renderPass);
  }
};
GridCellLayer.layerName = "GridCellLayer";
GridCellLayer.defaultProps = defaultProps8;

// node_modules/@deck.gl/layers/dist/path-layer/path.js
function normalizePath(path, size, gridResolution, wrapLongitude) {
  let flatPath;
  if (Array.isArray(path[0])) {
    const length5 = path.length * size;
    flatPath = new Array(length5);
    for (let i = 0; i < path.length; i++) {
      for (let j = 0; j < size; j++) {
        flatPath[i * size + j] = path[i][j] || 0;
      }
    }
  } else {
    flatPath = path;
  }
  if (gridResolution) {
    return cutPolylineByGrid(flatPath, { size, gridResolution });
  }
  if (wrapLongitude) {
    return cutPolylineByMercatorBounds(flatPath, { size });
  }
  return flatPath;
}

// node_modules/@deck.gl/layers/dist/path-layer/path-tesselator.js
var START_CAP = 1;
var END_CAP = 2;
var INVALID = 4;
var PathTesselator = class extends Tesselator {
  constructor(opts) {
    super({
      ...opts,
      attributes: {
        // Padding covers shaderAttributes for last segment in largest case fp64
        // additional vertex + hi & low parts, 3 * 6
        positions: {
          size: 3,
          padding: 18,
          initialize: true,
          type: opts.fp64 ? Float64Array : Float32Array
        },
        segmentTypes: { size: 1, type: Uint8ClampedArray }
      }
    });
  }
  /** Get packed attribute by name */
  get(attributeName) {
    return this.attributes[attributeName];
  }
  /* Implement base Tesselator interface */
  getGeometryFromBuffer(buffer) {
    if (this.normalize) {
      return super.getGeometryFromBuffer(buffer);
    }
    return null;
  }
  /* Implement base Tesselator interface */
  normalizeGeometry(path) {
    if (this.normalize) {
      return normalizePath(path, this.positionSize, this.opts.resolution, this.opts.wrapLongitude);
    }
    return path;
  }
  /* Implement base Tesselator interface */
  getGeometrySize(path) {
    if (isCut(path)) {
      let size = 0;
      for (const subPath of path) {
        size += this.getGeometrySize(subPath);
      }
      return size;
    }
    const numPoints = this.getPathLength(path);
    if (numPoints < 2) {
      return 0;
    }
    if (this.isClosed(path)) {
      return numPoints < 3 ? 0 : numPoints + 2;
    }
    return numPoints;
  }
  /* Implement base Tesselator interface */
  updateGeometryAttributes(path, context) {
    if (context.geometrySize === 0) {
      return;
    }
    if (path && isCut(path)) {
      for (const subPath of path) {
        const geometrySize = this.getGeometrySize(subPath);
        context.geometrySize = geometrySize;
        this.updateGeometryAttributes(subPath, context);
        context.vertexStart += geometrySize;
      }
    } else {
      this._updateSegmentTypes(path, context);
      this._updatePositions(path, context);
    }
  }
  _updateSegmentTypes(path, context) {
    const segmentTypes = this.attributes.segmentTypes;
    const isPathClosed = path ? this.isClosed(path) : false;
    const { vertexStart, geometrySize } = context;
    segmentTypes.fill(0, vertexStart, vertexStart + geometrySize);
    if (isPathClosed) {
      segmentTypes[vertexStart] = INVALID;
      segmentTypes[vertexStart + geometrySize - 2] = INVALID;
    } else {
      segmentTypes[vertexStart] += START_CAP;
      segmentTypes[vertexStart + geometrySize - 2] += END_CAP;
    }
    segmentTypes[vertexStart + geometrySize - 1] = INVALID;
  }
  _updatePositions(path, context) {
    const { positions } = this.attributes;
    if (!positions || !path) {
      return;
    }
    const { vertexStart, geometrySize } = context;
    const p = new Array(3);
    for (let i = vertexStart, ptIndex = 0; ptIndex < geometrySize; i++, ptIndex++) {
      this.getPointOnPath(path, ptIndex, p);
      positions[i * 3] = p[0];
      positions[i * 3 + 1] = p[1];
      positions[i * 3 + 2] = p[2];
    }
  }
  // Utilities
  /** Returns the number of points in the path */
  getPathLength(path) {
    return path.length / this.positionSize;
  }
  /** Returns a point on the path at the specified index */
  getPointOnPath(path, index, target = []) {
    const { positionSize } = this;
    if (index * positionSize >= path.length) {
      index += 1 - path.length / positionSize;
    }
    const i = index * positionSize;
    target[0] = path[i];
    target[1] = path[i + 1];
    target[2] = positionSize === 3 && path[i + 2] || 0;
    return target;
  }
  // Returns true if the first and last points are identical
  isClosed(path) {
    if (!this.normalize) {
      return Boolean(this.opts.loop);
    }
    const { positionSize } = this;
    const lastPointIndex = path.length - positionSize;
    return path[0] === path[lastPointIndex] && path[1] === path[lastPointIndex + 1] && (positionSize === 2 || path[2] === path[lastPointIndex + 2]);
  }
};
function isCut(path) {
  return Array.isArray(path[0]);
}

// node_modules/@deck.gl/layers/dist/path-layer/path-layer-uniforms.js
var uniformBlock5 = `uniform pathUniforms {
  float widthScale;
  float widthMinPixels;
  float widthMaxPixels;
  float jointType;
  float capType;
  float miterLimit;
  bool billboard;
  highp int widthUnits;
} path;
`;
var pathUniforms = {
  name: "path",
  vs: uniformBlock5,
  fs: uniformBlock5,
  uniformTypes: {
    widthScale: "f32",
    widthMinPixels: "f32",
    widthMaxPixels: "f32",
    jointType: "f32",
    capType: "f32",
    miterLimit: "f32",
    billboard: "f32",
    widthUnits: "i32"
  }
};

// node_modules/@deck.gl/layers/dist/path-layer/path-layer-vertex.glsl.js
var path_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME path-layer-vertex-shader
in vec2 positions;
in float instanceTypes;
in vec3 instanceStartPositions;
in vec3 instanceEndPositions;
in vec3 instanceLeftPositions;
in vec3 instanceRightPositions;
in vec3 instanceLeftPositions64Low;
in vec3 instanceStartPositions64Low;
in vec3 instanceEndPositions64Low;
in vec3 instanceRightPositions64Low;
in float instanceStrokeWidths;
in vec4 instanceColors;
in vec3 instancePickingColors;
uniform float opacity;
out vec4 vColor;
out vec2 vCornerOffset;
out float vMiterLength;
out vec2 vPathPosition;
out float vPathLength;
out float vJointType;
const float EPSILON = 0.001;
const vec3 ZERO_OFFSET = vec3(0.0);
float flipIfTrue(bool flag) {
return -(float(flag) * 2. - 1.);
}
vec3 getLineJoinOffset(
vec3 prevPoint, vec3 currPoint, vec3 nextPoint,
vec2 width
) {
bool isEnd = positions.x > 0.0;
float sideOfPath = positions.y;
float isJoint = float(sideOfPath == 0.0);
vec3 deltaA3 = (currPoint - prevPoint);
vec3 deltaB3 = (nextPoint - currPoint);
mat3 rotationMatrix;
bool needsRotation = !path.billboard && project_needs_rotation(currPoint, rotationMatrix);
if (needsRotation) {
deltaA3 = deltaA3 * rotationMatrix;
deltaB3 = deltaB3 * rotationMatrix;
}
vec2 deltaA = deltaA3.xy / width;
vec2 deltaB = deltaB3.xy / width;
float lenA = length(deltaA);
float lenB = length(deltaB);
vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);
vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);
vec2 perpA = vec2(-dirA.y, dirA.x);
vec2 perpB = vec2(-dirB.y, dirB.x);
vec2 tangent = dirA + dirB;
tangent = length(tangent) > 0. ? normalize(tangent) : perpA;
vec2 miterVec = vec2(-tangent.y, tangent.x);
vec2 dir = isEnd ? dirA : dirB;
vec2 perp = isEnd ? perpA : perpB;
float L = isEnd ? lenA : lenB;
float sinHalfA = abs(dot(miterVec, perp));
float cosHalfA = abs(dot(dirA, miterVec));
float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);
float cornerPosition = sideOfPath * turnDirection;
float miterSize = 1.0 / max(sinHalfA, EPSILON);
miterSize = mix(
min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),
miterSize,
step(0.0, cornerPosition)
);
vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))
* (sideOfPath + isJoint * turnDirection);
bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));
bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));
bool isCap = isStartCap || isEndCap;
if (isCap) {
offsetVec = mix(perp * sideOfPath, dir * path.capType * 4.0 * flipIfTrue(isStartCap), isJoint);
vJointType = path.capType;
} else {
vJointType = path.jointType;
}
vPathLength = L;
vCornerOffset = offsetVec;
vMiterLength = dot(vCornerOffset, miterVec * turnDirection);
vMiterLength = isCap ? isJoint : vMiterLength;
vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);
vPathPosition = vec2(
dot(offsetFromStartOfPath, perp),
dot(offsetFromStartOfPath, dir)
);
geometry.uv = vPathPosition;
float isValid = step(instanceTypes, 3.5);
vec3 offset = vec3(offsetVec * width * isValid, 0.0);
if (needsRotation) {
offset = rotationMatrix * offset;
}
return offset;
}
void clipLine(inout vec4 position, vec4 refPosition) {
if (position.w < EPSILON) {
float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);
position = refPosition + (position - refPosition) * r;
}
}
void main() {
geometry.pickingColor = instancePickingColors;
vColor = vec4(instanceColors.rgb, instanceColors.a * layer.opacity);
float isEnd = positions.x;
vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);
vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);
vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);
vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);
vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);
vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);
geometry.worldPosition = currPosition;
vec2 widthPixels = vec2(clamp(
project_size_to_pixel(instanceStrokeWidths * path.widthScale, path.widthUnits),
path.widthMinPixels, path.widthMaxPixels) / 2.0);
vec3 width;
if (path.billboard) {
vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);
vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);
vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);
clipLine(prevPositionScreen, currPositionScreen);
clipLine(nextPositionScreen, currPositionScreen);
clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));
width = vec3(widthPixels, 0.0);
DECKGL_FILTER_SIZE(width, geometry);
vec3 offset = getLineJoinOffset(
prevPositionScreen.xyz / prevPositionScreen.w,
currPositionScreen.xyz / currPositionScreen.w,
nextPositionScreen.xyz / nextPositionScreen.w,
project_pixel_size_to_clipspace(width.xy)
);
DECKGL_FILTER_GL_POSITION(currPositionScreen, geometry);
gl_Position = vec4(currPositionScreen.xyz + offset * currPositionScreen.w, currPositionScreen.w);
} else {
prevPosition = project_position(prevPosition, prevPosition64Low);
currPosition = project_position(currPosition, currPosition64Low);
nextPosition = project_position(nextPosition, nextPosition64Low);
width = vec3(project_pixel_size(widthPixels), 0.0);
DECKGL_FILTER_SIZE(width, geometry);
vec3 offset = getLineJoinOffset(prevPosition, currPosition, nextPosition, width.xy);
geometry.position = vec4(currPosition + offset, 1.0);
gl_Position = project_common_position_to_clipspace(geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/path-layer/path-layer-fragment.glsl.js
var path_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME path-layer-fragment-shader
precision highp float;
in vec4 vColor;
in vec2 vCornerOffset;
in float vMiterLength;
in vec2 vPathPosition;
in float vPathLength;
in float vJointType;
out vec4 fragColor;
void main(void) {
geometry.uv = vPathPosition;
if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {
if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {
discard;
}
if (vJointType < 0.5 && vMiterLength > path.miterLimit + 1.0) {
discard;
}
}
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/path-layer/path-layer.js
var DEFAULT_COLOR7 = [0, 0, 0, 255];
var defaultProps9 = {
  widthUnits: "meters",
  widthScale: { type: "number", min: 0, value: 1 },
  widthMinPixels: { type: "number", min: 0, value: 0 },
  widthMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
  jointRounded: false,
  capRounded: false,
  miterLimit: { type: "number", min: 0, value: 4 },
  billboard: false,
  _pathType: null,
  getPath: { type: "accessor", value: (object) => object.path },
  getColor: { type: "accessor", value: DEFAULT_COLOR7 },
  getWidth: { type: "accessor", value: 1 },
  // deprecated props
  rounded: { deprecatedFor: ["jointRounded", "capRounded"] }
};
var ATTRIBUTE_TRANSITION = {
  enter: (value, chunk) => {
    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;
  }
};
var PathLayer = class extends layer_default {
  getShaders() {
    return super.getShaders({ vs: path_layer_vertex_glsl_default, fs: path_layer_fragment_glsl_default, modules: [project32_default, picking_default, pathUniforms] });
  }
  get wrapLongitude() {
    return false;
  }
  getBounds() {
    var _a;
    return (_a = this.getAttributeManager()) == null ? void 0 : _a.getBounds(["vertexPositions"]);
  }
  initializeState() {
    const noAlloc = true;
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      vertexPositions: {
        size: 3,
        // Start filling buffer from 1 vertex in
        vertexOffset: 1,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: ATTRIBUTE_TRANSITION,
        accessor: "getPath",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculatePositions,
        noAlloc,
        shaderAttributes: {
          instanceLeftPositions: {
            vertexOffset: 0
          },
          instanceStartPositions: {
            vertexOffset: 1
          },
          instanceEndPositions: {
            vertexOffset: 2
          },
          instanceRightPositions: {
            vertexOffset: 3
          }
        }
      },
      instanceTypes: {
        size: 1,
        type: "uint8",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculateSegmentTypes,
        noAlloc
      },
      instanceStrokeWidths: {
        size: 1,
        accessor: "getWidth",
        transition: ATTRIBUTE_TRANSITION,
        defaultValue: 1
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        accessor: "getColor",
        transition: ATTRIBUTE_TRANSITION,
        defaultValue: DEFAULT_COLOR7
      },
      instancePickingColors: {
        size: 4,
        type: "uint8",
        accessor: (object, { index, target: value }) => this.encodePickingColor(object && object.__source ? object.__source.index : index, value)
      }
    });
    this.setState({
      pathTesselator: new PathTesselator({
        fp64: this.use64bitPositions()
      })
    });
  }
  updateState(params) {
    var _a;
    super.updateState(params);
    const { props, changeFlags } = params;
    const attributeManager = this.getAttributeManager();
    const geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPath);
    if (geometryChanged) {
      const { pathTesselator } = this.state;
      const buffers = props.data.attributes || {};
      pathTesselator.updateGeometry({
        data: props.data,
        geometryBuffer: buffers.getPath,
        buffers,
        normalize: !props._pathType,
        loop: props._pathType === "loop",
        getGeometry: props.getPath,
        positionFormat: props.positionFormat,
        wrapLongitude: props.wrapLongitude,
        // TODO - move the flag out of the viewport
        resolution: this.context.viewport.resolution,
        dataChanged: changeFlags.dataChanged
      });
      this.setState({
        numInstances: pathTesselator.instanceCount,
        startIndices: pathTesselator.vertexStarts
      });
      if (!changeFlags.dataChanged) {
        attributeManager.invalidateAll();
      }
    }
    if (changeFlags.extensionsChanged) {
      (_a = this.state.model) == null ? void 0 : _a.destroy();
      this.state.model = this._getModel();
      attributeManager.invalidateAll();
    }
  }
  getPickingInfo(params) {
    const info = super.getPickingInfo(params);
    const { index } = info;
    const data = this.props.data;
    if (data[0] && data[0].__source) {
      info.object = data.find((d2) => d2.__source.index === index);
    }
    return info;
  }
  /** Override base Layer method */
  disablePickingIndex(objectIndex) {
    const data = this.props.data;
    if (data[0] && data[0].__source) {
      for (let i = 0; i < data.length; i++) {
        if (data[i].__source.index === objectIndex) {
          this._disablePickingIndex(i);
        }
      }
    } else {
      super.disablePickingIndex(objectIndex);
    }
  }
  draw({ uniforms }) {
    const { jointRounded, capRounded, billboard, miterLimit, widthUnits, widthScale, widthMinPixels, widthMaxPixels } = this.props;
    const model = this.state.model;
    const pathProps = {
      jointType: Number(jointRounded),
      capType: Number(capRounded),
      billboard,
      widthUnits: UNIT[widthUnits],
      widthScale,
      miterLimit,
      widthMinPixels,
      widthMaxPixels
    };
    model.shaderInputs.setProps({ path: pathProps });
    model.draw(this.context.renderPass);
  }
  _getModel() {
    const SEGMENT_INDICES = [
      // start corner
      0,
      1,
      2,
      // body
      1,
      4,
      2,
      1,
      3,
      4,
      // end corner
      3,
      5,
      4
    ];
    const SEGMENT_POSITIONS = [
      // bevel start corner
      0,
      0,
      // start inner corner
      0,
      -1,
      // start outer corner
      0,
      1,
      // end inner corner
      1,
      -1,
      // end outer corner
      1,
      1,
      // bevel end corner
      1,
      0
    ];
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new Geometry({
        topology: "triangle-list",
        attributes: {
          indices: new Uint16Array(SEGMENT_INDICES),
          positions: { value: new Float32Array(SEGMENT_POSITIONS), size: 2 }
        }
      }),
      isInstanced: true
    });
  }
  calculatePositions(attribute) {
    const { pathTesselator } = this.state;
    attribute.startIndices = pathTesselator.vertexStarts;
    attribute.value = pathTesselator.get("positions");
  }
  calculateSegmentTypes(attribute) {
    const { pathTesselator } = this.state;
    attribute.startIndices = pathTesselator.vertexStarts;
    attribute.value = pathTesselator.get("segmentTypes");
  }
};
PathLayer.defaultProps = defaultProps9;
PathLayer.layerName = "PathLayer";
var path_layer_default = PathLayer;

// node_modules/@deck.gl/layers/dist/solid-polygon-layer/polygon.js
var import_earcut2 = __toESM(require_earcut(), 1);
var OUTER_POLYGON_WINDING = WINDING.CLOCKWISE;
var HOLE_POLYGON_WINDING = WINDING.COUNTER_CLOCKWISE;
var windingOptions = {
  isClosed: true
};
function validate(polygon) {
  polygon = polygon && polygon.positions || polygon;
  if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {
    throw new Error("invalid polygon");
  }
}
function getPositions(polygon) {
  return "positions" in polygon ? polygon.positions : polygon;
}
function getHoleIndices(polygon) {
  return "holeIndices" in polygon ? polygon.holeIndices : null;
}
function isNested(polygon) {
  return Array.isArray(polygon[0]);
}
function isSimple(polygon) {
  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);
}
function isNestedRingClosed(simplePolygon) {
  const p0 = simplePolygon[0];
  const p1 = simplePolygon[simplePolygon.length - 1];
  return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];
}
function isFlatRingClosed(positions, size, startIndex, endIndex) {
  for (let i = 0; i < size; i++) {
    if (positions[startIndex + i] !== positions[endIndex - size + i]) {
      return false;
    }
  }
  return true;
}
function copyNestedRing(target, targetStartIndex, simplePolygon, size, windingDirection) {
  let targetIndex = targetStartIndex;
  const len4 = simplePolygon.length;
  for (let i = 0; i < len4; i++) {
    for (let j = 0; j < size; j++) {
      target[targetIndex++] = simplePolygon[i][j] || 0;
    }
  }
  if (!isNestedRingClosed(simplePolygon)) {
    for (let j = 0; j < size; j++) {
      target[targetIndex++] = simplePolygon[0][j] || 0;
    }
  }
  windingOptions.start = targetStartIndex;
  windingOptions.end = targetIndex;
  windingOptions.size = size;
  modifyPolygonWindingDirection(target, windingDirection, windingOptions);
  return targetIndex;
}
function copyFlatRing(target, targetStartIndex, positions, size, srcStartIndex = 0, srcEndIndex, windingDirection) {
  srcEndIndex = srcEndIndex || positions.length;
  const srcLength = srcEndIndex - srcStartIndex;
  if (srcLength <= 0) {
    return targetStartIndex;
  }
  let targetIndex = targetStartIndex;
  for (let i = 0; i < srcLength; i++) {
    target[targetIndex++] = positions[srcStartIndex + i];
  }
  if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) {
    for (let i = 0; i < size; i++) {
      target[targetIndex++] = positions[srcStartIndex + i];
    }
  }
  windingOptions.start = targetStartIndex;
  windingOptions.end = targetIndex;
  windingOptions.size = size;
  modifyPolygonWindingDirection(target, windingDirection, windingOptions);
  return targetIndex;
}
function normalize(polygon, positionSize) {
  validate(polygon);
  const positions = [];
  const holeIndices = [];
  if ("positions" in polygon) {
    const { positions: srcPositions, holeIndices: srcHoleIndices } = polygon;
    if (srcHoleIndices) {
      let targetIndex = 0;
      for (let i = 0; i <= srcHoleIndices.length; i++) {
        targetIndex = copyFlatRing(positions, targetIndex, srcPositions, positionSize, srcHoleIndices[i - 1], srcHoleIndices[i], i === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);
        holeIndices.push(targetIndex);
      }
      holeIndices.pop();
      return { positions, holeIndices };
    }
    polygon = srcPositions;
  }
  if (!isNested(polygon)) {
    copyFlatRing(positions, 0, polygon, positionSize, 0, positions.length, OUTER_POLYGON_WINDING);
    return positions;
  }
  if (!isSimple(polygon)) {
    let targetIndex = 0;
    for (const [polygonIndex, simplePolygon] of polygon.entries()) {
      targetIndex = copyNestedRing(positions, targetIndex, simplePolygon, positionSize, polygonIndex === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);
      holeIndices.push(targetIndex);
    }
    holeIndices.pop();
    return { positions, holeIndices };
  }
  copyNestedRing(positions, 0, polygon, positionSize, OUTER_POLYGON_WINDING);
  return positions;
}
function getPlaneArea(positions, xIndex, yIndex) {
  const numVerts = positions.length / 3;
  let area2 = 0;
  for (let i = 0; i < numVerts; i++) {
    const j = (i + 1) % numVerts;
    area2 += positions[i * 3 + xIndex] * positions[j * 3 + yIndex];
    area2 -= positions[j * 3 + xIndex] * positions[i * 3 + yIndex];
  }
  return Math.abs(area2 / 2);
}
function permutePositions(positions, xIndex, yIndex, zIndex) {
  const numVerts = positions.length / 3;
  for (let i = 0; i < numVerts; i++) {
    const o = i * 3;
    const x = positions[o + 0];
    const y = positions[o + 1];
    const z = positions[o + 2];
    positions[o + xIndex] = x;
    positions[o + yIndex] = y;
    positions[o + zIndex] = z;
  }
}
function getSurfaceIndices(polygon, positionSize, preproject, full3d) {
  let holeIndices = getHoleIndices(polygon);
  if (holeIndices) {
    holeIndices = holeIndices.map((positionIndex) => positionIndex / positionSize);
  }
  let positions = getPositions(polygon);
  const is3d = full3d && positionSize === 3;
  if (preproject) {
    const n = positions.length;
    positions = positions.slice();
    const p = [];
    for (let i = 0; i < n; i += positionSize) {
      p[0] = positions[i];
      p[1] = positions[i + 1];
      if (is3d) {
        p[2] = positions[i + 2];
      }
      const xy = preproject(p);
      positions[i] = xy[0];
      positions[i + 1] = xy[1];
      if (is3d) {
        positions[i + 2] = xy[2];
      }
    }
  }
  if (is3d) {
    const xyArea = getPlaneArea(positions, 0, 1);
    const xzArea = getPlaneArea(positions, 0, 2);
    const yzArea = getPlaneArea(positions, 1, 2);
    if (!xyArea && !xzArea && !yzArea) {
      return [];
    }
    if (xyArea > xzArea && xyArea > yzArea) {
    } else if (xzArea > yzArea) {
      if (!preproject) {
        positions = positions.slice();
      }
      permutePositions(positions, 0, 2, 1);
    } else {
      if (!preproject) {
        positions = positions.slice();
      }
      permutePositions(positions, 2, 0, 1);
    }
  }
  return (0, import_earcut2.default)(positions, holeIndices, positionSize);
}

// node_modules/@deck.gl/layers/dist/solid-polygon-layer/polygon-tesselator.js
var PolygonTesselator = class extends Tesselator {
  constructor(opts) {
    const { fp64: fp642, IndexType = Uint32Array } = opts;
    super({
      ...opts,
      attributes: {
        positions: { size: 3, type: fp642 ? Float64Array : Float32Array },
        vertexValid: { type: Uint16Array, size: 1 },
        indices: { type: IndexType, size: 1 }
      }
    });
  }
  /** Get attribute by name */
  get(attributeName) {
    const { attributes } = this;
    if (attributeName === "indices") {
      return attributes.indices && attributes.indices.subarray(0, this.vertexCount);
    }
    return attributes[attributeName];
  }
  /** Override base Tesselator method */
  updateGeometry(opts) {
    super.updateGeometry(opts);
    const externalIndices = this.buffers.indices;
    if (externalIndices) {
      this.vertexCount = (externalIndices.value || externalIndices).length;
    } else if (this.data && !this.getGeometry) {
      throw new Error("missing indices buffer");
    }
  }
  /** Implement base Tesselator interface */
  normalizeGeometry(polygon) {
    if (this.normalize) {
      const normalizedPolygon = normalize(polygon, this.positionSize);
      if (this.opts.resolution) {
        return cutPolygonByGrid(getPositions(normalizedPolygon), getHoleIndices(normalizedPolygon), {
          size: this.positionSize,
          gridResolution: this.opts.resolution,
          edgeTypes: true
        });
      }
      if (this.opts.wrapLongitude) {
        return cutPolygonByMercatorBounds(getPositions(normalizedPolygon), getHoleIndices(normalizedPolygon), {
          size: this.positionSize,
          maxLatitude: 86,
          edgeTypes: true
        });
      }
      return normalizedPolygon;
    }
    return polygon;
  }
  /** Implement base Tesselator interface */
  getGeometrySize(polygon) {
    if (isCut2(polygon)) {
      let size = 0;
      for (const subPolygon of polygon) {
        size += this.getGeometrySize(subPolygon);
      }
      return size;
    }
    return getPositions(polygon).length / this.positionSize;
  }
  /** Override base Tesselator method */
  getGeometryFromBuffer(buffer) {
    if (this.normalize || !this.buffers.indices) {
      return super.getGeometryFromBuffer(buffer);
    }
    return null;
  }
  /** Implement base Tesselator interface */
  updateGeometryAttributes(polygon, context) {
    if (polygon && isCut2(polygon)) {
      for (const subPolygon of polygon) {
        const geometrySize = this.getGeometrySize(subPolygon);
        context.geometrySize = geometrySize;
        this.updateGeometryAttributes(subPolygon, context);
        context.vertexStart += geometrySize;
        context.indexStart = this.indexStarts[context.geometryIndex + 1];
      }
    } else {
      const normalizedPolygon = polygon;
      this._updateIndices(normalizedPolygon, context);
      this._updatePositions(normalizedPolygon, context);
      this._updateVertexValid(normalizedPolygon, context);
    }
  }
  // Flatten the indices array
  _updateIndices(polygon, { geometryIndex, vertexStart: offset, indexStart }) {
    const { attributes, indexStarts, typedArrayManager } = this;
    let target = attributes.indices;
    if (!target || !polygon) {
      return;
    }
    let i = indexStart;
    const indices = getSurfaceIndices(polygon, this.positionSize, this.opts.preproject, this.opts.full3d);
    target = typedArrayManager.allocate(target, indexStart + indices.length, {
      copy: true
    });
    for (let j = 0; j < indices.length; j++) {
      target[i++] = indices[j] + offset;
    }
    indexStarts[geometryIndex + 1] = indexStart + indices.length;
    attributes.indices = target;
  }
  // Flatten out all the vertices of all the sub subPolygons
  _updatePositions(polygon, { vertexStart, geometrySize }) {
    const { attributes: { positions }, positionSize } = this;
    if (!positions || !polygon) {
      return;
    }
    const polygonPositions = getPositions(polygon);
    for (let i = vertexStart, j = 0; j < geometrySize; i++, j++) {
      const x = polygonPositions[j * positionSize];
      const y = polygonPositions[j * positionSize + 1];
      const z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;
      positions[i * 3] = x;
      positions[i * 3 + 1] = y;
      positions[i * 3 + 2] = z;
    }
  }
  _updateVertexValid(polygon, { vertexStart, geometrySize }) {
    const { positionSize } = this;
    const vertexValid = this.attributes.vertexValid;
    const holeIndices = polygon && getHoleIndices(polygon);
    if (polygon && polygon.edgeTypes) {
      vertexValid.set(polygon.edgeTypes, vertexStart);
    } else {
      vertexValid.fill(1, vertexStart, vertexStart + geometrySize);
    }
    if (holeIndices) {
      for (let j = 0; j < holeIndices.length; j++) {
        vertexValid[vertexStart + holeIndices[j] / positionSize - 1] = 0;
      }
    }
    vertexValid[vertexStart + geometrySize - 1] = 0;
  }
};
function isCut2(polygon) {
  return Array.isArray(polygon) && polygon.length > 0 && !Number.isFinite(polygon[0]);
}

// node_modules/@deck.gl/layers/dist/solid-polygon-layer/solid-polygon-layer-uniforms.js
var uniformBlock6 = `uniform solidPolygonUniforms {
  bool extruded;
  bool isWireframe;
  float elevationScale;
} solidPolygon;
`;
var solidPolygonUniforms = {
  name: "solidPolygon",
  vs: uniformBlock6,
  fs: uniformBlock6,
  uniformTypes: {
    extruded: "f32",
    isWireframe: "f32",
    elevationScale: "f32"
  }
};

// node_modules/@deck.gl/layers/dist/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.js
var solid_polygon_layer_vertex_main_glsl_default = `in vec4 fillColors;
in vec4 lineColors;
in vec3 pickingColors;
out vec4 vColor;
struct PolygonProps {
vec3 positions;
vec3 positions64Low;
vec3 normal;
float elevations;
};
vec3 project_offset_normal(vec3 vector) {
if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {
return normalize(vector * project.commonUnitsPerWorldUnit);
}
return project_normal(vector);
}
void calculatePosition(PolygonProps props) {
vec3 pos = props.positions;
vec3 pos64Low = props.positions64Low;
vec3 normal = props.normal;
vec4 colors = solidPolygon.isWireframe ? lineColors : fillColors;
geometry.worldPosition = props.positions;
geometry.pickingColor = pickingColors;
if (solidPolygon.extruded) {
pos.z += props.elevations * solidPolygon.elevationScale;
}
gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
if (solidPolygon.extruded) {
#ifdef IS_SIDE_VERTEX
normal = project_offset_normal(normal);
#else
normal = project_normal(normal);
#endif
geometry.normal = normal;
vec3 lightColor = lighting_getLightColor(colors.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);
vColor = vec4(lightColor, colors.a * layer.opacity);
} else {
vColor = vec4(colors.rgb, colors.a * layer.opacity);
}
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/solid-polygon-layer/solid-polygon-layer-vertex-top.glsl.js
var solid_polygon_layer_vertex_top_glsl_default = `#version 300 es
#define SHADER_NAME solid-polygon-layer-vertex-shader
in vec3 vertexPositions;
in vec3 vertexPositions64Low;
in float elevations;
${solid_polygon_layer_vertex_main_glsl_default}
void main(void) {
PolygonProps props;
props.positions = vertexPositions;
props.positions64Low = vertexPositions64Low;
props.elevations = elevations;
props.normal = vec3(0.0, 0.0, 1.0);
calculatePosition(props);
}
`;

// node_modules/@deck.gl/layers/dist/solid-polygon-layer/solid-polygon-layer-vertex-side.glsl.js
var solid_polygon_layer_vertex_side_glsl_default = `#version 300 es
#define SHADER_NAME solid-polygon-layer-vertex-shader-side
#define IS_SIDE_VERTEX
in vec2 positions;
in vec3 vertexPositions;
in vec3 nextVertexPositions;
in vec3 vertexPositions64Low;
in vec3 nextVertexPositions64Low;
in float elevations;
in float instanceVertexValid;
${solid_polygon_layer_vertex_main_glsl_default}
void main(void) {
if(instanceVertexValid < 0.5){
gl_Position = vec4(0.);
return;
}
PolygonProps props;
vec3 pos;
vec3 pos64Low;
vec3 nextPos;
vec3 nextPos64Low;
#if RING_WINDING_ORDER_CW == 1
pos = vertexPositions;
pos64Low = vertexPositions64Low;
nextPos = nextVertexPositions;
nextPos64Low = nextVertexPositions64Low;
#else
pos = nextVertexPositions;
pos64Low = nextVertexPositions64Low;
nextPos = vertexPositions;
nextPos64Low = vertexPositions64Low;
#endif
props.positions = mix(pos, nextPos, positions.x);
props.positions64Low = mix(pos64Low, nextPos64Low, positions.x);
props.normal = vec3(
pos.y - nextPos.y + (pos64Low.y - nextPos64Low.y),
nextPos.x - pos.x + (nextPos64Low.x - pos64Low.x),
0.0);
props.elevations = elevations * positions.y;
calculatePosition(props);
}
`;

// node_modules/@deck.gl/layers/dist/solid-polygon-layer/solid-polygon-layer-fragment.glsl.js
var solid_polygon_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME solid-polygon-layer-fragment-shader
precision highp float;
in vec4 vColor;
out vec4 fragColor;
void main(void) {
fragColor = vColor;
geometry.uv = vec2(0.);
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/solid-polygon-layer/solid-polygon-layer.js
var DEFAULT_COLOR8 = [0, 0, 0, 255];
var defaultProps10 = {
  filled: true,
  extruded: false,
  wireframe: false,
  _normalize: true,
  _windingOrder: "CW",
  _full3d: false,
  elevationScale: { type: "number", min: 0, value: 1 },
  getPolygon: { type: "accessor", value: (f) => f.polygon },
  getElevation: { type: "accessor", value: 1e3 },
  getFillColor: { type: "accessor", value: DEFAULT_COLOR8 },
  getLineColor: { type: "accessor", value: DEFAULT_COLOR8 },
  material: true
};
var ATTRIBUTE_TRANSITION2 = {
  enter: (value, chunk) => {
    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;
  }
};
var SolidPolygonLayer = class extends layer_default {
  getShaders(type) {
    return super.getShaders({
      vs: type === "top" ? solid_polygon_layer_vertex_top_glsl_default : solid_polygon_layer_vertex_side_glsl_default,
      fs: solid_polygon_layer_fragment_glsl_default,
      defines: {
        RING_WINDING_ORDER_CW: !this.props._normalize && this.props._windingOrder === "CCW" ? 0 : 1
      },
      modules: [project32_default, gouraudMaterial, picking_default, solidPolygonUniforms]
    });
  }
  get wrapLongitude() {
    return false;
  }
  getBounds() {
    var _a;
    return (_a = this.getAttributeManager()) == null ? void 0 : _a.getBounds(["vertexPositions"]);
  }
  initializeState() {
    const { viewport } = this.context;
    let { coordinateSystem } = this.props;
    const { _full3d } = this.props;
    if (viewport.isGeospatial && coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
      coordinateSystem = COORDINATE_SYSTEM.LNGLAT;
    }
    let preproject;
    if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {
      if (_full3d) {
        preproject = viewport.projectPosition.bind(viewport);
      } else {
        preproject = viewport.projectFlat.bind(viewport);
      }
    }
    this.setState({
      numInstances: 0,
      polygonTesselator: new PolygonTesselator({
        // Lnglat coordinates are usually projected non-linearly, which affects tesselation results
        // Provide a preproject function if the coordinates are in lnglat
        preproject,
        fp64: this.use64bitPositions(),
        IndexType: Uint32Array
      })
    });
    const attributeManager = this.getAttributeManager();
    const noAlloc = true;
    attributeManager.remove(["instancePickingColors"]);
    attributeManager.add({
      indices: {
        size: 1,
        isIndexed: true,
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculateIndices,
        noAlloc
      },
      vertexPositions: {
        size: 3,
        type: "float64",
        stepMode: "dynamic",
        fp64: this.use64bitPositions(),
        transition: ATTRIBUTE_TRANSITION2,
        accessor: "getPolygon",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculatePositions,
        noAlloc,
        shaderAttributes: {
          nextVertexPositions: {
            vertexOffset: 1
          }
        }
      },
      instanceVertexValid: {
        size: 1,
        type: "uint16",
        stepMode: "instance",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculateVertexValid,
        noAlloc
      },
      elevations: {
        size: 1,
        stepMode: "dynamic",
        transition: ATTRIBUTE_TRANSITION2,
        accessor: "getElevation"
      },
      fillColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        stepMode: "dynamic",
        transition: ATTRIBUTE_TRANSITION2,
        accessor: "getFillColor",
        defaultValue: DEFAULT_COLOR8
      },
      lineColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        stepMode: "dynamic",
        transition: ATTRIBUTE_TRANSITION2,
        accessor: "getLineColor",
        defaultValue: DEFAULT_COLOR8
      },
      pickingColors: {
        size: 4,
        type: "uint8",
        stepMode: "dynamic",
        accessor: (object, { index, target: value }) => this.encodePickingColor(object && object.__source ? object.__source.index : index, value)
      }
    });
  }
  getPickingInfo(params) {
    const info = super.getPickingInfo(params);
    const { index } = info;
    const data = this.props.data;
    if (data[0] && data[0].__source) {
      info.object = data.find((d2) => d2.__source.index === index);
    }
    return info;
  }
  disablePickingIndex(objectIndex) {
    const data = this.props.data;
    if (data[0] && data[0].__source) {
      for (let i = 0; i < data.length; i++) {
        if (data[i].__source.index === objectIndex) {
          this._disablePickingIndex(i);
        }
      }
    } else {
      super.disablePickingIndex(objectIndex);
    }
  }
  draw({ uniforms }) {
    const { extruded, filled, wireframe, elevationScale } = this.props;
    const { topModel, sideModel, wireframeModel, polygonTesselator } = this.state;
    const renderUniforms = {
      extruded: Boolean(extruded),
      elevationScale,
      isWireframe: false
    };
    if (wireframeModel && wireframe) {
      wireframeModel.setInstanceCount(polygonTesselator.instanceCount - 1);
      wireframeModel.shaderInputs.setProps({ solidPolygon: { ...renderUniforms, isWireframe: true } });
      wireframeModel.draw(this.context.renderPass);
    }
    if (sideModel && filled) {
      sideModel.setInstanceCount(polygonTesselator.instanceCount - 1);
      sideModel.shaderInputs.setProps({ solidPolygon: renderUniforms });
      sideModel.draw(this.context.renderPass);
    }
    if (topModel && filled) {
      topModel.setVertexCount(polygonTesselator.vertexCount);
      topModel.shaderInputs.setProps({ solidPolygon: renderUniforms });
      topModel.draw(this.context.renderPass);
    }
  }
  updateState(updateParams) {
    var _a;
    super.updateState(updateParams);
    this.updateGeometry(updateParams);
    const { props, oldProps, changeFlags } = updateParams;
    const attributeManager = this.getAttributeManager();
    const regenerateModels = changeFlags.extensionsChanged || props.filled !== oldProps.filled || props.extruded !== oldProps.extruded;
    if (regenerateModels) {
      (_a = this.state.models) == null ? void 0 : _a.forEach((model) => model.destroy());
      this.setState(this._getModels());
      attributeManager.invalidateAll();
    }
  }
  updateGeometry({ props, oldProps, changeFlags }) {
    const geometryConfigChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);
    if (geometryConfigChanged) {
      const { polygonTesselator } = this.state;
      const buffers = props.data.attributes || {};
      polygonTesselator.updateGeometry({
        data: props.data,
        normalize: props._normalize,
        geometryBuffer: buffers.getPolygon,
        buffers,
        getGeometry: props.getPolygon,
        positionFormat: props.positionFormat,
        wrapLongitude: props.wrapLongitude,
        // TODO - move the flag out of the viewport
        resolution: this.context.viewport.resolution,
        fp64: this.use64bitPositions(),
        dataChanged: changeFlags.dataChanged,
        full3d: props._full3d
      });
      this.setState({
        numInstances: polygonTesselator.instanceCount,
        startIndices: polygonTesselator.vertexStarts
      });
      if (!changeFlags.dataChanged) {
        this.getAttributeManager().invalidateAll();
      }
    }
  }
  _getModels() {
    const { id, filled, extruded } = this.props;
    let topModel;
    let sideModel;
    let wireframeModel;
    if (filled) {
      const shaders = this.getShaders("top");
      shaders.defines.NON_INSTANCED_MODEL = 1;
      const bufferLayout = this.getAttributeManager().getBufferLayouts({ isInstanced: false });
      topModel = new Model(this.context.device, {
        ...shaders,
        id: `${id}-top`,
        topology: "triangle-list",
        bufferLayout,
        isIndexed: true,
        userData: {
          excludeAttributes: { instanceVertexValid: true }
        }
      });
    }
    if (extruded) {
      const bufferLayout = this.getAttributeManager().getBufferLayouts({ isInstanced: true });
      sideModel = new Model(this.context.device, {
        ...this.getShaders("side"),
        id: `${id}-side`,
        bufferLayout,
        geometry: new Geometry({
          topology: "triangle-strip",
          attributes: {
            // top right - top left - bottom right - bottom left
            positions: {
              size: 2,
              value: new Float32Array([1, 0, 0, 0, 1, 1, 0, 1])
            }
          }
        }),
        isInstanced: true,
        userData: {
          excludeAttributes: { indices: true }
        }
      });
      wireframeModel = new Model(this.context.device, {
        ...this.getShaders("side"),
        id: `${id}-wireframe`,
        bufferLayout,
        geometry: new Geometry({
          topology: "line-strip",
          attributes: {
            // top right - top left - bottom left - bottom right
            positions: {
              size: 2,
              value: new Float32Array([1, 0, 0, 0, 0, 1, 1, 1])
            }
          }
        }),
        isInstanced: true,
        userData: {
          excludeAttributes: { indices: true }
        }
      });
    }
    return {
      models: [sideModel, wireframeModel, topModel].filter(Boolean),
      topModel,
      sideModel,
      wireframeModel
    };
  }
  calculateIndices(attribute) {
    const { polygonTesselator } = this.state;
    attribute.startIndices = polygonTesselator.indexStarts;
    attribute.value = polygonTesselator.get("indices");
  }
  calculatePositions(attribute) {
    const { polygonTesselator } = this.state;
    attribute.startIndices = polygonTesselator.vertexStarts;
    attribute.value = polygonTesselator.get("positions");
  }
  calculateVertexValid(attribute) {
    attribute.value = this.state.polygonTesselator.get("vertexValid");
  }
};
SolidPolygonLayer.defaultProps = defaultProps10;
SolidPolygonLayer.layerName = "SolidPolygonLayer";
var solid_polygon_layer_default = SolidPolygonLayer;

// node_modules/@deck.gl/layers/dist/utils.js
function replaceInRange({ data, getIndex, dataRange, replace }) {
  const { startRow = 0, endRow = Infinity } = dataRange;
  const count = data.length;
  let replaceStart = count;
  let replaceEnd = count;
  for (let i = 0; i < count; i++) {
    const row = getIndex(data[i]);
    if (replaceStart > i && row >= startRow) {
      replaceStart = i;
    }
    if (row >= endRow) {
      replaceEnd = i;
      break;
    }
  }
  let index = replaceStart;
  const dataLengthChanged = replaceEnd - replaceStart !== replace.length;
  const endChunk = dataLengthChanged ? data.slice(replaceEnd) : void 0;
  for (let i = 0; i < replace.length; i++) {
    data[index++] = replace[i];
  }
  if (endChunk) {
    for (let i = 0; i < endChunk.length; i++) {
      data[index++] = endChunk[i];
    }
    data.length = index;
  }
  return {
    startRow: replaceStart,
    endRow: replaceStart + replace.length
  };
}

// node_modules/@deck.gl/layers/dist/polygon-layer/polygon-layer.js
var defaultLineColor = [0, 0, 0, 255];
var defaultFillColor = [0, 0, 0, 255];
var defaultProps11 = {
  stroked: true,
  filled: true,
  extruded: false,
  elevationScale: 1,
  wireframe: false,
  _normalize: true,
  _windingOrder: "CW",
  lineWidthUnits: "meters",
  lineWidthScale: 1,
  lineWidthMinPixels: 0,
  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
  lineJointRounded: false,
  lineMiterLimit: 4,
  getPolygon: { type: "accessor", value: (f) => f.polygon },
  // Polygon fill color
  getFillColor: { type: "accessor", value: defaultFillColor },
  // Point, line and polygon outline color
  getLineColor: { type: "accessor", value: defaultLineColor },
  // Line and polygon outline accessors
  getLineWidth: { type: "accessor", value: 1 },
  // Polygon extrusion accessor
  getElevation: { type: "accessor", value: 1e3 },
  // Optional material for 'lighting' shader module
  material: true
};
var PolygonLayer = class extends composite_layer_default {
  initializeState() {
    this.state = {
      paths: [],
      pathsDiff: null
    };
    if (this.props.getLineDashArray) {
      log_default.removed("getLineDashArray", "PathStyleExtension")();
    }
  }
  updateState({ changeFlags }) {
    const geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);
    if (geometryChanged && Array.isArray(changeFlags.dataChanged)) {
      const paths = this.state.paths.slice();
      const pathsDiff = changeFlags.dataChanged.map((dataRange) => replaceInRange({
        data: paths,
        getIndex: (p) => p.__source.index,
        dataRange,
        replace: this._getPaths(dataRange)
      }));
      this.setState({ paths, pathsDiff });
    } else if (geometryChanged) {
      this.setState({
        paths: this._getPaths(),
        pathsDiff: null
      });
    }
  }
  _getPaths(dataRange = {}) {
    const { data, getPolygon, positionFormat, _normalize } = this.props;
    const paths = [];
    const positionSize = positionFormat === "XY" ? 2 : 3;
    const { startRow, endRow } = dataRange;
    const { iterable, objectInfo } = createIterable(data, startRow, endRow);
    for (const object of iterable) {
      objectInfo.index++;
      let polygon = getPolygon(object, objectInfo);
      if (_normalize) {
        polygon = normalize(polygon, positionSize);
      }
      const { holeIndices } = polygon;
      const positions = polygon.positions || polygon;
      if (holeIndices) {
        for (let i = 0; i <= holeIndices.length; i++) {
          const path = positions.slice(holeIndices[i - 1] || 0, holeIndices[i] || positions.length);
          paths.push(this.getSubLayerRow({ path }, object, objectInfo.index));
        }
      } else {
        paths.push(this.getSubLayerRow({ path: positions }, object, objectInfo.index));
      }
    }
    return paths;
  }
  /* eslint-disable complexity */
  renderLayers() {
    const { data, _dataDiff, stroked, filled, extruded, wireframe, _normalize, _windingOrder, elevationScale, transitions, positionFormat } = this.props;
    const { lineWidthUnits, lineWidthScale, lineWidthMinPixels, lineWidthMaxPixels, lineJointRounded, lineMiterLimit, lineDashJustified } = this.props;
    const { getFillColor, getLineColor, getLineWidth, getLineDashArray, getElevation, getPolygon, updateTriggers, material } = this.props;
    const { paths, pathsDiff } = this.state;
    const FillLayer = this.getSubLayerClass("fill", solid_polygon_layer_default);
    const StrokeLayer = this.getSubLayerClass("stroke", path_layer_default);
    const polygonLayer = this.shouldRenderSubLayer("fill", paths) && new FillLayer({
      _dataDiff,
      extruded,
      elevationScale,
      filled,
      wireframe,
      _normalize,
      _windingOrder,
      getElevation,
      getFillColor,
      getLineColor: extruded && wireframe ? getLineColor : defaultLineColor,
      material,
      transitions
    }, this.getSubLayerProps({
      id: "fill",
      updateTriggers: updateTriggers && {
        getPolygon: updateTriggers.getPolygon,
        getElevation: updateTriggers.getElevation,
        getFillColor: updateTriggers.getFillColor,
        // using a legacy API to invalid lineColor attributes
        // if (extruded && wireframe) has changed
        lineColors: extruded && wireframe,
        getLineColor: updateTriggers.getLineColor
      }
    }), {
      data,
      positionFormat,
      getPolygon
    });
    const polygonLineLayer = !extruded && stroked && this.shouldRenderSubLayer("stroke", paths) && new StrokeLayer({
      _dataDiff: pathsDiff && (() => pathsDiff),
      widthUnits: lineWidthUnits,
      widthScale: lineWidthScale,
      widthMinPixels: lineWidthMinPixels,
      widthMaxPixels: lineWidthMaxPixels,
      jointRounded: lineJointRounded,
      miterLimit: lineMiterLimit,
      dashJustified: lineDashJustified,
      // Already normalized
      _pathType: "loop",
      transitions: transitions && {
        getWidth: transitions.getLineWidth,
        getColor: transitions.getLineColor,
        getPath: transitions.getPolygon
      },
      getColor: this.getSubLayerAccessor(getLineColor),
      getWidth: this.getSubLayerAccessor(getLineWidth),
      getDashArray: this.getSubLayerAccessor(getLineDashArray)
    }, this.getSubLayerProps({
      id: "stroke",
      updateTriggers: updateTriggers && {
        getWidth: updateTriggers.getLineWidth,
        getColor: updateTriggers.getLineColor,
        getDashArray: updateTriggers.getLineDashArray
      }
    }), {
      data: paths,
      positionFormat,
      getPath: (x) => x.path
    });
    return [
      // If not extruded: flat fill layer is drawn below outlines
      !extruded && polygonLayer,
      polygonLineLayer,
      // If extruded: draw fill layer last for correct blending behavior
      extruded && polygonLayer
    ];
  }
};
PolygonLayer.layerName = "PolygonLayer";
PolygonLayer.defaultProps = defaultProps11;
var polygon_layer_default = PolygonLayer;

// node_modules/@deck.gl/layers/dist/geojson-layer/geojson-binary.js
function binaryToFeatureForAccesor(data, index) {
  if (!data) {
    return null;
  }
  const featureIndex = "startIndices" in data ? data.startIndices[index] : index;
  const geometryIndex = data.featureIds.value[featureIndex];
  if (featureIndex !== -1) {
    return getPropertiesForIndex(data, geometryIndex, featureIndex);
  }
  return null;
}
function getPropertiesForIndex(data, propertiesIndex, numericPropsIndex) {
  const feature2 = {
    properties: { ...data.properties[propertiesIndex] }
  };
  for (const prop in data.numericProps) {
    feature2.properties[prop] = data.numericProps[prop].value[numericPropsIndex];
  }
  return feature2;
}
function calculatePickingColors(geojsonBinary, encodePickingColor) {
  const pickingColors = {
    points: null,
    lines: null,
    polygons: null
  };
  for (const key in pickingColors) {
    const featureIds = geojsonBinary[key].globalFeatureIds.value;
    pickingColors[key] = new Uint8ClampedArray(featureIds.length * 4);
    const pickingColor = [];
    for (let i = 0; i < featureIds.length; i++) {
      encodePickingColor(featureIds[i], pickingColor);
      pickingColors[key][i * 4 + 0] = pickingColor[0];
      pickingColors[key][i * 4 + 1] = pickingColor[1];
      pickingColors[key][i * 4 + 2] = pickingColor[2];
      pickingColors[key][i * 4 + 3] = 255;
    }
  }
  return pickingColors;
}

// node_modules/@deck.gl/layers/dist/text-layer/multi-icon-layer/sdf-uniforms.js
var uniformBlock7 = `uniform sdfUniforms {
  float gamma;
  bool enabled;
  float buffer;
  float outlineBuffer;
  vec4 outlineColor;
} sdf;
`;
var sdfUniforms = {
  name: "sdf",
  vs: uniformBlock7,
  fs: uniformBlock7,
  uniformTypes: {
    gamma: "f32",
    enabled: "f32",
    buffer: "f32",
    outlineBuffer: "f32",
    outlineColor: "vec4<f32>"
  }
};

// node_modules/@deck.gl/layers/dist/text-layer/multi-icon-layer/multi-icon-layer-fragment.glsl.js
var multi_icon_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME multi-icon-layer-fragment-shader
precision highp float;
uniform sampler2D iconsTexture;
in vec4 vColor;
in vec2 vTextureCoords;
in vec2 uv;
out vec4 fragColor;
void main(void) {
geometry.uv = uv;
if (!bool(picking.isActive)) {
float alpha = texture(iconsTexture, vTextureCoords).a;
vec4 color = vColor;
if (sdf.enabled) {
float distance = alpha;
alpha = smoothstep(sdf.buffer - sdf.gamma, sdf.buffer + sdf.gamma, distance);
if (sdf.outlineBuffer > 0.0) {
float inFill = alpha;
float inBorder = smoothstep(sdf.outlineBuffer - sdf.gamma, sdf.outlineBuffer + sdf.gamma, distance);
color = mix(sdf.outlineColor, vColor, inFill);
alpha = inBorder;
}
}
float a = alpha * color.a;
if (a < icon.alphaCutoff) {
discard;
}
fragColor = vec4(color.rgb, a * layer.opacity);
}
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/text-layer/multi-icon-layer/multi-icon-layer.js
var DEFAULT_BUFFER2 = 192 / 256;
var EMPTY_ARRAY = [];
var defaultProps12 = {
  getIconOffsets: { type: "accessor", value: (x) => x.offsets },
  alphaCutoff: 1e-3,
  smoothing: 0.1,
  outlineWidth: 0,
  outlineColor: { type: "color", value: [0, 0, 0, 255] }
};
var MultiIconLayer = class extends icon_layer_default {
  getShaders() {
    const shaders = super.getShaders();
    return { ...shaders, modules: [...shaders.modules, sdfUniforms], fs: multi_icon_layer_fragment_glsl_default };
  }
  initializeState() {
    super.initializeState();
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instanceOffsets: {
        size: 2,
        accessor: "getIconOffsets"
      },
      instancePickingColors: {
        type: "uint8",
        size: 3,
        accessor: (object, { index, target: value }) => this.encodePickingColor(index, value)
      }
    });
  }
  updateState(params) {
    super.updateState(params);
    const { props, oldProps } = params;
    let { outlineColor } = props;
    if (outlineColor !== oldProps.outlineColor) {
      outlineColor = outlineColor.map((x) => x / 255);
      outlineColor[3] = Number.isFinite(outlineColor[3]) ? outlineColor[3] : 1;
      this.setState({
        outlineColor
      });
    }
    if (!props.sdf && props.outlineWidth) {
      log_default.warn(`${this.id}: fontSettings.sdf is required to render outline`)();
    }
  }
  draw(params) {
    const { sdf, smoothing, outlineWidth } = this.props;
    const { outlineColor } = this.state;
    const outlineBuffer = outlineWidth ? Math.max(smoothing, DEFAULT_BUFFER2 * (1 - outlineWidth)) : -1;
    const model = this.state.model;
    const sdfProps = {
      buffer: DEFAULT_BUFFER2,
      outlineBuffer,
      gamma: smoothing,
      enabled: Boolean(sdf),
      outlineColor
    };
    model.shaderInputs.setProps({ sdf: sdfProps });
    super.draw(params);
    if (sdf && outlineWidth) {
      const { iconManager } = this.state;
      const iconsTexture = iconManager.getTexture();
      if (iconsTexture) {
        model.shaderInputs.setProps({ sdf: { ...sdfProps, outlineBuffer: DEFAULT_BUFFER2 } });
        model.draw(this.context.renderPass);
      }
    }
  }
  getInstanceOffset(icons) {
    return icons ? Array.from(icons).flatMap((icon) => super.getInstanceOffset(icon)) : EMPTY_ARRAY;
  }
  getInstanceColorMode(icons) {
    return 1;
  }
  getInstanceIconFrame(icons) {
    return icons ? Array.from(icons).flatMap((icon) => super.getInstanceIconFrame(icon)) : EMPTY_ARRAY;
  }
};
MultiIconLayer.defaultProps = defaultProps12;
MultiIconLayer.layerName = "MultiIconLayer";
var multi_icon_layer_default = MultiIconLayer;

// node_modules/@mapbox/tiny-sdf/index.js
var INF = 1e20;
var TinySDF = class {
  constructor({
    fontSize = 24,
    buffer = 3,
    radius = 8,
    cutoff = 0.25,
    fontFamily = "sans-serif",
    fontWeight = "normal",
    fontStyle = "normal",
    lang = null
  } = {}) {
    this.buffer = buffer;
    this.cutoff = cutoff;
    this.radius = radius;
    this.lang = lang;
    const size = this.size = fontSize + buffer * 4;
    const canvas = this._createCanvas(size);
    const ctx = this.ctx = canvas.getContext("2d", { willReadFrequently: true });
    ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;
    ctx.textBaseline = "alphabetic";
    ctx.textAlign = "left";
    ctx.fillStyle = "black";
    this.gridOuter = new Float64Array(size * size);
    this.gridInner = new Float64Array(size * size);
    this.f = new Float64Array(size);
    this.z = new Float64Array(size + 1);
    this.v = new Uint16Array(size);
  }
  _createCanvas(size) {
    const canvas = document.createElement("canvas");
    canvas.width = canvas.height = size;
    return canvas;
  }
  draw(char) {
    const {
      width: glyphAdvance,
      actualBoundingBoxAscent,
      actualBoundingBoxDescent,
      actualBoundingBoxLeft,
      actualBoundingBoxRight
    } = this.ctx.measureText(char);
    const glyphTop = Math.ceil(actualBoundingBoxAscent);
    const glyphLeft = 0;
    const glyphWidth = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(actualBoundingBoxRight - actualBoundingBoxLeft)));
    const glyphHeight = Math.min(this.size - this.buffer, glyphTop + Math.ceil(actualBoundingBoxDescent));
    const width = glyphWidth + 2 * this.buffer;
    const height = glyphHeight + 2 * this.buffer;
    const len4 = Math.max(width * height, 0);
    const data = new Uint8ClampedArray(len4);
    const glyph = { data, width, height, glyphWidth, glyphHeight, glyphTop, glyphLeft, glyphAdvance };
    if (glyphWidth === 0 || glyphHeight === 0) return glyph;
    const { ctx, buffer, gridInner, gridOuter } = this;
    if (this.lang) ctx.lang = this.lang;
    ctx.clearRect(buffer, buffer, glyphWidth, glyphHeight);
    ctx.fillText(char, buffer, buffer + glyphTop);
    const imgData = ctx.getImageData(buffer, buffer, glyphWidth, glyphHeight);
    gridOuter.fill(INF, 0, len4);
    gridInner.fill(0, 0, len4);
    for (let y = 0; y < glyphHeight; y++) {
      for (let x = 0; x < glyphWidth; x++) {
        const a2 = imgData.data[4 * (y * glyphWidth + x) + 3] / 255;
        if (a2 === 0) continue;
        const j = (y + buffer) * width + x + buffer;
        if (a2 === 1) {
          gridOuter[j] = 0;
          gridInner[j] = INF;
        } else {
          const d2 = 0.5 - a2;
          gridOuter[j] = d2 > 0 ? d2 * d2 : 0;
          gridInner[j] = d2 < 0 ? d2 * d2 : 0;
        }
      }
    }
    edt(gridOuter, 0, 0, width, height, width, this.f, this.v, this.z);
    edt(gridInner, buffer, buffer, glyphWidth, glyphHeight, width, this.f, this.v, this.z);
    for (let i = 0; i < len4; i++) {
      const d2 = Math.sqrt(gridOuter[i]) - Math.sqrt(gridInner[i]);
      data[i] = Math.round(255 - 255 * (d2 / this.radius + this.cutoff));
    }
    return glyph;
  }
};
function edt(data, x0, y0, width, height, gridSize, f, v2, z) {
  for (let x = x0; x < x0 + width; x++) edt1d(data, y0 * gridSize + x, gridSize, height, f, v2, z);
  for (let y = y0; y < y0 + height; y++) edt1d(data, y * gridSize + x0, 1, width, f, v2, z);
}
function edt1d(grid, offset, stride, length5, f, v2, z) {
  v2[0] = 0;
  z[0] = -INF;
  z[1] = INF;
  f[0] = grid[offset];
  for (let q = 1, k = 0, s = 0; q < length5; q++) {
    f[q] = grid[offset + q * stride];
    const q2 = q * q;
    do {
      const r = v2[k];
      s = (f[q] - f[r] + q2 - r * r) / (q - r) / 2;
    } while (s <= z[k] && --k > -1);
    k++;
    v2[k] = q;
    z[k] = s;
    z[k + 1] = INF;
  }
  for (let q = 0, k = 0; q < length5; q++) {
    while (z[k + 1] < q) k++;
    const r = v2[k];
    const qr = q - r;
    grid[offset + q * stride] = f[r] + qr * qr;
  }
}

// node_modules/@deck.gl/layers/dist/text-layer/utils.js
var MISSING_CHAR_WIDTH = 32;
var SINGLE_LINE = [];
function nextPowOfTwo2(number) {
  return Math.pow(2, Math.ceil(Math.log2(number)));
}
function buildMapping2({ characterSet, getFontWidth, fontHeight, buffer, maxCanvasWidth, mapping = {}, xOffset = 0, yOffset = 0 }) {
  let row = 0;
  let x = xOffset;
  const rowHeight = fontHeight + buffer * 2;
  for (const char of characterSet) {
    if (!mapping[char]) {
      const width = getFontWidth(char);
      if (x + width + buffer * 2 > maxCanvasWidth) {
        x = 0;
        row++;
      }
      mapping[char] = {
        x: x + buffer,
        y: yOffset + row * rowHeight + buffer,
        width,
        height: rowHeight,
        layoutWidth: width,
        layoutHeight: fontHeight
      };
      x += width + buffer * 2;
    }
  }
  return {
    mapping,
    xOffset: x,
    yOffset: yOffset + row * rowHeight,
    canvasHeight: nextPowOfTwo2(yOffset + (row + 1) * rowHeight)
  };
}
function getTextWidth(text, startIndex, endIndex, mapping) {
  var _a;
  let width = 0;
  for (let i = startIndex; i < endIndex; i++) {
    const character = text[i];
    width += ((_a = mapping[character]) == null ? void 0 : _a.layoutWidth) || 0;
  }
  return width;
}
function breakAll(text, startIndex, endIndex, maxWidth, iconMapping, target) {
  let rowStartCharIndex = startIndex;
  let rowOffsetLeft = 0;
  for (let i = startIndex; i < endIndex; i++) {
    const textWidth = getTextWidth(text, i, i + 1, iconMapping);
    if (rowOffsetLeft + textWidth > maxWidth) {
      if (rowStartCharIndex < i) {
        target.push(i);
      }
      rowStartCharIndex = i;
      rowOffsetLeft = 0;
    }
    rowOffsetLeft += textWidth;
  }
  return rowOffsetLeft;
}
function breakWord(text, startIndex, endIndex, maxWidth, iconMapping, target) {
  let rowStartCharIndex = startIndex;
  let groupStartCharIndex = startIndex;
  let groupEndCharIndex = startIndex;
  let rowOffsetLeft = 0;
  for (let i = startIndex; i < endIndex; i++) {
    if (text[i] === " ") {
      groupEndCharIndex = i + 1;
    } else if (text[i + 1] === " " || i + 1 === endIndex) {
      groupEndCharIndex = i + 1;
    }
    if (groupEndCharIndex > groupStartCharIndex) {
      let groupWidth = getTextWidth(text, groupStartCharIndex, groupEndCharIndex, iconMapping);
      if (rowOffsetLeft + groupWidth > maxWidth) {
        if (rowStartCharIndex < groupStartCharIndex) {
          target.push(groupStartCharIndex);
          rowStartCharIndex = groupStartCharIndex;
          rowOffsetLeft = 0;
        }
        if (groupWidth > maxWidth) {
          groupWidth = breakAll(text, groupStartCharIndex, groupEndCharIndex, maxWidth, iconMapping, target);
          rowStartCharIndex = target[target.length - 1];
        }
      }
      groupStartCharIndex = groupEndCharIndex;
      rowOffsetLeft += groupWidth;
    }
  }
  return rowOffsetLeft;
}
function autoWrapping(text, wordBreak, maxWidth, iconMapping, startIndex = 0, endIndex) {
  if (endIndex === void 0) {
    endIndex = text.length;
  }
  const result = [];
  if (wordBreak === "break-all") {
    breakAll(text, startIndex, endIndex, maxWidth, iconMapping, result);
  } else {
    breakWord(text, startIndex, endIndex, maxWidth, iconMapping, result);
  }
  return result;
}
function transformRow(line, startIndex, endIndex, iconMapping, leftOffsets, rowSize) {
  let x = 0;
  let rowHeight = 0;
  for (let i = startIndex; i < endIndex; i++) {
    const character = line[i];
    const frame = iconMapping[character];
    if (frame) {
      if (!rowHeight) {
        rowHeight = frame.layoutHeight;
      }
      leftOffsets[i] = x + frame.layoutWidth / 2;
      x += frame.layoutWidth;
    } else {
      log_default.warn(`Missing character: ${character} (${character.codePointAt(0)})`)();
      leftOffsets[i] = x;
      x += MISSING_CHAR_WIDTH;
    }
  }
  rowSize[0] = x;
  rowSize[1] = rowHeight;
}
function transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping) {
  var _a;
  const characters = Array.from(paragraph);
  const numCharacters = characters.length;
  const x = new Array(numCharacters);
  const y = new Array(numCharacters);
  const rowWidth = new Array(numCharacters);
  const autoWrappingEnabled = (wordBreak === "break-word" || wordBreak === "break-all") && isFinite(maxWidth) && maxWidth > 0;
  const size = [0, 0];
  const rowSize = [0, 0];
  let rowOffsetTop = 0;
  let lineStartIndex = 0;
  let lineEndIndex = 0;
  for (let i = 0; i <= numCharacters; i++) {
    const char = characters[i];
    if (char === "\n" || i === numCharacters) {
      lineEndIndex = i;
    }
    if (lineEndIndex > lineStartIndex) {
      const rows = autoWrappingEnabled ? autoWrapping(characters, wordBreak, maxWidth, iconMapping, lineStartIndex, lineEndIndex) : SINGLE_LINE;
      for (let rowIndex = 0; rowIndex <= rows.length; rowIndex++) {
        const rowStart = rowIndex === 0 ? lineStartIndex : rows[rowIndex - 1];
        const rowEnd = rowIndex < rows.length ? rows[rowIndex] : lineEndIndex;
        transformRow(characters, rowStart, rowEnd, iconMapping, x, rowSize);
        for (let j = rowStart; j < rowEnd; j++) {
          const char2 = characters[j];
          const layoutOffsetY = ((_a = iconMapping[char2]) == null ? void 0 : _a.layoutOffsetY) || 0;
          y[j] = rowOffsetTop + rowSize[1] / 2 + layoutOffsetY;
          rowWidth[j] = rowSize[0];
        }
        rowOffsetTop = rowOffsetTop + rowSize[1] * lineHeight;
        size[0] = Math.max(size[0], rowSize[0]);
      }
      lineStartIndex = lineEndIndex;
    }
    if (char === "\n") {
      x[lineStartIndex] = 0;
      y[lineStartIndex] = 0;
      rowWidth[lineStartIndex] = 0;
      lineStartIndex++;
    }
  }
  size[1] = rowOffsetTop;
  return { x, y, rowWidth, size };
}
function getTextFromBuffer({ value, length: length5, stride, offset, startIndices, characterSet }) {
  const bytesPerElement = value.BYTES_PER_ELEMENT;
  const elementStride = stride ? stride / bytesPerElement : 1;
  const elementOffset = offset ? offset / bytesPerElement : 0;
  const characterCount = startIndices[length5] || Math.ceil((value.length - elementOffset) / elementStride);
  const autoCharacterSet = characterSet && /* @__PURE__ */ new Set();
  const texts = new Array(length5);
  let codes = value;
  if (elementStride > 1 || elementOffset > 0) {
    const ArrayType = value.constructor;
    codes = new ArrayType(characterCount);
    for (let i = 0; i < characterCount; i++) {
      codes[i] = value[i * elementStride + elementOffset];
    }
  }
  for (let index = 0; index < length5; index++) {
    const startIndex = startIndices[index];
    const endIndex = startIndices[index + 1] || characterCount;
    const codesAtIndex = codes.subarray(startIndex, endIndex);
    texts[index] = String.fromCodePoint.apply(null, codesAtIndex);
    if (autoCharacterSet) {
      codesAtIndex.forEach(autoCharacterSet.add, autoCharacterSet);
    }
  }
  if (autoCharacterSet) {
    for (const charCode of autoCharacterSet) {
      characterSet.add(String.fromCodePoint(charCode));
    }
  }
  return { texts, characterCount };
}

// node_modules/@deck.gl/layers/dist/text-layer/lru-cache.js
var LRUCache = class {
  constructor(limit = 5) {
    this._cache = {};
    this._order = [];
    this.limit = limit;
  }
  get(key) {
    const value = this._cache[key];
    if (value) {
      this._deleteOrder(key);
      this._appendOrder(key);
    }
    return value;
  }
  set(key, value) {
    if (!this._cache[key]) {
      if (Object.keys(this._cache).length === this.limit) {
        this.delete(this._order[0]);
      }
      this._cache[key] = value;
      this._appendOrder(key);
    } else {
      this.delete(key);
      this._cache[key] = value;
      this._appendOrder(key);
    }
  }
  delete(key) {
    const value = this._cache[key];
    if (value) {
      delete this._cache[key];
      this._deleteOrder(key);
    }
  }
  _deleteOrder(key) {
    const index = this._order.indexOf(key);
    if (index >= 0) {
      this._order.splice(index, 1);
    }
  }
  _appendOrder(key) {
    this._order.push(key);
  }
};

// node_modules/@deck.gl/layers/dist/text-layer/font-atlas-manager.js
function getDefaultCharacterSet() {
  const charSet = [];
  for (let i = 32; i < 128; i++) {
    charSet.push(String.fromCharCode(i));
  }
  return charSet;
}
var DEFAULT_FONT_SETTINGS = {
  fontFamily: "Monaco, monospace",
  fontWeight: "normal",
  characterSet: getDefaultCharacterSet(),
  fontSize: 64,
  buffer: 4,
  sdf: false,
  cutoff: 0.25,
  radius: 12,
  smoothing: 0.1
};
var MAX_CANVAS_WIDTH = 1024;
var BASELINE_SCALE = 0.9;
var HEIGHT_SCALE = 1.2;
var CACHE_LIMIT = 3;
var cache = new LRUCache(CACHE_LIMIT);
function getNewChars(cacheKey, characterSet) {
  let newCharSet;
  if (typeof characterSet === "string") {
    newCharSet = new Set(Array.from(characterSet));
  } else {
    newCharSet = new Set(characterSet);
  }
  const cachedFontAtlas = cache.get(cacheKey);
  if (!cachedFontAtlas) {
    return newCharSet;
  }
  for (const char in cachedFontAtlas.mapping) {
    if (newCharSet.has(char)) {
      newCharSet.delete(char);
    }
  }
  return newCharSet;
}
function populateAlphaChannel(alphaChannel, imageData) {
  for (let i = 0; i < alphaChannel.length; i++) {
    imageData.data[4 * i + 3] = alphaChannel[i];
  }
}
function setTextStyle(ctx, fontFamily, fontSize, fontWeight) {
  ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;
  ctx.fillStyle = "#000";
  ctx.textBaseline = "alphabetic";
  ctx.textAlign = "left";
}
function setFontAtlasCacheLimit(limit) {
  log_default.assert(Number.isFinite(limit) && limit >= CACHE_LIMIT, "Invalid cache limit");
  cache = new LRUCache(limit);
}
var FontAtlasManager = class {
  constructor() {
    this.props = { ...DEFAULT_FONT_SETTINGS };
  }
  get atlas() {
    return this._atlas;
  }
  // TODO - cut during v9 porting as types reveal this is not correct
  // get texture(): Texture | undefined {
  //   return this._atlas;
  // }
  get mapping() {
    return this._atlas && this._atlas.mapping;
  }
  get scale() {
    const { fontSize, buffer } = this.props;
    return (fontSize * HEIGHT_SCALE + buffer * 2) / fontSize;
  }
  setProps(props = {}) {
    Object.assign(this.props, props);
    this._key = this._getKey();
    const charSet = getNewChars(this._key, this.props.characterSet);
    const cachedFontAtlas = cache.get(this._key);
    if (cachedFontAtlas && charSet.size === 0) {
      if (this._atlas !== cachedFontAtlas) {
        this._atlas = cachedFontAtlas;
      }
      return;
    }
    const fontAtlas = this._generateFontAtlas(charSet, cachedFontAtlas);
    this._atlas = fontAtlas;
    cache.set(this._key, fontAtlas);
  }
  // eslint-disable-next-line max-statements
  _generateFontAtlas(characterSet, cachedFontAtlas) {
    const { fontFamily, fontWeight, fontSize, buffer, sdf, radius, cutoff } = this.props;
    let canvas = cachedFontAtlas && cachedFontAtlas.data;
    if (!canvas) {
      canvas = document.createElement("canvas");
      canvas.width = MAX_CANVAS_WIDTH;
    }
    const ctx = canvas.getContext("2d", { willReadFrequently: true });
    setTextStyle(ctx, fontFamily, fontSize, fontWeight);
    const { mapping, canvasHeight, xOffset, yOffset } = buildMapping2({
      getFontWidth: (char) => ctx.measureText(char).width,
      fontHeight: fontSize * HEIGHT_SCALE,
      buffer,
      characterSet,
      maxCanvasWidth: MAX_CANVAS_WIDTH,
      ...cachedFontAtlas && {
        mapping: cachedFontAtlas.mapping,
        xOffset: cachedFontAtlas.xOffset,
        yOffset: cachedFontAtlas.yOffset
      }
    });
    if (canvas.height !== canvasHeight) {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      canvas.height = canvasHeight;
      ctx.putImageData(imageData, 0, 0);
    }
    setTextStyle(ctx, fontFamily, fontSize, fontWeight);
    if (sdf) {
      const tinySDF = new TinySDF({
        fontSize,
        buffer,
        radius,
        cutoff,
        fontFamily,
        fontWeight: `${fontWeight}`
      });
      for (const char of characterSet) {
        const { data, width, height, glyphTop } = tinySDF.draw(char);
        mapping[char].width = width;
        mapping[char].layoutOffsetY = fontSize * BASELINE_SCALE - glyphTop;
        const imageData = ctx.createImageData(width, height);
        populateAlphaChannel(data, imageData);
        ctx.putImageData(imageData, mapping[char].x, mapping[char].y);
      }
    } else {
      for (const char of characterSet) {
        ctx.fillText(char, mapping[char].x, mapping[char].y + buffer + fontSize * BASELINE_SCALE);
      }
    }
    return {
      xOffset,
      yOffset,
      mapping,
      data: canvas,
      width: canvas.width,
      height: canvas.height
    };
  }
  _getKey() {
    const { fontFamily, fontWeight, fontSize, buffer, sdf, radius, cutoff } = this.props;
    if (sdf) {
      return `${fontFamily} ${fontWeight} ${fontSize} ${buffer} ${radius} ${cutoff}`;
    }
    return `${fontFamily} ${fontWeight} ${fontSize} ${buffer}`;
  }
};

// node_modules/@deck.gl/layers/dist/text-layer/text-background-layer/text-background-layer-uniforms.js
var uniformBlock8 = `uniform textBackgroundUniforms {
  bool billboard;
  float sizeScale;
  float sizeMinPixels;
  float sizeMaxPixels;
  vec4 borderRadius;
  vec4 padding;
  highp int sizeUnits;
  bool stroked;
} textBackground;
`;
var textBackgroundUniforms = {
  name: "textBackground",
  vs: uniformBlock8,
  fs: uniformBlock8,
  uniformTypes: {
    billboard: "f32",
    sizeScale: "f32",
    sizeMinPixels: "f32",
    sizeMaxPixels: "f32",
    borderRadius: "vec4<f32>",
    padding: "vec4<f32>",
    sizeUnits: "i32",
    stroked: "f32"
  }
};

// node_modules/@deck.gl/layers/dist/text-layer/text-background-layer/text-background-layer-vertex.glsl.js
var text_background_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME text-background-layer-vertex-shader
in vec2 positions;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceRects;
in float instanceSizes;
in float instanceAngles;
in vec2 instancePixelOffsets;
in float instanceLineWidths;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in vec3 instancePickingColors;
out vec4 vFillColor;
out vec4 vLineColor;
out float vLineWidth;
out vec2 uv;
out vec2 dimensions;
vec2 rotate_by_angle(vec2 vertex, float angle) {
float angle_radian = radians(angle);
float cos_angle = cos(angle_radian);
float sin_angle = sin(angle_radian);
mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);
return rotationMatrix * vertex;
}
void main(void) {
geometry.worldPosition = instancePositions;
geometry.uv = positions;
geometry.pickingColor = instancePickingColors;
uv = positions;
vLineWidth = instanceLineWidths;
float sizePixels = clamp(
project_size_to_pixel(instanceSizes * textBackground.sizeScale, textBackground.sizeUnits),
textBackground.sizeMinPixels, textBackground.sizeMaxPixels
);
dimensions = instanceRects.zw * sizePixels + textBackground.padding.xy + textBackground.padding.zw;
vec2 pixelOffset = (positions * instanceRects.zw + instanceRects.xy) * sizePixels + mix(-textBackground.padding.xy, textBackground.padding.zw, positions);
pixelOffset = rotate_by_angle(pixelOffset, instanceAngles);
pixelOffset += instancePixelOffsets;
pixelOffset.y *= -1.0;
if (textBackground.billboard)  {
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
vec3 offset = vec3(pixelOffset, 0.0);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
} else {
vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);
DECKGL_FILTER_SIZE(offset_common, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vFillColor, geometry);
vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vLineColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/text-layer/text-background-layer/text-background-layer-fragment.glsl.js
var text_background_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME text-background-layer-fragment-shader
precision highp float;
in vec4 vFillColor;
in vec4 vLineColor;
in float vLineWidth;
in vec2 uv;
in vec2 dimensions;
out vec4 fragColor;
float round_rect(vec2 p, vec2 size, vec4 radii) {
vec2 pixelPositionCB = (p - 0.5) * size;
vec2 sizeCB = size * 0.5;
float maxBorderRadius = min(size.x, size.y) * 0.5;
vec4 borderRadius = vec4(min(radii, maxBorderRadius));
borderRadius.xy =
(pixelPositionCB.x > 0.0) ? borderRadius.xy : borderRadius.zw;
borderRadius.x = (pixelPositionCB.y > 0.0) ? borderRadius.x : borderRadius.y;
vec2 q = abs(pixelPositionCB) - sizeCB + borderRadius.x;
return -(min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - borderRadius.x);
}
float rect(vec2 p, vec2 size) {
vec2 pixelPosition = p * size;
return min(min(pixelPosition.x, size.x - pixelPosition.x),
min(pixelPosition.y, size.y - pixelPosition.y));
}
vec4 get_stroked_fragColor(float dist) {
float isBorder = smoothedge(dist, vLineWidth);
return mix(vFillColor, vLineColor, isBorder);
}
void main(void) {
geometry.uv = uv;
if (textBackground.borderRadius != vec4(0.0)) {
float distToEdge = round_rect(uv, dimensions, textBackground.borderRadius);
if (textBackground.stroked) {
fragColor = get_stroked_fragColor(distToEdge);
} else {
fragColor = vFillColor;
}
float shapeAlpha = smoothedge(-distToEdge, 0.0);
fragColor.a *= shapeAlpha;
} else {
if (textBackground.stroked) {
float distToEdge = rect(uv, dimensions);
fragColor = get_stroked_fragColor(distToEdge);
} else {
fragColor = vFillColor;
}
}
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/text-layer/text-background-layer/text-background-layer.js
var defaultProps13 = {
  billboard: true,
  sizeScale: 1,
  sizeUnits: "pixels",
  sizeMinPixels: 0,
  sizeMaxPixels: Number.MAX_SAFE_INTEGER,
  borderRadius: { type: "object", value: 0 },
  padding: { type: "array", value: [0, 0, 0, 0] },
  getPosition: { type: "accessor", value: (x) => x.position },
  getSize: { type: "accessor", value: 1 },
  getAngle: { type: "accessor", value: 0 },
  getPixelOffset: { type: "accessor", value: [0, 0] },
  getBoundingRect: { type: "accessor", value: [0, 0, 0, 0] },
  getFillColor: { type: "accessor", value: [0, 0, 0, 255] },
  getLineColor: { type: "accessor", value: [0, 0, 0, 255] },
  getLineWidth: { type: "accessor", value: 1 }
};
var TextBackgroundLayer = class extends layer_default {
  getShaders() {
    return super.getShaders({ vs: text_background_layer_vertex_glsl_default, fs: text_background_layer_fragment_glsl_default, modules: [project32_default, picking_default, textBackgroundUniforms] });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getPosition"
      },
      instanceSizes: {
        size: 1,
        transition: true,
        accessor: "getSize",
        defaultValue: 1
      },
      instanceAngles: {
        size: 1,
        transition: true,
        accessor: "getAngle"
      },
      instanceRects: {
        size: 4,
        accessor: "getBoundingRect"
      },
      instancePixelOffsets: {
        size: 2,
        transition: true,
        accessor: "getPixelOffset"
      },
      instanceFillColors: {
        size: 4,
        transition: true,
        type: "unorm8",
        accessor: "getFillColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineColors: {
        size: 4,
        transition: true,
        type: "unorm8",
        accessor: "getLineColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineWidths: {
        size: 1,
        transition: true,
        accessor: "getLineWidth",
        defaultValue: 1
      }
    });
  }
  updateState(params) {
    var _a;
    super.updateState(params);
    const { changeFlags } = params;
    if (changeFlags.extensionsChanged) {
      (_a = this.state.model) == null ? void 0 : _a.destroy();
      this.state.model = this._getModel();
      this.getAttributeManager().invalidateAll();
    }
  }
  draw({ uniforms }) {
    const { billboard, sizeScale, sizeUnits, sizeMinPixels, sizeMaxPixels, getLineWidth } = this.props;
    let { padding, borderRadius } = this.props;
    if (padding.length < 4) {
      padding = [padding[0], padding[1], padding[0], padding[1]];
    }
    if (!Array.isArray(borderRadius)) {
      borderRadius = [borderRadius, borderRadius, borderRadius, borderRadius];
    }
    const model = this.state.model;
    const textBackgroundProps = {
      billboard,
      stroked: Boolean(getLineWidth),
      borderRadius,
      padding,
      sizeUnits: UNIT[sizeUnits],
      sizeScale,
      sizeMinPixels,
      sizeMaxPixels
    };
    model.shaderInputs.setProps({ textBackground: textBackgroundProps });
    model.draw(this.context.renderPass);
  }
  _getModel() {
    const positions = [0, 0, 1, 0, 0, 1, 1, 1];
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new Geometry({
        topology: "triangle-strip",
        vertexCount: 4,
        attributes: {
          positions: { size: 2, value: new Float32Array(positions) }
        }
      }),
      isInstanced: true
    });
  }
};
TextBackgroundLayer.defaultProps = defaultProps13;
TextBackgroundLayer.layerName = "TextBackgroundLayer";
var text_background_layer_default = TextBackgroundLayer;

// node_modules/@deck.gl/layers/dist/text-layer/text-layer.js
var TEXT_ANCHOR = {
  start: 1,
  middle: 0,
  end: -1
};
var ALIGNMENT_BASELINE = {
  top: 1,
  center: 0,
  bottom: -1
};
var DEFAULT_COLOR9 = [0, 0, 0, 255];
var DEFAULT_LINE_HEIGHT = 1;
var defaultProps14 = {
  billboard: true,
  sizeScale: 1,
  sizeUnits: "pixels",
  sizeMinPixels: 0,
  sizeMaxPixels: Number.MAX_SAFE_INTEGER,
  background: false,
  getBackgroundColor: { type: "accessor", value: [255, 255, 255, 255] },
  getBorderColor: { type: "accessor", value: DEFAULT_COLOR9 },
  getBorderWidth: { type: "accessor", value: 0 },
  backgroundBorderRadius: { type: "object", value: 0 },
  backgroundPadding: { type: "array", value: [0, 0, 0, 0] },
  characterSet: { type: "object", value: DEFAULT_FONT_SETTINGS.characterSet },
  fontFamily: DEFAULT_FONT_SETTINGS.fontFamily,
  fontWeight: DEFAULT_FONT_SETTINGS.fontWeight,
  lineHeight: DEFAULT_LINE_HEIGHT,
  outlineWidth: { type: "number", value: 0, min: 0 },
  outlineColor: { type: "color", value: DEFAULT_COLOR9 },
  fontSettings: { type: "object", value: {}, compare: 1 },
  // auto wrapping options
  wordBreak: "break-word",
  maxWidth: { type: "number", value: -1 },
  getText: { type: "accessor", value: (x) => x.text },
  getPosition: { type: "accessor", value: (x) => x.position },
  getColor: { type: "accessor", value: DEFAULT_COLOR9 },
  getSize: { type: "accessor", value: 32 },
  getAngle: { type: "accessor", value: 0 },
  getTextAnchor: { type: "accessor", value: "middle" },
  getAlignmentBaseline: { type: "accessor", value: "center" },
  getPixelOffset: { type: "accessor", value: [0, 0] },
  // deprecated
  backgroundColor: { deprecatedFor: ["background", "getBackgroundColor"] }
};
var TextLayer = class extends composite_layer_default {
  constructor() {
    super(...arguments);
    this.getBoundingRect = (object, objectInfo) => {
      let { size: [width, height] } = this.transformParagraph(object, objectInfo);
      const { fontSize } = this.state.fontAtlasManager.props;
      width /= fontSize;
      height /= fontSize;
      const { getTextAnchor, getAlignmentBaseline } = this.props;
      const anchorX = TEXT_ANCHOR[typeof getTextAnchor === "function" ? getTextAnchor(object, objectInfo) : getTextAnchor];
      const anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === "function" ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];
      return [(anchorX - 1) * width / 2, (anchorY - 1) * height / 2, width, height];
    };
    this.getIconOffsets = (object, objectInfo) => {
      const { getTextAnchor, getAlignmentBaseline } = this.props;
      const { x, y, rowWidth, size: [width, height] } = this.transformParagraph(object, objectInfo);
      const anchorX = TEXT_ANCHOR[typeof getTextAnchor === "function" ? getTextAnchor(object, objectInfo) : getTextAnchor];
      const anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === "function" ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];
      const numCharacters = x.length;
      const offsets = new Array(numCharacters * 2);
      let index = 0;
      for (let i = 0; i < numCharacters; i++) {
        const rowOffset = (1 - anchorX) * (width - rowWidth[i]) / 2;
        offsets[index++] = (anchorX - 1) * width / 2 + rowOffset + x[i];
        offsets[index++] = (anchorY - 1) * height / 2 + y[i];
      }
      return offsets;
    };
  }
  initializeState() {
    this.state = {
      styleVersion: 0,
      fontAtlasManager: new FontAtlasManager()
    };
    if (this.props.maxWidth > 0) {
      log_default.once(1, "v8.9 breaking change: TextLayer maxWidth is now relative to text size")();
    }
  }
  // eslint-disable-next-line complexity
  updateState(params) {
    const { props, oldProps, changeFlags } = params;
    const textChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getText);
    if (textChanged) {
      this._updateText();
    }
    const fontChanged = this._updateFontAtlas();
    const styleChanged = fontChanged || props.lineHeight !== oldProps.lineHeight || props.wordBreak !== oldProps.wordBreak || props.maxWidth !== oldProps.maxWidth;
    if (styleChanged) {
      this.setState({
        styleVersion: this.state.styleVersion + 1
      });
    }
  }
  getPickingInfo({ info }) {
    info.object = info.index >= 0 ? this.props.data[info.index] : null;
    return info;
  }
  /** Returns true if font has changed */
  _updateFontAtlas() {
    const { fontSettings, fontFamily, fontWeight } = this.props;
    const { fontAtlasManager, characterSet } = this.state;
    const fontProps = {
      ...fontSettings,
      characterSet,
      fontFamily,
      fontWeight
    };
    if (!fontAtlasManager.mapping) {
      fontAtlasManager.setProps(fontProps);
      return true;
    }
    for (const key in fontProps) {
      if (fontProps[key] !== fontAtlasManager.props[key]) {
        fontAtlasManager.setProps(fontProps);
        return true;
      }
    }
    return false;
  }
  // Text strings are variable width objects
  // Count characters and start offsets
  _updateText() {
    var _a;
    const { data, characterSet } = this.props;
    const textBuffer = (_a = data.attributes) == null ? void 0 : _a.getText;
    let { getText } = this.props;
    let startIndices = data.startIndices;
    let numInstances;
    const autoCharacterSet = characterSet === "auto" && /* @__PURE__ */ new Set();
    if (textBuffer && startIndices) {
      const { texts, characterCount } = getTextFromBuffer({
        ...ArrayBuffer.isView(textBuffer) ? { value: textBuffer } : textBuffer,
        // @ts-ignore if data.attribute is defined then length is expected
        length: data.length,
        startIndices,
        characterSet: autoCharacterSet
      });
      numInstances = characterCount;
      getText = (_, { index }) => texts[index];
    } else {
      const { iterable, objectInfo } = createIterable(data);
      startIndices = [0];
      numInstances = 0;
      for (const object of iterable) {
        objectInfo.index++;
        const text = Array.from(getText(object, objectInfo) || "");
        if (autoCharacterSet) {
          text.forEach(autoCharacterSet.add, autoCharacterSet);
        }
        numInstances += text.length;
        startIndices.push(numInstances);
      }
    }
    this.setState({
      getText,
      startIndices,
      numInstances,
      characterSet: autoCharacterSet || characterSet
    });
  }
  /** There are two size systems in this layer:
  
      + Pixel size: user-specified text size, via getSize, sizeScale, sizeUnits etc.
        The layer roughly matches the output of the layer to CSS pixels, e.g. getSize: 12, sizeScale: 2
        in layer props is roughly equivalent to font-size: 24px in CSS.
      + Texture size: internally, character positions in a text blob are calculated using the sizes of iconMapping,
        which depends on how large each character is drawn into the font atlas. This is controlled by
        fontSettings.fontSize (default 64) and most users do not set it manually.
        These numbers are intended to be used in the vertex shader and never to be exposed to the end user.
  
      All surfaces exposed to the user should either use the pixel size or a multiplier relative to the pixel size. */
  /** Calculate the size and position of each character in a text string.
   * Values are in texture size */
  transformParagraph(object, objectInfo) {
    const { fontAtlasManager } = this.state;
    const iconMapping = fontAtlasManager.mapping;
    const getText = this.state.getText;
    const { wordBreak, lineHeight, maxWidth } = this.props;
    const paragraph = getText(object, objectInfo) || "";
    return transformParagraph(paragraph, lineHeight, wordBreak, maxWidth * fontAtlasManager.props.fontSize, iconMapping);
  }
  renderLayers() {
    const { startIndices, numInstances, getText, fontAtlasManager: { scale: scale7, atlas, mapping }, styleVersion } = this.state;
    const { data, _dataDiff, getPosition, getColor, getSize, getAngle: getAngle2, getPixelOffset, getBackgroundColor, getBorderColor, getBorderWidth, backgroundBorderRadius, backgroundPadding, background, billboard, fontSettings, outlineWidth, outlineColor, sizeScale, sizeUnits, sizeMinPixels, sizeMaxPixels, transitions, updateTriggers } = this.props;
    const CharactersLayerClass = this.getSubLayerClass("characters", multi_icon_layer_default);
    const BackgroundLayerClass = this.getSubLayerClass("background", text_background_layer_default);
    return [
      background && new BackgroundLayerClass({
        // background props
        getFillColor: getBackgroundColor,
        getLineColor: getBorderColor,
        getLineWidth: getBorderWidth,
        borderRadius: backgroundBorderRadius,
        padding: backgroundPadding,
        // props shared with characters layer
        getPosition,
        getSize,
        getAngle: getAngle2,
        getPixelOffset,
        billboard,
        sizeScale,
        sizeUnits,
        sizeMinPixels,
        sizeMaxPixels,
        transitions: transitions && {
          getPosition: transitions.getPosition,
          getAngle: transitions.getAngle,
          getSize: transitions.getSize,
          getFillColor: transitions.getBackgroundColor,
          getLineColor: transitions.getBorderColor,
          getLineWidth: transitions.getBorderWidth,
          getPixelOffset: transitions.getPixelOffset
        }
      }, this.getSubLayerProps({
        id: "background",
        updateTriggers: {
          getPosition: updateTriggers.getPosition,
          getAngle: updateTriggers.getAngle,
          getSize: updateTriggers.getSize,
          getFillColor: updateTriggers.getBackgroundColor,
          getLineColor: updateTriggers.getBorderColor,
          getLineWidth: updateTriggers.getBorderWidth,
          getPixelOffset: updateTriggers.getPixelOffset,
          getBoundingRect: {
            getText: updateTriggers.getText,
            getTextAnchor: updateTriggers.getTextAnchor,
            getAlignmentBaseline: updateTriggers.getAlignmentBaseline,
            styleVersion
          }
        }
      }), {
        data: (
          // @ts-ignore (2339) attribute is not defined on all data types
          data.attributes && data.attributes.background ? (
            // @ts-ignore (2339) attribute is not defined on all data types
            { length: data.length, attributes: data.attributes.background }
          ) : data
        ),
        _dataDiff,
        // Maintain the same background behavior as <=8.3. Remove in v9?
        autoHighlight: false,
        getBoundingRect: this.getBoundingRect
      }),
      new CharactersLayerClass({
        sdf: fontSettings.sdf,
        smoothing: Number.isFinite(fontSettings.smoothing) ? fontSettings.smoothing : DEFAULT_FONT_SETTINGS.smoothing,
        outlineWidth: outlineWidth / (fontSettings.radius || DEFAULT_FONT_SETTINGS.radius),
        outlineColor,
        iconAtlas: atlas,
        iconMapping: mapping,
        getPosition,
        getColor,
        getSize,
        getAngle: getAngle2,
        getPixelOffset,
        billboard,
        sizeScale: sizeScale * scale7,
        sizeUnits,
        sizeMinPixels: sizeMinPixels * scale7,
        sizeMaxPixels: sizeMaxPixels * scale7,
        transitions: transitions && {
          getPosition: transitions.getPosition,
          getAngle: transitions.getAngle,
          getColor: transitions.getColor,
          getSize: transitions.getSize,
          getPixelOffset: transitions.getPixelOffset
        }
      }, this.getSubLayerProps({
        id: "characters",
        updateTriggers: {
          all: updateTriggers.getText,
          getPosition: updateTriggers.getPosition,
          getAngle: updateTriggers.getAngle,
          getColor: updateTriggers.getColor,
          getSize: updateTriggers.getSize,
          getPixelOffset: updateTriggers.getPixelOffset,
          getIconOffsets: {
            getTextAnchor: updateTriggers.getTextAnchor,
            getAlignmentBaseline: updateTriggers.getAlignmentBaseline,
            styleVersion
          }
        }
      }), {
        data,
        _dataDiff,
        startIndices,
        numInstances,
        getIconOffsets: this.getIconOffsets,
        getIcon: getText
      })
    ];
  }
  static set fontAtlasCacheLimit(limit) {
    setFontAtlasCacheLimit(limit);
  }
};
TextLayer.defaultProps = defaultProps14;
TextLayer.layerName = "TextLayer";
var text_layer_default = TextLayer;

// node_modules/@deck.gl/layers/dist/geojson-layer/sub-layer-map.js
var POINT_LAYER = {
  circle: {
    type: scatterplot_layer_default,
    props: {
      filled: "filled",
      stroked: "stroked",
      lineWidthMaxPixels: "lineWidthMaxPixels",
      lineWidthMinPixels: "lineWidthMinPixels",
      lineWidthScale: "lineWidthScale",
      lineWidthUnits: "lineWidthUnits",
      pointRadiusMaxPixels: "radiusMaxPixels",
      pointRadiusMinPixels: "radiusMinPixels",
      pointRadiusScale: "radiusScale",
      pointRadiusUnits: "radiusUnits",
      pointAntialiasing: "antialiasing",
      pointBillboard: "billboard",
      getFillColor: "getFillColor",
      getLineColor: "getLineColor",
      getLineWidth: "getLineWidth",
      getPointRadius: "getRadius"
    }
  },
  icon: {
    type: icon_layer_default,
    props: {
      iconAtlas: "iconAtlas",
      iconMapping: "iconMapping",
      iconSizeMaxPixels: "sizeMaxPixels",
      iconSizeMinPixels: "sizeMinPixels",
      iconSizeScale: "sizeScale",
      iconSizeUnits: "sizeUnits",
      iconAlphaCutoff: "alphaCutoff",
      iconBillboard: "billboard",
      getIcon: "getIcon",
      getIconAngle: "getAngle",
      getIconColor: "getColor",
      getIconPixelOffset: "getPixelOffset",
      getIconSize: "getSize"
    }
  },
  text: {
    type: text_layer_default,
    props: {
      textSizeMaxPixels: "sizeMaxPixels",
      textSizeMinPixels: "sizeMinPixels",
      textSizeScale: "sizeScale",
      textSizeUnits: "sizeUnits",
      textBackground: "background",
      textBackgroundPadding: "backgroundPadding",
      textFontFamily: "fontFamily",
      textFontWeight: "fontWeight",
      textLineHeight: "lineHeight",
      textMaxWidth: "maxWidth",
      textOutlineColor: "outlineColor",
      textOutlineWidth: "outlineWidth",
      textWordBreak: "wordBreak",
      textCharacterSet: "characterSet",
      textBillboard: "billboard",
      textFontSettings: "fontSettings",
      getText: "getText",
      getTextAngle: "getAngle",
      getTextColor: "getColor",
      getTextPixelOffset: "getPixelOffset",
      getTextSize: "getSize",
      getTextAnchor: "getTextAnchor",
      getTextAlignmentBaseline: "getAlignmentBaseline",
      getTextBackgroundColor: "getBackgroundColor",
      getTextBorderColor: "getBorderColor",
      getTextBorderWidth: "getBorderWidth"
    }
  }
};
var LINE_LAYER = {
  type: path_layer_default,
  props: {
    lineWidthUnits: "widthUnits",
    lineWidthScale: "widthScale",
    lineWidthMinPixels: "widthMinPixels",
    lineWidthMaxPixels: "widthMaxPixels",
    lineJointRounded: "jointRounded",
    lineCapRounded: "capRounded",
    lineMiterLimit: "miterLimit",
    lineBillboard: "billboard",
    getLineColor: "getColor",
    getLineWidth: "getWidth"
  }
};
var POLYGON_LAYER = {
  type: solid_polygon_layer_default,
  props: {
    extruded: "extruded",
    filled: "filled",
    wireframe: "wireframe",
    elevationScale: "elevationScale",
    material: "material",
    _full3d: "_full3d",
    getElevation: "getElevation",
    getFillColor: "getFillColor",
    getLineColor: "getLineColor"
  }
};
function getDefaultProps({ type, props }) {
  const result = {};
  for (const key in props) {
    result[key] = type.defaultProps[props[key]];
  }
  return result;
}
function forwardProps(layer, mapping) {
  const { transitions, updateTriggers } = layer.props;
  const result = {
    updateTriggers: {},
    transitions: transitions && {
      getPosition: transitions.geometry
    }
  };
  for (const sourceKey in mapping) {
    const targetKey = mapping[sourceKey];
    let value = layer.props[sourceKey];
    if (sourceKey.startsWith("get")) {
      value = layer.getSubLayerAccessor(value);
      result.updateTriggers[targetKey] = updateTriggers[sourceKey];
      if (transitions) {
        result.transitions[targetKey] = transitions[sourceKey];
      }
    }
    result[targetKey] = value;
  }
  return result;
}

// node_modules/@deck.gl/layers/dist/geojson-layer/geojson.js
function getGeojsonFeatures(geojson) {
  if (Array.isArray(geojson)) {
    return geojson;
  }
  log_default.assert(geojson.type, "GeoJSON does not have type");
  switch (geojson.type) {
    case "Feature":
      return [geojson];
    case "FeatureCollection":
      log_default.assert(Array.isArray(geojson.features), "GeoJSON does not have features array");
      return geojson.features;
    default:
      return [{ geometry: geojson }];
  }
}
function separateGeojsonFeatures(features2, wrapFeature, dataRange = {}) {
  const separated = {
    pointFeatures: [],
    lineFeatures: [],
    polygonFeatures: [],
    polygonOutlineFeatures: []
  };
  const { startRow = 0, endRow = features2.length } = dataRange;
  for (let featureIndex = startRow; featureIndex < endRow; featureIndex++) {
    const feature2 = features2[featureIndex];
    const { geometry } = feature2;
    if (!geometry) {
      continue;
    }
    if (geometry.type === "GeometryCollection") {
      log_default.assert(Array.isArray(geometry.geometries), "GeoJSON does not have geometries array");
      const { geometries } = geometry;
      for (let i = 0; i < geometries.length; i++) {
        const subGeometry = geometries[i];
        separateGeometry(subGeometry, separated, wrapFeature, feature2, featureIndex);
      }
    } else {
      separateGeometry(geometry, separated, wrapFeature, feature2, featureIndex);
    }
  }
  return separated;
}
function separateGeometry(geometry, separated, wrapFeature, sourceFeature, sourceFeatureIndex) {
  const { type, coordinates } = geometry;
  const { pointFeatures, lineFeatures, polygonFeatures, polygonOutlineFeatures } = separated;
  if (!validateGeometry(type, coordinates)) {
    log_default.warn(`${type} coordinates are malformed`)();
    return;
  }
  switch (type) {
    case "Point":
      pointFeatures.push(wrapFeature({
        geometry
      }, sourceFeature, sourceFeatureIndex));
      break;
    case "MultiPoint":
      coordinates.forEach((point2) => {
        pointFeatures.push(wrapFeature({
          geometry: { type: "Point", coordinates: point2 }
        }, sourceFeature, sourceFeatureIndex));
      });
      break;
    case "LineString":
      lineFeatures.push(wrapFeature({
        geometry
      }, sourceFeature, sourceFeatureIndex));
      break;
    case "MultiLineString":
      coordinates.forEach((path) => {
        lineFeatures.push(wrapFeature({
          geometry: { type: "LineString", coordinates: path }
        }, sourceFeature, sourceFeatureIndex));
      });
      break;
    case "Polygon":
      polygonFeatures.push(wrapFeature({
        geometry
      }, sourceFeature, sourceFeatureIndex));
      coordinates.forEach((path) => {
        polygonOutlineFeatures.push(wrapFeature({
          geometry: { type: "LineString", coordinates: path }
        }, sourceFeature, sourceFeatureIndex));
      });
      break;
    case "MultiPolygon":
      coordinates.forEach((polygon) => {
        polygonFeatures.push(wrapFeature({
          geometry: { type: "Polygon", coordinates: polygon }
        }, sourceFeature, sourceFeatureIndex));
        polygon.forEach((path) => {
          polygonOutlineFeatures.push(wrapFeature({
            geometry: { type: "LineString", coordinates: path }
          }, sourceFeature, sourceFeatureIndex));
        });
      });
      break;
    default:
  }
}
var COORDINATE_NEST_LEVEL = {
  Point: 1,
  MultiPoint: 2,
  LineString: 2,
  MultiLineString: 3,
  Polygon: 3,
  MultiPolygon: 4
};
function validateGeometry(type, coordinates) {
  let nestLevel = COORDINATE_NEST_LEVEL[type];
  log_default.assert(nestLevel, `Unknown GeoJSON type ${type}`);
  while (coordinates && --nestLevel > 0) {
    coordinates = coordinates[0];
  }
  return coordinates && Number.isFinite(coordinates[0]);
}

// node_modules/@deck.gl/layers/dist/geojson-layer/geojson-layer-props.js
function createEmptyLayerProps() {
  return {
    points: {},
    lines: {},
    polygons: {},
    polygonsOutline: {}
  };
}
function getCoordinates(f) {
  return f.geometry.coordinates;
}
function createLayerPropsFromFeatures(features2, featuresDiff) {
  const layerProps = createEmptyLayerProps();
  const { pointFeatures, lineFeatures, polygonFeatures, polygonOutlineFeatures } = features2;
  layerProps.points.data = pointFeatures;
  layerProps.points._dataDiff = featuresDiff.pointFeatures && (() => featuresDiff.pointFeatures);
  layerProps.points.getPosition = getCoordinates;
  layerProps.lines.data = lineFeatures;
  layerProps.lines._dataDiff = featuresDiff.lineFeatures && (() => featuresDiff.lineFeatures);
  layerProps.lines.getPath = getCoordinates;
  layerProps.polygons.data = polygonFeatures;
  layerProps.polygons._dataDiff = featuresDiff.polygonFeatures && (() => featuresDiff.polygonFeatures);
  layerProps.polygons.getPolygon = getCoordinates;
  layerProps.polygonsOutline.data = polygonOutlineFeatures;
  layerProps.polygonsOutline._dataDiff = featuresDiff.polygonOutlineFeatures && (() => featuresDiff.polygonOutlineFeatures);
  layerProps.polygonsOutline.getPath = getCoordinates;
  return layerProps;
}
function createLayerPropsFromBinary(geojsonBinary, encodePickingColor) {
  const layerProps = createEmptyLayerProps();
  const { points, lines, polygons } = geojsonBinary;
  const customPickingColors = calculatePickingColors(geojsonBinary, encodePickingColor);
  layerProps.points.data = {
    length: points.positions.value.length / points.positions.size,
    attributes: {
      ...points.attributes,
      getPosition: points.positions,
      instancePickingColors: {
        size: 4,
        value: customPickingColors.points
      }
    },
    properties: points.properties,
    numericProps: points.numericProps,
    featureIds: points.featureIds
  };
  layerProps.lines.data = {
    length: lines.pathIndices.value.length - 1,
    startIndices: lines.pathIndices.value,
    attributes: {
      ...lines.attributes,
      getPath: lines.positions,
      instancePickingColors: {
        size: 4,
        value: customPickingColors.lines
      }
    },
    properties: lines.properties,
    numericProps: lines.numericProps,
    featureIds: lines.featureIds
  };
  layerProps.lines._pathType = "open";
  const vertexCount = polygons.positions.value.length / polygons.positions.size;
  const vertexValid = Array(vertexCount).fill(1);
  for (const index of polygons.primitivePolygonIndices.value) {
    vertexValid[index - 1] = 0;
  }
  layerProps.polygons.data = {
    length: polygons.polygonIndices.value.length - 1,
    startIndices: polygons.polygonIndices.value,
    attributes: {
      ...polygons.attributes,
      getPolygon: polygons.positions,
      instanceVertexValid: {
        size: 1,
        value: new Uint16Array(vertexValid)
      },
      pickingColors: {
        size: 4,
        value: customPickingColors.polygons
      }
    },
    properties: polygons.properties,
    numericProps: polygons.numericProps,
    featureIds: polygons.featureIds
  };
  layerProps.polygons._normalize = false;
  if (polygons.triangles) {
    layerProps.polygons.data.attributes.indices = polygons.triangles.value;
  }
  layerProps.polygonsOutline.data = {
    length: polygons.primitivePolygonIndices.value.length - 1,
    startIndices: polygons.primitivePolygonIndices.value,
    attributes: {
      ...polygons.attributes,
      getPath: polygons.positions,
      instancePickingColors: {
        size: 4,
        value: customPickingColors.polygons
      }
    },
    properties: polygons.properties,
    numericProps: polygons.numericProps,
    featureIds: polygons.featureIds
  };
  layerProps.polygonsOutline._pathType = "open";
  return layerProps;
}

// node_modules/@deck.gl/layers/dist/geojson-layer/geojson-layer.js
var FEATURE_TYPES = ["points", "linestrings", "polygons"];
var defaultProps15 = {
  ...getDefaultProps(POINT_LAYER.circle),
  ...getDefaultProps(POINT_LAYER.icon),
  ...getDefaultProps(POINT_LAYER.text),
  ...getDefaultProps(LINE_LAYER),
  ...getDefaultProps(POLYGON_LAYER),
  // Overwrite sub layer defaults
  stroked: true,
  filled: true,
  extruded: false,
  wireframe: false,
  _full3d: false,
  iconAtlas: { type: "object", value: null },
  iconMapping: { type: "object", value: {} },
  getIcon: { type: "accessor", value: (f) => f.properties.icon },
  getText: { type: "accessor", value: (f) => f.properties.text },
  // Self props
  pointType: "circle",
  // TODO: deprecated, remove in v9
  getRadius: { deprecatedFor: "getPointRadius" }
};
var GeoJsonLayer = class extends composite_layer_default {
  initializeState() {
    this.state = {
      layerProps: {},
      features: {},
      featuresDiff: {}
    };
  }
  updateState({ props, changeFlags }) {
    if (!changeFlags.dataChanged) {
      return;
    }
    const { data } = this.props;
    const binary = data && "points" in data && "polygons" in data && "lines" in data;
    this.setState({ binary });
    if (binary) {
      this._updateStateBinary({ props, changeFlags });
    } else {
      this._updateStateJSON({ props, changeFlags });
    }
  }
  _updateStateBinary({ props, changeFlags }) {
    const layerProps = createLayerPropsFromBinary(props.data, this.encodePickingColor);
    this.setState({ layerProps });
  }
  _updateStateJSON({ props, changeFlags }) {
    const features2 = getGeojsonFeatures(props.data);
    const wrapFeature = this.getSubLayerRow.bind(this);
    let newFeatures = {};
    const featuresDiff = {};
    if (Array.isArray(changeFlags.dataChanged)) {
      const oldFeatures = this.state.features;
      for (const key in oldFeatures) {
        newFeatures[key] = oldFeatures[key].slice();
        featuresDiff[key] = [];
      }
      for (const dataRange of changeFlags.dataChanged) {
        const partialFeatures = separateGeojsonFeatures(features2, wrapFeature, dataRange);
        for (const key in oldFeatures) {
          featuresDiff[key].push(replaceInRange({
            data: newFeatures[key],
            getIndex: (f) => f.__source.index,
            dataRange,
            replace: partialFeatures[key]
          }));
        }
      }
    } else {
      newFeatures = separateGeojsonFeatures(features2, wrapFeature);
    }
    const layerProps = createLayerPropsFromFeatures(newFeatures, featuresDiff);
    this.setState({
      features: newFeatures,
      featuresDiff,
      layerProps
    });
  }
  getPickingInfo(params) {
    const info = super.getPickingInfo(params);
    const { index, sourceLayer } = info;
    info.featureType = FEATURE_TYPES.find((ft) => sourceLayer.id.startsWith(`${this.id}-${ft}-`));
    if (index >= 0 && sourceLayer.id.startsWith(`${this.id}-points-text`) && this.state.binary) {
      info.index = this.props.data.points.globalFeatureIds.value[index];
    }
    return info;
  }
  _updateAutoHighlight(info) {
    const pointLayerIdPrefix = `${this.id}-points-`;
    const sourceIsPoints = info.featureType === "points";
    for (const layer of this.getSubLayers()) {
      if (layer.id.startsWith(pointLayerIdPrefix) === sourceIsPoints) {
        layer.updateAutoHighlight(info);
      }
    }
  }
  _renderPolygonLayer() {
    var _a;
    const { extruded, wireframe } = this.props;
    const { layerProps } = this.state;
    const id = "polygons-fill";
    const PolygonFillLayer = this.shouldRenderSubLayer(id, (_a = layerProps.polygons) == null ? void 0 : _a.data) && this.getSubLayerClass(id, POLYGON_LAYER.type);
    if (PolygonFillLayer) {
      const forwardedProps = forwardProps(this, POLYGON_LAYER.props);
      const useLineColor = extruded && wireframe;
      if (!useLineColor) {
        delete forwardedProps.getLineColor;
      }
      forwardedProps.updateTriggers.lineColors = useLineColor;
      return new PolygonFillLayer(forwardedProps, this.getSubLayerProps({
        id,
        updateTriggers: forwardedProps.updateTriggers
      }), layerProps.polygons);
    }
    return null;
  }
  _renderLineLayers() {
    var _a, _b;
    const { extruded, stroked } = this.props;
    const { layerProps } = this.state;
    const polygonStrokeLayerId = "polygons-stroke";
    const lineStringsLayerId = "linestrings";
    const PolygonStrokeLayer = !extruded && stroked && this.shouldRenderSubLayer(polygonStrokeLayerId, (_a = layerProps.polygonsOutline) == null ? void 0 : _a.data) && this.getSubLayerClass(polygonStrokeLayerId, LINE_LAYER.type);
    const LineStringsLayer = this.shouldRenderSubLayer(lineStringsLayerId, (_b = layerProps.lines) == null ? void 0 : _b.data) && this.getSubLayerClass(lineStringsLayerId, LINE_LAYER.type);
    if (PolygonStrokeLayer || LineStringsLayer) {
      const forwardedProps = forwardProps(this, LINE_LAYER.props);
      return [
        PolygonStrokeLayer && new PolygonStrokeLayer(forwardedProps, this.getSubLayerProps({
          id: polygonStrokeLayerId,
          updateTriggers: forwardedProps.updateTriggers
        }), layerProps.polygonsOutline),
        LineStringsLayer && new LineStringsLayer(forwardedProps, this.getSubLayerProps({
          id: lineStringsLayerId,
          updateTriggers: forwardedProps.updateTriggers
        }), layerProps.lines)
      ];
    }
    return null;
  }
  _renderPointLayers() {
    var _a;
    const { pointType } = this.props;
    const { layerProps, binary } = this.state;
    let { highlightedObjectIndex } = this.props;
    if (!binary && Number.isFinite(highlightedObjectIndex)) {
      highlightedObjectIndex = layerProps.points.data.findIndex((d2) => d2.__source.index === highlightedObjectIndex);
    }
    const types = new Set(pointType.split("+"));
    const pointLayers = [];
    for (const type of types) {
      const id = `points-${type}`;
      const PointLayerMapping = POINT_LAYER[type];
      const PointsLayer = PointLayerMapping && this.shouldRenderSubLayer(id, (_a = layerProps.points) == null ? void 0 : _a.data) && this.getSubLayerClass(id, PointLayerMapping.type);
      if (PointsLayer) {
        const forwardedProps = forwardProps(this, PointLayerMapping.props);
        let pointsLayerProps = layerProps.points;
        if (type === "text" && binary) {
          const { instancePickingColors, ...rest } = pointsLayerProps.data.attributes;
          pointsLayerProps = {
            ...pointsLayerProps,
            // @ts-expect-error TODO - type binary data
            data: { ...pointsLayerProps.data, attributes: rest }
          };
        }
        pointLayers.push(new PointsLayer(forwardedProps, this.getSubLayerProps({
          id,
          updateTriggers: forwardedProps.updateTriggers,
          highlightedObjectIndex
        }), pointsLayerProps));
      }
    }
    return pointLayers;
  }
  renderLayers() {
    const { extruded } = this.props;
    const polygonFillLayer = this._renderPolygonLayer();
    const lineLayers = this._renderLineLayers();
    const pointLayers = this._renderPointLayers();
    return [
      // If not extruded: flat fill layer is drawn below outlines
      !extruded && polygonFillLayer,
      lineLayers,
      pointLayers,
      // If extruded: draw fill layer last for correct blending behavior
      extruded && polygonFillLayer
    ];
  }
  getSubLayerAccessor(accessor) {
    const { binary } = this.state;
    if (!binary || typeof accessor !== "function") {
      return super.getSubLayerAccessor(accessor);
    }
    return (object, info) => {
      const { data, index } = info;
      const feature2 = binaryToFeatureForAccesor(data, index);
      return accessor(feature2, info);
    };
  }
};
GeoJsonLayer.layerName = "GeoJsonLayer";
GeoJsonLayer.defaultProps = defaultProps15;
var geojson_layer_default = GeoJsonLayer;

// node_modules/@deck.gl/geo-layers/dist/geo-cell-layer/GeoCellLayer.js
var defaultProps16 = {
  ...polygon_layer_default.defaultProps
};
var GeoCellLayer = class extends composite_layer_default {
  /** Implement to generate props to create geometry. */
  indexToBounds() {
    return null;
  }
  renderLayers() {
    const { elevationScale, extruded, wireframe, filled, stroked, lineWidthUnits, lineWidthScale, lineWidthMinPixels, lineWidthMaxPixels, lineJointRounded, lineMiterLimit, lineDashJustified, getElevation, getFillColor, getLineColor, getLineWidth } = this.props;
    const { updateTriggers, material, transitions } = this.props;
    const CellLayer = this.getSubLayerClass("cell", polygon_layer_default);
    const { updateTriggers: boundsUpdateTriggers, ...boundsProps } = this.indexToBounds() || {};
    return new CellLayer({
      filled,
      wireframe,
      extruded,
      elevationScale,
      stroked,
      lineWidthUnits,
      lineWidthScale,
      lineWidthMinPixels,
      lineWidthMaxPixels,
      lineJointRounded,
      lineMiterLimit,
      lineDashJustified,
      material,
      transitions,
      getElevation,
      getFillColor,
      getLineColor,
      getLineWidth
    }, this.getSubLayerProps({
      id: "cell",
      updateTriggers: updateTriggers && {
        ...boundsUpdateTriggers,
        getElevation: updateTriggers.getElevation,
        getFillColor: updateTriggers.getFillColor,
        getLineColor: updateTriggers.getLineColor,
        getLineWidth: updateTriggers.getLineWidth
      }
    }), boundsProps);
  }
};
GeoCellLayer.layerName = "GeoCellLayer";
GeoCellLayer.defaultProps = defaultProps16;
var GeoCellLayer_default = GeoCellLayer;

// node_modules/a5-js/dist/a5.js
var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var common_exports = {};
__export(common_exports, {
  ARRAY_TYPE: () => ARRAY_TYPE,
  EPSILON: () => EPSILON,
  RANDOM: () => RANDOM,
  equals: () => equals3,
  setMatrixArrayType: () => setMatrixArrayType,
  toRadian: () => toRadian
});
var EPSILON = 1e-6;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var RANDOM = Math.random;
function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}
var degree = Math.PI / 180;
function toRadian(a2) {
  return a2 * degree;
}
function equals3(a2, b2) {
  return Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2));
}
if (!Math.hypot) Math.hypot = function() {
  var y = 0, i = arguments.length;
  while (i--) {
    y += arguments[i] * arguments[i];
  }
  return Math.sqrt(y);
};
var mat2_exports = {};
__export(mat2_exports, {
  LDU: () => LDU,
  add: () => add,
  adjoint: () => adjoint,
  clone: () => clone,
  copy: () => copy2,
  create: () => create,
  determinant: () => determinant,
  equals: () => equals22,
  exactEquals: () => exactEquals,
  frob: () => frob,
  fromRotation: () => fromRotation,
  fromScaling: () => fromScaling,
  fromValues: () => fromValues,
  identity: () => identity,
  invert: () => invert,
  mul: () => mul,
  multiply: () => multiply,
  multiplyScalar: () => multiplyScalar,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd,
  rotate: () => rotate,
  scale: () => scale,
  set: () => set,
  str: () => str,
  sub: () => sub,
  subtract: () => subtract,
  transpose: () => transpose
});
function create() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
  }
  out[0] = 1;
  out[3] = 1;
  return out;
}
function clone(a2) {
  var out = new ARRAY_TYPE(4);
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  out[3] = a2[3];
  return out;
}
function copy2(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  out[3] = a2[3];
  return out;
}
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
function fromValues(m00, m01, m10, m11) {
  var out = new ARRAY_TYPE(4);
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
function set(out, m00, m01, m10, m11) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
function transpose(out, a2) {
  if (out === a2) {
    var a1 = a2[1];
    out[1] = a2[2];
    out[2] = a1;
  } else {
    out[0] = a2[0];
    out[1] = a2[2];
    out[2] = a2[1];
    out[3] = a2[3];
  }
  return out;
}
function invert(out, a2) {
  var a0 = a2[0], a1 = a2[1], a22 = a2[2], a3 = a2[3];
  var det = a0 * a3 - a22 * a1;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = a3 * det;
  out[1] = -a1 * det;
  out[2] = -a22 * det;
  out[3] = a0 * det;
  return out;
}
function adjoint(out, a2) {
  var a0 = a2[0];
  out[0] = a2[3];
  out[1] = -a2[1];
  out[2] = -a2[2];
  out[3] = a0;
  return out;
}
function determinant(a2) {
  return a2[0] * a2[3] - a2[2] * a2[1];
}
function multiply(out, a2, b2) {
  var a0 = a2[0], a1 = a2[1], a22 = a2[2], a3 = a2[3];
  var b0 = b2[0], b1 = b2[1], b22 = b2[2], b3 = b2[3];
  out[0] = a0 * b0 + a22 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b22 + a22 * b3;
  out[3] = a1 * b22 + a3 * b3;
  return out;
}
function rotate(out, a2, rad) {
  var a0 = a2[0], a1 = a2[1], a22 = a2[2], a3 = a2[3];
  var s = Math.sin(rad);
  var c2 = Math.cos(rad);
  out[0] = a0 * c2 + a22 * s;
  out[1] = a1 * c2 + a3 * s;
  out[2] = a0 * -s + a22 * c2;
  out[3] = a1 * -s + a3 * c2;
  return out;
}
function scale(out, a2, v2) {
  var a0 = a2[0], a1 = a2[1], a22 = a2[2], a3 = a2[3];
  var v0 = v2[0], v1 = v2[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a22 * v1;
  out[3] = a3 * v1;
  return out;
}
function fromRotation(out, rad) {
  var s = Math.sin(rad);
  var c2 = Math.cos(rad);
  out[0] = c2;
  out[1] = s;
  out[2] = -s;
  out[3] = c2;
  return out;
}
function fromScaling(out, v2) {
  out[0] = v2[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v2[1];
  return out;
}
function str(a2) {
  return "mat2(" + a2[0] + ", " + a2[1] + ", " + a2[2] + ", " + a2[3] + ")";
}
function frob(a2) {
  return Math.hypot(a2[0], a2[1], a2[2], a2[3]);
}
function LDU(L2, D2, U, a2) {
  L2[2] = a2[2] / a2[0];
  U[0] = a2[0];
  U[1] = a2[1];
  U[3] = a2[3] - L2[2] * U[1];
  return [L2, D2, U];
}
function add(out, a2, b2) {
  out[0] = a2[0] + b2[0];
  out[1] = a2[1] + b2[1];
  out[2] = a2[2] + b2[2];
  out[3] = a2[3] + b2[3];
  return out;
}
function subtract(out, a2, b2) {
  out[0] = a2[0] - b2[0];
  out[1] = a2[1] - b2[1];
  out[2] = a2[2] - b2[2];
  out[3] = a2[3] - b2[3];
  return out;
}
function exactEquals(a2, b2) {
  return a2[0] === b2[0] && a2[1] === b2[1] && a2[2] === b2[2] && a2[3] === b2[3];
}
function equals22(a2, b2) {
  var a0 = a2[0], a1 = a2[1], a22 = a2[2], a3 = a2[3];
  var b0 = b2[0], b1 = b2[1], b22 = b2[2], b3 = b2[3];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b22) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b22)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3));
}
function multiplyScalar(out, a2, b2) {
  out[0] = a2[0] * b2;
  out[1] = a2[1] * b2;
  out[2] = a2[2] * b2;
  out[3] = a2[3] * b2;
  return out;
}
function multiplyScalarAndAdd(out, a2, b2, scale7) {
  out[0] = a2[0] + b2[0] * scale7;
  out[1] = a2[1] + b2[1] * scale7;
  out[2] = a2[2] + b2[2] * scale7;
  out[3] = a2[3] + b2[3] * scale7;
  return out;
}
var mul = multiply;
var sub = subtract;
function create2() {
  var out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
var quat_exports = {};
__export(quat_exports, {
  add: () => add4,
  calculateW: () => calculateW,
  clone: () => clone4,
  conjugate: () => conjugate,
  copy: () => copy4,
  create: () => create5,
  dot: () => dot3,
  equals: () => equals5,
  exactEquals: () => exactEquals4,
  exp: () => exp,
  fromEuler: () => fromEuler,
  fromMat3: () => fromMat3,
  fromValues: () => fromValues4,
  getAngle: () => getAngle,
  getAxisAngle: () => getAxisAngle,
  identity: () => identity2,
  invert: () => invert2,
  len: () => len2,
  length: () => length3,
  lerp: () => lerp3,
  ln: () => ln,
  mul: () => mul3,
  multiply: () => multiply3,
  normalize: () => normalize3,
  pow: () => pow,
  random: () => random2,
  rotateX: () => rotateX2,
  rotateY: () => rotateY2,
  rotateZ: () => rotateZ2,
  rotationTo: () => rotationTo,
  scale: () => scale4,
  set: () => set4,
  setAxes: () => setAxes,
  setAxisAngle: () => setAxisAngle,
  slerp: () => slerp,
  sqlerp: () => sqlerp,
  sqrLen: () => sqrLen2,
  squaredLength: () => squaredLength3,
  str: () => str3
});
var vec3_exports2 = {};
__export(vec3_exports2, {
  add: () => add2,
  angle: () => angle,
  bezier: () => bezier,
  ceil: () => ceil,
  clone: () => clone2,
  copy: () => copy22,
  create: () => create3,
  cross: () => cross,
  dist: () => dist,
  distance: () => distance,
  div: () => div,
  divide: () => divide,
  dot: () => dot,
  equals: () => equals32,
  exactEquals: () => exactEquals2,
  floor: () => floor,
  forEach: () => forEach,
  fromValues: () => fromValues2,
  hermite: () => hermite,
  inverse: () => inverse,
  len: () => len,
  length: () => length,
  lerp: () => lerp2,
  max: () => max,
  min: () => min,
  mul: () => mul2,
  multiply: () => multiply2,
  negate: () => negate,
  normalize: () => normalize2,
  random: () => random,
  rotateX: () => rotateX,
  rotateY: () => rotateY,
  rotateZ: () => rotateZ,
  round: () => round,
  scale: () => scale2,
  scaleAndAdd: () => scaleAndAdd,
  set: () => set2,
  sqrDist: () => sqrDist,
  sqrLen: () => sqrLen,
  squaredDistance: () => squaredDistance,
  squaredLength: () => squaredLength,
  str: () => str2,
  sub: () => sub2,
  subtract: () => subtract2,
  transformMat3: () => transformMat3,
  transformMat4: () => transformMat4,
  transformQuat: () => transformQuat,
  zero: () => zero
});
function create3() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function clone2(a2) {
  var out = new ARRAY_TYPE(3);
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  return out;
}
function length(a2) {
  var x = a2[0];
  var y = a2[1];
  var z = a2[2];
  return Math.hypot(x, y, z);
}
function fromValues2(x, y, z) {
  var out = new ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function copy22(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  return out;
}
function set2(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function add2(out, a2, b2) {
  out[0] = a2[0] + b2[0];
  out[1] = a2[1] + b2[1];
  out[2] = a2[2] + b2[2];
  return out;
}
function subtract2(out, a2, b2) {
  out[0] = a2[0] - b2[0];
  out[1] = a2[1] - b2[1];
  out[2] = a2[2] - b2[2];
  return out;
}
function multiply2(out, a2, b2) {
  out[0] = a2[0] * b2[0];
  out[1] = a2[1] * b2[1];
  out[2] = a2[2] * b2[2];
  return out;
}
function divide(out, a2, b2) {
  out[0] = a2[0] / b2[0];
  out[1] = a2[1] / b2[1];
  out[2] = a2[2] / b2[2];
  return out;
}
function ceil(out, a2) {
  out[0] = Math.ceil(a2[0]);
  out[1] = Math.ceil(a2[1]);
  out[2] = Math.ceil(a2[2]);
  return out;
}
function floor(out, a2) {
  out[0] = Math.floor(a2[0]);
  out[1] = Math.floor(a2[1]);
  out[2] = Math.floor(a2[2]);
  return out;
}
function min(out, a2, b2) {
  out[0] = Math.min(a2[0], b2[0]);
  out[1] = Math.min(a2[1], b2[1]);
  out[2] = Math.min(a2[2], b2[2]);
  return out;
}
function max(out, a2, b2) {
  out[0] = Math.max(a2[0], b2[0]);
  out[1] = Math.max(a2[1], b2[1]);
  out[2] = Math.max(a2[2], b2[2]);
  return out;
}
function round(out, a2) {
  out[0] = Math.round(a2[0]);
  out[1] = Math.round(a2[1]);
  out[2] = Math.round(a2[2]);
  return out;
}
function scale2(out, a2, b2) {
  out[0] = a2[0] * b2;
  out[1] = a2[1] * b2;
  out[2] = a2[2] * b2;
  return out;
}
function scaleAndAdd(out, a2, b2, scale7) {
  out[0] = a2[0] + b2[0] * scale7;
  out[1] = a2[1] + b2[1] * scale7;
  out[2] = a2[2] + b2[2] * scale7;
  return out;
}
function distance(a2, b2) {
  var x = b2[0] - a2[0];
  var y = b2[1] - a2[1];
  var z = b2[2] - a2[2];
  return Math.hypot(x, y, z);
}
function squaredDistance(a2, b2) {
  var x = b2[0] - a2[0];
  var y = b2[1] - a2[1];
  var z = b2[2] - a2[2];
  return x * x + y * y + z * z;
}
function squaredLength(a2) {
  var x = a2[0];
  var y = a2[1];
  var z = a2[2];
  return x * x + y * y + z * z;
}
function negate(out, a2) {
  out[0] = -a2[0];
  out[1] = -a2[1];
  out[2] = -a2[2];
  return out;
}
function inverse(out, a2) {
  out[0] = 1 / a2[0];
  out[1] = 1 / a2[1];
  out[2] = 1 / a2[2];
  return out;
}
function normalize2(out, a2) {
  var x = a2[0];
  var y = a2[1];
  var z = a2[2];
  var len4 = x * x + y * y + z * z;
  if (len4 > 0) {
    len4 = 1 / Math.sqrt(len4);
  }
  out[0] = a2[0] * len4;
  out[1] = a2[1] * len4;
  out[2] = a2[2] * len4;
  return out;
}
function dot(a2, b2) {
  return a2[0] * b2[0] + a2[1] * b2[1] + a2[2] * b2[2];
}
function cross(out, a2, b2) {
  var ax = a2[0], ay = a2[1], az = a2[2];
  var bx = b2[0], by = b2[1], bz = b2[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function lerp2(out, a2, b2, t) {
  var ax = a2[0];
  var ay = a2[1];
  var az = a2[2];
  out[0] = ax + t * (b2[0] - ax);
  out[1] = ay + t * (b2[1] - ay);
  out[2] = az + t * (b2[2] - az);
  return out;
}
function hermite(out, a2, b2, c2, d2, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a2[0] * factor1 + b2[0] * factor2 + c2[0] * factor3 + d2[0] * factor4;
  out[1] = a2[1] * factor1 + b2[1] * factor2 + c2[1] * factor3 + d2[1] * factor4;
  out[2] = a2[2] * factor1 + b2[2] * factor2 + c2[2] * factor3 + d2[2] * factor4;
  return out;
}
function bezier(out, a2, b2, c2, d2, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a2[0] * factor1 + b2[0] * factor2 + c2[0] * factor3 + d2[0] * factor4;
  out[1] = a2[1] * factor1 + b2[1] * factor2 + c2[1] * factor3 + d2[1] * factor4;
  out[2] = a2[2] * factor1 + b2[2] * factor2 + c2[2] * factor3 + d2[2] * factor4;
  return out;
}
function random(out, scale7) {
  scale7 = scale7 || 1;
  var r = RANDOM() * 2 * Math.PI;
  var z = RANDOM() * 2 - 1;
  var zScale = Math.sqrt(1 - z * z) * scale7;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale7;
  return out;
}
function transformMat4(out, a2, m) {
  var x = a2[0], y = a2[1], z = a2[2];
  var w2 = m[3] * x + m[7] * y + m[11] * z + m[15];
  w2 = w2 || 1;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w2;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w2;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w2;
  return out;
}
function transformMat3(out, a2, m) {
  var x = a2[0], y = a2[1], z = a2[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
function transformQuat(out, a2, q) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var x = a2[0], y = a2[1], z = a2[2];
  var uvx = qy * z - qz * y, uvy = qz * x - qx * z, uvz = qx * y - qy * x;
  var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
function rotateX(out, a2, b2, rad) {
  var p = [], r = [];
  p[0] = a2[0] - b2[0];
  p[1] = a2[1] - b2[1];
  p[2] = a2[2] - b2[2];
  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);
  out[0] = r[0] + b2[0];
  out[1] = r[1] + b2[1];
  out[2] = r[2] + b2[2];
  return out;
}
function rotateY(out, a2, b2, rad) {
  var p = [], r = [];
  p[0] = a2[0] - b2[0];
  p[1] = a2[1] - b2[1];
  p[2] = a2[2] - b2[2];
  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);
  out[0] = r[0] + b2[0];
  out[1] = r[1] + b2[1];
  out[2] = r[2] + b2[2];
  return out;
}
function rotateZ(out, a2, b2, rad) {
  var p = [], r = [];
  p[0] = a2[0] - b2[0];
  p[1] = a2[1] - b2[1];
  p[2] = a2[2] - b2[2];
  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2];
  out[0] = r[0] + b2[0];
  out[1] = r[1] + b2[1];
  out[2] = r[2] + b2[2];
  return out;
}
function angle(a2, b2) {
  var ax = a2[0], ay = a2[1], az = a2[2], bx = b2[0], by = b2[1], bz = b2[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && dot(a2, b2) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}
function str2(a2) {
  return "vec3(" + a2[0] + ", " + a2[1] + ", " + a2[2] + ")";
}
function exactEquals2(a2, b2) {
  return a2[0] === b2[0] && a2[1] === b2[1] && a2[2] === b2[2];
}
function equals32(a2, b2) {
  var a0 = a2[0], a1 = a2[1], a22 = a2[2];
  var b0 = b2[0], b1 = b2[1], b22 = b2[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b22) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b22));
}
var sub2 = subtract2;
var mul2 = multiply2;
var div = divide;
var dist = distance;
var sqrDist = squaredDistance;
var len = length;
var sqrLen = squaredLength;
var forEach = (function() {
  var vec = create3();
  return function(a2, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a2.length);
    } else {
      l = a2.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a2[i];
      vec[1] = a2[i + 1];
      vec[2] = a2[i + 2];
      fn(vec, vec, arg);
      a2[i] = vec[0];
      a2[i + 1] = vec[1];
      a2[i + 2] = vec[2];
    }
    return a2;
  };
})();
function create4() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function clone3(a2) {
  var out = new ARRAY_TYPE(4);
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  out[3] = a2[3];
  return out;
}
function fromValues3(x, y, z, w2) {
  var out = new ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w2;
  return out;
}
function copy3(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  out[3] = a2[3];
  return out;
}
function set3(out, x, y, z, w2) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w2;
  return out;
}
function add3(out, a2, b2) {
  out[0] = a2[0] + b2[0];
  out[1] = a2[1] + b2[1];
  out[2] = a2[2] + b2[2];
  out[3] = a2[3] + b2[3];
  return out;
}
function scale3(out, a2, b2) {
  out[0] = a2[0] * b2;
  out[1] = a2[1] * b2;
  out[2] = a2[2] * b2;
  out[3] = a2[3] * b2;
  return out;
}
function length2(a2) {
  var x = a2[0];
  var y = a2[1];
  var z = a2[2];
  var w2 = a2[3];
  return Math.hypot(x, y, z, w2);
}
function squaredLength2(a2) {
  var x = a2[0];
  var y = a2[1];
  var z = a2[2];
  var w2 = a2[3];
  return x * x + y * y + z * z + w2 * w2;
}
function normalize22(out, a2) {
  var x = a2[0];
  var y = a2[1];
  var z = a2[2];
  var w2 = a2[3];
  var len4 = x * x + y * y + z * z + w2 * w2;
  if (len4 > 0) {
    len4 = 1 / Math.sqrt(len4);
  }
  out[0] = x * len4;
  out[1] = y * len4;
  out[2] = z * len4;
  out[3] = w2 * len4;
  return out;
}
function dot2(a2, b2) {
  return a2[0] * b2[0] + a2[1] * b2[1] + a2[2] * b2[2] + a2[3] * b2[3];
}
function lerp22(out, a2, b2, t) {
  var ax = a2[0];
  var ay = a2[1];
  var az = a2[2];
  var aw = a2[3];
  out[0] = ax + t * (b2[0] - ax);
  out[1] = ay + t * (b2[1] - ay);
  out[2] = az + t * (b2[2] - az);
  out[3] = aw + t * (b2[3] - aw);
  return out;
}
function exactEquals3(a2, b2) {
  return a2[0] === b2[0] && a2[1] === b2[1] && a2[2] === b2[2] && a2[3] === b2[3];
}
function equals4(a2, b2) {
  var a0 = a2[0], a1 = a2[1], a22 = a2[2], a3 = a2[3];
  var b0 = b2[0], b1 = b2[1], b22 = b2[2], b3 = b2[3];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b22) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b22)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3));
}
var forEach2 = (function() {
  var vec = create4();
  return function(a2, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 4;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a2.length);
    } else {
      l = a2.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a2[i];
      vec[1] = a2[i + 1];
      vec[2] = a2[i + 2];
      vec[3] = a2[i + 3];
      fn(vec, vec, arg);
      a2[i] = vec[0];
      a2[i + 1] = vec[1];
      a2[i + 2] = vec[2];
      a2[i + 3] = vec[3];
    }
    return a2;
  };
})();
function create5() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
function identity2(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2;
  var s = Math.sin(rad / 2);
  if (s > EPSILON) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad;
}
function getAngle(a2, b2) {
  var dotproduct = dot3(a2, b2);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
function multiply3(out, a2, b2) {
  var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
  var bx = b2[0], by = b2[1], bz = b2[2], bw = b2[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
function rotateX2(out, a2, rad) {
  rad *= 0.5;
  var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
  var bx = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
function rotateY2(out, a2, rad) {
  rad *= 0.5;
  var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
  var by = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
function rotateZ2(out, a2, rad) {
  rad *= 0.5;
  var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
  var bz = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
function calculateW(out, a2) {
  var x = a2[0], y = a2[1], z = a2[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1 - x * x - y * y - z * z));
  return out;
}
function exp(out, a2) {
  var x = a2[0], y = a2[1], z = a2[2], w2 = a2[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var et = Math.exp(w2);
  var s = r > 0 ? et * Math.sin(r) / r : 0;
  out[0] = x * s;
  out[1] = y * s;
  out[2] = z * s;
  out[3] = et * Math.cos(r);
  return out;
}
function ln(out, a2) {
  var x = a2[0], y = a2[1], z = a2[2], w2 = a2[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var t = r > 0 ? Math.atan2(r, w2) / r : 0;
  out[0] = x * t;
  out[1] = y * t;
  out[2] = z * t;
  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w2 * w2);
  return out;
}
function pow(out, a2, b2) {
  ln(out, a2);
  scale4(out, out, b2);
  exp(out, out);
  return out;
}
function slerp(out, a2, b2, t) {
  var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
  var bx = b2[0], by = b2[1], bz = b2[2], bw = b2[3];
  var omega, cosom, sinom, scale0, scale1;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > EPSILON) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    scale0 = 1 - t;
    scale1 = t;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
function random2(out) {
  var u1 = RANDOM();
  var u2 = RANDOM();
  var u3 = RANDOM();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2 * Math.PI * u3);
  return out;
}
function invert2(out, a2) {
  var a0 = a2[0], a1 = a2[1], a22 = a2[2], a3 = a2[3];
  var dot5 = a0 * a0 + a1 * a1 + a22 * a22 + a3 * a3;
  var invDot = dot5 ? 1 / dot5 : 0;
  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a22 * invDot;
  out[3] = a3 * invDot;
  return out;
}
function conjugate(out, a2) {
  out[0] = -a2[0];
  out[1] = -a2[1];
  out[2] = -a2[2];
  out[3] = a2[3];
  return out;
}
function fromMat3(out, m) {
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }
  return out;
}
function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
function str3(a2) {
  return "quat(" + a2[0] + ", " + a2[1] + ", " + a2[2] + ", " + a2[3] + ")";
}
var clone4 = clone3;
var fromValues4 = fromValues3;
var copy4 = copy3;
var set4 = set3;
var add4 = add3;
var mul3 = multiply3;
var scale4 = scale3;
var dot3 = dot2;
var lerp3 = lerp22;
var length3 = length2;
var len2 = length3;
var squaredLength3 = squaredLength2;
var sqrLen2 = squaredLength3;
var normalize3 = normalize22;
var exactEquals4 = exactEquals3;
var equals5 = equals4;
var rotationTo = (function() {
  var tmpvec3 = create3();
  var xUnitVec3 = fromValues2(1, 0, 0);
  var yUnitVec3 = fromValues2(0, 1, 0);
  return function(out, a2, b2) {
    var dot5 = dot(a2, b2);
    if (dot5 < -0.999999) {
      cross(tmpvec3, xUnitVec3, a2);
      if (len(tmpvec3) < 1e-6) cross(tmpvec3, yUnitVec3, a2);
      normalize2(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot5 > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      cross(tmpvec3, a2, b2);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot5;
      return normalize3(out, out);
    }
  };
})();
var sqlerp = (function() {
  var temp1 = create5();
  var temp2 = create5();
  return function(out, a2, b2, c2, d2, t) {
    slerp(temp1, a2, d2, t);
    slerp(temp2, b2, c2, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
})();
var setAxes = (function() {
  var matr = create2();
  return function(out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize3(out, fromMat3(out, matr));
  };
})();
var vec2_exports = {};
__export(vec2_exports, {
  add: () => add5,
  angle: () => angle2,
  ceil: () => ceil2,
  clone: () => clone5,
  copy: () => copy5,
  create: () => create6,
  cross: () => cross2,
  dist: () => dist2,
  distance: () => distance2,
  div: () => div2,
  divide: () => divide2,
  dot: () => dot4,
  equals: () => equals6,
  exactEquals: () => exactEquals5,
  floor: () => floor2,
  forEach: () => forEach3,
  fromValues: () => fromValues5,
  inverse: () => inverse2,
  len: () => len3,
  length: () => length4,
  lerp: () => lerp4,
  max: () => max2,
  min: () => min2,
  mul: () => mul4,
  multiply: () => multiply4,
  negate: () => negate2,
  normalize: () => normalize4,
  random: () => random3,
  rotate: () => rotate2,
  round: () => round2,
  scale: () => scale5,
  scaleAndAdd: () => scaleAndAdd2,
  set: () => set5,
  sqrDist: () => sqrDist2,
  sqrLen: () => sqrLen3,
  squaredDistance: () => squaredDistance2,
  squaredLength: () => squaredLength4,
  str: () => str4,
  sub: () => sub3,
  subtract: () => subtract3,
  transformMat2: () => transformMat2,
  transformMat2d: () => transformMat2d,
  transformMat3: () => transformMat32,
  transformMat4: () => transformMat42,
  zero: () => zero2
});
function create6() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
function clone5(a2) {
  var out = new ARRAY_TYPE(2);
  out[0] = a2[0];
  out[1] = a2[1];
  return out;
}
function fromValues5(x, y) {
  var out = new ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}
function copy5(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  return out;
}
function set5(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
function add5(out, a2, b2) {
  out[0] = a2[0] + b2[0];
  out[1] = a2[1] + b2[1];
  return out;
}
function subtract3(out, a2, b2) {
  out[0] = a2[0] - b2[0];
  out[1] = a2[1] - b2[1];
  return out;
}
function multiply4(out, a2, b2) {
  out[0] = a2[0] * b2[0];
  out[1] = a2[1] * b2[1];
  return out;
}
function divide2(out, a2, b2) {
  out[0] = a2[0] / b2[0];
  out[1] = a2[1] / b2[1];
  return out;
}
function ceil2(out, a2) {
  out[0] = Math.ceil(a2[0]);
  out[1] = Math.ceil(a2[1]);
  return out;
}
function floor2(out, a2) {
  out[0] = Math.floor(a2[0]);
  out[1] = Math.floor(a2[1]);
  return out;
}
function min2(out, a2, b2) {
  out[0] = Math.min(a2[0], b2[0]);
  out[1] = Math.min(a2[1], b2[1]);
  return out;
}
function max2(out, a2, b2) {
  out[0] = Math.max(a2[0], b2[0]);
  out[1] = Math.max(a2[1], b2[1]);
  return out;
}
function round2(out, a2) {
  out[0] = Math.round(a2[0]);
  out[1] = Math.round(a2[1]);
  return out;
}
function scale5(out, a2, b2) {
  out[0] = a2[0] * b2;
  out[1] = a2[1] * b2;
  return out;
}
function scaleAndAdd2(out, a2, b2, scale7) {
  out[0] = a2[0] + b2[0] * scale7;
  out[1] = a2[1] + b2[1] * scale7;
  return out;
}
function distance2(a2, b2) {
  var x = b2[0] - a2[0], y = b2[1] - a2[1];
  return Math.hypot(x, y);
}
function squaredDistance2(a2, b2) {
  var x = b2[0] - a2[0], y = b2[1] - a2[1];
  return x * x + y * y;
}
function length4(a2) {
  var x = a2[0], y = a2[1];
  return Math.hypot(x, y);
}
function squaredLength4(a2) {
  var x = a2[0], y = a2[1];
  return x * x + y * y;
}
function negate2(out, a2) {
  out[0] = -a2[0];
  out[1] = -a2[1];
  return out;
}
function inverse2(out, a2) {
  out[0] = 1 / a2[0];
  out[1] = 1 / a2[1];
  return out;
}
function normalize4(out, a2) {
  var x = a2[0], y = a2[1];
  var len4 = x * x + y * y;
  if (len4 > 0) {
    len4 = 1 / Math.sqrt(len4);
  }
  out[0] = a2[0] * len4;
  out[1] = a2[1] * len4;
  return out;
}
function dot4(a2, b2) {
  return a2[0] * b2[0] + a2[1] * b2[1];
}
function cross2(out, a2, b2) {
  var z = a2[0] * b2[1] - a2[1] * b2[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
function lerp4(out, a2, b2, t) {
  var ax = a2[0], ay = a2[1];
  out[0] = ax + t * (b2[0] - ax);
  out[1] = ay + t * (b2[1] - ay);
  return out;
}
function random3(out, scale7) {
  scale7 = scale7 || 1;
  var r = RANDOM() * 2 * Math.PI;
  out[0] = Math.cos(r) * scale7;
  out[1] = Math.sin(r) * scale7;
  return out;
}
function transformMat2(out, a2, m) {
  var x = a2[0], y = a2[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
function transformMat2d(out, a2, m) {
  var x = a2[0], y = a2[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
function transformMat32(out, a2, m) {
  var x = a2[0], y = a2[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
function transformMat42(out, a2, m) {
  var x = a2[0];
  var y = a2[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
function rotate2(out, a2, b2, rad) {
  var p0 = a2[0] - b2[0], p1 = a2[1] - b2[1], sinC = Math.sin(rad), cosC = Math.cos(rad);
  out[0] = p0 * cosC - p1 * sinC + b2[0];
  out[1] = p0 * sinC + p1 * cosC + b2[1];
  return out;
}
function angle2(a2, b2) {
  var x1 = a2[0], y1 = a2[1], x2 = b2[0], y2 = b2[1], mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2), cosine = mag && (x1 * x2 + y1 * y2) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero2(out) {
  out[0] = 0;
  out[1] = 0;
  return out;
}
function str4(a2) {
  return "vec2(" + a2[0] + ", " + a2[1] + ")";
}
function exactEquals5(a2, b2) {
  return a2[0] === b2[0] && a2[1] === b2[1];
}
function equals6(a2, b2) {
  var a0 = a2[0], a1 = a2[1];
  var b0 = b2[0], b1 = b2[1];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1));
}
var len3 = length4;
var sub3 = subtract3;
var mul4 = multiply4;
var div2 = divide2;
var dist2 = distance2;
var sqrDist2 = squaredDistance2;
var sqrLen3 = squaredLength4;
var forEach3 = (function() {
  var vec = create6();
  return function(a2, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a2.length);
    } else {
      l = a2.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a2[i];
      vec[1] = a2[i + 1];
      fn(vec, vec, arg);
      a2[i] = vec[0];
      a2[i + 1] = vec[1];
    }
    return a2;
  };
})();
var φ = (1 + Math.sqrt(5)) / 2;
var TWO_PI = 2 * Math.PI;
var TWO_PI_OVER_5 = 2 * Math.PI / 5;
var PI_OVER_5 = Math.PI / 5;
var PI_OVER_10 = Math.PI / 10;
var dihedralAngle = 2 * Math.atan(φ);
var interhedralAngle = Math.PI - dihedralAngle;
var faceEdgeAngle = -0.5 * Math.PI + Math.acos(-1 / Math.sqrt(3 - φ));
var distanceToEdge = (Math.sqrt(5) - 1) / 2;
var distanceToVertex = 3 - Math.sqrt(5);
var Rmidedge = Math.sqrt(3 - φ);
var Rcircumscribed = Math.sqrt(3) * Rmidedge / φ;
common_exports.setMatrixArrayType(Float64Array);
var PentagonShape = class _PentagonShape {
  constructor(vertices) {
    this.vertices = vertices;
    if (!this.isWindingCorrect()) {
      this.vertices.reverse();
    }
  }
  getArea() {
    let signedArea2 = 0;
    const N = this.vertices.length;
    for (let i = 0; i < N; i++) {
      const j = (i + 1) % N;
      signedArea2 += (this.vertices[j][0] - this.vertices[i][0]) * (this.vertices[j][1] + this.vertices[i][1]);
    }
    return signedArea2;
  }
  isWindingCorrect() {
    return this.getArea() >= 0;
  }
  getVertices() {
    return this.vertices;
  }
  scale(scale7) {
    for (const vertex4 of this.vertices) {
      vec2_exports.scale(vertex4, vertex4, scale7);
    }
    return this;
  }
  /**
   * Rotates the pentagon 180 degrees (equivalent to negating x & y)
   * @returns The rotated pentagon
   */
  rotate180() {
    for (const vertex4 of this.vertices) {
      vec2_exports.negate(vertex4, vertex4);
    }
    return this;
  }
  /**
   * Reflects the pentagon over the x-axis (equivalent to negating y)
   * and reverses the winding order to maintain consistent orientation
   * @returns The reflected pentagon
   */
  reflectY() {
    for (const vertex4 of this.vertices) {
      vertex4[1] = -vertex4[1];
    }
    this.vertices.reverse();
    return this;
  }
  translate(translation2) {
    for (const vertex4 of this.vertices) {
      vec2_exports.add(vertex4, vertex4, translation2);
    }
    return this;
  }
  transform(transform2) {
    for (const vertex4 of this.vertices) {
      vec2_exports.transformMat2(vertex4, vertex4, transform2);
    }
    return this;
  }
  transform2d(transform2) {
    for (const vertex4 of this.vertices) {
      vec2_exports.transformMat2d(vertex4, vertex4, transform2);
    }
    return this;
  }
  clone() {
    const newPentagon = new _PentagonShape(this.vertices.map((v2) => vec2_exports.clone(v2)));
    return newPentagon;
  }
  getCenter() {
    const n = this.vertices.length;
    const sum = this.vertices.reduce((sum2, v2) => [sum2[0] + v2[0] / n, sum2[1] + v2[1] / n], [0, 0]);
    return sum;
  }
  /**
   * Tests if a point is inside the pentagon by checking if it's on the correct side of all edges.
   * Assumes consistent winding order (counter-clockwise).
   * @param point The point to test
   * @returns 1 if point is inside, otherwise a negative value proportional to the distance from the point to the edge
   */
  containsPoint(point2) {
    if (!this.isWindingCorrect()) {
      throw new Error("Pentagon is not counter-clockwise");
    }
    const N = this.vertices.length;
    let dMax = 1;
    for (let i = 0; i < N; i++) {
      const v1 = this.vertices[i];
      const v2 = this.vertices[(i + 1) % N];
      const dx = v1[0] - v2[0];
      const dy = v1[1] - v2[1];
      const px = point2[0] - v1[0];
      const py = point2[1] - v1[1];
      const crossProduct = dx * py - dy * px;
      if (crossProduct < 0) {
        const pLength = Math.sqrt(px * px + py * py);
        dMax = Math.min(dMax, crossProduct / pLength);
      }
    }
    return dMax;
  }
  /**
   * Splits each edge of the pentagon into the specified number of segments
   * @param segments Number of segments to split each edge into
   * @returns A new PentagonShape with more vertices, or the original PentagonShape if segments <= 1
   */
  splitEdges(segments) {
    if (segments <= 1) {
      return this;
    }
    const newVertices = [];
    const N = this.vertices.length;
    for (let i = 0; i < N; i++) {
      const v1 = this.vertices[i];
      const v2 = this.vertices[(i + 1) % N];
      newVertices.push(vec2_exports.clone(v1));
      for (let j = 1; j < segments; j++) {
        const t = j / segments;
        const interpolated = vec2_exports.create();
        vec2_exports.lerp(interpolated, v1, v2, t);
        newVertices.push(interpolated);
      }
    }
    return new _PentagonShape(newVertices);
  }
};
common_exports.setMatrixArrayType(Float64Array);
var a = [0, 0];
var b = [0, 1];
var c = [0.7885966681787006, 1.6149108024237764];
var d = [1.6171013659387945, 1.054928690397459];
var e = [Math.cos(PI_OVER_10), Math.sin(PI_OVER_10)];
var edgeMidpointD = 2 * vec2_exports.length(c) * Math.cos(PI_OVER_5);
var BASIS_ROTATION = PI_OVER_5 - Math.atan2(c[1], c[0]);
var scale6 = 2 * distanceToEdge / edgeMidpointD;
[a, b, c, d, e].forEach((v2) => {
  vec2_exports.scale(v2, v2, scale6);
  vec2_exports.rotate(v2, v2, [0, 0], BASIS_ROTATION);
});
var PENTAGON = new PentagonShape([a, b, c, d, e]);
var bisectorAngle = Math.atan2(c[1], c[0]) - PI_OVER_5;
var u = [0, 0];
var L = distanceToEdge / Math.cos(PI_OVER_5);
var V = bisectorAngle + PI_OVER_5;
var v = [L * Math.cos(V), L * Math.sin(V)];
var W = bisectorAngle - PI_OVER_5;
var w = [L * Math.cos(W), L * Math.sin(W)];
var TRIANGLE = new PentagonShape([u, v, w]);
var BASIS = mat2_exports.fromValues(v[0], v[1], w[0], w[1]);
var BASIS_INVERSE = mat2_exports.invert(mat2_exports.create(), BASIS);
var GEODETIC_TO_AUTHALIC = new Float64Array([
  -0.0022392098386786394,
  21308606513250217e-22,
  -2559257686421274e-24,
  33701965267802837e-28,
  -4667545312611249e-30,
  667492870384816e-32
]);
var AUTHALIC_TO_GEODETIC = new Float64Array([
  0.0022392089963541657,
  28831978048607556e-22,
  508622073997266e-23,
  102018123778161e-25,
  21912872306767718e-30,
  49284235482523806e-33
]);
var AuthalicProjection = class {
  /**
   * Applies coefficients using Clenshaw summation algorithm (order 6)
   * @param phi Angle in radians
   * @param C Array of coefficients
   * @returns Transformed angle in radians
   */
  applyCoefficients(phi, C2) {
    const sinPhi = Math.sin(phi);
    const cosPhi = Math.cos(phi);
    const X = 2 * (cosPhi - sinPhi) * (cosPhi + sinPhi);
    let u0, u1;
    u0 = X * C2[5] + C2[4];
    u1 = X * u0 + C2[3];
    u0 = X * u1 - u0 + C2[2];
    u1 = X * u0 - u1 + C2[1];
    u0 = X * u1 - u0 + C2[0];
    return phi + 2 * sinPhi * cosPhi * u0;
  }
  /**
   * Converts geodetic latitude to authalic latitude
   * @param phi Geodetic latitude in radians
   * @returns Authalic latitude in radians
   */
  forward(phi) {
    return this.applyCoefficients(phi, GEODETIC_TO_AUTHALIC);
  }
  /**
   * Converts authalic latitude to geodetic latitude
   * @param phi Authalic latitude in radians
   * @returns Geodetic latitude in radians
   */
  inverse(phi) {
    return this.applyCoefficients(phi, AUTHALIC_TO_GEODETIC);
  }
};
common_exports.setMatrixArrayType(Float64Array);
var authalic = new AuthalicProjection();
function degToRad(deg) {
  return deg * (Math.PI / 180);
}
function radToDeg(rad) {
  return rad * (180 / Math.PI);
}
function toPolar(xy) {
  const rho = vec2_exports.length(xy);
  const gamma = Math.atan2(xy[1], xy[0]);
  return [rho, gamma];
}
function toFace([rho, gamma]) {
  const x = rho * Math.cos(gamma);
  const y = rho * Math.sin(gamma);
  return [x, y];
}
function faceToBarycentric(p, [p1, p2, p3]) {
  const d31 = [p1[0] - p3[0], p1[1] - p3[1]];
  const d23 = [p3[0] - p2[0], p3[1] - p2[1]];
  const d3p = [p[0] - p3[0], p[1] - p3[1]];
  const det = d23[0] * d31[1] - d23[1] * d31[0];
  const b0 = (d23[0] * d3p[1] - d23[1] * d3p[0]) / det;
  const b1 = (d31[0] * d3p[1] - d31[1] * d3p[0]) / det;
  const b2 = 1 - (b0 + b1);
  return [b0, b1, b2];
}
function barycentricToFace(b2, [p1, p2, p3]) {
  return [
    b2[0] * p1[0] + b2[1] * p2[0] + b2[2] * p3[0],
    b2[0] * p1[1] + b2[1] * p2[1] + b2[2] * p3[1]
  ];
}
function toSpherical(xyz) {
  const theta = Math.atan2(xyz[1], xyz[0]);
  const r = Math.sqrt(xyz[0] * xyz[0] + xyz[1] * xyz[1] + xyz[2] * xyz[2]);
  const phi = Math.acos(xyz[2] / r);
  return [theta, phi];
}
function toCartesian([theta, phi]) {
  const sinPhi = Math.sin(phi);
  const x = sinPhi * Math.cos(theta);
  const y = sinPhi * Math.sin(theta);
  const z = Math.cos(phi);
  return [x, y, z];
}
var LONGITUDE_OFFSET = 93;
function fromLonLat([longitude, latitude]) {
  const theta = degToRad(longitude + LONGITUDE_OFFSET);
  const geodeticLat = degToRad(latitude);
  const authalicLat = authalic.forward(geodeticLat);
  const phi = Math.PI / 2 - authalicLat;
  return [theta, phi];
}
function toLonLat([theta, phi]) {
  const longitude = radToDeg(theta) - LONGITUDE_OFFSET;
  const authalicLat = Math.PI / 2 - phi;
  const geodeticLat = authalic.inverse(authalicLat);
  const latitude = radToDeg(geodeticLat);
  return [longitude, latitude];
}
function normalizeLongitudes(contour) {
  const points = contour.map((lonLat) => toCartesian(fromLonLat(lonLat)));
  const center2 = vec3_exports2.create();
  for (const point2 of points) {
    vec3_exports2.add(center2, center2, point2);
  }
  vec3_exports2.normalize(center2, center2);
  let [centerLon, centerLat] = toLonLat(toSpherical(center2));
  if (centerLat > 89.99 || centerLat < -89.99) {
    centerLon = contour[0][0];
  }
  centerLon = ((centerLon + 180) % 360 + 360) % 360 - 180;
  return contour.map((point2) => {
    let [longitude, latitude] = point2;
    while (longitude - centerLon > 180) longitude = longitude - 360;
    while (longitude - centerLon < -180) longitude = longitude + 360;
    return [longitude, latitude];
  });
}
common_exports.setMatrixArrayType(Float64Array);
var SQRT5 = Math.sqrt(5);
var INV_SQRT5 = Math.sqrt(0.2);
var sinAlpha = Math.sqrt((1 - INV_SQRT5) / 2);
var cosAlpha = Math.sqrt((1 + INV_SQRT5) / 2);
var A = 0.5;
var B = Math.sqrt((2.5 - SQRT5) / 10);
var C = Math.sqrt((2.5 + SQRT5) / 10);
var D = Math.sqrt((1 + INV_SQRT5) / 8);
var E = Math.sqrt((1 - INV_SQRT5) / 8);
var F = Math.sqrt((3 - SQRT5) / 8);
var G = Math.sqrt((3 + SQRT5) / 8);
var faceCenters = [
  [0, 0],
  // Doesn't actually matter as rotation is 0
  // First ring: five vertices, CCW, multiplied by sinAlpha
  [sinAlpha, 0],
  // [cos0, sin0]
  [B, A],
  // [cos72, sin72]
  [-D, F],
  // [-cos36, sin36]
  [-D, -F],
  // [-cos36, -sin36]
  [B, -A],
  // [cos72, -sin72]
  // Second ring: the same five vertices but negated (180deg rotation), multiplied by cosAlpha
  [-cosAlpha, 0],
  // [-cos0, -sin0]
  [-E, -G],
  // [-cos72, -sin72]
  [C, -A],
  // [cos36, -sin36]
  [C, A],
  // [cos36, sin36]
  [-E, G],
  // [-cos72, sin72]
  [0, 0]
];
var axes = faceCenters.map(([x, y]) => [-y, x]);
var quaternions = axes.map((axis, i) => {
  if (i === 0) return [0, 0, 0, 1];
  if (i === 11) return [0, -1, 0, 0];
  return [...axis, 0, i < 6 ? cosAlpha : sinAlpha];
});
common_exports.setMatrixArrayType(Float64Array);
var clockwiseFan = ["vu", "uw", "vw", "vw", "vw"];
var clockwiseStep = ["wu", "uw", "vw", "vu", "uw"];
var counterStep = ["wu", "uv", "wv", "wu", "uw"];
var counterJump = ["vu", "uv", "wv", "wu", "uw"];
var QUINTANT_ORIENTATIONS = [
  clockwiseFan,
  // 0 Arctic
  counterJump,
  // 1 North America
  counterStep,
  // 2 South America
  clockwiseStep,
  // 3 North Atlantic & Western Europe & Africa
  counterStep,
  // 4 South Atlantic & Africa
  counterJump,
  // 5 Europe, Middle East & CentralAfrica
  counterStep,
  // 6 Indian Ocean
  clockwiseStep,
  // 7 Asia
  clockwiseStep,
  // 8 Australia
  clockwiseStep,
  // 9 North Pacific
  counterJump,
  // 10 South Pacific
  counterJump
  // 11 Antarctic
];
var QUINTANT_FIRST = [4, 2, 3, 2, 0, 4, 3, 2, 2, 0, 3, 0];
var ORIGIN_ORDER = [0, 1, 2, 4, 3, 5, 7, 8, 6, 11, 10, 9];
var origins = [];
function generateOrigins() {
  addOrigin([0, 0], 0, quaternions[0]);
  for (let i = 0; i < 5; i++) {
    const alpha = i * TWO_PI_OVER_5;
    const alpha2 = alpha + PI_OVER_5;
    addOrigin([alpha, interhedralAngle], PI_OVER_5, quaternions[i + 1]);
    addOrigin([alpha2, Math.PI - interhedralAngle], PI_OVER_5, quaternions[(i + 3) % 5 + 6]);
  }
  addOrigin([0, Math.PI], 0, quaternions[11]);
}
var originId = 0;
function addOrigin(axis, angle3, quaternion) {
  if (originId > 11) {
    throw new Error(`Too many origins: ${originId}`);
  }
  const inverseQuat = quat_exports.create();
  quat_exports.conjugate(inverseQuat, quaternion);
  const origin = {
    id: originId,
    axis,
    quat: quaternion,
    inverseQuat,
    angle: angle3,
    orientation: QUINTANT_ORIENTATIONS[originId],
    firstQuintant: QUINTANT_FIRST[originId]
  };
  origins.push(origin);
  originId++;
}
generateOrigins();
origins.sort((a2, b2) => ORIGIN_ORDER.indexOf(a2.id) - ORIGIN_ORDER.indexOf(b2.id));
origins.forEach((origin, i) => origin.id = i);
function segmentToQuintant(segment, origin) {
  const layout = origin.orientation;
  const step = layout === clockwiseFan || layout === clockwiseStep ? -1 : 1;
  const faceRelativeQuintant = (segment - origin.firstQuintant + 5) % 5;
  const orientation = layout[faceRelativeQuintant];
  const quintant = (origin.firstQuintant + step * faceRelativeQuintant + 5) % 5;
  return { quintant, orientation };
}
var GnomonicProjection = class {
  /**
   * Projects spherical coordinates to polar coordinates using gnomonic projection
   * @param spherical Spherical coordinates [theta, phi]
   * @returns Polar coordinates [rho, gamma]
   */
  forward([theta, phi]) {
    return [Math.tan(phi), theta];
  }
  /**
   * Unprojects polar coordinates to spherical coordinates using gnomonic projection
   * @param polar Polar coordinates [rho, gamma]
   * @returns Spherical coordinates [theta, phi]
   */
  inverse([rho, gamma]) {
    return [gamma, Math.atan(rho)];
  }
};
var midpointAB = vec3_exports2.create();
var crossCD = vec3_exports2.create();
var scaledA = vec3_exports2.create();
var scaledB = vec3_exports2.create();
function vectorDifference(A2, B2) {
  vec3_exports2.lerp(midpointAB, A2, B2, 0.5);
  vec3_exports2.normalize(midpointAB, midpointAB);
  vec3_exports2.cross(midpointAB, A2, midpointAB);
  const D2 = vec3_exports2.length(midpointAB);
  if (D2 < 1e-8) {
    const AB = vec3_exports2.subtract(vec3_exports2.create(), A2, B2);
    const halfDistance = 0.5 * vec3_exports2.length(AB);
    return halfDistance;
  }
  return D2;
}
function tripleProduct(A2, B2, C2) {
  vec3_exports2.cross(crossCD, B2, C2);
  return vec3_exports2.dot(A2, crossCD);
}
function quadrupleProduct(out, A2, B2, C2, D2) {
  vec3_exports2.cross(crossCD, C2, D2);
  const tripleProductACD = vec3_exports2.dot(A2, crossCD);
  const tripleProductBCD = vec3_exports2.dot(B2, crossCD);
  vec3_exports2.scale(scaledA, A2, tripleProductBCD);
  vec3_exports2.scale(scaledB, B2, tripleProductACD);
  return vec3_exports2.sub(out, scaledB, scaledA);
}
function slerp2(out, A2, B2, t) {
  const gamma = vec3_exports2.angle(A2, B2);
  if (gamma < 1e-12) {
    return vec3_exports2.lerp(out, A2, B2, t);
  }
  const weightA = Math.sin((1 - t) * gamma) / Math.sin(gamma);
  const weightB = Math.sin(t * gamma) / Math.sin(gamma);
  const scaledA2 = vec3_exports2.scale(vec3_exports2.create(), A2, weightA);
  const scaledB2 = vec3_exports2.scale(vec3_exports2.create(), B2, weightB);
  return vec3_exports2.add(out, scaledA2, scaledB2);
}
common_exports.setMatrixArrayType(Float64Array);
var midA = vec3_exports2.create();
var midB = vec3_exports2.create();
var midC = vec3_exports2.create();
var center = vec3_exports2.create();
var SphericalPolygonShape = class {
  constructor(vertices) {
    this._area = null;
    this.vertices = vertices;
    Object.freeze(this.vertices);
  }
  /**
   * 
   * @param nSegments Returns a closed boundary of the polygon, with nSegments points per edge
   * @returns SphericalPolygon
   */
  getBoundary(nSegments = 1, closedRing = true) {
    const points = [];
    const N = this.vertices.length;
    for (let s = 0; s < N * nSegments; s++) {
      const t = s / nSegments;
      points.push(this.slerp(t));
    }
    if (closedRing) {
      points.push(points[0]);
    }
    return points;
  }
  /**
   * Interpolates along boundary of polygon. Pass t = 1.5 to get the midpoint between 2nd and 3rd vertices
   * @param t 
   * @returns Cartesian coordinate
   */
  slerp(t) {
    const N = this.vertices.length;
    const f = t % 1;
    const i = Math.floor(t % N);
    const j = (i + 1) % N;
    return slerp2(vec3_exports2.create(), this.vertices[i], this.vertices[j], f);
  }
  /**
   * Returns the vertex given by index t, along with the vectors:
   * - VA: Vector from vertex to point A
   * - VB: Vector from vertex to point B
   * @param t 
   * @returns 
   */
  getTransformedVertices(t) {
    const N = this.vertices.length;
    const i = Math.floor(t % N);
    const j = (i + 1) % N;
    const k = (i + N - 1) % N;
    const V2 = vec3_exports2.clone(this.vertices[i]);
    const VA = vec3_exports2.clone(this.vertices[j]);
    const VB = vec3_exports2.clone(this.vertices[k]);
    vec3_exports2.sub(VA, VA, V2);
    vec3_exports2.sub(VB, VB, V2);
    return [V2, VA, VB];
  }
  containsPoint(point2) {
    const N = this.vertices.length;
    let thetaDeltaMin = Infinity;
    for (let i = 0; i < N; i++) {
      const [V2, VA, VB] = this.getTransformedVertices(i);
      const VP = vec3_exports2.sub(vec3_exports2.create(), point2, V2);
      vec3_exports2.normalize(VP, VP);
      vec3_exports2.normalize(VA, VA);
      vec3_exports2.normalize(VB, VB);
      const crossAP = vec3_exports2.cross(vec3_exports2.create(), VA, VP);
      const crossPB = vec3_exports2.cross(vec3_exports2.create(), VP, VB);
      const sinAP = vec3_exports2.dot(V2, crossAP);
      const sinPB = vec3_exports2.dot(V2, crossPB);
      thetaDeltaMin = Math.min(thetaDeltaMin, sinAP, sinPB);
    }
    return thetaDeltaMin;
  }
  /**
   * Calculate the area of a spherical triangle given three vertices
   * @param v1 First vertex
   * @param v2 Second vertex  
   * @param v3 Third vertex
   * @returns Area of the spherical triangle in radians
   */
  getTriangleArea(v1, v2, v3) {
    vec3_exports2.lerp(midA, v2, v3, 0.5);
    vec3_exports2.lerp(midB, v3, v1, 0.5);
    vec3_exports2.lerp(midC, v1, v2, 0.5);
    vec3_exports2.normalize(midA, midA);
    vec3_exports2.normalize(midB, midB);
    vec3_exports2.normalize(midC, midC);
    const S = tripleProduct(midA, midB, midC);
    const clamped = Math.max(-1, Math.min(1, S));
    if (Math.abs(clamped) < 1e-8) {
      return 2 * clamped;
    } else {
      return Math.asin(clamped) * 2;
    }
  }
  /**
   * Calculate the area of the spherical polygon by decomposing it into a fan of triangles
   * @returns The area of the spherical polygon in radians
   */
  getArea() {
    if (this._area === null) {
      this._area = this._getArea();
    }
    return this._area;
  }
  _getArea() {
    if (this.vertices.length < 3) {
      return 0;
    }
    if (this.vertices.length === 3) {
      this._area = this.getTriangleArea(this.vertices[0], this.vertices[1], this.vertices[2]);
      return this._area;
    }
    vec3_exports2.set(center, 0, 0, 0);
    for (const vertex4 of this.vertices) {
      vec3_exports2.add(center, center, vertex4);
    }
    vec3_exports2.normalize(center, center);
    let area2 = 0;
    for (let i = 0; i < this.vertices.length; i++) {
      const v1 = this.vertices[i];
      const v2 = this.vertices[(i + 1) % this.vertices.length];
      const triArea = this.getTriangleArea(center, v1, v2);
      if (!isNaN(triArea)) {
        area2 += triArea;
      }
    }
    this._area = area2;
    return this._area;
  }
  /**
   * For debugging purposes, check if the winding order is correct
   * In production, should always be correct
   */
  isWindingCorrect() {
    const area2 = this.getArea();
    const isCorrect = area2 > 0;
    if (!isCorrect) {
      debugger;
    }
  }
};
common_exports.setMatrixArrayType(Float64Array);
var SphericalTriangleShape = class extends SphericalPolygonShape {
  constructor(vertices) {
    if (vertices.length !== 3) {
      throw new Error("SphericalTriangleShape requires exactly 3 vertices");
    }
    super(vertices);
  }
};
common_exports.setMatrixArrayType(Float64Array);
var PolyhedralProjection = class {
  /**
   * Forward projection: converts a spherical point to face coordinates
   * @param v - The spherical point to project
   * @param sphericalTriangle - The spherical triangle vertices
   * @param faceTriangle - The face triangle vertices
   * @returns The face coordinates
   */
  forward(v2, sphericalTriangle, faceTriangle) {
    const [A2, B2, C2] = sphericalTriangle;
    const triangleShape = new SphericalTriangleShape([A2, B2, C2]);
    const Z = vec3_exports2.subtract(vec3_exports2.create(), v2, A2);
    vec3_exports2.normalize(Z, Z);
    const p = quadrupleProduct(vec3_exports2.create(), A2, Z, B2, C2);
    vec3_exports2.normalize(p, p);
    const h = vectorDifference(A2, v2) / vectorDifference(A2, p);
    const Area_ABC = triangleShape.getArea();
    const scaledArea = h / Area_ABC;
    const b2 = [
      1 - h,
      scaledArea * new SphericalTriangleShape([A2, p, C2]).getArea(),
      scaledArea * new SphericalTriangleShape([A2, B2, p]).getArea()
    ];
    return barycentricToFace(b2, faceTriangle);
  }
  /**
   * Inverse projection: converts face coordinates back to spherical coordinates
   * @param facePoint - The face coordinates
   * @param faceTriangle - The face triangle vertices
   * @param sphericalTriangle - The spherical triangle vertices
   * @returns The spherical coordinates
   */
  inverse(facePoint, faceTriangle, sphericalTriangle) {
    const [A2, B2, C2] = sphericalTriangle;
    const triangleShape = new SphericalTriangleShape([A2, B2, C2]);
    const b2 = faceToBarycentric(facePoint, faceTriangle);
    const threshold = 1 - 1e-14;
    if (b2[0] > threshold) return A2;
    if (b2[1] > threshold) return B2;
    if (b2[2] > threshold) return C2;
    const c1 = vec3_exports2.create();
    vec3_exports2.cross(c1, B2, C2);
    const Area_ABC = triangleShape.getArea();
    const h = 1 - b2[0];
    const R = b2[2] / h;
    const alpha = R * Area_ABC;
    const S = Math.sin(alpha);
    const halfC = Math.sin(alpha / 2);
    const CC = 2 * halfC * halfC;
    const c01 = vec3_exports2.dot(A2, B2);
    const c12 = vec3_exports2.dot(B2, C2);
    const c20 = vec3_exports2.dot(C2, A2);
    const s12 = vec3_exports2.length(c1);
    const V2 = vec3_exports2.dot(A2, c1);
    const f = S * V2 + CC * (c01 * c12 - c20);
    const g = CC * s12 * (1 + c01);
    const q = 2 / Math.acos(c12) * Math.atan2(g, f);
    const P = slerp2(vec3_exports2.create(), B2, C2, q);
    const K = vectorDifference(A2, P);
    const t = this.safeAcos(h * K) / this.safeAcos(K);
    const out = slerp2([0, 0, 0], A2, P, t);
    return out;
  }
  /**
   * Computes acos(1 - 2 * x * x) without loss of precision for small x
   * @param x 
   * @returns acos(1 - x)
   */
  safeAcos(x) {
    if (x < 1e-3) {
      return 2 * x + x * x * x / 3;
    } else {
      return Math.acos(1 - 2 * x * x);
    }
  }
};
common_exports.setMatrixArrayType(Float64Array);
var YES = -1;
var NO = 1;
var KJToIJ = ([k, j]) => {
  return vec2_exports.fromValues(k - j, j);
};
var kPos = vec2_exports.fromValues(1, 0);
var jPos = vec2_exports.fromValues(0, 1);
var kNeg = vec2_exports.negate(vec2_exports.create(), kPos);
var jNeg = vec2_exports.negate(vec2_exports.create(), jPos);
var ZERO = vec2_exports.fromValues(0, 0);
var quaternaryToKJ = (n, [flipX, flipY]) => {
  let p = ZERO;
  let q = ZERO;
  if (flipX === NO && flipY === NO) {
    p = kPos;
    q = jPos;
  } else if (flipX === YES && flipY === NO) {
    p = jNeg;
    q = kNeg;
  } else if (flipX === NO && flipY === YES) {
    p = jPos;
    q = kPos;
  } else if (flipX === YES && flipY === YES) {
    p = kNeg;
    q = jNeg;
  }
  switch (n) {
    case 0:
      return ZERO;
    // Length 0
    case 1:
      return p;
    // Length 1
    case 2:
      return vec2_exports.add(vec2_exports.create(), q, p);
    // Length SQRT2
    case 3:
      return vec2_exports.scaleAndAdd(vec2_exports.create(), q, p, 2);
    // Length SQRT5
    default:
      throw new Error(`Invalid Quaternary value: ${n}`);
  }
};
var quaternaryToFlips = (n) => {
  return [[NO, NO], [NO, YES], [NO, NO], [YES, NO]][n];
};
var FLIP_SHIFT = vec2_exports.fromValues(-1, 1);
function reversePattern(pattern) {
  return Array.from({ length: pattern.length }, (_, i) => pattern.indexOf(i));
}
var PATTERN = [0, 1, 3, 4, 5, 6, 7, 2];
var PATTERN_FLIPPED = [0, 1, 2, 7, 3, 4, 5, 6];
var PATTERN_REVERSED = reversePattern(PATTERN);
var PATTERN_FLIPPED_REVERSED = reversePattern(PATTERN_FLIPPED);
var _shiftDigits = (digits, i, flips, invertJ, pattern) => {
  if (i <= 0) return;
  const parentK = digits[i] || 0;
  const childK = digits[i - 1];
  const F2 = flips[0] + flips[1];
  let needsShift = true;
  let first = true;
  if (invertJ !== (F2 === 0)) {
    needsShift = parentK === 1 || parentK === 2;
    first = parentK === 1;
  } else {
    needsShift = parentK < 2;
    first = parentK === 0;
  }
  if (!needsShift) return;
  const src = first ? childK : childK + 4;
  const dst = pattern[src];
  digits[i - 1] = dst % 4;
  digits[i] = (parentK + 4 + Math.floor(dst / 4) - Math.floor(src / 4)) % 4;
};
var sToAnchor = (s, resolution, orientation) => {
  let input = BigInt(s);
  const reverse = orientation === "vu" || orientation === "wu" || orientation === "vw";
  const invertJ = orientation === "wv" || orientation === "vw";
  const flipIJ = orientation === "wu" || orientation === "uw";
  if (reverse) {
    input = (1n << BigInt(2 * resolution)) - input - 1n;
  }
  const anchor = _sToAnchor(input, resolution, invertJ, flipIJ);
  if (flipIJ) {
    const { offset: [_i, _j], flips: [flipX, flipY] } = anchor;
    anchor.offset = [_j, _i];
    if (flipX === YES) vec2_exports.add(anchor.offset, anchor.offset, FLIP_SHIFT);
    if (flipY === YES) vec2_exports.subtract(anchor.offset, anchor.offset, FLIP_SHIFT);
  }
  if (invertJ) {
    const { offset: [i, _j], flips } = anchor;
    const j = (1 << resolution) - (i + _j);
    flips[0] = -flips[0];
    anchor.offset[1] = j;
    anchor.flips = flips;
  }
  return anchor;
};
var _sToAnchor = (s, resolution, invertJ, flipIJ) => {
  const offset = vec2_exports.create();
  const flips = [NO, NO];
  let input = BigInt(s);
  const digits = [];
  while (input > 0n || digits.length < resolution) {
    digits.push(Number(input % 4n));
    input = input >> 2n;
  }
  const pattern = flipIJ ? PATTERN_FLIPPED : PATTERN;
  for (let i = digits.length - 1; i >= 0; i--) {
    _shiftDigits(digits, i, flips, invertJ, pattern);
    vec2_exports.multiply(flips, flips, quaternaryToFlips(digits[i]));
  }
  flips[0] = NO;
  flips[1] = NO;
  for (let i = digits.length - 1; i >= 0; i--) {
    vec2_exports.scale(offset, offset, 2);
    const childOffset = quaternaryToKJ(digits[i], flips);
    vec2_exports.add(offset, offset, childOffset);
    vec2_exports.multiply(flips, flips, quaternaryToFlips(digits[i]));
  }
  const k = digits[0] || 0;
  return { flips, k, offset: KJToIJ(offset) };
};
common_exports.setMatrixArrayType(Float64Array);
var TRIANGLE_MODE = false;
var shiftRight = vec2_exports.clone(w);
var shiftLeft = vec2_exports.negate(vec2_exports.create(), w);
var QUINTANT_ROTATIONS = [0, 1, 2, 3, 4].map((quintant) => {
  const rotation2 = mat2_exports.create();
  mat2_exports.fromRotation(rotation2, TWO_PI_OVER_5 * quintant);
  return rotation2;
});
var translation = vec2_exports.create();
function getPentagonVertices(resolution, quintant, anchor) {
  const pentagon = (TRIANGLE_MODE ? TRIANGLE : PENTAGON).clone();
  vec2_exports.transformMat2(translation, anchor.offset, BASIS);
  if (anchor.flips[0] === NO && anchor.flips[1] === YES) {
    pentagon.rotate180();
  }
  const { k } = anchor;
  const F2 = anchor.flips[0] + anchor.flips[1];
  if (
    // Orient last two pentagons when both or neither flips are YES
    (F2 === -2 || F2 === 2) && k > 1 || // Orient first & last pentagons when only one of flips is YES
    F2 === 0 && (k === 0 || k === 3)
  ) {
    pentagon.reflectY();
  }
  if (anchor.flips[0] === YES && anchor.flips[1] === YES) {
    pentagon.rotate180();
  } else if (anchor.flips[0] === YES) {
    pentagon.translate(shiftLeft);
  } else if (anchor.flips[1] === YES) {
    pentagon.translate(shiftRight);
  }
  pentagon.translate(translation);
  pentagon.scale(1 / 2 ** resolution);
  pentagon.transform(QUINTANT_ROTATIONS[quintant]);
  return pentagon;
}
function getQuintantVertices(quintant) {
  const triangle = TRIANGLE.clone();
  triangle.transform(QUINTANT_ROTATIONS[quintant]);
  return triangle;
}
function getFaceVertices() {
  const vertices = [];
  for (const rotation2 of QUINTANT_ROTATIONS) {
    vertices.push(vec2_exports.transformMat2(vec2_exports.create(), v, rotation2));
  }
  vertices.reverse();
  return new PentagonShape(vertices);
}
common_exports.setMatrixArrayType(Float64Array);
var CRS = class {
  constructor() {
    this.vertices = [];
    this.invocations = 0;
    this.addFaceCenters();
    this.addVertices();
    this.addMidpoints();
    if (this.vertices.length !== 62) {
      throw new Error("Failed to construct CRS: vertices length is not 62");
    }
    Object.freeze(this.vertices);
  }
  getVertex(point2) {
    this.invocations++;
    if (this.invocations === 1e4) {
      console.warn("Too many CRS invocations, results should be cached");
    }
    for (const vertex4 of this.vertices) {
      if (vec3_exports2.distance(point2, vertex4) < 1e-5) {
        return vertex4;
      }
    }
    throw new Error("Failed to find vertex in CRS");
  }
  addFaceCenters() {
    origins.forEach((origin) => this.add(toCartesian(origin.axis)));
  }
  addVertices() {
    const phiVertex = Math.atan(distanceToVertex);
    for (const origin of origins) {
      for (let i = 0; i < 5; i++) {
        const thetaVertex = (2 * i + 1) * Math.PI / 5;
        const vertex4 = toCartesian([thetaVertex + origin.angle, phiVertex]);
        vec3_exports2.transformQuat(vertex4, vertex4, origin.quat);
        this.add(vertex4);
      }
    }
  }
  addMidpoints() {
    const phiMidpoint = Math.atan(distanceToEdge);
    for (const origin of origins) {
      for (let i = 0; i < 5; i++) {
        const thetaMidpoint = 2 * i * Math.PI / 5;
        const midpoint = toCartesian([thetaMidpoint + origin.angle, phiMidpoint]);
        vec3_exports2.transformQuat(midpoint, midpoint, origin.quat);
        this.add(midpoint);
      }
    }
  }
  add(newVertex) {
    const normalized = vec3_exports2.normalize(vec3_exports2.create(), newVertex);
    const existingVertex = this.vertices.find((existingVertex2) => vec3_exports2.distance(normalized, existingVertex2) < 1e-5);
    if (existingVertex) {
      return false;
    }
    this.vertices.push(normalized);
    return true;
  }
};
common_exports.setMatrixArrayType(Float64Array);
var crs = new CRS();
var DodecahedronProjection = class {
  constructor() {
    this.faceTriangles = [];
    this.sphericalTriangles = [];
    this.polyhedral = new PolyhedralProjection();
    this.gnomonic = new GnomonicProjection();
  }
  /**
   * Projects spherical coordinates to face coordinates using dodecahedron projection
   * @param spherical Spherical coordinates [theta, phi]
   * @param originId Origin ID
   * @returns Face coordinates [x, y]
   */
  forward(spherical, originId2) {
    const origin = origins[originId2];
    const unprojected = toCartesian(spherical);
    const out = vec3_exports2.create();
    vec3_exports2.transformQuat(out, unprojected, origin.inverseQuat);
    const projectedSpherical = toSpherical(out);
    const polar = this.gnomonic.forward(projectedSpherical);
    polar[1] = polar[1] - origin.angle;
    const faceTriangleIndex = this.getFaceTriangleIndex(polar);
    const reflect = this.shouldReflect(polar);
    let faceTriangle = this.getFaceTriangle(faceTriangleIndex, reflect, false);
    let sphericalTriangle = this.getSphericalTriangle(faceTriangleIndex, originId2, reflect);
    return this.polyhedral.forward(unprojected, sphericalTriangle, faceTriangle);
  }
  /**
   * Unprojects face coordinates to spherical coordinates using dodecahedron projection
   * @param face Face coordinates [x, y]
   * @param originId Origin ID
   * @returns Spherical coordinates [theta, phi]
   */
  inverse(face, originId2) {
    const polar = toPolar(face);
    const faceTriangleIndex = this.getFaceTriangleIndex(polar);
    const reflect = this.shouldReflect(polar);
    const faceTriangle = this.getFaceTriangle(faceTriangleIndex, reflect, false);
    const sphericalTriangle = this.getSphericalTriangle(faceTriangleIndex, originId2, reflect);
    const unprojected = this.polyhedral.inverse(face, faceTriangle, sphericalTriangle);
    return toSpherical(unprojected);
  }
  /**
   * Detects when point is beyond the edge of the dodecahedron face
   * In the standard case (reflect = false), the face and spherical triangle can be
   * used directly.
   * In the reflected case (reflect = true), the point is beyond the edge of the dodecahedron face,
   * and so the face triangle is squashed to unproject correctly onto the neighboring dodecahedron face.
   * @param polar Polar coordinates
   * @returns True if point is beyond the edge of the dodecahedron face
   */
  shouldReflect(polar) {
    const [rho, gamma] = polar;
    const D2 = toFace([rho, this.normalizeGamma(gamma)])[0];
    return D2 > distanceToEdge;
  }
  /**
   * Given a polar coordinate, returns the index of the face triangle it belongs to
   * @param polar Polar coordinates
   * @returns Face triangle index, value from 0 to 9
   */
  getFaceTriangleIndex([_, gamma]) {
    return (Math.floor(gamma / PI_OVER_5) + 10) % 10;
  }
  /**
   * Gets the face triangle for a given polar coordinate
   * @param faceTriangleIndex Face triangle index, value from 0 to 9
   * @returns FaceTriangle: 3 vertices in counter-clockwise order
   */
  getFaceTriangle(faceTriangleIndex, reflected = false, squashed = false) {
    let index = faceTriangleIndex;
    if (reflected) {
      index += squashed ? 20 : 10;
    }
    if (this.faceTriangles[index]) {
      return this.faceTriangles[index];
    }
    this.faceTriangles[index] = reflected ? this._getReflectedFaceTriangle(faceTriangleIndex, squashed) : this._getFaceTriangle(faceTriangleIndex);
    Object.freeze(this.faceTriangles[index]);
    return this.faceTriangles[index];
  }
  _getFaceTriangle(faceTriangleIndex) {
    const quintant = Math.floor((faceTriangleIndex + 1) / 2) % 5;
    const [vCenter, vCorner1, vCorner2] = getQuintantVertices(quintant).getVertices();
    const vEdgeMidpoint = vec2_exports.create();
    vec2_exports.lerp(vEdgeMidpoint, vCorner1, vCorner2, 0.5);
    const even = faceTriangleIndex % 2 === 0;
    return even ? [vCenter, vEdgeMidpoint, vCorner1] : [vCenter, vCorner2, vEdgeMidpoint];
  }
  _getReflectedFaceTriangle(faceTriangleIndex, squashed = false) {
    let [A2, B2, C2] = this._getFaceTriangle(faceTriangleIndex).map((face) => vec2_exports.clone(face));
    const even = faceTriangleIndex % 2 === 0;
    vec2_exports.negate(A2, A2);
    const midpoint = even ? B2 : C2;
    vec2_exports.scaleAndAdd(A2, A2, midpoint, squashed ? 1 + 1 / Math.cos(interhedralAngle) : 2);
    return [A2, C2, B2];
  }
  /**
   * Gets the spherical triangle for a given face triangle index and origin
   * @param faceTriangleIndex Face triangle index
   * @param originId Origin ID
   * @returns Spherical triangle
   */
  getSphericalTriangle(faceTriangleIndex, originId2, reflected = false) {
    let index = 10 * originId2 + faceTriangleIndex;
    if (reflected) {
      index += 120;
    }
    if (this.sphericalTriangles[index]) {
      return this.sphericalTriangles[index];
    }
    this.sphericalTriangles[index] = this._getSphericalTriangle(faceTriangleIndex, originId2, reflected);
    Object.freeze(this.sphericalTriangles[index]);
    return this.sphericalTriangles[index];
  }
  _getSphericalTriangle(faceTriangleIndex, originId2, reflected = false) {
    const origin = origins[originId2];
    const faceTriangle = this.getFaceTriangle(faceTriangleIndex, reflected, true);
    const sphericalTriangle = faceTriangle.map((face) => {
      const [rho, gamma] = toPolar(face);
      const rotatedPolar = [rho, gamma + origin.angle];
      const rotated = toCartesian(this.gnomonic.inverse(rotatedPolar));
      vec3_exports2.transformQuat(rotated, rotated, origin.quat);
      return crs.getVertex(rotated);
    });
    return sphericalTriangle;
  }
  /**
   * Normalizes gamma to the range [-PI_OVER_5, PI_OVER_5]
   * @param gamma The gamma value to normalize
   * @returns Normalized gamma value
   */
  normalizeGamma(gamma) {
    const segment = gamma / TWO_PI_OVER_5;
    const sCenter = Math.round(segment);
    const sOffset = segment - sCenter;
    const beta = sOffset * TWO_PI_OVER_5;
    return beta;
  }
};
var FIRST_HILBERT_RESOLUTION = 2;
var MAX_RESOLUTION = 30;
var HILBERT_START_BIT = 58n;
var REMOVAL_MASK = 0x3ffffffffffffffn;
function getResolution(index) {
  let resolution = MAX_RESOLUTION - 1;
  let shifted = index >> 1n;
  while (resolution > -1 && (shifted & 0b1n) === 0n) {
    resolution -= 1;
    shifted = shifted >> (resolution < FIRST_HILBERT_RESOLUTION ? 1n : 2n);
  }
  return resolution;
}
function deserialize(index) {
  const resolution = getResolution(index);
  if (resolution === -1) {
    return { origin: origins[0], segment: 0, S: 0n, resolution };
  }
  const top6Bits = Number(index >> 58n);
  let origin, segment;
  if (resolution === 0) {
    const originId2 = top6Bits;
    origin = origins[originId2];
    segment = 0;
  } else {
    const originId2 = Math.floor(top6Bits / 5);
    origin = origins[originId2];
    segment = (top6Bits + origin.firstQuintant) % 5;
  }
  if (!origin) {
    throw new Error(`Could not parse origin: ${top6Bits}`);
  }
  if (resolution < FIRST_HILBERT_RESOLUTION) {
    return { origin, segment, S: 0n, resolution };
  }
  const hilbertLevels = resolution - FIRST_HILBERT_RESOLUTION + 1;
  const hilbertBits = BigInt(2 * hilbertLevels);
  const shift = HILBERT_START_BIT - hilbertBits;
  const S = (index & REMOVAL_MASK) >> shift;
  return { origin, segment, S, resolution };
}
common_exports.setMatrixArrayType(Float64Array);
var rotation = mat2_exports.create();
var dodecahedron = new DodecahedronProjection();
function _getPentagon({ S, segment, origin, resolution }) {
  const { quintant, orientation } = segmentToQuintant(segment, origin);
  if (resolution === FIRST_HILBERT_RESOLUTION - 1) {
    const out = getQuintantVertices(quintant);
    return out;
  } else if (resolution === FIRST_HILBERT_RESOLUTION - 2) {
    return getFaceVertices();
  }
  const hilbertResolution = resolution - FIRST_HILBERT_RESOLUTION + 1;
  const anchor = sToAnchor(S, hilbertResolution, orientation);
  return getPentagonVertices(hilbertResolution, quintant, anchor);
}
function cellToBoundary(cellId, { closedRing = true, segments = "auto" } = { closedRing: true, segments: "auto" }) {
  const { S, segment, origin, resolution } = deserialize(cellId);
  if (segments === "auto") {
    segments = Math.max(1, Math.pow(2, 6 - resolution));
  }
  const pentagon = _getPentagon({ S, segment, origin, resolution });
  const splitPentagon = pentagon.splitEdges(segments);
  const vertices = splitPentagon.getVertices();
  const unprojectedVertices = vertices.map((vertex4) => dodecahedron.inverse(vertex4, origin.id));
  const boundary = unprojectedVertices.map((vertex4) => toLonLat(vertex4));
  const normalizedBoundary = normalizeLongitudes(boundary);
  if (closedRing) {
    normalizedBoundary.push(normalizedBoundary[0]);
  }
  normalizedBoundary.reverse();
  return normalizedBoundary;
}
function hexToU64(hex) {
  return BigInt(`0x${hex}`);
}
var AUTHALIC_RADIUS = 63710072e-1;
var AUTHALIC_AREA = 4 * Math.PI * AUTHALIC_RADIUS * AUTHALIC_RADIUS;
common_exports.setMatrixArrayType(Float64Array);

// node_modules/h3-js/dist/browser/h3-js.es.js
var libh3 = (function(libh32) {
  libh32 = libh32 || {};
  var Module = typeof libh32 !== "undefined" ? libh32 : {};
  var moduleOverrides = {};
  var key;
  for (key in Module) {
    if (Module.hasOwnProperty(key)) {
      moduleOverrides[key] = Module[key];
    }
  }
  var arguments_ = [];
  var scriptDirectory = "";
  function locateFile(path) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path, scriptDirectory);
    }
    return scriptDirectory + path;
  }
  var readAsync;
  {
    if (typeof document !== "undefined" && document.currentScript) {
      scriptDirectory = document.currentScript.src;
    }
    if (scriptDirectory.indexOf("blob:") !== 0) {
      scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf("/") + 1);
    } else {
      scriptDirectory = "";
    }
    readAsync = function readAsync2(url, onload, onerror) {
      var xhr = new XMLHttpRequest();
      xhr.open("GET", url, true);
      xhr.responseType = "arraybuffer";
      xhr.onload = function xhr_onload() {
        if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
          onload(xhr.response);
          return;
        }
        var data = tryParseAsDataURI(url);
        if (data) {
          onload(data.buffer);
          return;
        }
        onerror();
      };
      xhr.onerror = onerror;
      xhr.send(null);
    };
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.warn.bind(console);
  for (key in moduleOverrides) {
    if (moduleOverrides.hasOwnProperty(key)) {
      Module[key] = moduleOverrides[key];
    }
  }
  moduleOverrides = null;
  if (Module["arguments"]) {
    arguments_ = Module["arguments"];
  }
  var tempRet0 = 0;
  var setTempRet0 = function(value) {
    tempRet0 = value;
  };
  var getTempRet0 = function() {
    return tempRet0;
  };
  var GLOBAL_BASE = 8;
  function setValue(ptr, value, type, noSafe) {
    type = type || "i8";
    if (type.charAt(type.length - 1) === "*") {
      type = "i32";
    }
    switch (type) {
      case "i1":
        HEAP8[ptr >> 0] = value;
        break;
      case "i8":
        HEAP8[ptr >> 0] = value;
        break;
      case "i16":
        HEAP16[ptr >> 1] = value;
        break;
      case "i32":
        HEAP32[ptr >> 2] = value;
        break;
      case "i64":
        tempI64 = [value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];
        break;
      case "float":
        HEAPF32[ptr >> 2] = value;
        break;
      case "double":
        HEAPF64[ptr >> 3] = value;
        break;
      default:
        abort("invalid type for setValue: " + type);
    }
  }
  function getValue(ptr, type, noSafe) {
    type = type || "i8";
    if (type.charAt(type.length - 1) === "*") {
      type = "i32";
    }
    switch (type) {
      case "i1":
        return HEAP8[ptr >> 0];
      case "i8":
        return HEAP8[ptr >> 0];
      case "i16":
        return HEAP16[ptr >> 1];
      case "i32":
        return HEAP32[ptr >> 2];
      case "i64":
        return HEAP32[ptr >> 2];
      case "float":
        return HEAPF32[ptr >> 2];
      case "double":
        return HEAPF64[ptr >> 3];
      default:
        abort("invalid type for getValue: " + type);
    }
    return null;
  }
  var ABORT = false;
  function assert(condition, text) {
    if (!condition) {
      abort("Assertion failed: " + text);
    }
  }
  function getCFunc(ident) {
    var func = Module["_" + ident];
    assert(func, "Cannot call unknown function " + ident + ", make sure it is exported");
    return func;
  }
  function ccall(ident, returnType, argTypes, args, opts) {
    var toC = {
      "string": function(str5) {
        var ret2 = 0;
        if (str5 !== null && str5 !== void 0 && str5 !== 0) {
          var len4 = (str5.length << 2) + 1;
          ret2 = stackAlloc(len4);
          stringToUTF8(str5, ret2, len4);
        }
        return ret2;
      },
      "array": function(arr) {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      }
    };
    function convertReturnValue(ret2) {
      if (returnType === "string") {
        return UTF8ToString(ret2);
      }
      if (returnType === "boolean") {
        return Boolean(ret2);
      }
      return ret2;
    }
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack === 0) {
            stack = stackSave();
          }
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var ret = func.apply(null, cArgs);
    ret = convertReturnValue(ret);
    if (stack !== 0) {
      stackRestore(stack);
    }
    return ret;
  }
  function cwrap(ident, returnType, argTypes, opts) {
    argTypes = argTypes || [];
    var numericArgs = argTypes.every(function(type) {
      return type === "number";
    });
    var numericRet = returnType !== "string";
    if (numericRet && numericArgs && !opts) {
      return getCFunc(ident);
    }
    return function() {
      return ccall(ident, returnType, argTypes, arguments, opts);
    };
  }
  var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : void 0;
  function UTF8ArrayToString(u8Array, idx, maxBytesToRead) {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (u8Array[endPtr] && !(endPtr >= endIdx)) {
      ++endPtr;
    }
    if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {
      return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));
    } else {
      var str5 = "";
      while (idx < endPtr) {
        var u0 = u8Array[idx++];
        if (!(u0 & 128)) {
          str5 += String.fromCharCode(u0);
          continue;
        }
        var u1 = u8Array[idx++] & 63;
        if ((u0 & 224) == 192) {
          str5 += String.fromCharCode((u0 & 31) << 6 | u1);
          continue;
        }
        var u2 = u8Array[idx++] & 63;
        if ((u0 & 240) == 224) {
          u0 = (u0 & 15) << 12 | u1 << 6 | u2;
        } else {
          u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | u8Array[idx++] & 63;
        }
        if (u0 < 65536) {
          str5 += String.fromCharCode(u0);
        } else {
          var ch = u0 - 65536;
          str5 += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
        }
      }
    }
    return str5;
  }
  function UTF8ToString(ptr, maxBytesToRead) {
    return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  }
  function stringToUTF8Array(str5, outU8Array, outIdx, maxBytesToWrite) {
    if (!(maxBytesToWrite > 0)) {
      return 0;
    }
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i = 0; i < str5.length; ++i) {
      var u2 = str5.charCodeAt(i);
      if (u2 >= 55296 && u2 <= 57343) {
        var u1 = str5.charCodeAt(++i);
        u2 = 65536 + ((u2 & 1023) << 10) | u1 & 1023;
      }
      if (u2 <= 127) {
        if (outIdx >= endIdx) {
          break;
        }
        outU8Array[outIdx++] = u2;
      } else if (u2 <= 2047) {
        if (outIdx + 1 >= endIdx) {
          break;
        }
        outU8Array[outIdx++] = 192 | u2 >> 6;
        outU8Array[outIdx++] = 128 | u2 & 63;
      } else if (u2 <= 65535) {
        if (outIdx + 2 >= endIdx) {
          break;
        }
        outU8Array[outIdx++] = 224 | u2 >> 12;
        outU8Array[outIdx++] = 128 | u2 >> 6 & 63;
        outU8Array[outIdx++] = 128 | u2 & 63;
      } else {
        if (outIdx + 3 >= endIdx) {
          break;
        }
        outU8Array[outIdx++] = 240 | u2 >> 18;
        outU8Array[outIdx++] = 128 | u2 >> 12 & 63;
        outU8Array[outIdx++] = 128 | u2 >> 6 & 63;
        outU8Array[outIdx++] = 128 | u2 & 63;
      }
    }
    outU8Array[outIdx] = 0;
    return outIdx - startIdx;
  }
  function stringToUTF8(str5, outPtr, maxBytesToWrite) {
    return stringToUTF8Array(str5, HEAPU8, outPtr, maxBytesToWrite);
  }
  var UTF16Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-16le") : void 0;
  function writeArrayToMemory(array, buffer2) {
    HEAP8.set(array, buffer2);
  }
  function alignUp(x, multiple) {
    if (x % multiple > 0) {
      x += multiple - x % multiple;
    }
    return x;
  }
  var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
  function updateGlobalBufferAndViews(buf) {
    buffer = buf;
    Module["HEAP8"] = HEAP8 = new Int8Array(buf);
    Module["HEAP16"] = HEAP16 = new Int16Array(buf);
    Module["HEAP32"] = HEAP32 = new Int32Array(buf);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
    Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
    Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
    Module["HEAPF64"] = HEAPF64 = new Float64Array(buf);
  }
  var DYNAMIC_BASE = 5271536, DYNAMICTOP_PTR = 28624;
  var INITIAL_TOTAL_MEMORY = Module["TOTAL_MEMORY"] || 33554432;
  if (Module["buffer"]) {
    buffer = Module["buffer"];
  } else {
    buffer = new ArrayBuffer(INITIAL_TOTAL_MEMORY);
  }
  INITIAL_TOTAL_MEMORY = buffer.byteLength;
  updateGlobalBufferAndViews(buffer);
  HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;
  function callRuntimeCallbacks(callbacks) {
    while (callbacks.length > 0) {
      var callback = callbacks.shift();
      if (typeof callback == "function") {
        callback();
        continue;
      }
      var func = callback.func;
      if (typeof func === "number") {
        if (callback.arg === void 0) {
          Module["dynCall_v"](func);
        } else {
          Module["dynCall_vi"](func, callback.arg);
        }
      } else {
        func(callback.arg === void 0 ? null : callback.arg);
      }
    }
  }
  var __ATPRERUN__ = [];
  var __ATINIT__ = [];
  var __ATMAIN__ = [];
  var __ATPOSTRUN__ = [];
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function") {
        Module["preRun"] = [Module["preRun"]];
      }
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPRERUN__);
  }
  function initRuntime() {
    callRuntimeCallbacks(__ATINIT__);
  }
  function preMain() {
    callRuntimeCallbacks(__ATMAIN__);
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function") {
        Module["postRun"] = [Module["postRun"]];
      }
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPOSTRUN__);
  }
  function addOnPreRun(cb) {
    __ATPRERUN__.unshift(cb);
  }
  function addOnPostRun(cb) {
    __ATPOSTRUN__.unshift(cb);
  }
  var Math_abs = Math.abs;
  var Math_ceil = Math.ceil;
  var Math_floor = Math.floor;
  var Math_min = Math.min;
  var runDependencies = 0;
  var runDependencyWatcher = null;
  var dependenciesFulfilled = null;
  function addRunDependency(id) {
    runDependencies++;
    if (Module["monitorRunDependencies"]) {
      Module["monitorRunDependencies"](runDependencies);
    }
  }
  function removeRunDependency(id) {
    runDependencies--;
    if (Module["monitorRunDependencies"]) {
      Module["monitorRunDependencies"](runDependencies);
    }
    if (runDependencies == 0) {
      if (runDependencyWatcher !== null) {
        clearInterval(runDependencyWatcher);
        runDependencyWatcher = null;
      }
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  Module["preloadedImages"] = {};
  Module["preloadedAudios"] = {};
  var memoryInitializer = null;
  var dataURIPrefix = "data:application/octet-stream;base64,";
  function isDataURI(filename) {
    return String.prototype.startsWith ? filename.startsWith(dataURIPrefix) : filename.indexOf(dataURIPrefix) === 0;
  }
  var tempDouble;
  var tempI64;
  memoryInitializer = "data:application/octet-stream;base64,AAAAAAAAAAAAAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAAAQAAAAQAAAADAAAABgAAAAUAAAACAAAAAAAAAAIAAAADAAAAAQAAAAQAAAAGAAAAAAAAAAUAAAADAAAABgAAAAQAAAAFAAAAAAAAAAEAAAACAAAABAAAAAUAAAAGAAAAAAAAAAIAAAADAAAAAQAAAAUAAAACAAAAAAAAAAEAAAADAAAABgAAAAQAAAAGAAAAAAAAAAUAAAACAAAAAQAAAAQAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAIAAAADAAAAAAAAAAAAAAACAAAAAAAAAAEAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAABAAAAAYAAAAAAAAABQAAAAAAAAAAAAAABAAAAAUAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAYAAAAAAAAABgAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAgAAAAMAAAAEAAAABQAAAAYAAAABAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAAAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAAAAAAAQAAAAMAAAAEAAAABQAAAAYAAAAAAAAAAQAAAAIAAAAEAAAABQAAAAYAAAAAAAAAAQAAAAIAAAADAAAABQAAAAYAAAAAAAAAAQAAAAIAAAADAAAABAAAAAYAAAAAAAAAAQAAAAIAAAADAAAABAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAgAAAAIAAAAAAAAAAAAAAAYAAAAAAAAAAwAAAAIAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAFAAAABAAAAAAAAAABAAAAAAAAAAAAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAYAAAAAAAAABAAAAAAAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAgAAAAQAAAADAAAACAAAAAEAAAAHAAAABgAAAAkAAAAAAAAAAwAAAAIAAAACAAAABgAAAAoAAAALAAAAAAAAAAEAAAAFAAAAAwAAAA0AAAABAAAABwAAAAQAAAAMAAAAAAAAAAQAAAB/AAAADwAAAAgAAAADAAAAAAAAAAwAAAAFAAAAAgAAABIAAAAKAAAACAAAAAAAAAAQAAAABgAAAA4AAAALAAAAEQAAAAEAAAAJAAAAAgAAAAcAAAAVAAAACQAAABMAAAADAAAADQAAAAEAAAAIAAAABQAAABYAAAAQAAAABAAAAAAAAAAPAAAACQAAABMAAAAOAAAAFAAAAAEAAAAHAAAABgAAAAoAAAALAAAAGAAAABcAAAAFAAAAAgAAABIAAAALAAAAEQAAABcAAAAZAAAAAgAAAAYAAAAKAAAADAAAABwAAAANAAAAGgAAAAQAAAAPAAAAAwAAAA0AAAAaAAAAFQAAAB0AAAADAAAADAAAAAcAAAAOAAAAfwAAABEAAAAbAAAACQAAABQAAAAGAAAADwAAABYAAAAcAAAAHwAAAAQAAAAIAAAADAAAABAAAAASAAAAIQAAAB4AAAAIAAAABQAAABYAAAARAAAACwAAAA4AAAAGAAAAIwAAABkAAAAbAAAAEgAAABgAAAAeAAAAIAAAAAUAAAAKAAAAEAAAABMAAAAiAAAAFAAAACQAAAAHAAAAFQAAAAkAAAAUAAAADgAAABMAAAAJAAAAKAAAABsAAAAkAAAAFQAAACYAAAATAAAAIgAAAA0AAAAdAAAABwAAABYAAAAQAAAAKQAAACEAAAAPAAAACAAAAB8AAAAXAAAAGAAAAAsAAAAKAAAAJwAAACUAAAAZAAAAGAAAAH8AAAAgAAAAJQAAAAoAAAAXAAAAEgAAABkAAAAXAAAAEQAAAAsAAAAtAAAAJwAAACMAAAAaAAAAKgAAAB0AAAArAAAADAAAABwAAAANAAAAGwAAACgAAAAjAAAALgAAAA4AAAAUAAAAEQAAABwAAAAfAAAAKgAAACwAAAAMAAAADwAAABoAAAAdAAAAKwAAACYAAAAvAAAADQAAABoAAAAVAAAAHgAAACAAAAAwAAAAMgAAABAAAAASAAAAIQAAAB8AAAApAAAALAAAADUAAAAPAAAAFgAAABwAAAAgAAAAHgAAABgAAAASAAAANAAAADIAAAAlAAAAIQAAAB4AAAAxAAAAMAAAABYAAAAQAAAAKQAAACIAAAATAAAAJgAAABUAAAA2AAAAJAAAADMAAAAjAAAALgAAAC0AAAA4AAAAEQAAABsAAAAZAAAAJAAAABQAAAAiAAAAEwAAADcAAAAoAAAANgAAACUAAAAnAAAANAAAADkAAAAYAAAAFwAAACAAAAAmAAAAfwAAACIAAAAzAAAAHQAAAC8AAAAVAAAAJwAAACUAAAAZAAAAFwAAADsAAAA5AAAALQAAACgAAAAbAAAAJAAAABQAAAA8AAAALgAAADcAAAApAAAAMQAAADUAAAA9AAAAFgAAACEAAAAfAAAAKgAAADoAAAArAAAAPgAAABwAAAAsAAAAGgAAACsAAAA+AAAALwAAAEAAAAAaAAAAKgAAAB0AAAAsAAAANQAAADoAAABBAAAAHAAAAB8AAAAqAAAALQAAACcAAAAjAAAAGQAAAD8AAAA7AAAAOAAAAC4AAAA8AAAAOAAAAEQAAAAbAAAAKAAAACMAAAAvAAAAJgAAACsAAAAdAAAARQAAADMAAABAAAAAMAAAADEAAAAeAAAAIQAAAEMAAABCAAAAMgAAADEAAAB/AAAAPQAAAEIAAAAhAAAAMAAAACkAAAAyAAAAMAAAACAAAAAeAAAARgAAAEMAAAA0AAAAMwAAAEUAAAA2AAAARwAAACYAAAAvAAAAIgAAADQAAAA5AAAARgAAAEoAAAAgAAAAJQAAADIAAAA1AAAAPQAAAEEAAABLAAAAHwAAACkAAAAsAAAANgAAAEcAAAA3AAAASQAAACIAAAAzAAAAJAAAADcAAAAoAAAANgAAACQAAABIAAAAPAAAAEkAAAA4AAAARAAAAD8AAABNAAAAIwAAAC4AAAAtAAAAOQAAADsAAABKAAAATgAAACUAAAAnAAAANAAAADoAAAB/AAAAPgAAAEwAAAAsAAAAQQAAACoAAAA7AAAAPwAAAE4AAABPAAAAJwAAAC0AAAA5AAAAPAAAAEgAAABEAAAAUAAAACgAAAA3AAAALgAAAD0AAAA1AAAAMQAAACkAAABRAAAASwAAAEIAAAA+AAAAKwAAADoAAAAqAAAAUgAAAEAAAABMAAAAPwAAAH8AAAA4AAAALQAAAE8AAAA7AAAATQAAAEAAAAAvAAAAPgAAACsAAABUAAAARQAAAFIAAABBAAAAOgAAADUAAAAsAAAAVgAAAEwAAABLAAAAQgAAAEMAAABRAAAAVQAAADEAAAAwAAAAPQAAAEMAAABCAAAAMgAAADAAAABXAAAAVQAAAEYAAABEAAAAOAAAADwAAAAuAAAAWgAAAE0AAABQAAAARQAAADMAAABAAAAALwAAAFkAAABHAAAAVAAAAEYAAABDAAAANAAAADIAAABTAAAAVwAAAEoAAABHAAAAWQAAAEkAAABbAAAAMwAAAEUAAAA2AAAASAAAAH8AAABJAAAANwAAAFAAAAA8AAAAWAAAAEkAAABbAAAASAAAAFgAAAA2AAAARwAAADcAAABKAAAATgAAAFMAAABcAAAANAAAADkAAABGAAAASwAAAEEAAAA9AAAANQAAAF4AAABWAAAAUQAAAEwAAABWAAAAUgAAAGAAAAA6AAAAQQAAAD4AAABNAAAAPwAAAEQAAAA4AAAAXQAAAE8AAABaAAAATgAAAEoAAAA7AAAAOQAAAF8AAABcAAAATwAAAE8AAABOAAAAPwAAADsAAABdAAAAXwAAAE0AAABQAAAARAAAAEgAAAA8AAAAYwAAAFoAAABYAAAAUQAAAFUAAABeAAAAZQAAAD0AAABCAAAASwAAAFIAAABgAAAAVAAAAGIAAAA+AAAATAAAAEAAAABTAAAAfwAAAEoAAABGAAAAZAAAAFcAAABcAAAAVAAAAEUAAABSAAAAQAAAAGEAAABZAAAAYgAAAFUAAABXAAAAZQAAAGYAAABCAAAAQwAAAFEAAABWAAAATAAAAEsAAABBAAAAaAAAAGAAAABeAAAAVwAAAFMAAABmAAAAZAAAAEMAAABGAAAAVQAAAFgAAABIAAAAWwAAAEkAAABjAAAAUAAAAGkAAABZAAAAYQAAAFsAAABnAAAARQAAAFQAAABHAAAAWgAAAE0AAABQAAAARAAAAGoAAABdAAAAYwAAAFsAAABJAAAAWQAAAEcAAABpAAAAWAAAAGcAAABcAAAAUwAAAE4AAABKAAAAbAAAAGQAAABfAAAAXQAAAE8AAABaAAAATQAAAG0AAABfAAAAagAAAF4AAABWAAAAUQAAAEsAAABrAAAAaAAAAGUAAABfAAAAXAAAAE8AAABOAAAAbQAAAGwAAABdAAAAYAAAAGgAAABiAAAAbgAAAEwAAABWAAAAUgAAAGEAAAB/AAAAYgAAAFQAAABnAAAAWQAAAG8AAABiAAAAbgAAAGEAAABvAAAAUgAAAGAAAABUAAAAYwAAAFAAAABpAAAAWAAAAGoAAABaAAAAcQAAAGQAAABmAAAAUwAAAFcAAABsAAAAcgAAAFwAAABlAAAAZgAAAGsAAABwAAAAUQAAAFUAAABeAAAAZgAAAGUAAABXAAAAVQAAAHIAAABwAAAAZAAAAGcAAABbAAAAYQAAAFkAAAB0AAAAaQAAAG8AAABoAAAAawAAAG4AAABzAAAAVgAAAF4AAABgAAAAaQAAAFgAAABnAAAAWwAAAHEAAABjAAAAdAAAAGoAAABdAAAAYwAAAFoAAAB1AAAAbQAAAHEAAABrAAAAfwAAAGUAAABeAAAAcwAAAGgAAABwAAAAbAAAAGQAAABfAAAAXAAAAHYAAAByAAAAbQAAAG0AAABsAAAAXQAAAF8AAAB1AAAAdgAAAGoAAABuAAAAYgAAAGgAAABgAAAAdwAAAG8AAABzAAAAbwAAAGEAAABuAAAAYgAAAHQAAABnAAAAdwAAAHAAAABrAAAAZgAAAGUAAAB4AAAAcwAAAHIAAABxAAAAYwAAAHQAAABpAAAAdQAAAGoAAAB5AAAAcgAAAHAAAABkAAAAZgAAAHYAAAB4AAAAbAAAAHMAAABuAAAAawAAAGgAAAB4AAAAdwAAAHAAAAB0AAAAZwAAAHcAAABvAAAAcQAAAGkAAAB5AAAAdQAAAH8AAABtAAAAdgAAAHEAAAB5AAAAagAAAHYAAAB4AAAAbAAAAHIAAAB1AAAAeQAAAG0AAAB3AAAAbwAAAHMAAABuAAAAeQAAAHQAAAB4AAAAeAAAAHMAAAByAAAAcAAAAHkAAAB3AAAAdgAAAHkAAAB0AAAAeAAAAHcAAAB1AAAAcQAAAHYAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAABAAAABQAAAAEAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAACAAAABQAAAAEAAAAAAAAA/////wEAAAAAAAAAAwAAAAQAAAACAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAMAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAFAAAAAQAAAAAAAAAAAAAAAQAAAAMAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAADAAAAAAAAAAAAAAABAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAADAAAABQAAAAEAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAP////8DAAAAAAAAAAUAAAACAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAEAAAABQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAFAAAABQAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAD/////AwAAAAAAAAAFAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAAAAAABAAAAAwAAAAAAAAAAAAAAAQAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAQAAAAMAAAAAAAAAAAAAAAEAAAAAAAAAAwAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAADAAAAAAAAAP////8DAAAAAAAAAAUAAAACAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAFAAAABQAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAwAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAwAAAAAAAAAAAAAA/////wMAAAAAAAAABQAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAA/////wMAAAAAAAAABQAAAAIAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAMAAAADAAAAAAAAAAAAAAADAAAAAwAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAMAAAADAAAAAwAAAAMAAAAAAAAAAwAAAAAAAAD/////AwAAAAAAAAAFAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAAAAAD/////AwAAAAAAAAAFAAAAAgAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAADAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAFAAAAAAAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAADAAAAAQAAAAAAAAABAAAAAAAAAAAAAAABAAAAAwAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAADAAAAAAAAAP////8DAAAAAAAAAAUAAAACAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAAAAAADAAAAAwAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAUAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAFAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAA/////wMAAAAAAAAABQAAAAIAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAAFAAAAAAAAAAAAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAEAAAADAAAAAQAAAAAAAAABAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAADAAAAAQAAAAAAAAABAAAAAAAAAAMAAAADAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAAAAAAAAwAAAAUAAAABAAAAAAAAAP////8DAAAAAAAAAAUAAAACAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAABAAAAAUAAAABAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAIAAAAFAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAADAAAAAQAAAAAAAAABAAAAAAAAAAUAAAAAAAAAAAAAAAUAAAAFAAAAAAAAAAAAAAD/////AQAAAAAAAAADAAAABAAAAAIAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAUAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAFAAAAAAAAAAAAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAUAAAABAAAAAAAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAEAAAD//////////wEAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAADAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAsAAAACAAAAAAAAAAAAAAABAAAAAgAAAAYAAAAEAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAKAAAAAgAAAAAAAAAAAAAAAQAAAAEAAAAFAAAABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAABwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAsAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAACAAAAAAAAAAAAAAABAAAAAwAAAAcAAAAGAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAABwAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAADgAAAAIAAAAAAAAAAAAAAAEAAAAAAAAACQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAMAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAABwAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAsAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADQAAAAIAAAAAAAAAAAAAAAEAAAAEAAAACAAAAAoAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAALAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAACQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAgAAAAAAAAAAAAAAAQAAAAsAAAAPAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAOAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAIAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAABQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAgAAAAAAAAAAAAAAAQAAAAwAAAAQAAAADAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAoAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAPAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAADwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAADQAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAACAAAAAAAAAAAAAAABAAAACgAAABMAAAAIAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAEQAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEQAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAA8AAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAQAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAACQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAIAAAAAAAAAAAAAAAEAAAANAAAAEQAAAA0AAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAARAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAEwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAAEQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAA0AAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAARAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkAAAACAAAAAAAAAAAAAAABAAAADgAAABIAAAAPAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAADwAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAASAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAEwAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAABEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAABIAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAATAAAAAgAAAAAAAAAAAAAAAQAAAP//////////EwAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAEgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAASAAAAAAAAABgAAAAAAAAAIQAAAAAAAAAeAAAAAAAAACAAAAADAAAAMQAAAAEAAAAwAAAAAwAAADIAAAADAAAACAAAAAAAAAAFAAAABQAAAAoAAAAFAAAAFgAAAAAAAAAQAAAAAAAAABIAAAAAAAAAKQAAAAEAAAAhAAAAAAAAAB4AAAAAAAAABAAAAAAAAAAAAAAABQAAAAIAAAAFAAAADwAAAAEAAAAIAAAAAAAAAAUAAAAFAAAAHwAAAAEAAAAWAAAAAAAAABAAAAAAAAAAAgAAAAAAAAAGAAAAAAAAAA4AAAAAAAAACgAAAAAAAAALAAAAAAAAABEAAAADAAAAGAAAAAEAAAAXAAAAAwAAABkAAAADAAAAAAAAAAAAAAABAAAABQAAAAkAAAAFAAAABQAAAAAAAAACAAAAAAAAAAYAAAAAAAAAEgAAAAEAAAAKAAAAAAAAAAsAAAAAAAAABAAAAAEAAAADAAAABQAAAAcAAAAFAAAACAAAAAEAAAAAAAAAAAAAAAEAAAAFAAAAEAAAAAEAAAAFAAAAAAAAAAIAAAAAAAAABwAAAAAAAAAVAAAAAAAAACYAAAAAAAAACQAAAAAAAAATAAAAAAAAACIAAAADAAAADgAAAAEAAAAUAAAAAwAAACQAAAADAAAAAwAAAAAAAAANAAAABQAAAB0AAAAFAAAAAQAAAAAAAAAHAAAAAAAAABUAAAAAAAAABgAAAAEAAAAJAAAAAAAAABMAAAAAAAAABAAAAAIAAAAMAAAABQAAABoAAAAFAAAAAAAAAAEAAAADAAAAAAAAAA0AAAAFAAAAAgAAAAEAAAABAAAAAAAAAAcAAAAAAAAAGgAAAAAAAAAqAAAAAAAAADoAAAAAAAAAHQAAAAAAAAArAAAAAAAAAD4AAAADAAAAJgAAAAEAAAAvAAAAAwAAAEAAAAADAAAADAAAAAAAAAAcAAAABQAAACwAAAAFAAAADQAAAAAAAAAaAAAAAAAAACoAAAAAAAAAFQAAAAEAAAAdAAAAAAAAACsAAAAAAAAABAAAAAMAAAAPAAAABQAAAB8AAAAFAAAAAwAAAAEAAAAMAAAAAAAAABwAAAAFAAAABwAAAAEAAAANAAAAAAAAABoAAAAAAAAAHwAAAAAAAAApAAAAAAAAADEAAAAAAAAALAAAAAAAAAA1AAAAAAAAAD0AAAADAAAAOgAAAAEAAABBAAAAAwAAAEsAAAADAAAADwAAAAAAAAAWAAAABQAAACEAAAAFAAAAHAAAAAAAAAAfAAAAAAAAACkAAAAAAAAAKgAAAAEAAAAsAAAAAAAAADUAAAAAAAAABAAAAAQAAAAIAAAABQAAABAAAAAFAAAADAAAAAEAAAAPAAAAAAAAABYAAAAFAAAAGgAAAAEAAAAcAAAAAAAAAB8AAAAAAAAAMgAAAAAAAAAwAAAAAAAAADEAAAADAAAAIAAAAAAAAAAeAAAAAwAAACEAAAADAAAAGAAAAAMAAAASAAAAAwAAABAAAAADAAAARgAAAAAAAABDAAAAAAAAAEIAAAADAAAANAAAAAMAAAAyAAAAAAAAADAAAAAAAAAAJQAAAAMAAAAgAAAAAAAAAB4AAAADAAAAUwAAAAAAAABXAAAAAwAAAFUAAAADAAAASgAAAAMAAABGAAAAAAAAAEMAAAAAAAAAOQAAAAEAAAA0AAAAAwAAADIAAAAAAAAAGQAAAAAAAAAXAAAAAAAAABgAAAADAAAAEQAAAAAAAAALAAAAAwAAAAoAAAADAAAADgAAAAMAAAAGAAAAAwAAAAIAAAADAAAALQAAAAAAAAAnAAAAAAAAACUAAAADAAAAIwAAAAMAAAAZAAAAAAAAABcAAAAAAAAAGwAAAAMAAAARAAAAAAAAAAsAAAADAAAAPwAAAAAAAAA7AAAAAwAAADkAAAADAAAAOAAAAAMAAAAtAAAAAAAAACcAAAAAAAAALgAAAAMAAAAjAAAAAwAAABkAAAAAAAAAJAAAAAAAAAAUAAAAAAAAAA4AAAADAAAAIgAAAAAAAAATAAAAAwAAAAkAAAADAAAAJgAAAAMAAAAVAAAAAwAAAAcAAAADAAAANwAAAAAAAAAoAAAAAAAAABsAAAADAAAANgAAAAMAAAAkAAAAAAAAABQAAAAAAAAAMwAAAAMAAAAiAAAAAAAAABMAAAADAAAASAAAAAAAAAA8AAAAAwAAAC4AAAADAAAASQAAAAMAAAA3AAAAAAAAACgAAAAAAAAARwAAAAMAAAA2AAAAAwAAACQAAAAAAAAAQAAAAAAAAAAvAAAAAAAAACYAAAADAAAAPgAAAAAAAAArAAAAAwAAAB0AAAADAAAAOgAAAAMAAAAqAAAAAwAAABoAAAADAAAAVAAAAAAAAABFAAAAAAAAADMAAAADAAAAUgAAAAMAAABAAAAAAAAAAC8AAAAAAAAATAAAAAMAAAA+AAAAAAAAACsAAAADAAAAYQAAAAAAAABZAAAAAwAAAEcAAAADAAAAYgAAAAMAAABUAAAAAAAAAEUAAAAAAAAAYAAAAAMAAABSAAAAAwAAAEAAAAAAAAAASwAAAAAAAABBAAAAAAAAADoAAAADAAAAPQAAAAAAAAA1AAAAAwAAACwAAAADAAAAMQAAAAMAAAApAAAAAwAAAB8AAAADAAAAXgAAAAAAAABWAAAAAAAAAEwAAAADAAAAUQAAAAMAAABLAAAAAAAAAEEAAAAAAAAAQgAAAAMAAAA9AAAAAAAAADUAAAADAAAAawAAAAAAAABoAAAAAwAAAGAAAAADAAAAZQAAAAMAAABeAAAAAAAAAFYAAAAAAAAAVQAAAAMAAABRAAAAAwAAAEsAAAAAAAAAOQAAAAAAAAA7AAAAAAAAAD8AAAADAAAASgAAAAAAAABOAAAAAwAAAE8AAAADAAAAUwAAAAMAAABcAAAAAwAAAF8AAAADAAAAJQAAAAAAAAAnAAAAAwAAAC0AAAADAAAANAAAAAAAAAA5AAAAAAAAADsAAAAAAAAARgAAAAMAAABKAAAAAAAAAE4AAAADAAAAGAAAAAAAAAAXAAAAAwAAABkAAAADAAAAIAAAAAMAAAAlAAAAAAAAACcAAAADAAAAMgAAAAMAAAA0AAAAAAAAADkAAAAAAAAALgAAAAAAAAA8AAAAAAAAAEgAAAADAAAAOAAAAAAAAABEAAAAAwAAAFAAAAADAAAAPwAAAAMAAABNAAAAAwAAAFoAAAADAAAAGwAAAAAAAAAoAAAAAwAAADcAAAADAAAAIwAAAAAAAAAuAAAAAAAAADwAAAAAAAAALQAAAAMAAAA4AAAAAAAAAEQAAAADAAAADgAAAAAAAAAUAAAAAwAAACQAAAADAAAAEQAAAAMAAAAbAAAAAAAAACgAAAADAAAAGQAAAAMAAAAjAAAAAAAAAC4AAAAAAAAARwAAAAAAAABZAAAAAAAAAGEAAAADAAAASQAAAAAAAABbAAAAAwAAAGcAAAADAAAASAAAAAMAAABYAAAAAwAAAGkAAAADAAAAMwAAAAAAAABFAAAAAwAAAFQAAAADAAAANgAAAAAAAABHAAAAAAAAAFkAAAAAAAAANwAAAAMAAABJAAAAAAAAAFsAAAADAAAAJgAAAAAAAAAvAAAAAwAAAEAAAAADAAAAIgAAAAMAAAAzAAAAAAAAAEUAAAADAAAAJAAAAAMAAAA2AAAAAAAAAEcAAAAAAAAAYAAAAAAAAABoAAAAAAAAAGsAAAADAAAAYgAAAAAAAABuAAAAAwAAAHMAAAADAAAAYQAAAAMAAABvAAAAAwAAAHcAAAADAAAATAAAAAAAAABWAAAAAwAAAF4AAAADAAAAUgAAAAAAAABgAAAAAAAAAGgAAAAAAAAAVAAAAAMAAABiAAAAAAAAAG4AAAADAAAAOgAAAAAAAABBAAAAAwAAAEsAAAADAAAAPgAAAAMAAABMAAAAAAAAAFYAAAADAAAAQAAAAAMAAABSAAAAAAAAAGAAAAAAAAAAVQAAAAAAAABXAAAAAAAAAFMAAAADAAAAZQAAAAAAAABmAAAAAwAAAGQAAAADAAAAawAAAAMAAABwAAAAAwAAAHIAAAADAAAAQgAAAAAAAABDAAAAAwAAAEYAAAADAAAAUQAAAAAAAABVAAAAAAAAAFcAAAAAAAAAXgAAAAMAAABlAAAAAAAAAGYAAAADAAAAMQAAAAAAAAAwAAAAAwAAADIAAAADAAAAPQAAAAMAAABCAAAAAAAAAEMAAAADAAAASwAAAAMAAABRAAAAAAAAAFUAAAAAAAAAXwAAAAAAAABcAAAAAAAAAFMAAAAAAAAATwAAAAAAAABOAAAAAAAAAEoAAAADAAAAPwAAAAEAAAA7AAAAAwAAADkAAAADAAAAbQAAAAAAAABsAAAAAAAAAGQAAAAFAAAAXQAAAAEAAABfAAAAAAAAAFwAAAAAAAAATQAAAAEAAABPAAAAAAAAAE4AAAAAAAAAdQAAAAQAAAB2AAAABQAAAHIAAAAFAAAAagAAAAEAAABtAAAAAAAAAGwAAAAAAAAAWgAAAAEAAABdAAAAAQAAAF8AAAAAAAAAWgAAAAAAAABNAAAAAAAAAD8AAAAAAAAAUAAAAAAAAABEAAAAAAAAADgAAAADAAAASAAAAAEAAAA8AAAAAwAAAC4AAAADAAAAagAAAAAAAABdAAAAAAAAAE8AAAAFAAAAYwAAAAEAAABaAAAAAAAAAE0AAAAAAAAAWAAAAAEAAABQAAAAAAAAAEQAAAAAAAAAdQAAAAMAAABtAAAABQAAAF8AAAAFAAAAcQAAAAEAAABqAAAAAAAAAF0AAAAAAAAAaQAAAAEAAABjAAAAAQAAAFoAAAAAAAAAaQAAAAAAAABYAAAAAAAAAEgAAAAAAAAAZwAAAAAAAABbAAAAAAAAAEkAAAADAAAAYQAAAAEAAABZAAAAAwAAAEcAAAADAAAAcQAAAAAAAABjAAAAAAAAAFAAAAAFAAAAdAAAAAEAAABpAAAAAAAAAFgAAAAAAAAAbwAAAAEAAABnAAAAAAAAAFsAAAAAAAAAdQAAAAIAAABqAAAABQAAAFoAAAAFAAAAeQAAAAEAAABxAAAAAAAAAGMAAAAAAAAAdwAAAAEAAAB0AAAAAQAAAGkAAAAAAAAAdwAAAAAAAABvAAAAAAAAAGEAAAAAAAAAcwAAAAAAAABuAAAAAAAAAGIAAAADAAAAawAAAAEAAABoAAAAAwAAAGAAAAADAAAAeQAAAAAAAAB0AAAAAAAAAGcAAAAFAAAAeAAAAAEAAAB3AAAAAAAAAG8AAAAAAAAAcAAAAAEAAABzAAAAAAAAAG4AAAAAAAAAdQAAAAEAAABxAAAABQAAAGkAAAAFAAAAdgAAAAEAAAB5AAAAAAAAAHQAAAAAAAAAcgAAAAEAAAB4AAAAAQAAAHcAAAAAAAAAcgAAAAAAAABwAAAAAAAAAGsAAAAAAAAAZAAAAAAAAABmAAAAAAAAAGUAAAADAAAAUwAAAAEAAABXAAAAAwAAAFUAAAADAAAAdgAAAAAAAAB4AAAAAAAAAHMAAAAFAAAAbAAAAAEAAAByAAAAAAAAAHAAAAAAAAAAXAAAAAEAAABkAAAAAAAAAGYAAAAAAAAAdQAAAAAAAAB5AAAABQAAAHcAAAAFAAAAbQAAAAEAAAB2AAAAAAAAAHgAAAAAAAAAXwAAAAEAAABsAAAAAQAAAHIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAABAAAAAQAAAAAAAAAAAAAAAQAAAAAAAAABAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAGAAAAAgAAAAUAAAABAAAABAAAAAAAAAAAAAAABQAAAAMAAAABAAAABgAAAAQAAAACAAAAAAAAAH6iBfbytuk/Gq6akm/58z/Xrm0Liez0P5doSdOpSwRAWs602ULg8D/dT7Rcbo/1v1N1RQHFNOM/g9Snx7HW3L8HWsP8Q3jfP6VwOLosutk/9rjk1YQcxj+gnmKMsNn6P/HDeuPFY+M/YHwDjqKhB0Ci19/fCVrbP4UxKkDWOP6/pvljWa09tL9wi7wrQXjnv/Z6yLImkM2/3yTlOzY14D+m+WNZrT20PzwKVQnrQwNA9nrIsiaQzT/g40rFrRQFwPa45NWEHMa/kbslHEZq97/xw3rjxWPjv4cLC2SMBci/otff3wla27+rKF5oIAv0P1N1RQHFNOO/iDJPGyWHBUAHWsP8Q3jfvwQf/by16gXAfqIF9vK26b8XrO0Vh0r+v9eubQuJ7PS/BxLrA0ZZ479azrTZQuDwv1MK1EuItPw/yscgV9Z6FkAwHBR2WjQMQJNRzXsQ5vY/GlUHVJYKF0DONuFv2lMNQNCGZ28QJfk/0WUwoIL36D8ggDOMQuATQNqMOeAy/wZAWFYOYM+M2z/LWC4uH3oSQDE+LyTsMgRAkJzhRGWFGEDd4soovCQQQKqk0DJMEP8/rGmNdwOLBUAW2X/9xCbjP4hu3dcqJhNAzuYItRvdB0CgzW3zJW/sPxotm/Y2TxRAQAk9XmdDDEC1Kx9MKgT3P1M+NctcghZAFVqcLlb0C0Bgzd3sB2b2P77mZDPUWhZAFROHJpUGCEDAfma5CxXtPz1DWq/zYxRAmhYY5824F0DOuQKWSbAOQNCMqrvu3fs/L6DR22K2wT9nAAxPBU8RQGiN6mW43AFAZhu25b633D8c1YgmzowSQNM25BRKWARArGS08/lNxD+LFssHwmMRQLC5aNcxBgJABL9HT0WRF0CjCmJmOGEOQHsuaVzMP/s/TWJCaGGwBUCeu1PAPLzjP9nqN9DZOBNAKE4JcydbCkCGtbd1qjPzP8dgm9U8jhVAtPeKTkVwDkCeCLss5l37P401XMPLmBdAFd29VMVQDUBg0yA55h75Pz6odcYLCRdApBM4rBrkAkDyAVWgQxbRP4XDMnK20hFAymLlF7EmzD8GUgo9XBHlP3lbK7T9COc/k+OhPthhy7+YGEpnrOvCPzBFhLs15u4/epbqB6H4uz9IuuLF5svev6lzLKY31es/CaQ0envF5z8ZY0xlUADXv7zaz7HYEuI/CfbK1sn16T8uAQfWwxLWPzKn/YuFN94/5KdbC1AFu793fyCSnlfvPzK2y4doAMY/NRg5t1/X6b/shq4QJaHDP5yNIAKPOeI/vpn7BSE30r/X4YQrO6nrv78Ziv/Thto/DqJ1Y6+y5z9l51NaxFrlv8QlA65HOLS/86dxiEc96z+Hj0+LFjneP6LzBZ8LTc2/DaJ1Y6+y579l51NaxFrlP8QlA65HOLQ/8qdxiEc967+Jj0+LFjnev6LzBZ8LTc0/1qdbC1AFuz93fyCSnlfvvzK2y4doAMa/NRg5t1/X6T/vhq4QJaHDv5yNIAKPOeK/wJn7BSE30j/W4YQrO6nrP78Ziv/Thtq/CaQ0envF578XY0xlUADXP7zaz7HYEuK/CvbK1sn16b8rAQfWwxLWvzKn/YuFN96/zWLlF7EmzL8GUgo9XBHlv3lbK7T9COe/kOOhPthhyz+cGEpnrOvCvzBFhLs15u6/c5bqB6H4u79IuuLF5sveP6lzLKY31eu/AQAAAP////8HAAAA/////zEAAAD/////VwEAAP////9hCQAA/////6dBAAD/////kcsBAP/////3kAwA/////8H2VwAAAAAAAAAAAAAAAAACAAAA/////w4AAAD/////YgAAAP////+uAgAA/////8ISAAD/////ToMAAP////8ilwMA/////+4hGQD/////gu2vAAAAAAAAAAAAAAAAAAAAAAACAAAA//////////8BAAAAAwAAAP//////////////////////////////////////////////////////////////////////////AQAAAAAAAAACAAAA////////////////AwAAAP//////////////////////////////////////////////////////////////////////////AQAAAAAAAAACAAAA////////////////AwAAAP//////////////////////////////////////////////////////////////////////////AQAAAAAAAAACAAAA////////////////AwAAAP//////////////////////////////////////////////////////////AgAAAP//////////AQAAAAAAAAD/////////////////////AwAAAP////////////////////////////////////////////////////8DAAAA/////////////////////wAAAAD/////////////////////AQAAAP///////////////wIAAAD///////////////////////////////8DAAAA/////////////////////wAAAAD///////////////8CAAAAAQAAAP////////////////////////////////////////////////////8DAAAA/////////////////////wAAAAD///////////////8CAAAAAQAAAP////////////////////////////////////////////////////8DAAAA/////////////////////wAAAAD///////////////8CAAAAAQAAAP////////////////////////////////////////////////////8DAAAA/////////////////////wAAAAD///////////////8CAAAAAQAAAP////////////////////////////////////////////////////8BAAAAAgAAAP///////////////wAAAAD/////////////////////AwAAAP////////////////////////////////////////////////////8BAAAAAgAAAP///////////////wAAAAD/////////////////////AwAAAP////////////////////////////////////////////////////8BAAAAAgAAAP///////////////wAAAAD/////////////////////AwAAAP////////////////////////////////////////////////////8BAAAAAgAAAP///////////////wAAAAD/////////////////////AwAAAP///////////////////////////////wIAAAD///////////////8BAAAA/////////////////////wAAAAD/////////////////////AwAAAP////////////////////////////////////////////////////8DAAAA/////////////////////wAAAAABAAAA//////////8CAAAA//////////////////////////////////////////////////////////8DAAAA////////////////AgAAAAAAAAABAAAA//////////////////////////////////////////////////////////////////////////8DAAAA////////////////AgAAAAAAAAABAAAA//////////////////////////////////////////////////////////////////////////8DAAAA////////////////AgAAAAAAAAABAAAA//////////////////////////////////////////////////////////////////////////8DAAAAAQAAAP//////////AgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAACAAAAAAAAAAIAAAABAAAAAQAAAAIAAAACAAAAAAAAAAUAAAAFAAAAAAAAAAIAAAACAAAAAwAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAgAAAAEAAAACAAAAAgAAAAIAAAAAAAAABQAAAAYAAAAAAAAAAgAAAAIAAAADAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAgAAAAAAAAACAAAAAQAAAAMAAAACAAAAAgAAAAAAAAAFAAAABwAAAAAAAAACAAAAAgAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAACAAAAAAAAAAIAAAABAAAABAAAAAIAAAACAAAAAAAAAAUAAAAIAAAAAAAAAAIAAAACAAAAAwAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAIAAAAAAAAAAgAAAAEAAAAAAAAAAgAAAAIAAAAAAAAABQAAAAkAAAAAAAAAAgAAAAIAAAADAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAKAAAAAgAAAAIAAAAAAAAAAwAAAA4AAAACAAAAAAAAAAIAAAADAAAAAAAAAAAAAAACAAAAAgAAAAMAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAsAAAACAAAAAgAAAAAAAAADAAAACgAAAAIAAAAAAAAAAgAAAAMAAAABAAAAAAAAAAIAAAACAAAAAwAAAAcAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAIAAAACAAAAAAAAAAMAAAALAAAAAgAAAAAAAAACAAAAAwAAAAIAAAAAAAAAAgAAAAIAAAADAAAACAAAAAAAAAAAAAAAAAAAAAAAAAANAAAAAgAAAAIAAAAAAAAAAwAAAAwAAAACAAAAAAAAAAIAAAADAAAAAwAAAAAAAAACAAAAAgAAAAMAAAAJAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAACAAAAAgAAAAAAAAADAAAADQAAAAIAAAAAAAAAAgAAAAMAAAAEAAAAAAAAAAIAAAACAAAAAwAAAAoAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAIAAAACAAAAAAAAAAMAAAAGAAAAAgAAAAAAAAACAAAAAwAAAA8AAAAAAAAAAgAAAAIAAAADAAAACwAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAgAAAAIAAAAAAAAAAwAAAAcAAAACAAAAAAAAAAIAAAADAAAAEAAAAAAAAAACAAAAAgAAAAMAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAcAAAACAAAAAgAAAAAAAAADAAAACAAAAAIAAAAAAAAAAgAAAAMAAAARAAAAAAAAAAIAAAACAAAAAwAAAA0AAAAAAAAAAAAAAAAAAAAAAAAACAAAAAIAAAACAAAAAAAAAAMAAAAJAAAAAgAAAAAAAAACAAAAAwAAABIAAAAAAAAAAgAAAAIAAAADAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAJAAAAAgAAAAIAAAAAAAAAAwAAAAUAAAACAAAAAAAAAAIAAAADAAAAEwAAAAAAAAACAAAAAgAAAAMAAAAPAAAAAAAAAAAAAAAAAAAAAAAAABAAAAACAAAAAAAAAAIAAAABAAAAEwAAAAIAAAACAAAAAAAAAAUAAAAKAAAAAAAAAAIAAAACAAAAAwAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEQAAAAIAAAAAAAAAAgAAAAEAAAAPAAAAAgAAAAIAAAAAAAAABQAAAAsAAAAAAAAAAgAAAAIAAAADAAAAEQAAAAAAAAAAAAAAAAAAAAAAAAASAAAAAgAAAAAAAAACAAAAAQAAABAAAAACAAAAAgAAAAAAAAAFAAAADAAAAAAAAAACAAAAAgAAAAMAAAASAAAAAAAAAAAAAAAAAAAAAAAAABMAAAACAAAAAAAAAAIAAAABAAAAEQAAAAIAAAACAAAAAAAAAAUAAAANAAAAAAAAAAIAAAACAAAAAwAAABMAAAAAAAAAAAAAAAAAAAAAAAAADwAAAAIAAAAAAAAAAgAAAAEAAAASAAAAAgAAAAIAAAAAAAAABQAAAA4AAAAAAAAAAgAAAAIAAAADAAAAAgAAAAEAAAAAAAAAAQAAAAIAAAAAAAAAAAAAAAIAAAABAAAAAAAAAAEAAAACAAAAAQAAAAAAAAACAAAAAAAAAAUAAAAEAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAFAAAABAAAAAAAAAABAAAABQAAAAQAAAAAAAAABQAAAAAAAAACAAAAAQAAAAAAAAABAAAAAgAAAAAAAAAAAAAAAgAAAAEAAAAAAAAAAQAAAAIAAAABAAAAAAAAAAIAAAACAAAAAAAAAAEAAAAAAAAAAAAAAAUAAAAEAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAFAAAABAAAAAAAAAABAAAABQAAAAQAAAAAAAAABQAAAAUAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAABAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAEAAAAAAAAAAAEAAAAAAQAAAAAAAAAAAQAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAABAAAAAAAAAAAAAQAAAAAAAAAAAAA6B6FaUp9QQTPXMuL4myJBraiDfBwx9UBYJseitzTIQOL5if9jqZtAnXX+Z+ycb0C3pucbhRBCQG8wJBYqpRRAlWbDCzCY5z/eFWBUEve6P/+qo4Q50Y4/D9YM3iCcYT8fcA2QJSA0P4ADxu0qAAc/BNcGolVJ2j5d9FACqwquPh9z7MthtI9CSUSYJke/YUJQ/64OyjU0Qpi0+HCmFQdCm3GfIVdh2kHsJ11kAyauQYC3UDFJOoFBSJsFV1OwU0FK5fcxX4AmQWhy/zZIt/lACqaCPsBjzUDbdUNIScugQMYQlVJ4MXNANiuq8GTvRUDxTXnulxEZQFZ8QX5kpuw/qmG/JwYFlEAluh3Q6DB+QKn4vyNq0GZAKOXekas+UUB8xabXXhI6QG63C2pLtSNAdDBtyNfLDUDyOcu67ID2P0rCMvRXAeE/Ki2TSVyzyT9Dk+8Sz2uzP5J+w5ARWp0/NQAoOiMuhj9YnP+RyMJwPxgW7TvQVFk/KgsLYF0kQz9g5dAC6IwzQcgHPVvDex1B1XjppodHBkHJq3OMM9fwQNvcmJ7wddlAInGPpQs/w0BRobq5EBmtQJZ2ai7n+ZVAtv2G5E+bgECG+gIfKBlpQK5f8jdI91JAL39sL/WpPEB8rGxhDqklQK6yUf43XhBAxL9y/tK8+D86XyZpgrHiPwAAAAD/////AAAAAAAAAAAAAAAAAAAAAAAAAAD/////////////////////////////////////AAAAAP////8AAAAAAAAAAAAAAAABAAAAAAAAAAAAAAD/////AAAAAAAAAAABAAAAAQAAAAAAAAAAAAAA/////wAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAP////8FAAAABQAAAAAAAAAAAAAAAAAAAAAAAAD/////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////////////////////////////////////wAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////////////////////////////////////8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAFAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////////////////////////////////////AAAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAQAAAAEAAAABAAAAAAAAAAEAAAAAAAAABQAAAAEAAAABAAAAAAAAAAAAAAABAAAAAQAAAAAAAAABAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQAAAAAAAQABAAABAQAAAAAAAQAAAAEAAAABAAEAAAAAAAAAAAAAAAAAAAAAquJYWJZl+D9jaeZNtj/zPwwdI9KqaeO/qGefXwdHdz+q4lhYlmX4P+OrlPMN3PI/DB0j0qpp47+7SQLV4VIEQKriWFiWZfg/r2kma3tz8T82eQmLqNIGwMRIWXMqSvo/fcCszPux9j+jara6ozTwP6hnn18HR3c/MSoKLequ8r+SabgA2nj0P7jBLbDOHO8/1Ym/ICfH4T+6lxjvlFXHv73m373LRPU/0vXyDVxo7T+ToKRHJXMAQF/33578aPE/pAyy64tD9T8+U/hCvyruPwxv8Y7YYwLAuXYr8NAiCEB4+LDK0Sn0P1Qeuy4j+eo/OMx50n7K7L+TrGB/nyf8v5ehC2fbYPM/aXMKexiT6z8mFRIMjg/zP7yUVwGGBNw/E6opHERf8z/z0wR2g9DqPw4pBpcOhvu/NbA29uWAA8DMaTExyXzyP02biiQ+Ruk/S8jz2/FKBEB1pzZnpbb9P7pQU4wLfPI//7ZcQXeG6D9CqEQvAYoIwDB2VB6sSgRAVyv8H5We8T+EHWF8XNPmPzB2wT8Nrrg/SEi+cX+w4L8of+GtdSDxP1sjk5AdouU/6ZjOVru13r8K0obqI6bxvwVbdNXyhfA/w5GG024n5z+rwmtMzP8BwLw9pSX49QXABe/2uQxP8D+b6wCzCvXkP7uGT87fK+Q/pz/JWw4coj+qoBf2J0nwP/yE3PUo0+I/vFJeHcaC+D96luSIqvntP/bf8sHUYu8/gZNN41mL4z9bhOqVOF4FwO6lmAh1hQhAbCVxbdhk7z+1C8NdDcfiPwG36x/0OQBAx0WJ76c2+D9nlSHXANfuP2HlfZ3gqOE/EwnVlVPg9r96+oHzEH//v5bXzdT1Auw/DM3GwLsA4D9p/8uoKcr+v+U9x5DQVAPAehjSdghb7D9sc1IetODgP8MVwwB1pu6/azPk6OGe978W8t/TUc3rP+0QMvYfP+A/RsG/QpSE8D+l3uwScxzgPwQaifgujuw/k1Vti1I43z8MAwLnSh0GQH5nYnwwZgJAiGUzWC5s6j8WyyI/BbLgPw4iUapGeQJAB3W+imnp/j9BLWR4ssrpP2t+gG5Pstk/cpBsfm6DCMCOpU9dOZsFQEv8nFypHeo/ehJ6i+6S2D9jqlGEmarLv7STC5TRiOa/bC+x8WZD6D9H3yUkWpDZP8gZvmCMuQLAreY19/eRBsCoPOc8UzzpP6KI/QV+y9g/t/MoboyWzT+Hv5q3Zu3Mvy2xROCT4uY/9gQitMMg1T9abAqhWMDkv1oLTavoUfG/PMUJP9CD5j+fHRX3t6fSPz7W2gk6bvs/WRnuHwqN9D8YFturGCTmP1EZczv0b9I/5t4exabB5D/1ESLh5fTEP9X2z6SYweQ/6lv3I2zT0D9zkRGNUNMAQKoSvc4EIfs/Xggt8wQI5T+mJHHg/w/SP4lhT/9t8vQ/DrZ/DbwH7D+XlhbYZrjkP34LIpFt6c4/lwfp8fLX9L+j96CTTf76v3WdNhEv9uM/d8c3o4lV0D/vFdCHVcsFwAHeDq0F1QhApbYqcZiN5D9KoilqByXLPwX0/diA0vq/0fo0GxnxAMBbaTkvlCzjP/RrFrWXrMs/UYTrky7jA0DB9f4FiZYAQEGAk/3QzeE/r/TeqE8t0D/OqjlsnPbvvz8RKU8JOfW/smSEbK/O4T8MzuyPm3DDP/rFtctq9gZAfb1EVEaSA0Dts5dVInnhP18SFMc79MM/7y34cw6LAMDFrRJsZO0DwC2KLvLSYuA/hx5wcUHewz+49SnK/4ruPyeS0PX9a+E/ZxaaLvvZ3z8WPu5T2QS8Pygo4RIvMqa/BJ0Kqsd0279cKW4ay8jdP3b05bmZ364/10/qtdxk2r+Bcz6CDMvpv54qOw+Amdw/qLV71pW7sT/YKc80nIPUP8OfIaBJ77G/LyTuD1un2z+diYu8efWzP1wU7ACkfwjAZroyPL1yBkAmv3lKJJbbPysKSE4W+p0/dIgqY79TA8ATLTOQ3tsGwJ2zweD/Xdg/XO/jXeFUaL8VW2qLFKfov1cA9Aa6XfK/tIa7YGgI2T+f3hu/sxqPv2nXdPpf3Pc/jkw8Jbda8j+tT/z8tGPVP1yBHpJd35k/KYvYOy1s8j/yz+kCQjPrP9+agH7x59g/PZfJ9aBhpr/rDKzvYBb+PwtkiaGCt/c/vb1mVr+f1T/JIHwHc8Govw7aeF6+9vG/Xv7kD6fp979isYioQYHVP7AIQZuSFrG/3z1AdUTnAUDN3XY9O7f9P0AdQ9ljYNQ/dJANJPTOrb8kLECUiiPlP4yF7UgmStA/9xGmXxCG1T9qZzix4W2zv2SGJRJVrPe/Fh9a2M/B/b8IexzFCoPSP9y1QFD2bLe/Q86cWLJe/b+mOOfYm78BwOTjkPAGE9E/8aPCUKu/ub9pPZyLCiUGwBA7Mev/BQlALOmrlRi+0j+AMJ/dKULBv7iLtL6a6QRAEMDV/yajAUDa62dE3crJP1P70RgBUbq/38hVnR6esT/s1tG10Z/Ov/zLwalHPss/dTS9NKTXx78nMcRzCIEHQAabxDsAmQRA0tyLK3gSyT+Aui7nOhDGv5Gs58z3WgHATN3forJuBMCAui7nOhDGP9Lciyt4Esm/WAJyHQ4c7z8UP5HFIs3iP3U0vTSk18c//MvBqUc+y7+cvv8HLg/Kvy1I/mHsI+K/U/vRGAFRuj/a62dE3crJv8p+WV8KlQjAuQ/nOP43B0CAMJ/dKULBPyzpq5UYvtK/ZoU+VoLh4L9etLlRUfvtv/GjwlCrv7k/5OOQ8AYT0b9DfT9FhufXPwUX8hJp+4u/3LVAUPZstz8IexzFCoPSv9+L609E5fQ/q9Fz7X2J7T9qZzix4W2zP/cRpl8QhtW/vtNilqGX+j8MOy7QJoL0P3SQDST0zq0/QB1D2WNg1L8IIjSvGNkDwGB8Jou2GAfAsAhBm5IWsT9isYioQYHVvyS9D3zb6uy/gnwRa7uM9L/JIHwHc8GoP729Zla/n9W/CsAHJZwmAEDEW6OYT1r6Pz2XyfWgYaY/35qAfvHn2L83Tdy4lS30vxf2/gZ0jPq/XIEekl3fmb+tT/z8tGPVvybPr2zJ1/+/K7mJ0ypVAsCf3hu/sxqPPwCGu2BoCNm/5oITrpZn+r+UDUyDP+n/v1zv413hVGg/nbPB4P9d2L9MlmkxNvgCQMtZlKE85v8/KwpIThb6nb8mv3lKJJbbv8+SZsTvOOc/pQCIIOYw0j+diYu8efWzvy8k7g9bp9u/kxYDa+pKtD9XlYvA8HnVv6i1e9aVu7G/nio7D4CZ3L/WR6rNh5EGwCkgQweBkghAdvTluZnfrr9cKW4ay8jdvxbjhr1f1QVAR5C0MzivAkAWPu5T2QS8v2cWmi772d+/cKj4lzLJCEBx2QJfYrMFQIcecHFB3sO/LYou8tJi4L+jr7lhO38BwIcI0Nb7xgTAXxIUxzv0w7/ts5dVInnhv0T+l8DZLfE/MP3FoFvS5D8MzuyPm3DDv7JkhGyvzuG/tzhzRIRc0b9Ovv3/0z7mv6/03qhPLdC/m4CT/dDN4b9dwjU5VCQBQBBJX1ntCv0/9GsWtZesy79baTkvlCzjv1mjYgEz++S/oW6KnOQW8b9KoilqByXLv6W2KnGYjeS/SmaKz3Vx9z+BZB5yxGHwP3fHN6OJVdC/dZ02ES/2478PuaBjLrXaP4/JU81pPaO/fgsikW3pzr+XlhbYZrjkv4tSn7YDbP0/f2LnFKlF9z+mJHHg/w/Sv14ILfMECOW/mfg4qYhR/b+OP+RQDCACwOpb9yNs09C/1fbPpJjB5L9pN2WOVZ3wv3hHy9nxIve/URlzO/Rv0r8YFturGCTmv1d1/KKR8QPA8gsy9qzSB8CfHRX3t6fSvzzFCT/Qg+a/EYStnrzV9r/2QJqI7Lb9v/YEIrTDINW/LbFE4JPi5r/7kQEs5fEDQHunnf4GeQBAooj9BX7L2L+oPOc8Uzzpv+ydYY2SSAfAL4HK6CRTB0BH3yUkWpDZv2wvsfFmQ+i/Ik0Yzruh6T8fM3LoGoDUP3oSeovukti/S/ycXKkd6r9rEv+7UWcHQCRIQe/GfwNAa36Abk+y2b9BLWR4ssrpv9KT87qa0bM/FTyktw823L8WyyI/BbLgv4hlM1gubOq/DizMp9Ki6r8b5ckdjVrzv5NVbYtSON+/BBqJ+C6O7L/dUBFqgyXYv00Wh18r7+q/7RAy9h8/4L8W8t/TUc3rv4RM5DKx3wDAfvWIj94aBcBsc1IetODgv3oY0nYIW+y/oGcTFF54AUDkJqS/FKX6PwzNxsC7AOC/ltfN1PUC7L+5Wrz/zHnzP6688w2rNOc/YeV9neCo4b9nlSHXANfuvw9RsxKjY/s/1V8GteXE8j+1C8NdDcfiv2wlcW3YZO+/IOywaA7Q8b9bFP+4Tg36v4GTTeNZi+O/9t/ywdRi77+tRc3yFR7eP2bkcHXJkLO//ITc9SjT4r+qoBf2J0nwv2YHKoswwfm/iQcLspCjAcCb6wCzCvXkvwXv9rkMT/C/YkuwYAMXBMApCNUai9kIwMORhtNuJ+e/BVt01fKF8L+ZqWEfvIjsP6h693QZYNk/WyOTkB2i5b8of+GtdSDxvwpaaulDSwVADMQAX+lOAECEHWF8XNPmv1cr/B+VnvG/XyFG6opcCMD/mtR32/UEQP+2XEF3hui/ulBTjAt88r/imfCfRP+yP9zbvtc8XeO/TZuKJD5G6b/MaTExyXzyvxiTQeElXOO/rbJRQVGN9L/z0wR2g9DqvxOqKRxEX/O/FDGCEei99j9x8zV4VYTmP2lzCnsYk+u/l6ELZ9tg878pRXacaDT/v3k6GZRqoQXAVB67LiP56r94+LDK0Sn0vwO6pZ9b7wFAvK0nKVcc9j8+U/hCvyruv6QMsuuLQ/W/FPhKFYv46j8MyxaDTOW/v9L18g1caO2/vebfvctE9b/7GD8ZrF3xv3gx1AR9bQDAuMEtsM4c77+SabgA2nj0v5xKFIwxsATArKNSBaKsB0Cjara6ozTwv33ArMz7sfa/dF2U0FcWCcDxL357DJX/P69pJmt7c/G/quJYWJZl+L/YntVJlnrSP4sRLzXM+fe/46uU8w3c8r+q4lhYlmX4v85lu5+QRwRAsI0H/WU8479jaeZNtj/zv6riWFiWZfi/sI0H/WU847/OZbufkEcEQHAoPUBrnss/9exKzDtFtT88wM8kax+gP9OqeKeAYog/MW0ItiZvcj+ph+smvt5bP2lCaV5dEUU/StaUmQDaLz+kK9y22BMYP0O3whZuMwI/IIbgZGWE6z7UkjYaEM3UPuezxwa9cr8+LybxRMnFpz6E1N8DbPiRPsYjySMvK3s+//////8fAAj//////zMQCP////9/MiAI/////28yMAj/////YzJACP///z9iMlAI////N2IyYAj///8zYjJwCP//vzNiMoAI//+rM2IykAj/f6szYjKgCP8PqzNiMrAI/wOrM2IywAi/A6szYjLQCJ8DqzNiMuAImQOrM2Iy8Aj//////z8PCP//////Kx8I/////38pLwj/////Pyk/CP////85KU8I////PzgpXwj///8POClvCP///w44KX8I//8fDjgpjwj//w8OOCmfCP9/DQ44Ka8I/w8NDjgpvwj/DQ0OOCnPCP8MDQ44Kd8IxwwNDjgp7wjEDA0OOCn/CAcAAAAHAAAAAQAAAAIAAAAEAAAAAwAAAAAAAAAAAAAABwAAAAMAAAABAAAAAgAAAAUAAAAEAAAAAAAAAAAAAAAEAAAABAAAAAAAAAACAAAAAQAAAAMAAAAOAAAABgAAAAsAAAACAAAABwAAAAEAAAAYAAAABQAAAAoAAAABAAAABgAAAAAAAAAmAAAABwAAAAwAAAADAAAACAAAAAIAAAAxAAAACQAAAA4AAAAAAAAABQAAAAQAAAA6AAAACAAAAA0AAAAEAAAACQAAAAMAAAA/AAAACwAAAAYAAAAPAAAACgAAABAAAABIAAAADAAAAAcAAAAQAAAACwAAABEAAABTAAAACgAAAAUAAAATAAAADgAAAA8AAABhAAAADQAAAAgAAAARAAAADAAAABIAAABrAAAADgAAAAkAAAASAAAADQAAABMAAAB1AAAADwAAABMAAAARAAAAEgAAABAAAAAGAAAAAgAAAAMAAAAFAAAABAAAAAAAAAAAAAAAAAAAAAYAAAACAAAAAwAAAAEAAAAFAAAABAAAAAAAAAAAAAAABwAAAAUAAAADAAAABAAAAAEAAAAAAAAAAgAAAAAAAAACAAAAAwAAAAEAAAAFAAAABAAAAAYAAAAAAAAAAAAAABgtRFT7Ifk/GC1EVPsh+b8YLURU+yEJQBgtRFT7IQnAYWxnb3MuYwBoM05laWdoYm9yUm90YXRpb25zAGNvb3JkaWprLmMAX3VwQXA3Q2hlY2tlZABfdXBBcDdyQ2hlY2tlZABkaXJlY3RlZEVkZ2UuYwBkaXJlY3RlZEVkZ2VUb0JvdW5kYXJ5AGFkamFjZW50RmFjZURpclt0bXBGaWprLmZhY2VdW2ZpamsuZmFjZV0gPT0gS0kAZmFjZWlqay5jAF9mYWNlSWprUGVudFRvQ2VsbEJvdW5kYXJ5AGFkamFjZW50RmFjZURpcltjZW50ZXJJSksuZmFjZV1bZmFjZTJdID09IEtJAF9mYWNlSWprVG9DZWxsQm91bmRhcnkAaDNJbmRleC5jAGNvbXBhY3RDZWxscwBsYXRMbmdUb0NlbGwAY2VsbFRvQ2hpbGRQb3MAdmFsaWRhdGVDaGlsZFBvcwBsYXRMbmcuYwBjZWxsQXJlYVJhZHMyAHBvbHlnb24tPm5leHQgPT0gTlVMTABsaW5rZWRHZW8uYwBhZGROZXdMaW5rZWRQb2x5Z29uAG5leHQgIT0gTlVMTABsb29wICE9IE5VTEwAYWRkTmV3TGlua2VkTG9vcABwb2x5Z29uLT5maXJzdCA9PSBOVUxMAGFkZExpbmtlZExvb3AAY29vcmQgIT0gTlVMTABhZGRMaW5rZWRDb29yZABsb29wLT5maXJzdCA9PSBOVUxMAGlubmVyTG9vcHMgIT0gTlVMTABub3JtYWxpemVNdWx0aVBvbHlnb24AYmJveGVzICE9IE5VTEwAY2FuZGlkYXRlcyAhPSBOVUxMAGZpbmRQb2x5Z29uRm9ySG9sZQBjYW5kaWRhdGVCQm94ZXMgIT0gTlVMTAByZXZEaXIgIT0gSU5WQUxJRF9ESUdJVABsb2NhbGlqLmMAY2VsbFRvTG9jYWxJamsAYmFzZUNlbGwgIT0gb3JpZ2luQmFzZUNlbGwAIShvcmlnaW5PblBlbnQgJiYgaW5kZXhPblBlbnQpAGJhc2VDZWxsID09IG9yaWdpbkJhc2VDZWxsAGJhc2VDZWxsICE9IElOVkFMSURfQkFTRV9DRUxMAGxvY2FsSWprVG9DZWxsACFfaXNCYXNlQ2VsbFBlbnRhZ29uKGJhc2VDZWxsKQBiYXNlQ2VsbFJvdGF0aW9ucyA+PSAwAGdyaWRQYXRoQ2VsbHMAcG9seWZpbGwuYwBpdGVyU3RlcFBvbHlnb25Db21wYWN0ADAAdmVydGV4LmMAdmVydGV4Um90YXRpb25zAGNlbGxUb1ZlcnRleABncmFwaC0+YnVja2V0cyAhPSBOVUxMAHZlcnRleEdyYXBoLmMAaW5pdFZlcnRleEdyYXBoAG5vZGUgIT0gTlVMTABhZGRWZXJ0ZXhOb2Rl";
  var tempDoublePtr = 28640;
  function demangle(func) {
    return func;
  }
  function demangleAll(text) {
    var regex = /\b__Z[\w\d_]+/g;
    return text.replace(regex, function(x) {
      var y = demangle(x);
      return x === y ? x : y + " [" + x + "]";
    });
  }
  function jsStackTrace() {
    var err2 = new Error();
    if (!err2.stack) {
      try {
        throw new Error(0);
      } catch (e2) {
        err2 = e2;
      }
      if (!err2.stack) {
        return "(no stack trace available)";
      }
    }
    return err2.stack.toString();
  }
  function stackTrace() {
    var js = jsStackTrace();
    if (Module["extraStackTrace"]) {
      js += "\n" + Module["extraStackTrace"]();
    }
    return demangleAll(js);
  }
  function ___assert_fail(condition, filename, line, func) {
    abort("Assertion failed: " + UTF8ToString(condition) + ", at: " + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
  }
  function _emscripten_get_heap_size() {
    return HEAP8.length;
  }
  function _emscripten_memcpy_big(dest, src, num) {
    HEAPU8.set(HEAPU8.subarray(src, src + num), dest);
  }
  function ___setErrNo(value) {
    if (Module["___errno_location"]) {
      HEAP32[Module["___errno_location"]() >> 2] = value;
    }
    return value;
  }
  function abortOnCannotGrowMemory(requestedSize) {
    abort("OOM");
  }
  function emscripten_realloc_buffer(size) {
    try {
      var newBuffer = new ArrayBuffer(size);
      if (newBuffer.byteLength != size) {
        return;
      }
      new Int8Array(newBuffer).set(HEAP8);
      _emscripten_replace_memory(newBuffer);
      updateGlobalBufferAndViews(newBuffer);
      return 1;
    } catch (e2) {
    }
  }
  function _emscripten_resize_heap(requestedSize) {
    var oldSize = _emscripten_get_heap_size();
    var PAGE_MULTIPLE = 16777216;
    var LIMIT = 2147483648 - PAGE_MULTIPLE;
    if (requestedSize > LIMIT) {
      return false;
    }
    var MIN_TOTAL_MEMORY = 16777216;
    var newSize = Math.max(oldSize, MIN_TOTAL_MEMORY);
    while (newSize < requestedSize) {
      if (newSize <= 536870912) {
        newSize = alignUp(2 * newSize, PAGE_MULTIPLE);
      } else {
        newSize = Math.min(alignUp((3 * newSize + 2147483648) / 4, PAGE_MULTIPLE), LIMIT);
      }
    }
    var replacement = emscripten_realloc_buffer(newSize);
    if (!replacement) {
      return false;
    }
    return true;
  }
  var decodeBase64 = typeof atob === "function" ? atob : function(input) {
    var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var output = "";
    var chr1, chr2, chr3;
    var enc1, enc2, enc3, enc4;
    var i = 0;
    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
    do {
      enc1 = keyStr.indexOf(input.charAt(i++));
      enc2 = keyStr.indexOf(input.charAt(i++));
      enc3 = keyStr.indexOf(input.charAt(i++));
      enc4 = keyStr.indexOf(input.charAt(i++));
      chr1 = enc1 << 2 | enc2 >> 4;
      chr2 = (enc2 & 15) << 4 | enc3 >> 2;
      chr3 = (enc3 & 3) << 6 | enc4;
      output = output + String.fromCharCode(chr1);
      if (enc3 !== 64) {
        output = output + String.fromCharCode(chr2);
      }
      if (enc4 !== 64) {
        output = output + String.fromCharCode(chr3);
      }
    } while (i < input.length);
    return output;
  };
  function intArrayFromBase64(s) {
    try {
      var decoded = decodeBase64(s);
      var bytes = new Uint8Array(decoded.length);
      for (var i = 0; i < decoded.length; ++i) {
        bytes[i] = decoded.charCodeAt(i);
      }
      return bytes;
    } catch (_) {
      throw new Error("Converting base64 string to bytes failed.");
    }
  }
  function tryParseAsDataURI(filename) {
    if (!isDataURI(filename)) {
      return;
    }
    return intArrayFromBase64(filename.slice(dataURIPrefix.length));
  }
  var asmGlobalArg = {
    "Math": Math,
    "Int8Array": Int8Array,
    "Int32Array": Int32Array,
    "Uint8Array": Uint8Array,
    "Float32Array": Float32Array,
    "Float64Array": Float64Array
  };
  var asmLibraryArg = {
    "a": abort,
    "b": setTempRet0,
    "c": getTempRet0,
    "d": ___assert_fail,
    "e": ___setErrNo,
    "f": _emscripten_get_heap_size,
    "g": _emscripten_memcpy_big,
    "h": _emscripten_resize_heap,
    "i": abortOnCannotGrowMemory,
    "j": demangle,
    "k": demangleAll,
    "l": emscripten_realloc_buffer,
    "m": jsStackTrace,
    "n": stackTrace,
    "o": tempDoublePtr,
    "p": DYNAMICTOP_PTR
  };
  var asm = (
    /** @suppress {uselessCode} */
    (function(global, env, buffer2) {
      "almost asm";
      var a2 = new global.Int8Array(buffer2), b2 = new global.Int32Array(buffer2), c2 = new global.Uint8Array(buffer2), d2 = new global.Float32Array(buffer2), e2 = new global.Float64Array(buffer2), f = env.o | 0, g = env.p | 0, p = global.Math.floor, q = global.Math.abs, r = global.Math.sqrt, s = global.Math.pow, t = global.Math.cos, u2 = global.Math.sin, v2 = global.Math.tan, w2 = global.Math.acos, x = global.Math.asin, y = global.Math.atan, z = global.Math.atan2, A2 = global.Math.ceil, B2 = global.Math.imul, C2 = global.Math.min, D2 = global.Math.max, E2 = global.Math.clz32, G2 = env.b, H = env.c, I = env.d, J = env.e, K = env.f, L2 = env.g, M = env.h, N = env.i, T = 28656;
      function W2(newBuffer) {
        a2 = new Int8Array(newBuffer);
        c2 = new Uint8Array(newBuffer);
        b2 = new Int32Array(newBuffer);
        d2 = new Float32Array(newBuffer);
        e2 = new Float64Array(newBuffer);
        buffer2 = newBuffer;
        return true;
      }
      function X(a3) {
        a3 = a3 | 0;
        var b3 = 0;
        b3 = T;
        T = T + a3 | 0;
        T = T + 15 & -16;
        return b3 | 0;
      }
      function Y() {
        return T | 0;
      }
      function Z(a3) {
        a3 = a3 | 0;
        T = a3;
      }
      function _(a3, b3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        T = a3;
      }
      function $(a3, c3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        var d3 = 0, e3 = 0, f2 = 0;
        if ((a3 | 0) < 0) {
          c3 = 2;
          return c3 | 0;
        }
        if ((a3 | 0) > 13780509) {
          c3 = xc(15, c3) | 0;
          return c3 | 0;
        } else {
          d3 = ((a3 | 0) < 0) << 31 >> 31;
          f2 = Pd(a3 | 0, d3 | 0, 3, 0) | 0;
          e3 = H() | 0;
          d3 = Jd(a3 | 0, d3 | 0, 1, 0) | 0;
          d3 = Pd(f2 | 0, e3 | 0, d3 | 0, H() | 0) | 0;
          d3 = Jd(d3 | 0, H() | 0, 1, 0) | 0;
          a3 = H() | 0;
          b2[c3 >> 2] = d3;
          b2[c3 + 4 >> 2] = a3;
          c3 = 0;
          return c3 | 0;
        }
        return 0;
      }
      function aa(a3, b3, c3, d3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        return ba(a3, b3, c3, d3, 0) | 0;
      }
      function ba(a3, c3, d3, e3, f2) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0;
        j = T;
        T = T + 16 | 0;
        h = j;
        if (!(ca(a3, c3, d3, e3, f2) | 0)) {
          e3 = 0;
          T = j;
          return e3 | 0;
        }
        do {
          if ((d3 | 0) >= 0) {
            if ((d3 | 0) > 13780509) {
              g2 = xc(15, h) | 0;
              if (g2 | 0) {
                break;
              }
              i = h;
              h = b2[i >> 2] | 0;
              i = b2[i + 4 >> 2] | 0;
            } else {
              g2 = ((d3 | 0) < 0) << 31 >> 31;
              k = Pd(d3 | 0, g2 | 0, 3, 0) | 0;
              i = H() | 0;
              g2 = Jd(d3 | 0, g2 | 0, 1, 0) | 0;
              g2 = Pd(k | 0, i | 0, g2 | 0, H() | 0) | 0;
              g2 = Jd(g2 | 0, H() | 0, 1, 0) | 0;
              i = H() | 0;
              b2[h >> 2] = g2;
              b2[h + 4 >> 2] = i;
              h = g2;
            }
            _d(e3 | 0, 0, h << 3 | 0) | 0;
            if (f2 | 0) {
              _d(f2 | 0, 0, h << 2 | 0) | 0;
              g2 = da(a3, c3, d3, e3, f2, h, i, 0) | 0;
              break;
            }
            g2 = Id(h, 4) | 0;
            if (!g2) {
              g2 = 13;
            } else {
              k = da(a3, c3, d3, e3, g2, h, i, 0) | 0;
              Hd(g2);
              g2 = k;
            }
          } else {
            g2 = 2;
          }
        } while (0);
        k = g2;
        T = j;
        return k | 0;
      }
      function ca(a3, c3, d3, e3, f2) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0;
        q2 = T;
        T = T + 16 | 0;
        o = q2;
        p2 = q2 + 8 | 0;
        n = o;
        b2[n >> 2] = a3;
        b2[n + 4 >> 2] = c3;
        if ((d3 | 0) < 0) {
          p2 = 2;
          T = q2;
          return p2 | 0;
        }
        g2 = e3;
        b2[g2 >> 2] = a3;
        b2[g2 + 4 >> 2] = c3;
        g2 = (f2 | 0) != 0;
        if (g2) {
          b2[f2 >> 2] = 0;
        }
        if (Kb(a3, c3) | 0) {
          p2 = 9;
          T = q2;
          return p2 | 0;
        }
        b2[p2 >> 2] = 0;
        a: do {
          if ((d3 | 0) >= 1) {
            if (g2) {
              l = 1;
              k = 0;
              m = 0;
              n = 1;
              g2 = a3;
              while (1) {
                if (!(k | m)) {
                  g2 = ea(g2, c3, 4, p2, o) | 0;
                  if (g2 | 0) {
                    break a;
                  }
                  c3 = o;
                  g2 = b2[c3 >> 2] | 0;
                  c3 = b2[c3 + 4 >> 2] | 0;
                  if (Kb(g2, c3) | 0) {
                    g2 = 9;
                    break a;
                  }
                }
                g2 = ea(g2, c3, b2[26800 + (m << 2) >> 2] | 0, p2, o) | 0;
                if (g2 | 0) {
                  break a;
                }
                c3 = o;
                g2 = b2[c3 >> 2] | 0;
                c3 = b2[c3 + 4 >> 2] | 0;
                a3 = e3 + (l << 3) | 0;
                b2[a3 >> 2] = g2;
                b2[a3 + 4 >> 2] = c3;
                b2[f2 + (l << 2) >> 2] = n;
                a3 = k + 1 | 0;
                h = (a3 | 0) == (n | 0);
                i = m + 1 | 0;
                j = (i | 0) == 6;
                if (Kb(g2, c3) | 0) {
                  g2 = 9;
                  break a;
                }
                n = n + (j & h & 1) | 0;
                if ((n | 0) > (d3 | 0)) {
                  g2 = 0;
                  break;
                } else {
                  l = l + 1 | 0;
                  k = h ? 0 : a3;
                  m = h ? j ? 0 : i : m;
                }
              }
            } else {
              l = 1;
              k = 0;
              m = 0;
              n = 1;
              g2 = a3;
              while (1) {
                if (!(k | m)) {
                  g2 = ea(g2, c3, 4, p2, o) | 0;
                  if (g2 | 0) {
                    break a;
                  }
                  c3 = o;
                  g2 = b2[c3 >> 2] | 0;
                  c3 = b2[c3 + 4 >> 2] | 0;
                  if (Kb(g2, c3) | 0) {
                    g2 = 9;
                    break a;
                  }
                }
                g2 = ea(g2, c3, b2[26800 + (m << 2) >> 2] | 0, p2, o) | 0;
                if (g2 | 0) {
                  break a;
                }
                c3 = o;
                g2 = b2[c3 >> 2] | 0;
                c3 = b2[c3 + 4 >> 2] | 0;
                a3 = e3 + (l << 3) | 0;
                b2[a3 >> 2] = g2;
                b2[a3 + 4 >> 2] = c3;
                a3 = k + 1 | 0;
                h = (a3 | 0) == (n | 0);
                i = m + 1 | 0;
                j = (i | 0) == 6;
                if (Kb(g2, c3) | 0) {
                  g2 = 9;
                  break a;
                }
                n = n + (j & h & 1) | 0;
                if ((n | 0) > (d3 | 0)) {
                  g2 = 0;
                  break;
                } else {
                  l = l + 1 | 0;
                  k = h ? 0 : a3;
                  m = h ? j ? 0 : i : m;
                }
              }
            }
          } else {
            g2 = 0;
          }
        } while (0);
        p2 = g2;
        T = q2;
        return p2 | 0;
      }
      function da(a3, c3, d3, e3, f2, g2, h, i) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        h = h | 0;
        i = i | 0;
        var j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0;
        q2 = T;
        T = T + 16 | 0;
        o = q2 + 8 | 0;
        p2 = q2;
        j = Rd(a3 | 0, c3 | 0, g2 | 0, h | 0) | 0;
        l = H() | 0;
        m = e3 + (j << 3) | 0;
        r2 = m;
        s2 = b2[r2 >> 2] | 0;
        r2 = b2[r2 + 4 >> 2] | 0;
        k = (s2 | 0) == (a3 | 0) & (r2 | 0) == (c3 | 0);
        if (!((s2 | 0) == 0 & (r2 | 0) == 0 | k)) {
          do {
            j = Jd(j | 0, l | 0, 1, 0) | 0;
            j = Qd(j | 0, H() | 0, g2 | 0, h | 0) | 0;
            l = H() | 0;
            m = e3 + (j << 3) | 0;
            s2 = m;
            r2 = b2[s2 >> 2] | 0;
            s2 = b2[s2 + 4 >> 2] | 0;
            k = (r2 | 0) == (a3 | 0) & (s2 | 0) == (c3 | 0);
          } while (!((r2 | 0) == 0 & (s2 | 0) == 0 | k));
        }
        j = f2 + (j << 2) | 0;
        if (k ? (b2[j >> 2] | 0) <= (i | 0) : 0) {
          s2 = 0;
          T = q2;
          return s2 | 0;
        }
        s2 = m;
        b2[s2 >> 2] = a3;
        b2[s2 + 4 >> 2] = c3;
        b2[j >> 2] = i;
        if ((i | 0) >= (d3 | 0)) {
          s2 = 0;
          T = q2;
          return s2 | 0;
        }
        k = i + 1 | 0;
        b2[o >> 2] = 0;
        j = ea(a3, c3, 2, o, p2) | 0;
        switch (j | 0) {
          case 9: {
            n = 9;
            break;
          }
          case 0: {
            j = p2;
            j = da(b2[j >> 2] | 0, b2[j + 4 >> 2] | 0, d3, e3, f2, g2, h, k) | 0;
            if (!j) {
              n = 9;
            }
            break;
          }
          default:
        }
        a: do {
          if ((n | 0) == 9) {
            b2[o >> 2] = 0;
            j = ea(a3, c3, 3, o, p2) | 0;
            switch (j | 0) {
              case 9:
                break;
              case 0: {
                j = p2;
                j = da(b2[j >> 2] | 0, b2[j + 4 >> 2] | 0, d3, e3, f2, g2, h, k) | 0;
                if (j | 0) {
                  break a;
                }
                break;
              }
              default:
                break a;
            }
            b2[o >> 2] = 0;
            j = ea(a3, c3, 1, o, p2) | 0;
            switch (j | 0) {
              case 9:
                break;
              case 0: {
                j = p2;
                j = da(b2[j >> 2] | 0, b2[j + 4 >> 2] | 0, d3, e3, f2, g2, h, k) | 0;
                if (j | 0) {
                  break a;
                }
                break;
              }
              default:
                break a;
            }
            b2[o >> 2] = 0;
            j = ea(a3, c3, 5, o, p2) | 0;
            switch (j | 0) {
              case 9:
                break;
              case 0: {
                j = p2;
                j = da(b2[j >> 2] | 0, b2[j + 4 >> 2] | 0, d3, e3, f2, g2, h, k) | 0;
                if (j | 0) {
                  break a;
                }
                break;
              }
              default:
                break a;
            }
            b2[o >> 2] = 0;
            j = ea(a3, c3, 4, o, p2) | 0;
            switch (j | 0) {
              case 9:
                break;
              case 0: {
                j = p2;
                j = da(b2[j >> 2] | 0, b2[j + 4 >> 2] | 0, d3, e3, f2, g2, h, k) | 0;
                if (j | 0) {
                  break a;
                }
                break;
              }
              default:
                break a;
            }
            b2[o >> 2] = 0;
            j = ea(a3, c3, 6, o, p2) | 0;
            switch (j | 0) {
              case 9:
                break;
              case 0: {
                j = p2;
                j = da(b2[j >> 2] | 0, b2[j + 4 >> 2] | 0, d3, e3, f2, g2, h, k) | 0;
                if (j | 0) {
                  break a;
                }
                break;
              }
              default:
                break a;
            }
            s2 = 0;
            T = q2;
            return s2 | 0;
          }
        } while (0);
        s2 = j;
        T = q2;
        return s2 | 0;
      }
      function ea(a3, c3, d3, e3, f2) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0;
        if (d3 >>> 0 > 6) {
          f2 = 1;
          return f2 | 0;
        }
        m = (b2[e3 >> 2] | 0) % 6 | 0;
        b2[e3 >> 2] = m;
        if ((m | 0) > 0) {
          g2 = 0;
          do {
            d3 = $a(d3) | 0;
            g2 = g2 + 1 | 0;
          } while ((g2 | 0) < (b2[e3 >> 2] | 0));
        }
        m = Td(a3 | 0, c3 | 0, 45) | 0;
        H() | 0;
        l = m & 127;
        if (l >>> 0 > 121) {
          f2 = 5;
          return f2 | 0;
        }
        j = Sb(a3, c3) | 0;
        g2 = Td(a3 | 0, c3 | 0, 52) | 0;
        H() | 0;
        g2 = g2 & 15;
        a: do {
          if (!g2) {
            k = 8;
          } else {
            while (1) {
              h = (15 - g2 | 0) * 3 | 0;
              i = Td(a3 | 0, c3 | 0, h | 0) | 0;
              H() | 0;
              i = i & 7;
              if ((i | 0) == 7) {
                c3 = 5;
                break;
              }
              p2 = (Yb(g2) | 0) == 0;
              g2 = g2 + -1 | 0;
              n = Ud(7, 0, h | 0) | 0;
              c3 = c3 & ~(H() | 0);
              o = Ud(b2[(p2 ? 432 : 16) + (i * 28 | 0) + (d3 << 2) >> 2] | 0, 0, h | 0) | 0;
              h = H() | 0;
              d3 = b2[(p2 ? 640 : 224) + (i * 28 | 0) + (d3 << 2) >> 2] | 0;
              a3 = o | a3 & ~n;
              c3 = h | c3;
              if (!d3) {
                d3 = 0;
                break a;
              }
              if (!g2) {
                k = 8;
                break a;
              }
            }
            return c3 | 0;
          }
        } while (0);
        if ((k | 0) == 8) {
          p2 = b2[848 + (l * 28 | 0) + (d3 << 2) >> 2] | 0;
          o = Ud(p2 | 0, 0, 45) | 0;
          a3 = o | a3;
          c3 = H() | 0 | c3 & -1040385;
          d3 = b2[4272 + (l * 28 | 0) + (d3 << 2) >> 2] | 0;
          if ((p2 & 127 | 0) == 127) {
            p2 = Ud(b2[848 + (l * 28 | 0) + 20 >> 2] | 0, 0, 45) | 0;
            c3 = H() | 0 | c3 & -1040385;
            d3 = b2[4272 + (l * 28 | 0) + 20 >> 2] | 0;
            a3 = Ub(p2 | a3, c3) | 0;
            c3 = H() | 0;
            b2[e3 >> 2] = (b2[e3 >> 2] | 0) + 1;
          }
        }
        i = Td(a3 | 0, c3 | 0, 45) | 0;
        H() | 0;
        i = i & 127;
        b: do {
          if (!(oa(i) | 0)) {
            if ((d3 | 0) > 0) {
              g2 = 0;
              do {
                a3 = Ub(a3, c3) | 0;
                c3 = H() | 0;
                g2 = g2 + 1 | 0;
              } while ((g2 | 0) != (d3 | 0));
            }
          } else {
            c: do {
              if ((Sb(a3, c3) | 0) == 1) {
                if ((l | 0) != (i | 0)) {
                  if (ua(i, b2[7696 + (l * 28 | 0) >> 2] | 0) | 0) {
                    a3 = Wb(a3, c3) | 0;
                    h = 1;
                    c3 = H() | 0;
                    break;
                  } else {
                    I(27795, 26864, 533, 26872);
                  }
                }
                switch (j | 0) {
                  case 3: {
                    a3 = Ub(a3, c3) | 0;
                    c3 = H() | 0;
                    b2[e3 >> 2] = (b2[e3 >> 2] | 0) + 1;
                    h = 0;
                    break c;
                  }
                  case 5: {
                    a3 = Wb(a3, c3) | 0;
                    c3 = H() | 0;
                    b2[e3 >> 2] = (b2[e3 >> 2] | 0) + 5;
                    h = 0;
                    break c;
                  }
                  case 0: {
                    p2 = 9;
                    return p2 | 0;
                  }
                  default: {
                    p2 = 1;
                    return p2 | 0;
                  }
                }
              } else {
                h = 0;
              }
            } while (0);
            if ((d3 | 0) > 0) {
              g2 = 0;
              do {
                a3 = Tb(a3, c3) | 0;
                c3 = H() | 0;
                g2 = g2 + 1 | 0;
              } while ((g2 | 0) != (d3 | 0));
            }
            if ((l | 0) != (i | 0)) {
              if (!(pa(i) | 0)) {
                if ((h | 0) != 0 | (Sb(a3, c3) | 0) != 5) {
                  break;
                }
                b2[e3 >> 2] = (b2[e3 >> 2] | 0) + 1;
                break;
              }
              switch (m & 127) {
                case 8:
                case 118:
                  break b;
                default:
              }
              if ((Sb(a3, c3) | 0) != 3) {
                b2[e3 >> 2] = (b2[e3 >> 2] | 0) + 1;
              }
            }
          }
        } while (0);
        b2[e3 >> 2] = ((b2[e3 >> 2] | 0) + d3 | 0) % 6 | 0;
        p2 = f2;
        b2[p2 >> 2] = a3;
        b2[p2 + 4 >> 2] = c3;
        p2 = 0;
        return p2 | 0;
      }
      function fa(a3, b3, c3, d3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        if (!(ga(a3, b3, c3, d3) | 0)) {
          d3 = 0;
          return d3 | 0;
        }
        _d(d3 | 0, 0, c3 * 48 | 0) | 0;
        d3 = ha(a3, b3, c3, d3) | 0;
        return d3 | 0;
      }
      function ga(a3, c3, d3, e3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0;
        p2 = T;
        T = T + 16 | 0;
        n = p2;
        o = p2 + 8 | 0;
        m = n;
        b2[m >> 2] = a3;
        b2[m + 4 >> 2] = c3;
        if ((d3 | 0) < 0) {
          o = 2;
          T = p2;
          return o | 0;
        }
        if (!d3) {
          o = e3;
          b2[o >> 2] = a3;
          b2[o + 4 >> 2] = c3;
          o = 0;
          T = p2;
          return o | 0;
        }
        b2[o >> 2] = 0;
        a: do {
          if (!(Kb(a3, c3) | 0)) {
            f2 = 0;
            m = a3;
            do {
              a3 = ea(m, c3, 4, o, n) | 0;
              if (a3 | 0) {
                break a;
              }
              c3 = n;
              m = b2[c3 >> 2] | 0;
              c3 = b2[c3 + 4 >> 2] | 0;
              f2 = f2 + 1 | 0;
              if (Kb(m, c3) | 0) {
                a3 = 9;
                break a;
              }
            } while ((f2 | 0) < (d3 | 0));
            l = e3;
            b2[l >> 2] = m;
            b2[l + 4 >> 2] = c3;
            l = d3 + -1 | 0;
            k = 0;
            a3 = 1;
            do {
              f2 = 26800 + (k << 2) | 0;
              if ((k | 0) == 5) {
                h = b2[f2 >> 2] | 0;
                g2 = 0;
                f2 = a3;
                while (1) {
                  a3 = n;
                  a3 = ea(b2[a3 >> 2] | 0, b2[a3 + 4 >> 2] | 0, h, o, n) | 0;
                  if (a3 | 0) {
                    break a;
                  }
                  if ((g2 | 0) != (l | 0)) {
                    j = n;
                    i = b2[j >> 2] | 0;
                    j = b2[j + 4 >> 2] | 0;
                    a3 = e3 + (f2 << 3) | 0;
                    b2[a3 >> 2] = i;
                    b2[a3 + 4 >> 2] = j;
                    if (!(Kb(i, j) | 0)) {
                      a3 = f2 + 1 | 0;
                    } else {
                      a3 = 9;
                      break a;
                    }
                  } else {
                    a3 = f2;
                  }
                  g2 = g2 + 1 | 0;
                  if ((g2 | 0) >= (d3 | 0)) {
                    break;
                  } else {
                    f2 = a3;
                  }
                }
              } else {
                h = n;
                j = b2[f2 >> 2] | 0;
                i = 0;
                f2 = a3;
                g2 = b2[h >> 2] | 0;
                h = b2[h + 4 >> 2] | 0;
                while (1) {
                  a3 = ea(g2, h, j, o, n) | 0;
                  if (a3 | 0) {
                    break a;
                  }
                  h = n;
                  g2 = b2[h >> 2] | 0;
                  h = b2[h + 4 >> 2] | 0;
                  a3 = e3 + (f2 << 3) | 0;
                  b2[a3 >> 2] = g2;
                  b2[a3 + 4 >> 2] = h;
                  a3 = f2 + 1 | 0;
                  if (Kb(g2, h) | 0) {
                    a3 = 9;
                    break a;
                  }
                  i = i + 1 | 0;
                  if ((i | 0) >= (d3 | 0)) {
                    break;
                  } else {
                    f2 = a3;
                  }
                }
              }
              k = k + 1 | 0;
            } while (k >>> 0 < 6);
            a3 = n;
            a3 = ((m | 0) == (b2[a3 >> 2] | 0) ? (c3 | 0) == (b2[a3 + 4 >> 2] | 0) : 0) ? 0 : 9;
          } else {
            a3 = 9;
          }
        } while (0);
        o = a3;
        T = p2;
        return o | 0;
      }
      function ha(a3, c3, d3, e3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0;
        m = T;
        T = T + 16 | 0;
        h = m;
        if (!d3) {
          b2[e3 >> 2] = a3;
          b2[e3 + 4 >> 2] = c3;
          e3 = 0;
          T = m;
          return e3 | 0;
        }
        do {
          if ((d3 | 0) >= 0) {
            if ((d3 | 0) > 13780509) {
              f2 = xc(15, h) | 0;
              if (f2 | 0) {
                break;
              }
              g2 = h;
              f2 = b2[g2 >> 2] | 0;
              g2 = b2[g2 + 4 >> 2] | 0;
            } else {
              f2 = ((d3 | 0) < 0) << 31 >> 31;
              l = Pd(d3 | 0, f2 | 0, 3, 0) | 0;
              g2 = H() | 0;
              f2 = Jd(d3 | 0, f2 | 0, 1, 0) | 0;
              f2 = Pd(l | 0, g2 | 0, f2 | 0, H() | 0) | 0;
              f2 = Jd(f2 | 0, H() | 0, 1, 0) | 0;
              g2 = H() | 0;
              l = h;
              b2[l >> 2] = f2;
              b2[l + 4 >> 2] = g2;
            }
            k = Id(f2, 8) | 0;
            if (!k) {
              f2 = 13;
            } else {
              l = Id(f2, 4) | 0;
              if (!l) {
                Hd(k);
                f2 = 13;
                break;
              }
              f2 = da(a3, c3, d3, k, l, f2, g2, 0) | 0;
              if (f2 | 0) {
                Hd(k);
                Hd(l);
                break;
              }
              c3 = b2[h >> 2] | 0;
              h = b2[h + 4 >> 2] | 0;
              if ((h | 0) > 0 | (h | 0) == 0 & c3 >>> 0 > 0) {
                f2 = 0;
                i = 0;
                j = 0;
                do {
                  a3 = k + (i << 3) | 0;
                  g2 = b2[a3 >> 2] | 0;
                  a3 = b2[a3 + 4 >> 2] | 0;
                  if (!((g2 | 0) == 0 & (a3 | 0) == 0) ? (b2[l + (i << 2) >> 2] | 0) == (d3 | 0) : 0) {
                    n = e3 + (f2 << 3) | 0;
                    b2[n >> 2] = g2;
                    b2[n + 4 >> 2] = a3;
                    f2 = f2 + 1 | 0;
                  }
                  i = Jd(i | 0, j | 0, 1, 0) | 0;
                  j = H() | 0;
                } while ((j | 0) < (h | 0) | (j | 0) == (h | 0) & i >>> 0 < c3 >>> 0);
              }
              Hd(k);
              Hd(l);
              f2 = 0;
            }
          } else {
            f2 = 2;
          }
        } while (0);
        n = f2;
        T = m;
        return n | 0;
      }
      function ia(a3, c3, d3, e3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0;
        i = T;
        T = T + 16 | 0;
        g2 = i;
        h = i + 8 | 0;
        f2 = (Kb(a3, c3) | 0) == 0;
        f2 = f2 ? 1 : 2;
        while (1) {
          b2[h >> 2] = 0;
          k = (ea(a3, c3, f2, h, g2) | 0) == 0;
          j = g2;
          if (k & ((b2[j >> 2] | 0) == (d3 | 0) ? (b2[j + 4 >> 2] | 0) == (e3 | 0) : 0)) {
            a3 = 4;
            break;
          }
          f2 = f2 + 1 | 0;
          if (f2 >>> 0 >= 7) {
            f2 = 7;
            a3 = 4;
            break;
          }
        }
        if ((a3 | 0) == 4) {
          T = i;
          return f2 | 0;
        }
        return 0;
      }
      function ja(a3, c3, d3, e3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0;
        i = T;
        T = T + 48 | 0;
        f2 = i + 16 | 0;
        g2 = i + 8 | 0;
        h = i;
        d3 = _c(d3) | 0;
        if (d3 | 0) {
          h = d3;
          T = i;
          return h | 0;
        }
        k = a3;
        j = b2[k + 4 >> 2] | 0;
        d3 = g2;
        b2[d3 >> 2] = b2[k >> 2];
        b2[d3 + 4 >> 2] = j;
        Zc(g2, f2);
        d3 = Ha(f2, c3, h) | 0;
        if (!d3) {
          c3 = b2[g2 >> 2] | 0;
          g2 = b2[a3 + 8 >> 2] | 0;
          if ((g2 | 0) > 0) {
            f2 = b2[a3 + 12 >> 2] | 0;
            d3 = 0;
            do {
              c3 = (b2[f2 + (d3 << 3) >> 2] | 0) + c3 | 0;
              d3 = d3 + 1 | 0;
            } while ((d3 | 0) < (g2 | 0));
          }
          d3 = h;
          f2 = b2[d3 >> 2] | 0;
          d3 = b2[d3 + 4 >> 2] | 0;
          g2 = ((c3 | 0) < 0) << 31 >> 31;
          if ((d3 | 0) < (g2 | 0) | (d3 | 0) == (g2 | 0) & f2 >>> 0 < c3 >>> 0) {
            d3 = h;
            b2[d3 >> 2] = c3;
            b2[d3 + 4 >> 2] = g2;
            d3 = g2;
          } else {
            c3 = f2;
          }
          j = Jd(c3 | 0, d3 | 0, 12, 0) | 0;
          k = H() | 0;
          d3 = h;
          b2[d3 >> 2] = j;
          b2[d3 + 4 >> 2] = k;
          d3 = e3;
          b2[d3 >> 2] = j;
          b2[d3 + 4 >> 2] = k;
          d3 = 0;
        }
        k = d3;
        T = i;
        return k | 0;
      }
      function ka(a3, c3, d3, f2, g2, h, i) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        h = h | 0;
        i = i | 0;
        var j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t2 = 0, u3 = 0, v3 = 0, w3 = 0, x2 = 0, y2 = 0, z2 = 0, A3 = 0, B3 = 0, C3 = 0, D3 = 0, E3 = 0, F2 = 0, G3 = 0, I2 = 0, J2 = 0, K2 = 0, L3 = 0, M2 = 0;
        I2 = T;
        T = T + 64 | 0;
        D3 = I2 + 48 | 0;
        E3 = I2 + 32 | 0;
        F2 = I2 + 24 | 0;
        x2 = I2 + 8 | 0;
        y2 = I2;
        k = b2[a3 >> 2] | 0;
        if ((k | 0) <= 0) {
          G3 = 0;
          T = I2;
          return G3 | 0;
        }
        z2 = a3 + 4 | 0;
        A3 = D3 + 8 | 0;
        B3 = E3 + 8 | 0;
        C3 = x2 + 8 | 0;
        j = 0;
        v3 = 0;
        while (1) {
          l = b2[z2 >> 2] | 0;
          u3 = l + (v3 << 4) | 0;
          b2[D3 >> 2] = b2[u3 >> 2];
          b2[D3 + 4 >> 2] = b2[u3 + 4 >> 2];
          b2[D3 + 8 >> 2] = b2[u3 + 8 >> 2];
          b2[D3 + 12 >> 2] = b2[u3 + 12 >> 2];
          if ((v3 | 0) == (k + -1 | 0)) {
            b2[E3 >> 2] = b2[l >> 2];
            b2[E3 + 4 >> 2] = b2[l + 4 >> 2];
            b2[E3 + 8 >> 2] = b2[l + 8 >> 2];
            b2[E3 + 12 >> 2] = b2[l + 12 >> 2];
          } else {
            u3 = l + (v3 + 1 << 4) | 0;
            b2[E3 >> 2] = b2[u3 >> 2];
            b2[E3 + 4 >> 2] = b2[u3 + 4 >> 2];
            b2[E3 + 8 >> 2] = b2[u3 + 8 >> 2];
            b2[E3 + 12 >> 2] = b2[u3 + 12 >> 2];
          }
          k = Ia(D3, E3, f2, F2) | 0;
          a: do {
            if (!k) {
              k = F2;
              l = b2[k >> 2] | 0;
              k = b2[k + 4 >> 2] | 0;
              if ((k | 0) > 0 | (k | 0) == 0 & l >>> 0 > 0) {
                t2 = 0;
                u3 = 0;
                b: while (1) {
                  K2 = 1 / (+(l >>> 0) + 4294967296 * +(k | 0));
                  M2 = +e2[D3 >> 3];
                  k = Kd(l | 0, k | 0, t2 | 0, u3 | 0) | 0;
                  L3 = +(k >>> 0) + 4294967296 * +(H() | 0);
                  J2 = +(t2 >>> 0) + 4294967296 * +(u3 | 0);
                  e2[x2 >> 3] = K2 * (M2 * L3) + K2 * (+e2[E3 >> 3] * J2);
                  e2[C3 >> 3] = K2 * (+e2[A3 >> 3] * L3) + K2 * (+e2[B3 >> 3] * J2);
                  k = Zb(x2, f2, y2) | 0;
                  if (k | 0) {
                    j = k;
                    break;
                  }
                  s2 = y2;
                  r2 = b2[s2 >> 2] | 0;
                  s2 = b2[s2 + 4 >> 2] | 0;
                  o = Rd(r2 | 0, s2 | 0, c3 | 0, d3 | 0) | 0;
                  m = H() | 0;
                  k = i + (o << 3) | 0;
                  n = k;
                  l = b2[n >> 2] | 0;
                  n = b2[n + 4 >> 2] | 0;
                  c: do {
                    if ((l | 0) == 0 & (n | 0) == 0) {
                      w3 = k;
                      G3 = 16;
                    } else {
                      p2 = 0;
                      q2 = 0;
                      while (1) {
                        if ((p2 | 0) > (d3 | 0) | (p2 | 0) == (d3 | 0) & q2 >>> 0 > c3 >>> 0) {
                          j = 1;
                          break b;
                        }
                        if ((l | 0) == (r2 | 0) & (n | 0) == (s2 | 0)) {
                          break c;
                        }
                        k = Jd(o | 0, m | 0, 1, 0) | 0;
                        o = Qd(k | 0, H() | 0, c3 | 0, d3 | 0) | 0;
                        m = H() | 0;
                        q2 = Jd(q2 | 0, p2 | 0, 1, 0) | 0;
                        p2 = H() | 0;
                        k = i + (o << 3) | 0;
                        n = k;
                        l = b2[n >> 2] | 0;
                        n = b2[n + 4 >> 2] | 0;
                        if ((l | 0) == 0 & (n | 0) == 0) {
                          w3 = k;
                          G3 = 16;
                          break;
                        }
                      }
                    }
                  } while (0);
                  if ((G3 | 0) == 16 ? (G3 = 0, !((r2 | 0) == 0 & (s2 | 0) == 0)) : 0) {
                    q2 = w3;
                    b2[q2 >> 2] = r2;
                    b2[q2 + 4 >> 2] = s2;
                    q2 = h + (b2[g2 >> 2] << 3) | 0;
                    b2[q2 >> 2] = r2;
                    b2[q2 + 4 >> 2] = s2;
                    q2 = g2;
                    q2 = Jd(b2[q2 >> 2] | 0, b2[q2 + 4 >> 2] | 0, 1, 0) | 0;
                    r2 = H() | 0;
                    s2 = g2;
                    b2[s2 >> 2] = q2;
                    b2[s2 + 4 >> 2] = r2;
                  }
                  t2 = Jd(t2 | 0, u3 | 0, 1, 0) | 0;
                  u3 = H() | 0;
                  k = F2;
                  l = b2[k >> 2] | 0;
                  k = b2[k + 4 >> 2] | 0;
                  if (!((k | 0) > (u3 | 0) | (k | 0) == (u3 | 0) & l >>> 0 > t2 >>> 0)) {
                    l = 1;
                    break a;
                  }
                }
                l = 0;
              } else {
                l = 1;
              }
            } else {
              l = 0;
              j = k;
            }
          } while (0);
          v3 = v3 + 1 | 0;
          if (!l) {
            G3 = 21;
            break;
          }
          k = b2[a3 >> 2] | 0;
          if ((v3 | 0) >= (k | 0)) {
            j = 0;
            G3 = 21;
            break;
          }
        }
        if ((G3 | 0) == 21) {
          T = I2;
          return j | 0;
        }
        return 0;
      }
      function la(a3, c3, d3, e3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t2 = 0, u3 = 0, v3 = 0, w3 = 0, x2 = 0, y2 = 0, z2 = 0, A3 = 0, B3 = 0, C3 = 0, D3 = 0, E3 = 0, F2 = 0, G3 = 0, I2 = 0, J2 = 0, K2 = 0;
        K2 = T;
        T = T + 112 | 0;
        F2 = K2 + 80 | 0;
        j = K2 + 72 | 0;
        G3 = K2;
        I2 = K2 + 56 | 0;
        f2 = _c(d3) | 0;
        if (f2 | 0) {
          J2 = f2;
          T = K2;
          return J2 | 0;
        }
        k = a3 + 8 | 0;
        J2 = Gd((b2[k >> 2] << 5) + 32 | 0) | 0;
        if (!J2) {
          J2 = 13;
          T = K2;
          return J2 | 0;
        }
        $c(a3, J2);
        f2 = _c(d3) | 0;
        if (!f2) {
          D3 = a3;
          E3 = b2[D3 + 4 >> 2] | 0;
          f2 = j;
          b2[f2 >> 2] = b2[D3 >> 2];
          b2[f2 + 4 >> 2] = E3;
          Zc(j, F2);
          f2 = Ha(F2, c3, G3) | 0;
          if (!f2) {
            f2 = b2[j >> 2] | 0;
            g2 = b2[k >> 2] | 0;
            if ((g2 | 0) > 0) {
              h = b2[a3 + 12 >> 2] | 0;
              d3 = 0;
              do {
                f2 = (b2[h + (d3 << 3) >> 2] | 0) + f2 | 0;
                d3 = d3 + 1 | 0;
              } while ((d3 | 0) != (g2 | 0));
              d3 = f2;
            } else {
              d3 = f2;
            }
            f2 = G3;
            g2 = b2[f2 >> 2] | 0;
            f2 = b2[f2 + 4 >> 2] | 0;
            h = ((d3 | 0) < 0) << 31 >> 31;
            if ((f2 | 0) < (h | 0) | (f2 | 0) == (h | 0) & g2 >>> 0 < d3 >>> 0) {
              f2 = G3;
              b2[f2 >> 2] = d3;
              b2[f2 + 4 >> 2] = h;
              f2 = h;
            } else {
              d3 = g2;
            }
            D3 = Jd(d3 | 0, f2 | 0, 12, 0) | 0;
            E3 = H() | 0;
            f2 = G3;
            b2[f2 >> 2] = D3;
            b2[f2 + 4 >> 2] = E3;
            f2 = 0;
          } else {
            D3 = 0;
            E3 = 0;
          }
          if (!f2) {
            d3 = Id(D3, 8) | 0;
            if (!d3) {
              Hd(J2);
              J2 = 13;
              T = K2;
              return J2 | 0;
            }
            i = Id(D3, 8) | 0;
            if (!i) {
              Hd(J2);
              Hd(d3);
              J2 = 13;
              T = K2;
              return J2 | 0;
            }
            B3 = F2;
            b2[B3 >> 2] = 0;
            b2[B3 + 4 >> 2] = 0;
            B3 = a3;
            C3 = b2[B3 + 4 >> 2] | 0;
            f2 = j;
            b2[f2 >> 2] = b2[B3 >> 2];
            b2[f2 + 4 >> 2] = C3;
            f2 = ka(j, D3, E3, c3, F2, d3, i) | 0;
            a: do {
              if (!f2) {
                b: do {
                  if ((b2[k >> 2] | 0) > 0) {
                    h = a3 + 12 | 0;
                    g2 = 0;
                    while (1) {
                      f2 = ka((b2[h >> 2] | 0) + (g2 << 3) | 0, D3, E3, c3, F2, d3, i) | 0;
                      g2 = g2 + 1 | 0;
                      if (f2 | 0) {
                        break;
                      }
                      if ((g2 | 0) >= (b2[k >> 2] | 0)) {
                        break b;
                      }
                    }
                    Hd(d3);
                    Hd(i);
                    Hd(J2);
                    break a;
                  }
                } while (0);
                if ((E3 | 0) > 0 | (E3 | 0) == 0 & D3 >>> 0 > 0) {
                  _d(i | 0, 0, D3 << 3 | 0) | 0;
                }
                C3 = F2;
                B3 = b2[C3 + 4 >> 2] | 0;
                c: do {
                  if ((B3 | 0) > 0 | (B3 | 0) == 0 & (b2[C3 >> 2] | 0) >>> 0 > 0) {
                    y2 = d3;
                    z2 = i;
                    A3 = d3;
                    B3 = i;
                    C3 = d3;
                    f2 = d3;
                    v3 = d3;
                    w3 = i;
                    x2 = i;
                    d3 = i;
                    d: while (1) {
                      r2 = 0;
                      s2 = 0;
                      t2 = 0;
                      u3 = 0;
                      g2 = 0;
                      h = 0;
                      while (1) {
                        i = G3;
                        j = i + 56 | 0;
                        do {
                          b2[i >> 2] = 0;
                          i = i + 4 | 0;
                        } while ((i | 0) < (j | 0));
                        c3 = y2 + (r2 << 3) | 0;
                        k = b2[c3 >> 2] | 0;
                        c3 = b2[c3 + 4 >> 2] | 0;
                        if (ca(k, c3, 1, G3, 0) | 0) {
                          i = G3;
                          j = i + 56 | 0;
                          do {
                            b2[i >> 2] = 0;
                            i = i + 4 | 0;
                          } while ((i | 0) < (j | 0));
                          i = Id(7, 4) | 0;
                          if (i | 0) {
                            da(k, c3, 1, G3, i, 7, 0, 0) | 0;
                            Hd(i);
                          }
                        }
                        q2 = 0;
                        while (1) {
                          p2 = G3 + (q2 << 3) | 0;
                          o = b2[p2 >> 2] | 0;
                          p2 = b2[p2 + 4 >> 2] | 0;
                          e: do {
                            if ((o | 0) == 0 & (p2 | 0) == 0) {
                              i = g2;
                              j = h;
                            } else {
                              l = Rd(o | 0, p2 | 0, D3 | 0, E3 | 0) | 0;
                              k = H() | 0;
                              i = e3 + (l << 3) | 0;
                              c3 = i;
                              j = b2[c3 >> 2] | 0;
                              c3 = b2[c3 + 4 >> 2] | 0;
                              if (!((j | 0) == 0 & (c3 | 0) == 0)) {
                                m = 0;
                                n = 0;
                                do {
                                  if ((m | 0) > (E3 | 0) | (m | 0) == (E3 | 0) & n >>> 0 > D3 >>> 0) {
                                    break d;
                                  }
                                  if ((j | 0) == (o | 0) & (c3 | 0) == (p2 | 0)) {
                                    i = g2;
                                    j = h;
                                    break e;
                                  }
                                  i = Jd(l | 0, k | 0, 1, 0) | 0;
                                  l = Qd(i | 0, H() | 0, D3 | 0, E3 | 0) | 0;
                                  k = H() | 0;
                                  n = Jd(n | 0, m | 0, 1, 0) | 0;
                                  m = H() | 0;
                                  i = e3 + (l << 3) | 0;
                                  c3 = i;
                                  j = b2[c3 >> 2] | 0;
                                  c3 = b2[c3 + 4 >> 2] | 0;
                                } while (!((j | 0) == 0 & (c3 | 0) == 0));
                              }
                              if ((o | 0) == 0 & (p2 | 0) == 0) {
                                i = g2;
                                j = h;
                                break;
                              }
                              ac(o, p2, I2) | 0;
                              if (ad(a3, J2, I2) | 0) {
                                n = Jd(g2 | 0, h | 0, 1, 0) | 0;
                                h = H() | 0;
                                m = i;
                                b2[m >> 2] = o;
                                b2[m + 4 >> 2] = p2;
                                g2 = z2 + (g2 << 3) | 0;
                                b2[g2 >> 2] = o;
                                b2[g2 + 4 >> 2] = p2;
                                g2 = n;
                              }
                              i = g2;
                              j = h;
                            }
                          } while (0);
                          q2 = q2 + 1 | 0;
                          if (q2 >>> 0 >= 7) {
                            break;
                          } else {
                            g2 = i;
                            h = j;
                          }
                        }
                        r2 = Jd(r2 | 0, s2 | 0, 1, 0) | 0;
                        s2 = H() | 0;
                        t2 = Jd(t2 | 0, u3 | 0, 1, 0) | 0;
                        u3 = H() | 0;
                        h = F2;
                        g2 = b2[h >> 2] | 0;
                        h = b2[h + 4 >> 2] | 0;
                        if (!((u3 | 0) < (h | 0) | (u3 | 0) == (h | 0) & t2 >>> 0 < g2 >>> 0)) {
                          break;
                        } else {
                          g2 = i;
                          h = j;
                        }
                      }
                      if ((h | 0) > 0 | (h | 0) == 0 & g2 >>> 0 > 0) {
                        g2 = 0;
                        h = 0;
                        do {
                          u3 = y2 + (g2 << 3) | 0;
                          b2[u3 >> 2] = 0;
                          b2[u3 + 4 >> 2] = 0;
                          g2 = Jd(g2 | 0, h | 0, 1, 0) | 0;
                          h = H() | 0;
                          u3 = F2;
                          t2 = b2[u3 + 4 >> 2] | 0;
                        } while ((h | 0) < (t2 | 0) | ((h | 0) == (t2 | 0) ? g2 >>> 0 < (b2[u3 >> 2] | 0) >>> 0 : 0));
                      }
                      u3 = F2;
                      b2[u3 >> 2] = i;
                      b2[u3 + 4 >> 2] = j;
                      if ((j | 0) > 0 | (j | 0) == 0 & i >>> 0 > 0) {
                        q2 = d3;
                        r2 = x2;
                        s2 = C3;
                        t2 = w3;
                        u3 = z2;
                        d3 = v3;
                        x2 = f2;
                        w3 = A3;
                        v3 = q2;
                        f2 = r2;
                        C3 = B3;
                        B3 = s2;
                        A3 = t2;
                        z2 = y2;
                        y2 = u3;
                      } else {
                        break c;
                      }
                    }
                    Hd(A3);
                    Hd(B3);
                    Hd(J2);
                    f2 = 1;
                    break a;
                  } else {
                    f2 = i;
                  }
                } while (0);
                Hd(J2);
                Hd(d3);
                Hd(f2);
                f2 = 0;
              } else {
                Hd(d3);
                Hd(i);
                Hd(J2);
              }
            } while (0);
            J2 = f2;
            T = K2;
            return J2 | 0;
          }
        }
        Hd(J2);
        J2 = f2;
        T = K2;
        return J2 | 0;
      }
      function ma(a3, c3, d3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0;
        l = T;
        T = T + 176 | 0;
        j = l;
        if ((c3 | 0) < 1) {
          xd(d3, 0, 0);
          k = 0;
          T = l;
          return k | 0;
        }
        i = a3;
        i = Td(b2[i >> 2] | 0, b2[i + 4 >> 2] | 0, 52) | 0;
        H() | 0;
        xd(d3, (c3 | 0) > 6 ? c3 : 6, i & 15);
        i = 0;
        while (1) {
          e3 = a3 + (i << 3) | 0;
          e3 = bc(b2[e3 >> 2] | 0, b2[e3 + 4 >> 2] | 0, j) | 0;
          if (e3 | 0) {
            break;
          }
          e3 = b2[j >> 2] | 0;
          if ((e3 | 0) > 0) {
            h = 0;
            do {
              g2 = j + 8 + (h << 4) | 0;
              h = h + 1 | 0;
              e3 = j + 8 + (((h | 0) % (e3 | 0) | 0) << 4) | 0;
              f2 = Cd(d3, e3, g2) | 0;
              if (!f2) {
                Bd(d3, g2, e3) | 0;
              } else {
                Ad(d3, f2) | 0;
              }
              e3 = b2[j >> 2] | 0;
            } while ((h | 0) < (e3 | 0));
          }
          i = i + 1 | 0;
          if ((i | 0) >= (c3 | 0)) {
            e3 = 0;
            k = 13;
            break;
          }
        }
        if ((k | 0) == 13) {
          T = l;
          return e3 | 0;
        }
        yd(d3);
        k = e3;
        T = l;
        return k | 0;
      }
      function na(a3, c3, d3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0, g2 = 0, h = 0;
        g2 = T;
        T = T + 32 | 0;
        e3 = g2;
        f2 = g2 + 16 | 0;
        a3 = ma(a3, c3, f2) | 0;
        if (a3 | 0) {
          d3 = a3;
          T = g2;
          return d3 | 0;
        }
        b2[d3 >> 2] = 0;
        b2[d3 + 4 >> 2] = 0;
        b2[d3 + 8 >> 2] = 0;
        a3 = zd(f2) | 0;
        if (a3 | 0) {
          do {
            c3 = Fc(d3) | 0;
            do {
              Gc(c3, a3) | 0;
              h = a3 + 16 | 0;
              b2[e3 >> 2] = b2[h >> 2];
              b2[e3 + 4 >> 2] = b2[h + 4 >> 2];
              b2[e3 + 8 >> 2] = b2[h + 8 >> 2];
              b2[e3 + 12 >> 2] = b2[h + 12 >> 2];
              Ad(f2, a3) | 0;
              a3 = Dd(f2, e3) | 0;
            } while ((a3 | 0) != 0);
            a3 = zd(f2) | 0;
          } while ((a3 | 0) != 0);
        }
        yd(f2);
        a3 = Ic(d3) | 0;
        if (!a3) {
          h = 0;
          T = g2;
          return h | 0;
        }
        Hc(d3);
        h = a3;
        T = g2;
        return h | 0;
      }
      function oa(a3) {
        a3 = a3 | 0;
        if (a3 >>> 0 > 121) {
          a3 = 0;
          return a3 | 0;
        }
        a3 = b2[7696 + (a3 * 28 | 0) + 16 >> 2] | 0;
        return a3 | 0;
      }
      function pa(a3) {
        a3 = a3 | 0;
        return (a3 | 0) == 4 | (a3 | 0) == 117 | 0;
      }
      function qa(a3) {
        a3 = a3 | 0;
        return b2[11120 + ((b2[a3 >> 2] | 0) * 216 | 0) + ((b2[a3 + 4 >> 2] | 0) * 72 | 0) + ((b2[a3 + 8 >> 2] | 0) * 24 | 0) + (b2[a3 + 12 >> 2] << 3) >> 2] | 0;
      }
      function ra(a3) {
        a3 = a3 | 0;
        return b2[11120 + ((b2[a3 >> 2] | 0) * 216 | 0) + ((b2[a3 + 4 >> 2] | 0) * 72 | 0) + ((b2[a3 + 8 >> 2] | 0) * 24 | 0) + (b2[a3 + 12 >> 2] << 3) + 4 >> 2] | 0;
      }
      function sa(a3, c3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        a3 = 7696 + (a3 * 28 | 0) | 0;
        b2[c3 >> 2] = b2[a3 >> 2];
        b2[c3 + 4 >> 2] = b2[a3 + 4 >> 2];
        b2[c3 + 8 >> 2] = b2[a3 + 8 >> 2];
        b2[c3 + 12 >> 2] = b2[a3 + 12 >> 2];
        return;
      }
      function ta(a3, c3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        var d3 = 0, e3 = 0;
        if (c3 >>> 0 > 20) {
          c3 = -1;
          return c3 | 0;
        }
        do {
          if ((b2[11120 + (c3 * 216 | 0) >> 2] | 0) != (a3 | 0)) {
            if ((b2[11120 + (c3 * 216 | 0) + 8 >> 2] | 0) != (a3 | 0)) {
              if ((b2[11120 + (c3 * 216 | 0) + 16 >> 2] | 0) != (a3 | 0)) {
                if ((b2[11120 + (c3 * 216 | 0) + 24 >> 2] | 0) != (a3 | 0)) {
                  if ((b2[11120 + (c3 * 216 | 0) + 32 >> 2] | 0) != (a3 | 0)) {
                    if ((b2[11120 + (c3 * 216 | 0) + 40 >> 2] | 0) != (a3 | 0)) {
                      if ((b2[11120 + (c3 * 216 | 0) + 48 >> 2] | 0) != (a3 | 0)) {
                        if ((b2[11120 + (c3 * 216 | 0) + 56 >> 2] | 0) != (a3 | 0)) {
                          if ((b2[11120 + (c3 * 216 | 0) + 64 >> 2] | 0) != (a3 | 0)) {
                            if ((b2[11120 + (c3 * 216 | 0) + 72 >> 2] | 0) != (a3 | 0)) {
                              if ((b2[11120 + (c3 * 216 | 0) + 80 >> 2] | 0) != (a3 | 0)) {
                                if ((b2[11120 + (c3 * 216 | 0) + 88 >> 2] | 0) != (a3 | 0)) {
                                  if ((b2[11120 + (c3 * 216 | 0) + 96 >> 2] | 0) != (a3 | 0)) {
                                    if ((b2[11120 + (c3 * 216 | 0) + 104 >> 2] | 0) != (a3 | 0)) {
                                      if ((b2[11120 + (c3 * 216 | 0) + 112 >> 2] | 0) != (a3 | 0)) {
                                        if ((b2[11120 + (c3 * 216 | 0) + 120 >> 2] | 0) != (a3 | 0)) {
                                          if ((b2[11120 + (c3 * 216 | 0) + 128 >> 2] | 0) != (a3 | 0)) {
                                            if ((b2[11120 + (c3 * 216 | 0) + 136 >> 2] | 0) == (a3 | 0)) {
                                              a3 = 2;
                                              d3 = 1;
                                              e3 = 2;
                                            } else {
                                              if ((b2[11120 + (c3 * 216 | 0) + 144 >> 2] | 0) == (a3 | 0)) {
                                                a3 = 0;
                                                d3 = 2;
                                                e3 = 0;
                                                break;
                                              }
                                              if ((b2[11120 + (c3 * 216 | 0) + 152 >> 2] | 0) == (a3 | 0)) {
                                                a3 = 0;
                                                d3 = 2;
                                                e3 = 1;
                                                break;
                                              }
                                              if ((b2[11120 + (c3 * 216 | 0) + 160 >> 2] | 0) == (a3 | 0)) {
                                                a3 = 0;
                                                d3 = 2;
                                                e3 = 2;
                                                break;
                                              }
                                              if ((b2[11120 + (c3 * 216 | 0) + 168 >> 2] | 0) == (a3 | 0)) {
                                                a3 = 1;
                                                d3 = 2;
                                                e3 = 0;
                                                break;
                                              }
                                              if ((b2[11120 + (c3 * 216 | 0) + 176 >> 2] | 0) == (a3 | 0)) {
                                                a3 = 1;
                                                d3 = 2;
                                                e3 = 1;
                                                break;
                                              }
                                              if ((b2[11120 + (c3 * 216 | 0) + 184 >> 2] | 0) == (a3 | 0)) {
                                                a3 = 1;
                                                d3 = 2;
                                                e3 = 2;
                                                break;
                                              }
                                              if ((b2[11120 + (c3 * 216 | 0) + 192 >> 2] | 0) == (a3 | 0)) {
                                                a3 = 2;
                                                d3 = 2;
                                                e3 = 0;
                                                break;
                                              }
                                              if ((b2[11120 + (c3 * 216 | 0) + 200 >> 2] | 0) == (a3 | 0)) {
                                                a3 = 2;
                                                d3 = 2;
                                                e3 = 1;
                                                break;
                                              }
                                              if ((b2[11120 + (c3 * 216 | 0) + 208 >> 2] | 0) == (a3 | 0)) {
                                                a3 = 2;
                                                d3 = 2;
                                                e3 = 2;
                                                break;
                                              } else {
                                                a3 = -1;
                                              }
                                              return a3 | 0;
                                            }
                                          } else {
                                            a3 = 2;
                                            d3 = 1;
                                            e3 = 1;
                                          }
                                        } else {
                                          a3 = 2;
                                          d3 = 1;
                                          e3 = 0;
                                        }
                                      } else {
                                        a3 = 1;
                                        d3 = 1;
                                        e3 = 2;
                                      }
                                    } else {
                                      a3 = 1;
                                      d3 = 1;
                                      e3 = 1;
                                    }
                                  } else {
                                    a3 = 1;
                                    d3 = 1;
                                    e3 = 0;
                                  }
                                } else {
                                  a3 = 0;
                                  d3 = 1;
                                  e3 = 2;
                                }
                              } else {
                                a3 = 0;
                                d3 = 1;
                                e3 = 1;
                              }
                            } else {
                              a3 = 0;
                              d3 = 1;
                              e3 = 0;
                            }
                          } else {
                            a3 = 2;
                            d3 = 0;
                            e3 = 2;
                          }
                        } else {
                          a3 = 2;
                          d3 = 0;
                          e3 = 1;
                        }
                      } else {
                        a3 = 2;
                        d3 = 0;
                        e3 = 0;
                      }
                    } else {
                      a3 = 1;
                      d3 = 0;
                      e3 = 2;
                    }
                  } else {
                    a3 = 1;
                    d3 = 0;
                    e3 = 1;
                  }
                } else {
                  a3 = 1;
                  d3 = 0;
                  e3 = 0;
                }
              } else {
                a3 = 0;
                d3 = 0;
                e3 = 2;
              }
            } else {
              a3 = 0;
              d3 = 0;
              e3 = 1;
            }
          } else {
            a3 = 0;
            d3 = 0;
            e3 = 0;
          }
        } while (0);
        c3 = b2[11120 + (c3 * 216 | 0) + (d3 * 72 | 0) + (a3 * 24 | 0) + (e3 << 3) + 4 >> 2] | 0;
        return c3 | 0;
      }
      function ua(a3, c3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        if ((b2[7696 + (a3 * 28 | 0) + 20 >> 2] | 0) == (c3 | 0)) {
          c3 = 1;
          return c3 | 0;
        }
        c3 = (b2[7696 + (a3 * 28 | 0) + 24 >> 2] | 0) == (c3 | 0);
        return c3 | 0;
      }
      function va(a3, c3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        return b2[848 + (a3 * 28 | 0) + (c3 << 2) >> 2] | 0;
      }
      function wa(a3, c3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        if ((b2[848 + (a3 * 28 | 0) >> 2] | 0) == (c3 | 0)) {
          c3 = 0;
          return c3 | 0;
        }
        if ((b2[848 + (a3 * 28 | 0) + 4 >> 2] | 0) == (c3 | 0)) {
          c3 = 1;
          return c3 | 0;
        }
        if ((b2[848 + (a3 * 28 | 0) + 8 >> 2] | 0) == (c3 | 0)) {
          c3 = 2;
          return c3 | 0;
        }
        if ((b2[848 + (a3 * 28 | 0) + 12 >> 2] | 0) == (c3 | 0)) {
          c3 = 3;
          return c3 | 0;
        }
        if ((b2[848 + (a3 * 28 | 0) + 16 >> 2] | 0) == (c3 | 0)) {
          c3 = 4;
          return c3 | 0;
        }
        if ((b2[848 + (a3 * 28 | 0) + 20 >> 2] | 0) == (c3 | 0)) {
          c3 = 5;
          return c3 | 0;
        } else {
          return ((b2[848 + (a3 * 28 | 0) + 24 >> 2] | 0) == (c3 | 0) ? 6 : 7) | 0;
        }
        return 0;
      }
      function xa() {
        return 122;
      }
      function ya(a3) {
        a3 = a3 | 0;
        var c3 = 0, d3 = 0, e3 = 0;
        c3 = 0;
        do {
          Ud(c3 | 0, 0, 45) | 0;
          e3 = H() | 0 | 134225919;
          d3 = a3 + (c3 << 3) | 0;
          b2[d3 >> 2] = -1;
          b2[d3 + 4 >> 2] = e3;
          c3 = c3 + 1 | 0;
        } while ((c3 | 0) != 122);
        return 0;
      }
      function za(a3) {
        a3 = a3 | 0;
        var b3 = 0, c3 = 0, d3 = 0;
        d3 = +e2[a3 + 16 >> 3];
        c3 = +e2[a3 + 24 >> 3];
        b3 = d3 - c3;
        return +(d3 < c3 ? b3 + 6.283185307179586 : b3);
      }
      function Aa(a3) {
        a3 = a3 | 0;
        return +e2[a3 + 16 >> 3] < +e2[a3 + 24 >> 3] | 0;
      }
      function Ba(a3) {
        a3 = a3 | 0;
        return +(+e2[a3 >> 3] - +e2[a3 + 8 >> 3]);
      }
      function Ca(a3, b3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        var c3 = 0, d3 = 0, f2 = 0;
        c3 = +e2[b3 >> 3];
        if (!(c3 >= +e2[a3 + 8 >> 3])) {
          b3 = 0;
          return b3 | 0;
        }
        if (!(c3 <= +e2[a3 >> 3])) {
          b3 = 0;
          return b3 | 0;
        }
        d3 = +e2[a3 + 16 >> 3];
        c3 = +e2[a3 + 24 >> 3];
        f2 = +e2[b3 + 8 >> 3];
        b3 = f2 >= c3;
        a3 = f2 <= d3 & 1;
        if (d3 < c3) {
          if (b3) {
            a3 = 1;
          }
        } else if (!b3) {
          a3 = 0;
        }
        b3 = (a3 | 0) != 0;
        return b3 | 0;
      }
      function Da(a3, b3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        var c3 = 0, d3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0;
        if (+e2[a3 >> 3] < +e2[b3 + 8 >> 3]) {
          d3 = 0;
          return d3 | 0;
        }
        if (+e2[a3 + 8 >> 3] > +e2[b3 >> 3]) {
          d3 = 0;
          return d3 | 0;
        }
        g2 = +e2[a3 + 16 >> 3];
        c3 = a3 + 24 | 0;
        l = +e2[c3 >> 3];
        h = g2 < l;
        d3 = b3 + 16 | 0;
        k = +e2[d3 >> 3];
        f2 = b3 + 24 | 0;
        j = +e2[f2 >> 3];
        i = k < j;
        b3 = l - k < j - g2;
        a3 = h ? i | b3 ? 1 : 2 : 0;
        b3 = i ? h ? 1 : b3 ? 2 : 1 : 0;
        g2 = +nc(g2, a3);
        if (g2 < +nc(+e2[f2 >> 3], b3)) {
          i = 0;
          return i | 0;
        }
        l = +nc(+e2[c3 >> 3], a3);
        if (l > +nc(+e2[d3 >> 3], b3)) {
          i = 0;
          return i | 0;
        }
        i = 1;
        return i | 0;
      }
      function Ea(a3, c3, d3, f2) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0;
        h = +e2[a3 + 16 >> 3];
        k = +e2[a3 + 24 >> 3];
        a3 = h < k;
        j = +e2[c3 + 16 >> 3];
        i = +e2[c3 + 24 >> 3];
        g2 = j < i;
        c3 = k - j < i - h;
        b2[d3 >> 2] = a3 ? g2 | c3 ? 1 : 2 : 0;
        b2[f2 >> 2] = g2 ? a3 ? 1 : c3 ? 2 : 1 : 0;
        return;
      }
      function Fa(a3, b3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        var c3 = 0, d3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0;
        if (+e2[a3 >> 3] < +e2[b3 >> 3]) {
          d3 = 0;
          return d3 | 0;
        }
        if (+e2[a3 + 8 >> 3] > +e2[b3 + 8 >> 3]) {
          d3 = 0;
          return d3 | 0;
        }
        d3 = a3 + 16 | 0;
        j = +e2[d3 >> 3];
        g2 = +e2[a3 + 24 >> 3];
        h = j < g2;
        c3 = b3 + 16 | 0;
        l = +e2[c3 >> 3];
        f2 = b3 + 24 | 0;
        k = +e2[f2 >> 3];
        i = l < k;
        b3 = g2 - l < k - j;
        a3 = h ? i | b3 ? 1 : 2 : 0;
        b3 = i ? h ? 1 : b3 ? 2 : 1 : 0;
        g2 = +nc(g2, a3);
        if (!(g2 <= +nc(+e2[f2 >> 3], b3))) {
          i = 0;
          return i | 0;
        }
        l = +nc(+e2[d3 >> 3], a3);
        i = l >= +nc(+e2[c3 >> 3], b3);
        return i | 0;
      }
      function Ga(a3, c3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        var d3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0;
        g2 = T;
        T = T + 176 | 0;
        f2 = g2;
        b2[f2 >> 2] = 4;
        j = +e2[c3 >> 3];
        e2[f2 + 8 >> 3] = j;
        h = +e2[c3 + 16 >> 3];
        e2[f2 + 16 >> 3] = h;
        e2[f2 + 24 >> 3] = j;
        j = +e2[c3 + 24 >> 3];
        e2[f2 + 32 >> 3] = j;
        i = +e2[c3 + 8 >> 3];
        e2[f2 + 40 >> 3] = i;
        e2[f2 + 48 >> 3] = j;
        e2[f2 + 56 >> 3] = i;
        e2[f2 + 64 >> 3] = h;
        c3 = f2 + 72 | 0;
        d3 = c3 + 96 | 0;
        do {
          b2[c3 >> 2] = 0;
          c3 = c3 + 4 | 0;
        } while ((c3 | 0) < (d3 | 0));
        Zd(a3 | 0, f2 | 0, 168) | 0;
        T = g2;
        return;
      }
      function Ha(a3, c3, d3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, r2 = 0, s2 = 0, t2 = 0, u3 = 0, v3 = 0;
        t2 = T;
        T = T + 288 | 0;
        n = t2 + 264 | 0;
        o = t2 + 96 | 0;
        m = t2;
        k = m;
        l = k + 96 | 0;
        do {
          b2[k >> 2] = 0;
          k = k + 4 | 0;
        } while ((k | 0) < (l | 0));
        c3 = fc(c3, m) | 0;
        if (c3 | 0) {
          s2 = c3;
          T = t2;
          return s2 | 0;
        }
        l = m;
        m = b2[l >> 2] | 0;
        l = b2[l + 4 >> 2] | 0;
        ac(m, l, n) | 0;
        bc(m, l, o) | 0;
        j = +pc(n, o + 8 | 0);
        e2[n >> 3] = +e2[a3 >> 3];
        l = n + 8 | 0;
        e2[l >> 3] = +e2[a3 + 16 >> 3];
        e2[o >> 3] = +e2[a3 + 8 >> 3];
        m = o + 8 | 0;
        e2[m >> 3] = +e2[a3 + 24 >> 3];
        h = +pc(n, o);
        v3 = +e2[l >> 3] - +e2[m >> 3];
        i = +q(+v3);
        u3 = +e2[n >> 3] - +e2[o >> 3];
        g2 = +q(+u3);
        if (!(v3 == 0 | u3 == 0) ? (v3 = +Wd(+i, +g2), v3 = +A2(+(h * h / +Xd(+(v3 / +Xd(+i, +g2)), 3) / (j * (j * 2.59807621135) * 0.8))), e2[f >> 3] = v3, r2 = ~~v3 >>> 0, s2 = +q(v3) >= 1 ? v3 > 0 ? ~~+C2(+p(v3 / 4294967296), 4294967295) >>> 0 : ~~+A2((v3 - +(~~v3 >>> 0)) / 4294967296) >>> 0 : 0, !((b2[f + 4 >> 2] & 2146435072 | 0) == 2146435072)) : 0) {
          o = (r2 | 0) == 0 & (s2 | 0) == 0;
          c3 = d3;
          b2[c3 >> 2] = o ? 1 : r2;
          b2[c3 + 4 >> 2] = o ? 0 : s2;
          c3 = 0;
        } else {
          c3 = 1;
        }
        s2 = c3;
        T = t2;
        return s2 | 0;
      }
      function Ia(a3, c3, d3, g2) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        g2 = g2 | 0;
        var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0;
        m = T;
        T = T + 288 | 0;
        j = m + 264 | 0;
        k = m + 96 | 0;
        l = m;
        h = l;
        i = h + 96 | 0;
        do {
          b2[h >> 2] = 0;
          h = h + 4 | 0;
        } while ((h | 0) < (i | 0));
        d3 = fc(d3, l) | 0;
        if (d3 | 0) {
          g2 = d3;
          T = m;
          return g2 | 0;
        }
        d3 = l;
        h = b2[d3 >> 2] | 0;
        d3 = b2[d3 + 4 >> 2] | 0;
        ac(h, d3, j) | 0;
        bc(h, d3, k) | 0;
        n = +pc(j, k + 8 | 0);
        n = +A2(+(+pc(a3, c3) / (n * 2)));
        e2[f >> 3] = n;
        d3 = ~~n >>> 0;
        h = +q(n) >= 1 ? n > 0 ? ~~+C2(+p(n / 4294967296), 4294967295) >>> 0 : ~~+A2((n - +(~~n >>> 0)) / 4294967296) >>> 0 : 0;
        if ((b2[f + 4 >> 2] & 2146435072 | 0) == 2146435072) {
          g2 = 1;
          T = m;
          return g2 | 0;
        }
        l = (d3 | 0) == 0 & (h | 0) == 0;
        b2[g2 >> 2] = l ? 1 : d3;
        b2[g2 + 4 >> 2] = l ? 0 : h;
        g2 = 0;
        T = m;
        return g2 | 0;
      }
      function Ja(a3, b3) {
        a3 = a3 | 0;
        b3 = +b3;
        var c3 = 0, d3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0;
        g2 = a3 + 16 | 0;
        h = +e2[g2 >> 3];
        c3 = a3 + 24 | 0;
        f2 = +e2[c3 >> 3];
        d3 = h - f2;
        d3 = h < f2 ? d3 + 6.283185307179586 : d3;
        k = +e2[a3 >> 3];
        i = a3 + 8 | 0;
        j = +e2[i >> 3];
        l = k - j;
        d3 = (d3 * b3 - d3) * 0.5;
        b3 = (l * b3 - l) * 0.5;
        k = k + b3;
        e2[a3 >> 3] = k > 1.5707963267948966 ? 1.5707963267948966 : k;
        b3 = j - b3;
        e2[i >> 3] = b3 < -1.5707963267948966 ? -1.5707963267948966 : b3;
        b3 = h + d3;
        b3 = b3 > 3.141592653589793 ? b3 + -6.283185307179586 : b3;
        e2[g2 >> 3] = b3 < -3.141592653589793 ? b3 + 6.283185307179586 : b3;
        b3 = f2 - d3;
        b3 = b3 > 3.141592653589793 ? b3 + -6.283185307179586 : b3;
        e2[c3 >> 3] = b3 < -3.141592653589793 ? b3 + 6.283185307179586 : b3;
        return;
      }
      function Ka(a3, c3, d3, e3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        b2[a3 >> 2] = c3;
        b2[a3 + 4 >> 2] = d3;
        b2[a3 + 8 >> 2] = e3;
        return;
      }
      function La(a3, c3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        var d3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0;
        n = c3 + 8 | 0;
        b2[n >> 2] = 0;
        k = +e2[a3 >> 3];
        i = +q(+k);
        l = +e2[a3 + 8 >> 3];
        j = +q(+l) * 1.1547005383792515;
        i = i + j * 0.5;
        d3 = ~~i;
        a3 = ~~j;
        i = i - +(d3 | 0);
        j = j - +(a3 | 0);
        do {
          if (i < 0.5) {
            if (i < 0.3333333333333333) {
              b2[c3 >> 2] = d3;
              if (j < (i + 1) * 0.5) {
                b2[c3 + 4 >> 2] = a3;
                break;
              } else {
                a3 = a3 + 1 | 0;
                b2[c3 + 4 >> 2] = a3;
                break;
              }
            } else {
              o = 1 - i;
              a3 = (!(j < o) & 1) + a3 | 0;
              b2[c3 + 4 >> 2] = a3;
              if (o <= j & j < i * 2) {
                d3 = d3 + 1 | 0;
                b2[c3 >> 2] = d3;
                break;
              } else {
                b2[c3 >> 2] = d3;
                break;
              }
            }
          } else {
            if (!(i < 0.6666666666666666)) {
              d3 = d3 + 1 | 0;
              b2[c3 >> 2] = d3;
              if (j < i * 0.5) {
                b2[c3 + 4 >> 2] = a3;
                break;
              } else {
                a3 = a3 + 1 | 0;
                b2[c3 + 4 >> 2] = a3;
                break;
              }
            }
            if (j < 1 - i) {
              b2[c3 + 4 >> 2] = a3;
              if (i * 2 + -1 < j) {
                b2[c3 >> 2] = d3;
                break;
              }
            } else {
              a3 = a3 + 1 | 0;
              b2[c3 + 4 >> 2] = a3;
            }
            d3 = d3 + 1 | 0;
            b2[c3 >> 2] = d3;
          }
        } while (0);
        do {
          if (k < 0) {
            if (!(a3 & 1)) {
              m = (a3 | 0) / 2 | 0;
              m = Kd(d3 | 0, ((d3 | 0) < 0) << 31 >> 31 | 0, m | 0, ((m | 0) < 0) << 31 >> 31 | 0) | 0;
              d3 = ~~(+(d3 | 0) - (+(m >>> 0) + 4294967296 * +(H() | 0)) * 2);
              b2[c3 >> 2] = d3;
              break;
            } else {
              m = (a3 + 1 | 0) / 2 | 0;
              m = Kd(d3 | 0, ((d3 | 0) < 0) << 31 >> 31 | 0, m | 0, ((m | 0) < 0) << 31 >> 31 | 0) | 0;
              d3 = ~~(+(d3 | 0) - ((+(m >>> 0) + 4294967296 * +(H() | 0)) * 2 + 1));
              b2[c3 >> 2] = d3;
              break;
            }
          }
        } while (0);
        m = c3 + 4 | 0;
        if (l < 0) {
          d3 = d3 - ((a3 << 1 | 1 | 0) / 2 | 0) | 0;
          b2[c3 >> 2] = d3;
          a3 = 0 - a3 | 0;
          b2[m >> 2] = a3;
        }
        f2 = a3 - d3 | 0;
        if ((d3 | 0) < 0) {
          g2 = 0 - d3 | 0;
          b2[m >> 2] = f2;
          b2[n >> 2] = g2;
          b2[c3 >> 2] = 0;
          a3 = f2;
          d3 = 0;
        } else {
          g2 = 0;
        }
        if ((a3 | 0) < 0) {
          d3 = d3 - a3 | 0;
          b2[c3 >> 2] = d3;
          g2 = g2 - a3 | 0;
          b2[n >> 2] = g2;
          b2[m >> 2] = 0;
          a3 = 0;
        }
        h = d3 - g2 | 0;
        f2 = a3 - g2 | 0;
        if ((g2 | 0) < 0) {
          b2[c3 >> 2] = h;
          b2[m >> 2] = f2;
          b2[n >> 2] = 0;
          a3 = f2;
          d3 = h;
          g2 = 0;
        }
        f2 = (a3 | 0) < (d3 | 0) ? a3 : d3;
        f2 = (g2 | 0) < (f2 | 0) ? g2 : f2;
        if ((f2 | 0) <= 0) {
          return;
        }
        b2[c3 >> 2] = d3 - f2;
        b2[m >> 2] = a3 - f2;
        b2[n >> 2] = g2 - f2;
        return;
      }
      function Ma(a3) {
        a3 = a3 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0;
        c3 = b2[a3 >> 2] | 0;
        h = a3 + 4 | 0;
        d3 = b2[h >> 2] | 0;
        if ((c3 | 0) < 0) {
          d3 = d3 - c3 | 0;
          b2[h >> 2] = d3;
          g2 = a3 + 8 | 0;
          b2[g2 >> 2] = (b2[g2 >> 2] | 0) - c3;
          b2[a3 >> 2] = 0;
          c3 = 0;
        }
        if ((d3 | 0) < 0) {
          c3 = c3 - d3 | 0;
          b2[a3 >> 2] = c3;
          g2 = a3 + 8 | 0;
          f2 = (b2[g2 >> 2] | 0) - d3 | 0;
          b2[g2 >> 2] = f2;
          b2[h >> 2] = 0;
          d3 = 0;
        } else {
          f2 = a3 + 8 | 0;
          g2 = f2;
          f2 = b2[f2 >> 2] | 0;
        }
        if ((f2 | 0) < 0) {
          c3 = c3 - f2 | 0;
          b2[a3 >> 2] = c3;
          d3 = d3 - f2 | 0;
          b2[h >> 2] = d3;
          b2[g2 >> 2] = 0;
          f2 = 0;
        }
        e3 = (d3 | 0) < (c3 | 0) ? d3 : c3;
        e3 = (f2 | 0) < (e3 | 0) ? f2 : e3;
        if ((e3 | 0) <= 0) {
          return;
        }
        b2[a3 >> 2] = c3 - e3;
        b2[h >> 2] = d3 - e3;
        b2[g2 >> 2] = f2 - e3;
        return;
      }
      function Na(a3, c3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        var d3 = 0, f2 = 0;
        f2 = b2[a3 + 8 >> 2] | 0;
        d3 = +((b2[a3 + 4 >> 2] | 0) - f2 | 0);
        e2[c3 >> 3] = +((b2[a3 >> 2] | 0) - f2 | 0) - d3 * 0.5;
        e2[c3 + 8 >> 3] = d3 * 0.8660254037844386;
        return;
      }
      function Oa(a3, c3, d3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        b2[d3 >> 2] = (b2[c3 >> 2] | 0) + (b2[a3 >> 2] | 0);
        b2[d3 + 4 >> 2] = (b2[c3 + 4 >> 2] | 0) + (b2[a3 + 4 >> 2] | 0);
        b2[d3 + 8 >> 2] = (b2[c3 + 8 >> 2] | 0) + (b2[a3 + 8 >> 2] | 0);
        return;
      }
      function Pa(a3, c3, d3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        b2[d3 >> 2] = (b2[a3 >> 2] | 0) - (b2[c3 >> 2] | 0);
        b2[d3 + 4 >> 2] = (b2[a3 + 4 >> 2] | 0) - (b2[c3 + 4 >> 2] | 0);
        b2[d3 + 8 >> 2] = (b2[a3 + 8 >> 2] | 0) - (b2[c3 + 8 >> 2] | 0);
        return;
      }
      function Qa(a3, c3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        var d3 = 0, e3 = 0;
        d3 = B2(b2[a3 >> 2] | 0, c3) | 0;
        b2[a3 >> 2] = d3;
        d3 = a3 + 4 | 0;
        e3 = B2(b2[d3 >> 2] | 0, c3) | 0;
        b2[d3 >> 2] = e3;
        a3 = a3 + 8 | 0;
        c3 = B2(b2[a3 >> 2] | 0, c3) | 0;
        b2[a3 >> 2] = c3;
        return;
      }
      function Ra(a3) {
        a3 = a3 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        h = b2[a3 >> 2] | 0;
        i = (h | 0) < 0;
        e3 = (b2[a3 + 4 >> 2] | 0) - (i ? h : 0) | 0;
        g2 = (e3 | 0) < 0;
        f2 = (g2 ? 0 - e3 | 0 : 0) + ((b2[a3 + 8 >> 2] | 0) - (i ? h : 0)) | 0;
        d3 = (f2 | 0) < 0;
        a3 = d3 ? 0 : f2;
        c3 = (g2 ? 0 : e3) - (d3 ? f2 : 0) | 0;
        f2 = (i ? 0 : h) - (g2 ? e3 : 0) - (d3 ? f2 : 0) | 0;
        d3 = (c3 | 0) < (f2 | 0) ? c3 : f2;
        d3 = (a3 | 0) < (d3 | 0) ? a3 : d3;
        e3 = (d3 | 0) > 0;
        a3 = a3 - (e3 ? d3 : 0) | 0;
        c3 = c3 - (e3 ? d3 : 0) | 0;
        a: do {
          switch (f2 - (e3 ? d3 : 0) | 0) {
            case 0:
              switch (c3 | 0) {
                case 0: {
                  i = (a3 | 0) == 0 ? 0 : (a3 | 0) == 1 ? 1 : 7;
                  return i | 0;
                }
                case 1: {
                  i = (a3 | 0) == 0 ? 2 : (a3 | 0) == 1 ? 3 : 7;
                  return i | 0;
                }
                default:
                  break a;
              }
            case 1:
              switch (c3 | 0) {
                case 0: {
                  i = (a3 | 0) == 0 ? 4 : (a3 | 0) == 1 ? 5 : 7;
                  return i | 0;
                }
                case 1: {
                  if (!a3) {
                    a3 = 6;
                  } else {
                    break a;
                  }
                  return a3 | 0;
                }
                default:
                  break a;
              }
            default:
          }
        } while (0);
        i = 7;
        return i | 0;
      }
      function Sa(a3) {
        a3 = a3 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0;
        j = a3 + 8 | 0;
        h = b2[j >> 2] | 0;
        i = (b2[a3 >> 2] | 0) - h | 0;
        k = a3 + 4 | 0;
        h = (b2[k >> 2] | 0) - h | 0;
        if (i >>> 0 > 715827881 | h >>> 0 > 715827881) {
          e3 = (i | 0) > 0;
          f2 = 2147483647 - i | 0;
          g2 = -2147483648 - i | 0;
          if (e3 ? (f2 | 0) < (i | 0) : (g2 | 0) > (i | 0)) {
            k = 1;
            return k | 0;
          }
          d3 = i << 1;
          if (e3 ? (2147483647 - d3 | 0) < (i | 0) : (-2147483648 - d3 | 0) > (i | 0)) {
            k = 1;
            return k | 0;
          }
          if ((h | 0) > 0 ? (2147483647 - h | 0) < (h | 0) : (-2147483648 - h | 0) > (h | 0)) {
            k = 1;
            return k | 0;
          }
          c3 = i * 3 | 0;
          d3 = h << 1;
          if ((e3 ? (f2 | 0) < (d3 | 0) : (g2 | 0) > (d3 | 0)) ? 1 : (i | 0) > -1 ? (c3 | -2147483648 | 0) >= (h | 0) : (c3 ^ -2147483648 | 0) < (h | 0)) {
            k = 1;
            return k | 0;
          }
        } else {
          d3 = h << 1;
          c3 = i * 3 | 0;
        }
        e3 = Fd(+(c3 - h | 0) * 0.14285714285714285) | 0;
        b2[a3 >> 2] = e3;
        f2 = Fd(+(d3 + i | 0) * 0.14285714285714285) | 0;
        b2[k >> 2] = f2;
        b2[j >> 2] = 0;
        d3 = (f2 | 0) < (e3 | 0);
        c3 = d3 ? e3 : f2;
        d3 = d3 ? f2 : e3;
        if ((d3 | 0) < 0) {
          if ((d3 | 0) == -2147483648 ? 1 : (c3 | 0) > 0 ? (2147483647 - c3 | 0) < (d3 | 0) : (-2147483648 - c3 | 0) > (d3 | 0)) {
            I(27795, 26892, 354, 26903);
          }
          if ((c3 | 0) > -1 ? (c3 | -2147483648 | 0) >= (d3 | 0) : (c3 ^ -2147483648 | 0) < (d3 | 0)) {
            I(27795, 26892, 354, 26903);
          }
        }
        c3 = f2 - e3 | 0;
        if ((e3 | 0) < 0) {
          d3 = 0 - e3 | 0;
          b2[k >> 2] = c3;
          b2[j >> 2] = d3;
          b2[a3 >> 2] = 0;
          e3 = 0;
        } else {
          c3 = f2;
          d3 = 0;
        }
        if ((c3 | 0) < 0) {
          e3 = e3 - c3 | 0;
          b2[a3 >> 2] = e3;
          d3 = d3 - c3 | 0;
          b2[j >> 2] = d3;
          b2[k >> 2] = 0;
          c3 = 0;
        }
        g2 = e3 - d3 | 0;
        f2 = c3 - d3 | 0;
        if ((d3 | 0) < 0) {
          b2[a3 >> 2] = g2;
          b2[k >> 2] = f2;
          b2[j >> 2] = 0;
          c3 = f2;
          f2 = g2;
          d3 = 0;
        } else {
          f2 = e3;
        }
        e3 = (c3 | 0) < (f2 | 0) ? c3 : f2;
        e3 = (d3 | 0) < (e3 | 0) ? d3 : e3;
        if ((e3 | 0) <= 0) {
          k = 0;
          return k | 0;
        }
        b2[a3 >> 2] = f2 - e3;
        b2[k >> 2] = c3 - e3;
        b2[j >> 2] = d3 - e3;
        k = 0;
        return k | 0;
      }
      function Ta(a3) {
        a3 = a3 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0;
        h = a3 + 8 | 0;
        f2 = b2[h >> 2] | 0;
        g2 = (b2[a3 >> 2] | 0) - f2 | 0;
        i = a3 + 4 | 0;
        f2 = (b2[i >> 2] | 0) - f2 | 0;
        if (g2 >>> 0 > 715827881 | f2 >>> 0 > 715827881) {
          d3 = (g2 | 0) > 0;
          if (d3 ? (2147483647 - g2 | 0) < (g2 | 0) : (-2147483648 - g2 | 0) > (g2 | 0)) {
            i = 1;
            return i | 0;
          }
          c3 = g2 << 1;
          e3 = (f2 | 0) > 0;
          if (e3 ? (2147483647 - f2 | 0) < (f2 | 0) : (-2147483648 - f2 | 0) > (f2 | 0)) {
            i = 1;
            return i | 0;
          }
          j = f2 << 1;
          if (e3 ? (2147483647 - j | 0) < (f2 | 0) : (-2147483648 - j | 0) > (f2 | 0)) {
            j = 1;
            return j | 0;
          }
          if (d3 ? (2147483647 - c3 | 0) < (f2 | 0) : (-2147483648 - c3 | 0) > (f2 | 0)) {
            j = 1;
            return j | 0;
          }
          d3 = f2 * 3 | 0;
          if ((f2 | 0) > -1 ? (d3 | -2147483648 | 0) >= (g2 | 0) : (d3 ^ -2147483648 | 0) < (g2 | 0)) {
            j = 1;
            return j | 0;
          }
        } else {
          d3 = f2 * 3 | 0;
          c3 = g2 << 1;
        }
        e3 = Fd(+(c3 + f2 | 0) * 0.14285714285714285) | 0;
        b2[a3 >> 2] = e3;
        f2 = Fd(+(d3 - g2 | 0) * 0.14285714285714285) | 0;
        b2[i >> 2] = f2;
        b2[h >> 2] = 0;
        d3 = (f2 | 0) < (e3 | 0);
        c3 = d3 ? e3 : f2;
        d3 = d3 ? f2 : e3;
        if ((d3 | 0) < 0) {
          if ((d3 | 0) == -2147483648 ? 1 : (c3 | 0) > 0 ? (2147483647 - c3 | 0) < (d3 | 0) : (-2147483648 - c3 | 0) > (d3 | 0)) {
            I(27795, 26892, 402, 26917);
          }
          if ((c3 | 0) > -1 ? (c3 | -2147483648 | 0) >= (d3 | 0) : (c3 ^ -2147483648 | 0) < (d3 | 0)) {
            I(27795, 26892, 402, 26917);
          }
        }
        c3 = f2 - e3 | 0;
        if ((e3 | 0) < 0) {
          d3 = 0 - e3 | 0;
          b2[i >> 2] = c3;
          b2[h >> 2] = d3;
          b2[a3 >> 2] = 0;
          e3 = 0;
        } else {
          c3 = f2;
          d3 = 0;
        }
        if ((c3 | 0) < 0) {
          e3 = e3 - c3 | 0;
          b2[a3 >> 2] = e3;
          d3 = d3 - c3 | 0;
          b2[h >> 2] = d3;
          b2[i >> 2] = 0;
          c3 = 0;
        }
        g2 = e3 - d3 | 0;
        f2 = c3 - d3 | 0;
        if ((d3 | 0) < 0) {
          b2[a3 >> 2] = g2;
          b2[i >> 2] = f2;
          b2[h >> 2] = 0;
          c3 = f2;
          f2 = g2;
          d3 = 0;
        } else {
          f2 = e3;
        }
        e3 = (c3 | 0) < (f2 | 0) ? c3 : f2;
        e3 = (d3 | 0) < (e3 | 0) ? d3 : e3;
        if ((e3 | 0) <= 0) {
          j = 0;
          return j | 0;
        }
        b2[a3 >> 2] = f2 - e3;
        b2[i >> 2] = c3 - e3;
        b2[h >> 2] = d3 - e3;
        j = 0;
        return j | 0;
      }
      function Ua(a3) {
        a3 = a3 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        h = a3 + 8 | 0;
        d3 = b2[h >> 2] | 0;
        c3 = (b2[a3 >> 2] | 0) - d3 | 0;
        i = a3 + 4 | 0;
        d3 = (b2[i >> 2] | 0) - d3 | 0;
        e3 = Fd(+((c3 * 3 | 0) - d3 | 0) * 0.14285714285714285) | 0;
        b2[a3 >> 2] = e3;
        c3 = Fd(+((d3 << 1) + c3 | 0) * 0.14285714285714285) | 0;
        b2[i >> 2] = c3;
        b2[h >> 2] = 0;
        d3 = c3 - e3 | 0;
        if ((e3 | 0) < 0) {
          g2 = 0 - e3 | 0;
          b2[i >> 2] = d3;
          b2[h >> 2] = g2;
          b2[a3 >> 2] = 0;
          c3 = d3;
          e3 = 0;
          d3 = g2;
        } else {
          d3 = 0;
        }
        if ((c3 | 0) < 0) {
          e3 = e3 - c3 | 0;
          b2[a3 >> 2] = e3;
          d3 = d3 - c3 | 0;
          b2[h >> 2] = d3;
          b2[i >> 2] = 0;
          c3 = 0;
        }
        g2 = e3 - d3 | 0;
        f2 = c3 - d3 | 0;
        if ((d3 | 0) < 0) {
          b2[a3 >> 2] = g2;
          b2[i >> 2] = f2;
          b2[h >> 2] = 0;
          c3 = f2;
          f2 = g2;
          d3 = 0;
        } else {
          f2 = e3;
        }
        e3 = (c3 | 0) < (f2 | 0) ? c3 : f2;
        e3 = (d3 | 0) < (e3 | 0) ? d3 : e3;
        if ((e3 | 0) <= 0) {
          return;
        }
        b2[a3 >> 2] = f2 - e3;
        b2[i >> 2] = c3 - e3;
        b2[h >> 2] = d3 - e3;
        return;
      }
      function Va(a3) {
        a3 = a3 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        h = a3 + 8 | 0;
        d3 = b2[h >> 2] | 0;
        c3 = (b2[a3 >> 2] | 0) - d3 | 0;
        i = a3 + 4 | 0;
        d3 = (b2[i >> 2] | 0) - d3 | 0;
        e3 = Fd(+((c3 << 1) + d3 | 0) * 0.14285714285714285) | 0;
        b2[a3 >> 2] = e3;
        c3 = Fd(+((d3 * 3 | 0) - c3 | 0) * 0.14285714285714285) | 0;
        b2[i >> 2] = c3;
        b2[h >> 2] = 0;
        d3 = c3 - e3 | 0;
        if ((e3 | 0) < 0) {
          g2 = 0 - e3 | 0;
          b2[i >> 2] = d3;
          b2[h >> 2] = g2;
          b2[a3 >> 2] = 0;
          c3 = d3;
          e3 = 0;
          d3 = g2;
        } else {
          d3 = 0;
        }
        if ((c3 | 0) < 0) {
          e3 = e3 - c3 | 0;
          b2[a3 >> 2] = e3;
          d3 = d3 - c3 | 0;
          b2[h >> 2] = d3;
          b2[i >> 2] = 0;
          c3 = 0;
        }
        g2 = e3 - d3 | 0;
        f2 = c3 - d3 | 0;
        if ((d3 | 0) < 0) {
          b2[a3 >> 2] = g2;
          b2[i >> 2] = f2;
          b2[h >> 2] = 0;
          c3 = f2;
          f2 = g2;
          d3 = 0;
        } else {
          f2 = e3;
        }
        e3 = (c3 | 0) < (f2 | 0) ? c3 : f2;
        e3 = (d3 | 0) < (e3 | 0) ? d3 : e3;
        if ((e3 | 0) <= 0) {
          return;
        }
        b2[a3 >> 2] = f2 - e3;
        b2[i >> 2] = c3 - e3;
        b2[h >> 2] = d3 - e3;
        return;
      }
      function Wa(a3) {
        a3 = a3 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        c3 = b2[a3 >> 2] | 0;
        h = a3 + 4 | 0;
        d3 = b2[h >> 2] | 0;
        i = a3 + 8 | 0;
        e3 = b2[i >> 2] | 0;
        f2 = d3 + (c3 * 3 | 0) | 0;
        b2[a3 >> 2] = f2;
        d3 = e3 + (d3 * 3 | 0) | 0;
        b2[h >> 2] = d3;
        c3 = (e3 * 3 | 0) + c3 | 0;
        b2[i >> 2] = c3;
        e3 = d3 - f2 | 0;
        if ((f2 | 0) < 0) {
          c3 = c3 - f2 | 0;
          b2[h >> 2] = e3;
          b2[i >> 2] = c3;
          b2[a3 >> 2] = 0;
          d3 = e3;
          e3 = 0;
        } else {
          e3 = f2;
        }
        if ((d3 | 0) < 0) {
          e3 = e3 - d3 | 0;
          b2[a3 >> 2] = e3;
          c3 = c3 - d3 | 0;
          b2[i >> 2] = c3;
          b2[h >> 2] = 0;
          d3 = 0;
        }
        g2 = e3 - c3 | 0;
        f2 = d3 - c3 | 0;
        if ((c3 | 0) < 0) {
          b2[a3 >> 2] = g2;
          b2[h >> 2] = f2;
          b2[i >> 2] = 0;
          e3 = g2;
          c3 = 0;
        } else {
          f2 = d3;
        }
        d3 = (f2 | 0) < (e3 | 0) ? f2 : e3;
        d3 = (c3 | 0) < (d3 | 0) ? c3 : d3;
        if ((d3 | 0) <= 0) {
          return;
        }
        b2[a3 >> 2] = e3 - d3;
        b2[h >> 2] = f2 - d3;
        b2[i >> 2] = c3 - d3;
        return;
      }
      function Xa(a3) {
        a3 = a3 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        f2 = b2[a3 >> 2] | 0;
        h = a3 + 4 | 0;
        c3 = b2[h >> 2] | 0;
        i = a3 + 8 | 0;
        d3 = b2[i >> 2] | 0;
        e3 = (c3 * 3 | 0) + f2 | 0;
        f2 = d3 + (f2 * 3 | 0) | 0;
        b2[a3 >> 2] = f2;
        b2[h >> 2] = e3;
        c3 = (d3 * 3 | 0) + c3 | 0;
        b2[i >> 2] = c3;
        d3 = e3 - f2 | 0;
        if ((f2 | 0) < 0) {
          c3 = c3 - f2 | 0;
          b2[h >> 2] = d3;
          b2[i >> 2] = c3;
          b2[a3 >> 2] = 0;
          f2 = 0;
        } else {
          d3 = e3;
        }
        if ((d3 | 0) < 0) {
          f2 = f2 - d3 | 0;
          b2[a3 >> 2] = f2;
          c3 = c3 - d3 | 0;
          b2[i >> 2] = c3;
          b2[h >> 2] = 0;
          d3 = 0;
        }
        g2 = f2 - c3 | 0;
        e3 = d3 - c3 | 0;
        if ((c3 | 0) < 0) {
          b2[a3 >> 2] = g2;
          b2[h >> 2] = e3;
          b2[i >> 2] = 0;
          f2 = g2;
          c3 = 0;
        } else {
          e3 = d3;
        }
        d3 = (e3 | 0) < (f2 | 0) ? e3 : f2;
        d3 = (c3 | 0) < (d3 | 0) ? c3 : d3;
        if ((d3 | 0) <= 0) {
          return;
        }
        b2[a3 >> 2] = f2 - d3;
        b2[h >> 2] = e3 - d3;
        b2[i >> 2] = c3 - d3;
        return;
      }
      function Ya(a3, c3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        var d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        if ((c3 + -1 | 0) >>> 0 >= 6) {
          return;
        }
        f2 = (b2[15440 + (c3 * 12 | 0) >> 2] | 0) + (b2[a3 >> 2] | 0) | 0;
        b2[a3 >> 2] = f2;
        i = a3 + 4 | 0;
        e3 = (b2[15440 + (c3 * 12 | 0) + 4 >> 2] | 0) + (b2[i >> 2] | 0) | 0;
        b2[i >> 2] = e3;
        h = a3 + 8 | 0;
        c3 = (b2[15440 + (c3 * 12 | 0) + 8 >> 2] | 0) + (b2[h >> 2] | 0) | 0;
        b2[h >> 2] = c3;
        d3 = e3 - f2 | 0;
        if ((f2 | 0) < 0) {
          c3 = c3 - f2 | 0;
          b2[i >> 2] = d3;
          b2[h >> 2] = c3;
          b2[a3 >> 2] = 0;
          e3 = 0;
        } else {
          d3 = e3;
          e3 = f2;
        }
        if ((d3 | 0) < 0) {
          e3 = e3 - d3 | 0;
          b2[a3 >> 2] = e3;
          c3 = c3 - d3 | 0;
          b2[h >> 2] = c3;
          b2[i >> 2] = 0;
          d3 = 0;
        }
        g2 = e3 - c3 | 0;
        f2 = d3 - c3 | 0;
        if ((c3 | 0) < 0) {
          b2[a3 >> 2] = g2;
          b2[i >> 2] = f2;
          b2[h >> 2] = 0;
          e3 = g2;
          c3 = 0;
        } else {
          f2 = d3;
        }
        d3 = (f2 | 0) < (e3 | 0) ? f2 : e3;
        d3 = (c3 | 0) < (d3 | 0) ? c3 : d3;
        if ((d3 | 0) <= 0) {
          return;
        }
        b2[a3 >> 2] = e3 - d3;
        b2[i >> 2] = f2 - d3;
        b2[h >> 2] = c3 - d3;
        return;
      }
      function Za(a3) {
        a3 = a3 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        f2 = b2[a3 >> 2] | 0;
        h = a3 + 4 | 0;
        c3 = b2[h >> 2] | 0;
        i = a3 + 8 | 0;
        d3 = b2[i >> 2] | 0;
        e3 = c3 + f2 | 0;
        f2 = d3 + f2 | 0;
        b2[a3 >> 2] = f2;
        b2[h >> 2] = e3;
        c3 = d3 + c3 | 0;
        b2[i >> 2] = c3;
        d3 = e3 - f2 | 0;
        if ((f2 | 0) < 0) {
          c3 = c3 - f2 | 0;
          b2[h >> 2] = d3;
          b2[i >> 2] = c3;
          b2[a3 >> 2] = 0;
          e3 = 0;
        } else {
          d3 = e3;
          e3 = f2;
        }
        if ((d3 | 0) < 0) {
          e3 = e3 - d3 | 0;
          b2[a3 >> 2] = e3;
          c3 = c3 - d3 | 0;
          b2[i >> 2] = c3;
          b2[h >> 2] = 0;
          d3 = 0;
        }
        g2 = e3 - c3 | 0;
        f2 = d3 - c3 | 0;
        if ((c3 | 0) < 0) {
          b2[a3 >> 2] = g2;
          b2[h >> 2] = f2;
          b2[i >> 2] = 0;
          e3 = g2;
          c3 = 0;
        } else {
          f2 = d3;
        }
        d3 = (f2 | 0) < (e3 | 0) ? f2 : e3;
        d3 = (c3 | 0) < (d3 | 0) ? c3 : d3;
        if ((d3 | 0) <= 0) {
          return;
        }
        b2[a3 >> 2] = e3 - d3;
        b2[h >> 2] = f2 - d3;
        b2[i >> 2] = c3 - d3;
        return;
      }
      function _a(a3) {
        a3 = a3 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        c3 = b2[a3 >> 2] | 0;
        h = a3 + 4 | 0;
        e3 = b2[h >> 2] | 0;
        i = a3 + 8 | 0;
        d3 = b2[i >> 2] | 0;
        f2 = e3 + c3 | 0;
        b2[a3 >> 2] = f2;
        e3 = d3 + e3 | 0;
        b2[h >> 2] = e3;
        c3 = d3 + c3 | 0;
        b2[i >> 2] = c3;
        d3 = e3 - f2 | 0;
        if ((f2 | 0) < 0) {
          c3 = c3 - f2 | 0;
          b2[h >> 2] = d3;
          b2[i >> 2] = c3;
          b2[a3 >> 2] = 0;
          e3 = 0;
        } else {
          d3 = e3;
          e3 = f2;
        }
        if ((d3 | 0) < 0) {
          e3 = e3 - d3 | 0;
          b2[a3 >> 2] = e3;
          c3 = c3 - d3 | 0;
          b2[i >> 2] = c3;
          b2[h >> 2] = 0;
          d3 = 0;
        }
        g2 = e3 - c3 | 0;
        f2 = d3 - c3 | 0;
        if ((c3 | 0) < 0) {
          b2[a3 >> 2] = g2;
          b2[h >> 2] = f2;
          b2[i >> 2] = 0;
          e3 = g2;
          c3 = 0;
        } else {
          f2 = d3;
        }
        d3 = (f2 | 0) < (e3 | 0) ? f2 : e3;
        d3 = (c3 | 0) < (d3 | 0) ? c3 : d3;
        if ((d3 | 0) <= 0) {
          return;
        }
        b2[a3 >> 2] = e3 - d3;
        b2[h >> 2] = f2 - d3;
        b2[i >> 2] = c3 - d3;
        return;
      }
      function $a(a3) {
        a3 = a3 | 0;
        switch (a3 | 0) {
          case 1: {
            a3 = 5;
            break;
          }
          case 5: {
            a3 = 4;
            break;
          }
          case 4: {
            a3 = 6;
            break;
          }
          case 6: {
            a3 = 2;
            break;
          }
          case 2: {
            a3 = 3;
            break;
          }
          case 3: {
            a3 = 1;
            break;
          }
          default:
        }
        return a3 | 0;
      }
      function ab(a3) {
        a3 = a3 | 0;
        switch (a3 | 0) {
          case 1: {
            a3 = 3;
            break;
          }
          case 3: {
            a3 = 2;
            break;
          }
          case 2: {
            a3 = 6;
            break;
          }
          case 6: {
            a3 = 4;
            break;
          }
          case 4: {
            a3 = 5;
            break;
          }
          case 5: {
            a3 = 1;
            break;
          }
          default:
        }
        return a3 | 0;
      }
      function bb(a3) {
        a3 = a3 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        c3 = b2[a3 >> 2] | 0;
        h = a3 + 4 | 0;
        d3 = b2[h >> 2] | 0;
        i = a3 + 8 | 0;
        e3 = b2[i >> 2] | 0;
        f2 = d3 + (c3 << 1) | 0;
        b2[a3 >> 2] = f2;
        d3 = e3 + (d3 << 1) | 0;
        b2[h >> 2] = d3;
        c3 = (e3 << 1) + c3 | 0;
        b2[i >> 2] = c3;
        e3 = d3 - f2 | 0;
        if ((f2 | 0) < 0) {
          c3 = c3 - f2 | 0;
          b2[h >> 2] = e3;
          b2[i >> 2] = c3;
          b2[a3 >> 2] = 0;
          d3 = e3;
          e3 = 0;
        } else {
          e3 = f2;
        }
        if ((d3 | 0) < 0) {
          e3 = e3 - d3 | 0;
          b2[a3 >> 2] = e3;
          c3 = c3 - d3 | 0;
          b2[i >> 2] = c3;
          b2[h >> 2] = 0;
          d3 = 0;
        }
        g2 = e3 - c3 | 0;
        f2 = d3 - c3 | 0;
        if ((c3 | 0) < 0) {
          b2[a3 >> 2] = g2;
          b2[h >> 2] = f2;
          b2[i >> 2] = 0;
          e3 = g2;
          c3 = 0;
        } else {
          f2 = d3;
        }
        d3 = (f2 | 0) < (e3 | 0) ? f2 : e3;
        d3 = (c3 | 0) < (d3 | 0) ? c3 : d3;
        if ((d3 | 0) <= 0) {
          return;
        }
        b2[a3 >> 2] = e3 - d3;
        b2[h >> 2] = f2 - d3;
        b2[i >> 2] = c3 - d3;
        return;
      }
      function cb(a3) {
        a3 = a3 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        f2 = b2[a3 >> 2] | 0;
        h = a3 + 4 | 0;
        c3 = b2[h >> 2] | 0;
        i = a3 + 8 | 0;
        d3 = b2[i >> 2] | 0;
        e3 = (c3 << 1) + f2 | 0;
        f2 = d3 + (f2 << 1) | 0;
        b2[a3 >> 2] = f2;
        b2[h >> 2] = e3;
        c3 = (d3 << 1) + c3 | 0;
        b2[i >> 2] = c3;
        d3 = e3 - f2 | 0;
        if ((f2 | 0) < 0) {
          c3 = c3 - f2 | 0;
          b2[h >> 2] = d3;
          b2[i >> 2] = c3;
          b2[a3 >> 2] = 0;
          f2 = 0;
        } else {
          d3 = e3;
        }
        if ((d3 | 0) < 0) {
          f2 = f2 - d3 | 0;
          b2[a3 >> 2] = f2;
          c3 = c3 - d3 | 0;
          b2[i >> 2] = c3;
          b2[h >> 2] = 0;
          d3 = 0;
        }
        g2 = f2 - c3 | 0;
        e3 = d3 - c3 | 0;
        if ((c3 | 0) < 0) {
          b2[a3 >> 2] = g2;
          b2[h >> 2] = e3;
          b2[i >> 2] = 0;
          f2 = g2;
          c3 = 0;
        } else {
          e3 = d3;
        }
        d3 = (e3 | 0) < (f2 | 0) ? e3 : f2;
        d3 = (c3 | 0) < (d3 | 0) ? c3 : d3;
        if ((d3 | 0) <= 0) {
          return;
        }
        b2[a3 >> 2] = f2 - d3;
        b2[h >> 2] = e3 - d3;
        b2[i >> 2] = c3 - d3;
        return;
      }
      function db(a3, c3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        var d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        h = (b2[a3 >> 2] | 0) - (b2[c3 >> 2] | 0) | 0;
        i = (h | 0) < 0;
        e3 = (b2[a3 + 4 >> 2] | 0) - (b2[c3 + 4 >> 2] | 0) - (i ? h : 0) | 0;
        g2 = (e3 | 0) < 0;
        f2 = (i ? 0 - h | 0 : 0) + (b2[a3 + 8 >> 2] | 0) - (b2[c3 + 8 >> 2] | 0) + (g2 ? 0 - e3 | 0 : 0) | 0;
        a3 = (f2 | 0) < 0;
        c3 = a3 ? 0 : f2;
        d3 = (g2 ? 0 : e3) - (a3 ? f2 : 0) | 0;
        f2 = (i ? 0 : h) - (g2 ? e3 : 0) - (a3 ? f2 : 0) | 0;
        a3 = (d3 | 0) < (f2 | 0) ? d3 : f2;
        a3 = (c3 | 0) < (a3 | 0) ? c3 : a3;
        e3 = (a3 | 0) > 0;
        c3 = c3 - (e3 ? a3 : 0) | 0;
        d3 = d3 - (e3 ? a3 : 0) | 0;
        a3 = f2 - (e3 ? a3 : 0) | 0;
        a3 = (a3 | 0) > -1 ? a3 : 0 - a3 | 0;
        d3 = (d3 | 0) > -1 ? d3 : 0 - d3 | 0;
        c3 = (c3 | 0) > -1 ? c3 : 0 - c3 | 0;
        c3 = (d3 | 0) > (c3 | 0) ? d3 : c3;
        return ((a3 | 0) > (c3 | 0) ? a3 : c3) | 0;
      }
      function eb(a3, c3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        var d3 = 0;
        d3 = b2[a3 + 8 >> 2] | 0;
        b2[c3 >> 2] = (b2[a3 >> 2] | 0) - d3;
        b2[c3 + 4 >> 2] = (b2[a3 + 4 >> 2] | 0) - d3;
        return;
      }
      function fb(a3, c3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        var d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        e3 = b2[a3 >> 2] | 0;
        b2[c3 >> 2] = e3;
        f2 = b2[a3 + 4 >> 2] | 0;
        h = c3 + 4 | 0;
        b2[h >> 2] = f2;
        i = c3 + 8 | 0;
        b2[i >> 2] = 0;
        d3 = (f2 | 0) < (e3 | 0);
        a3 = d3 ? e3 : f2;
        d3 = d3 ? f2 : e3;
        if ((d3 | 0) < 0) {
          if ((d3 | 0) == -2147483648 ? 1 : (a3 | 0) > 0 ? (2147483647 - a3 | 0) < (d3 | 0) : (-2147483648 - a3 | 0) > (d3 | 0)) {
            c3 = 1;
            return c3 | 0;
          }
          if ((a3 | 0) > -1 ? (a3 | -2147483648 | 0) >= (d3 | 0) : (a3 ^ -2147483648 | 0) < (d3 | 0)) {
            c3 = 1;
            return c3 | 0;
          }
        }
        a3 = f2 - e3 | 0;
        if ((e3 | 0) < 0) {
          d3 = 0 - e3 | 0;
          b2[h >> 2] = a3;
          b2[i >> 2] = d3;
          b2[c3 >> 2] = 0;
          e3 = 0;
        } else {
          a3 = f2;
          d3 = 0;
        }
        if ((a3 | 0) < 0) {
          e3 = e3 - a3 | 0;
          b2[c3 >> 2] = e3;
          d3 = d3 - a3 | 0;
          b2[i >> 2] = d3;
          b2[h >> 2] = 0;
          a3 = 0;
        }
        g2 = e3 - d3 | 0;
        f2 = a3 - d3 | 0;
        if ((d3 | 0) < 0) {
          b2[c3 >> 2] = g2;
          b2[h >> 2] = f2;
          b2[i >> 2] = 0;
          a3 = f2;
          f2 = g2;
          d3 = 0;
        } else {
          f2 = e3;
        }
        e3 = (a3 | 0) < (f2 | 0) ? a3 : f2;
        e3 = (d3 | 0) < (e3 | 0) ? d3 : e3;
        if ((e3 | 0) <= 0) {
          c3 = 0;
          return c3 | 0;
        }
        b2[c3 >> 2] = f2 - e3;
        b2[h >> 2] = a3 - e3;
        b2[i >> 2] = d3 - e3;
        c3 = 0;
        return c3 | 0;
      }
      function gb(a3) {
        a3 = a3 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0;
        c3 = a3 + 8 | 0;
        f2 = b2[c3 >> 2] | 0;
        d3 = f2 - (b2[a3 >> 2] | 0) | 0;
        b2[a3 >> 2] = d3;
        e3 = a3 + 4 | 0;
        a3 = (b2[e3 >> 2] | 0) - f2 | 0;
        b2[e3 >> 2] = a3;
        b2[c3 >> 2] = 0 - (a3 + d3);
        return;
      }
      function hb(a3) {
        a3 = a3 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        d3 = b2[a3 >> 2] | 0;
        c3 = 0 - d3 | 0;
        b2[a3 >> 2] = c3;
        h = a3 + 8 | 0;
        b2[h >> 2] = 0;
        i = a3 + 4 | 0;
        e3 = b2[i >> 2] | 0;
        f2 = e3 + d3 | 0;
        if ((d3 | 0) > 0) {
          b2[i >> 2] = f2;
          b2[h >> 2] = d3;
          b2[a3 >> 2] = 0;
          c3 = 0;
          e3 = f2;
        } else {
          d3 = 0;
        }
        if ((e3 | 0) < 0) {
          g2 = c3 - e3 | 0;
          b2[a3 >> 2] = g2;
          d3 = d3 - e3 | 0;
          b2[h >> 2] = d3;
          b2[i >> 2] = 0;
          f2 = g2 - d3 | 0;
          c3 = 0 - d3 | 0;
          if ((d3 | 0) < 0) {
            b2[a3 >> 2] = f2;
            b2[i >> 2] = c3;
            b2[h >> 2] = 0;
            e3 = c3;
            d3 = 0;
          } else {
            e3 = 0;
            f2 = g2;
          }
        } else {
          f2 = c3;
        }
        c3 = (e3 | 0) < (f2 | 0) ? e3 : f2;
        c3 = (d3 | 0) < (c3 | 0) ? d3 : c3;
        if ((c3 | 0) <= 0) {
          return;
        }
        b2[a3 >> 2] = f2 - c3;
        b2[i >> 2] = e3 - c3;
        b2[h >> 2] = d3 - c3;
        return;
      }
      function ib(a3, c3, d3, e3, f2) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0;
        m = T;
        T = T + 64 | 0;
        l = m;
        i = m + 56 | 0;
        if (!(true & (c3 & 2013265920 | 0) == 134217728 & (true & (e3 & 2013265920 | 0) == 134217728))) {
          f2 = 5;
          T = m;
          return f2 | 0;
        }
        if ((a3 | 0) == (d3 | 0) & (c3 | 0) == (e3 | 0)) {
          b2[f2 >> 2] = 0;
          f2 = 0;
          T = m;
          return f2 | 0;
        }
        h = Td(a3 | 0, c3 | 0, 52) | 0;
        H() | 0;
        h = h & 15;
        k = Td(d3 | 0, e3 | 0, 52) | 0;
        H() | 0;
        if ((h | 0) != (k & 15 | 0)) {
          f2 = 12;
          T = m;
          return f2 | 0;
        }
        g2 = h + -1 | 0;
        if (h >>> 0 > 1) {
          Ib(a3, c3, g2, l) | 0;
          Ib(d3, e3, g2, i) | 0;
          k = l;
          j = b2[k >> 2] | 0;
          k = b2[k + 4 >> 2] | 0;
          a: do {
            if ((j | 0) == (b2[i >> 2] | 0) ? (k | 0) == (b2[i + 4 >> 2] | 0) : 0) {
              h = (h ^ 15) * 3 | 0;
              g2 = Td(a3 | 0, c3 | 0, h | 0) | 0;
              H() | 0;
              g2 = g2 & 7;
              h = Td(d3 | 0, e3 | 0, h | 0) | 0;
              H() | 0;
              h = h & 7;
              do {
                if (!((g2 | 0) == 0 | (h | 0) == 0)) {
                  if ((g2 | 0) == 7) {
                    g2 = 5;
                  } else {
                    if ((g2 | 0) == 1 | (h | 0) == 1 ? Kb(j, k) | 0 : 0) {
                      g2 = 5;
                      break;
                    }
                    if ((b2[15536 + (g2 << 2) >> 2] | 0) != (h | 0) ? (b2[15568 + (g2 << 2) >> 2] | 0) != (h | 0) : 0) {
                      break a;
                    }
                    b2[f2 >> 2] = 1;
                    g2 = 0;
                  }
                } else {
                  b2[f2 >> 2] = 1;
                  g2 = 0;
                }
              } while (0);
              f2 = g2;
              T = m;
              return f2 | 0;
            }
          } while (0);
        }
        g2 = l;
        h = g2 + 56 | 0;
        do {
          b2[g2 >> 2] = 0;
          g2 = g2 + 4 | 0;
        } while ((g2 | 0) < (h | 0));
        aa(a3, c3, 1, l) | 0;
        c3 = l;
        if (((((!((b2[c3 >> 2] | 0) == (d3 | 0) ? (b2[c3 + 4 >> 2] | 0) == (e3 | 0) : 0) ? (c3 = l + 8 | 0, !((b2[c3 >> 2] | 0) == (d3 | 0) ? (b2[c3 + 4 >> 2] | 0) == (e3 | 0) : 0)) : 0) ? (c3 = l + 16 | 0, !((b2[c3 >> 2] | 0) == (d3 | 0) ? (b2[c3 + 4 >> 2] | 0) == (e3 | 0) : 0)) : 0) ? (c3 = l + 24 | 0, !((b2[c3 >> 2] | 0) == (d3 | 0) ? (b2[c3 + 4 >> 2] | 0) == (e3 | 0) : 0)) : 0) ? (c3 = l + 32 | 0, !((b2[c3 >> 2] | 0) == (d3 | 0) ? (b2[c3 + 4 >> 2] | 0) == (e3 | 0) : 0)) : 0) ? (c3 = l + 40 | 0, !((b2[c3 >> 2] | 0) == (d3 | 0) ? (b2[c3 + 4 >> 2] | 0) == (e3 | 0) : 0)) : 0) {
          g2 = l + 48 | 0;
          g2 = ((b2[g2 >> 2] | 0) == (d3 | 0) ? (b2[g2 + 4 >> 2] | 0) == (e3 | 0) : 0) & 1;
        } else {
          g2 = 1;
        }
        b2[f2 >> 2] = g2;
        f2 = 0;
        T = m;
        return f2 | 0;
      }
      function jb(a3, c3, d3, e3, f2) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        d3 = ia(a3, c3, d3, e3) | 0;
        if ((d3 | 0) == 7) {
          f2 = 11;
          return f2 | 0;
        }
        e3 = Ud(d3 | 0, 0, 56) | 0;
        c3 = c3 & -2130706433 | (H() | 0) | 268435456;
        b2[f2 >> 2] = a3 | e3;
        b2[f2 + 4 >> 2] = c3;
        f2 = 0;
        return f2 | 0;
      }
      function kb(a3, c3, d3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        if (!(true & (c3 & 2013265920 | 0) == 268435456)) {
          d3 = 6;
          return d3 | 0;
        }
        b2[d3 >> 2] = a3;
        b2[d3 + 4 >> 2] = c3 & -2130706433 | 134217728;
        d3 = 0;
        return d3 | 0;
      }
      function lb(a3, c3, d3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0, g2 = 0;
        f2 = T;
        T = T + 16 | 0;
        e3 = f2;
        b2[e3 >> 2] = 0;
        if (!(true & (c3 & 2013265920 | 0) == 268435456)) {
          e3 = 6;
          T = f2;
          return e3 | 0;
        }
        g2 = Td(a3 | 0, c3 | 0, 56) | 0;
        H() | 0;
        e3 = ea(a3, c3 & -2130706433 | 134217728, g2 & 7, e3, d3) | 0;
        T = f2;
        return e3 | 0;
      }
      function mb(a3, b3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        var c3 = 0;
        c3 = Td(a3 | 0, b3 | 0, 56) | 0;
        H() | 0;
        switch (c3 & 7) {
          case 0:
          case 7: {
            c3 = 0;
            return c3 | 0;
          }
          default:
        }
        c3 = b3 & -2130706433 | 134217728;
        if (!(true & (b3 & 2013265920 | 0) == 268435456)) {
          c3 = 0;
          return c3 | 0;
        }
        if (true & (b3 & 117440512 | 0) == 16777216 & (Kb(a3, c3) | 0) != 0) {
          c3 = 0;
          return c3 | 0;
        }
        c3 = Fb(a3, c3) | 0;
        return c3 | 0;
      }
      function nb(a3, c3, d3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0, g2 = 0, h = 0;
        f2 = T;
        T = T + 16 | 0;
        e3 = f2;
        if (!(true & (c3 & 2013265920 | 0) == 268435456)) {
          e3 = 6;
          T = f2;
          return e3 | 0;
        }
        g2 = c3 & -2130706433 | 134217728;
        h = d3;
        b2[h >> 2] = a3;
        b2[h + 4 >> 2] = g2;
        b2[e3 >> 2] = 0;
        c3 = Td(a3 | 0, c3 | 0, 56) | 0;
        H() | 0;
        e3 = ea(a3, g2, c3 & 7, e3, d3 + 8 | 0) | 0;
        T = f2;
        return e3 | 0;
      }
      function ob(a3, c3, d3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0;
        f2 = (Kb(a3, c3) | 0) == 0;
        c3 = c3 & -2130706433;
        e3 = d3;
        b2[e3 >> 2] = f2 ? a3 : 0;
        b2[e3 + 4 >> 2] = f2 ? c3 | 285212672 : 0;
        e3 = d3 + 8 | 0;
        b2[e3 >> 2] = a3;
        b2[e3 + 4 >> 2] = c3 | 301989888;
        e3 = d3 + 16 | 0;
        b2[e3 >> 2] = a3;
        b2[e3 + 4 >> 2] = c3 | 318767104;
        e3 = d3 + 24 | 0;
        b2[e3 >> 2] = a3;
        b2[e3 + 4 >> 2] = c3 | 335544320;
        e3 = d3 + 32 | 0;
        b2[e3 >> 2] = a3;
        b2[e3 + 4 >> 2] = c3 | 352321536;
        d3 = d3 + 40 | 0;
        b2[d3 >> 2] = a3;
        b2[d3 + 4 >> 2] = c3 | 369098752;
        return 0;
      }
      function pb(a3, c3, d3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0, g2 = 0, h = 0;
        h = T;
        T = T + 16 | 0;
        f2 = h;
        g2 = c3 & -2130706433 | 134217728;
        if (!(true & (c3 & 2013265920 | 0) == 268435456)) {
          g2 = 6;
          T = h;
          return g2 | 0;
        }
        e3 = Td(a3 | 0, c3 | 0, 56) | 0;
        H() | 0;
        e3 = rd(a3, g2, e3 & 7) | 0;
        if ((e3 | 0) == -1) {
          b2[d3 >> 2] = 0;
          g2 = 6;
          T = h;
          return g2 | 0;
        }
        if ($b(a3, g2, f2) | 0) {
          I(27795, 26932, 282, 26947);
        }
        c3 = Td(a3 | 0, c3 | 0, 52) | 0;
        H() | 0;
        c3 = c3 & 15;
        if (!(Kb(a3, g2) | 0)) {
          zb(f2, c3, e3, 2, d3);
        } else {
          vb(f2, c3, e3, 2, d3);
        }
        g2 = 0;
        T = h;
        return g2 | 0;
      }
      function qb(a3, b3, c3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        c3 = c3 | 0;
        var d3 = 0, e3 = 0;
        d3 = T;
        T = T + 16 | 0;
        e3 = d3;
        rb(a3, b3, c3, e3);
        La(e3, c3 + 4 | 0);
        T = d3;
        return;
      }
      function rb(a3, c3, d3, f2) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0;
        j = T;
        T = T + 16 | 0;
        k = j;
        sb(a3, d3, k);
        h = +w2(+(1 - +e2[k >> 3] * 0.5));
        if (h < 1e-16) {
          b2[f2 >> 2] = 0;
          b2[f2 + 4 >> 2] = 0;
          b2[f2 + 8 >> 2] = 0;
          b2[f2 + 12 >> 2] = 0;
          T = j;
          return;
        }
        k = b2[d3 >> 2] | 0;
        g2 = +e2[15920 + (k * 24 | 0) >> 3];
        g2 = +lc(g2 - +lc(+rc(15600 + (k << 4) | 0, a3)));
        if (!(Yb(c3) | 0)) {
          i = g2;
        } else {
          i = +lc(g2 + -0.3334731722518321);
        }
        g2 = +v2(+h) * 2.618033988749896;
        if ((c3 | 0) > 0) {
          a3 = 0;
          do {
            g2 = g2 * 2.6457513110645907;
            a3 = a3 + 1 | 0;
          } while ((a3 | 0) != (c3 | 0));
        }
        h = +t(+i) * g2;
        e2[f2 >> 3] = h;
        i = +u2(+i) * g2;
        e2[f2 + 8 >> 3] = i;
        T = j;
        return;
      }
      function sb(a3, c3, d3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var f2 = 0, g2 = 0, h = 0;
        h = T;
        T = T + 32 | 0;
        g2 = h;
        qd(a3, g2);
        b2[c3 >> 2] = 0;
        e2[d3 >> 3] = 5;
        f2 = +pd(16400, g2);
        if (f2 < +e2[d3 >> 3]) {
          b2[c3 >> 2] = 0;
          e2[d3 >> 3] = f2;
        }
        f2 = +pd(16424, g2);
        if (f2 < +e2[d3 >> 3]) {
          b2[c3 >> 2] = 1;
          e2[d3 >> 3] = f2;
        }
        f2 = +pd(16448, g2);
        if (f2 < +e2[d3 >> 3]) {
          b2[c3 >> 2] = 2;
          e2[d3 >> 3] = f2;
        }
        f2 = +pd(16472, g2);
        if (f2 < +e2[d3 >> 3]) {
          b2[c3 >> 2] = 3;
          e2[d3 >> 3] = f2;
        }
        f2 = +pd(16496, g2);
        if (f2 < +e2[d3 >> 3]) {
          b2[c3 >> 2] = 4;
          e2[d3 >> 3] = f2;
        }
        f2 = +pd(16520, g2);
        if (f2 < +e2[d3 >> 3]) {
          b2[c3 >> 2] = 5;
          e2[d3 >> 3] = f2;
        }
        f2 = +pd(16544, g2);
        if (f2 < +e2[d3 >> 3]) {
          b2[c3 >> 2] = 6;
          e2[d3 >> 3] = f2;
        }
        f2 = +pd(16568, g2);
        if (f2 < +e2[d3 >> 3]) {
          b2[c3 >> 2] = 7;
          e2[d3 >> 3] = f2;
        }
        f2 = +pd(16592, g2);
        if (f2 < +e2[d3 >> 3]) {
          b2[c3 >> 2] = 8;
          e2[d3 >> 3] = f2;
        }
        f2 = +pd(16616, g2);
        if (f2 < +e2[d3 >> 3]) {
          b2[c3 >> 2] = 9;
          e2[d3 >> 3] = f2;
        }
        f2 = +pd(16640, g2);
        if (f2 < +e2[d3 >> 3]) {
          b2[c3 >> 2] = 10;
          e2[d3 >> 3] = f2;
        }
        f2 = +pd(16664, g2);
        if (f2 < +e2[d3 >> 3]) {
          b2[c3 >> 2] = 11;
          e2[d3 >> 3] = f2;
        }
        f2 = +pd(16688, g2);
        if (f2 < +e2[d3 >> 3]) {
          b2[c3 >> 2] = 12;
          e2[d3 >> 3] = f2;
        }
        f2 = +pd(16712, g2);
        if (f2 < +e2[d3 >> 3]) {
          b2[c3 >> 2] = 13;
          e2[d3 >> 3] = f2;
        }
        f2 = +pd(16736, g2);
        if (f2 < +e2[d3 >> 3]) {
          b2[c3 >> 2] = 14;
          e2[d3 >> 3] = f2;
        }
        f2 = +pd(16760, g2);
        if (f2 < +e2[d3 >> 3]) {
          b2[c3 >> 2] = 15;
          e2[d3 >> 3] = f2;
        }
        f2 = +pd(16784, g2);
        if (f2 < +e2[d3 >> 3]) {
          b2[c3 >> 2] = 16;
          e2[d3 >> 3] = f2;
        }
        f2 = +pd(16808, g2);
        if (f2 < +e2[d3 >> 3]) {
          b2[c3 >> 2] = 17;
          e2[d3 >> 3] = f2;
        }
        f2 = +pd(16832, g2);
        if (f2 < +e2[d3 >> 3]) {
          b2[c3 >> 2] = 18;
          e2[d3 >> 3] = f2;
        }
        f2 = +pd(16856, g2);
        if (!(f2 < +e2[d3 >> 3])) {
          T = h;
          return;
        }
        b2[c3 >> 2] = 19;
        e2[d3 >> 3] = f2;
        T = h;
        return;
      }
      function tb(a3, c3, d3, f2, g2) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        var h = 0, i = 0, j = 0;
        h = +md(a3);
        if (h < 1e-16) {
          c3 = 15600 + (c3 << 4) | 0;
          b2[g2 >> 2] = b2[c3 >> 2];
          b2[g2 + 4 >> 2] = b2[c3 + 4 >> 2];
          b2[g2 + 8 >> 2] = b2[c3 + 8 >> 2];
          b2[g2 + 12 >> 2] = b2[c3 + 12 >> 2];
          return;
        }
        i = +z(+ +e2[a3 + 8 >> 3], + +e2[a3 >> 3]);
        if ((d3 | 0) > 0) {
          a3 = 0;
          do {
            h = h * 0.37796447300922725;
            a3 = a3 + 1 | 0;
          } while ((a3 | 0) != (d3 | 0));
        }
        j = h * 0.3333333333333333;
        if (!f2) {
          h = +y(+(h * 0.381966011250105));
          if (Yb(d3) | 0) {
            i = +lc(i + 0.3334731722518321);
          }
        } else {
          d3 = (Yb(d3) | 0) == 0;
          h = +y(+((d3 ? j : j * 0.37796447300922725) * 0.381966011250105));
        }
        sc(15600 + (c3 << 4) | 0, +lc(+e2[15920 + (c3 * 24 | 0) >> 3] - i), h, g2);
        return;
      }
      function ub(a3, c3, d3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0;
        e3 = T;
        T = T + 16 | 0;
        f2 = e3;
        Na(a3 + 4 | 0, f2);
        tb(f2, b2[a3 >> 2] | 0, c3, 0, d3);
        T = e3;
        return;
      }
      function vb(a3, c3, d3, f2, g2) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t2 = 0, u3 = 0, v3 = 0, w3 = 0, x2 = 0, y2 = 0, z2 = 0, A3 = 0, B3 = 0, C3 = 0, D3 = 0, E3 = 0, F2 = 0, G3 = 0, H2 = 0, J2 = 0;
        G3 = T;
        T = T + 272 | 0;
        h = G3 + 256 | 0;
        u3 = G3 + 240 | 0;
        D3 = G3;
        E3 = G3 + 224 | 0;
        F2 = G3 + 208 | 0;
        v3 = G3 + 176 | 0;
        w3 = G3 + 160 | 0;
        x2 = G3 + 192 | 0;
        y2 = G3 + 144 | 0;
        z2 = G3 + 128 | 0;
        A3 = G3 + 112 | 0;
        B3 = G3 + 96 | 0;
        C3 = G3 + 80 | 0;
        b2[h >> 2] = c3;
        b2[u3 >> 2] = b2[a3 >> 2];
        b2[u3 + 4 >> 2] = b2[a3 + 4 >> 2];
        b2[u3 + 8 >> 2] = b2[a3 + 8 >> 2];
        b2[u3 + 12 >> 2] = b2[a3 + 12 >> 2];
        wb(u3, h, D3);
        b2[g2 >> 2] = 0;
        u3 = f2 + d3 + ((f2 | 0) == 5 & 1) | 0;
        if ((u3 | 0) <= (d3 | 0)) {
          T = G3;
          return;
        }
        k = b2[h >> 2] | 0;
        l = E3 + 4 | 0;
        m = v3 + 4 | 0;
        n = d3 + 5 | 0;
        o = 16880 + (k << 2) | 0;
        p2 = 16960 + (k << 2) | 0;
        q2 = z2 + 8 | 0;
        r2 = A3 + 8 | 0;
        s2 = B3 + 8 | 0;
        t2 = F2 + 4 | 0;
        j = d3;
        a: while (1) {
          i = D3 + (((j | 0) % 5 | 0) << 4) | 0;
          b2[F2 >> 2] = b2[i >> 2];
          b2[F2 + 4 >> 2] = b2[i + 4 >> 2];
          b2[F2 + 8 >> 2] = b2[i + 8 >> 2];
          b2[F2 + 12 >> 2] = b2[i + 12 >> 2];
          do {
          } while ((xb(F2, k, 0, 1) | 0) == 2);
          if ((j | 0) > (d3 | 0) & (Yb(c3) | 0) != 0) {
            b2[v3 >> 2] = b2[F2 >> 2];
            b2[v3 + 4 >> 2] = b2[F2 + 4 >> 2];
            b2[v3 + 8 >> 2] = b2[F2 + 8 >> 2];
            b2[v3 + 12 >> 2] = b2[F2 + 12 >> 2];
            Na(l, w3);
            f2 = b2[v3 >> 2] | 0;
            h = b2[17040 + (f2 * 80 | 0) + (b2[E3 >> 2] << 2) >> 2] | 0;
            b2[v3 >> 2] = b2[18640 + (f2 * 80 | 0) + (h * 20 | 0) >> 2];
            i = b2[18640 + (f2 * 80 | 0) + (h * 20 | 0) + 16 >> 2] | 0;
            if ((i | 0) > 0) {
              a3 = 0;
              do {
                Za(m);
                a3 = a3 + 1 | 0;
              } while ((a3 | 0) < (i | 0));
            }
            i = 18640 + (f2 * 80 | 0) + (h * 20 | 0) + 4 | 0;
            b2[x2 >> 2] = b2[i >> 2];
            b2[x2 + 4 >> 2] = b2[i + 4 >> 2];
            b2[x2 + 8 >> 2] = b2[i + 8 >> 2];
            Qa(x2, (b2[o >> 2] | 0) * 3 | 0);
            Oa(m, x2, m);
            Ma(m);
            Na(m, y2);
            H2 = +(b2[p2 >> 2] | 0);
            e2[z2 >> 3] = H2 * 3;
            e2[q2 >> 3] = 0;
            J2 = H2 * -1.5;
            e2[A3 >> 3] = J2;
            e2[r2 >> 3] = H2 * 2.598076211353316;
            e2[B3 >> 3] = J2;
            e2[s2 >> 3] = H2 * -2.598076211353316;
            switch (b2[17040 + ((b2[v3 >> 2] | 0) * 80 | 0) + (b2[F2 >> 2] << 2) >> 2] | 0) {
              case 1: {
                a3 = A3;
                f2 = z2;
                break;
              }
              case 3: {
                a3 = B3;
                f2 = A3;
                break;
              }
              case 2: {
                a3 = z2;
                f2 = B3;
                break;
              }
              default: {
                a3 = 12;
                break a;
              }
            }
            nd(w3, y2, f2, a3, C3);
            tb(C3, b2[v3 >> 2] | 0, k, 1, g2 + 8 + (b2[g2 >> 2] << 4) | 0);
            b2[g2 >> 2] = (b2[g2 >> 2] | 0) + 1;
          }
          if ((j | 0) < (n | 0)) {
            Na(t2, v3);
            tb(v3, b2[F2 >> 2] | 0, k, 1, g2 + 8 + (b2[g2 >> 2] << 4) | 0);
            b2[g2 >> 2] = (b2[g2 >> 2] | 0) + 1;
          }
          b2[E3 >> 2] = b2[F2 >> 2];
          b2[E3 + 4 >> 2] = b2[F2 + 4 >> 2];
          b2[E3 + 8 >> 2] = b2[F2 + 8 >> 2];
          b2[E3 + 12 >> 2] = b2[F2 + 12 >> 2];
          j = j + 1 | 0;
          if ((j | 0) >= (u3 | 0)) {
            a3 = 3;
            break;
          }
        }
        if ((a3 | 0) == 3) {
          T = G3;
          return;
        } else if ((a3 | 0) == 12) {
          I(26970, 27017, 572, 27027);
        }
      }
      function wb(a3, c3, d3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0;
        j = T;
        T = T + 128 | 0;
        e3 = j + 64 | 0;
        f2 = j;
        g2 = e3;
        h = 20240;
        i = g2 + 60 | 0;
        do {
          b2[g2 >> 2] = b2[h >> 2];
          g2 = g2 + 4 | 0;
          h = h + 4 | 0;
        } while ((g2 | 0) < (i | 0));
        g2 = f2;
        h = 20304;
        i = g2 + 60 | 0;
        do {
          b2[g2 >> 2] = b2[h >> 2];
          g2 = g2 + 4 | 0;
          h = h + 4 | 0;
        } while ((g2 | 0) < (i | 0));
        i = (Yb(b2[c3 >> 2] | 0) | 0) == 0;
        e3 = i ? e3 : f2;
        f2 = a3 + 4 | 0;
        bb(f2);
        cb(f2);
        if (Yb(b2[c3 >> 2] | 0) | 0) {
          Xa(f2);
          b2[c3 >> 2] = (b2[c3 >> 2] | 0) + 1;
        }
        b2[d3 >> 2] = b2[a3 >> 2];
        c3 = d3 + 4 | 0;
        Oa(f2, e3, c3);
        Ma(c3);
        b2[d3 + 16 >> 2] = b2[a3 >> 2];
        c3 = d3 + 20 | 0;
        Oa(f2, e3 + 12 | 0, c3);
        Ma(c3);
        b2[d3 + 32 >> 2] = b2[a3 >> 2];
        c3 = d3 + 36 | 0;
        Oa(f2, e3 + 24 | 0, c3);
        Ma(c3);
        b2[d3 + 48 >> 2] = b2[a3 >> 2];
        c3 = d3 + 52 | 0;
        Oa(f2, e3 + 36 | 0, c3);
        Ma(c3);
        b2[d3 + 64 >> 2] = b2[a3 >> 2];
        d3 = d3 + 68 | 0;
        Oa(f2, e3 + 48 | 0, d3);
        Ma(d3);
        T = j;
        return;
      }
      function xb(a3, c3, d3, e3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0;
        p2 = T;
        T = T + 32 | 0;
        n = p2 + 12 | 0;
        i = p2;
        o = a3 + 4 | 0;
        m = b2[16960 + (c3 << 2) >> 2] | 0;
        l = (e3 | 0) != 0;
        m = l ? m * 3 | 0 : m;
        f2 = b2[o >> 2] | 0;
        k = a3 + 8 | 0;
        h = b2[k >> 2] | 0;
        if (l) {
          g2 = a3 + 12 | 0;
          e3 = b2[g2 >> 2] | 0;
          f2 = h + f2 + e3 | 0;
          if ((f2 | 0) == (m | 0)) {
            o = 1;
            T = p2;
            return o | 0;
          } else {
            j = g2;
          }
        } else {
          j = a3 + 12 | 0;
          e3 = b2[j >> 2] | 0;
          f2 = h + f2 + e3 | 0;
        }
        if ((f2 | 0) <= (m | 0)) {
          o = 0;
          T = p2;
          return o | 0;
        }
        do {
          if ((e3 | 0) > 0) {
            e3 = b2[a3 >> 2] | 0;
            if ((h | 0) > 0) {
              g2 = 18640 + (e3 * 80 | 0) + 60 | 0;
              e3 = a3;
              break;
            }
            e3 = 18640 + (e3 * 80 | 0) + 40 | 0;
            if (!d3) {
              g2 = e3;
              e3 = a3;
            } else {
              Ka(n, m, 0, 0);
              Pa(o, n, i);
              _a(i);
              Oa(i, n, o);
              g2 = e3;
              e3 = a3;
            }
          } else {
            g2 = 18640 + ((b2[a3 >> 2] | 0) * 80 | 0) + 20 | 0;
            e3 = a3;
          }
        } while (0);
        b2[e3 >> 2] = b2[g2 >> 2];
        f2 = g2 + 16 | 0;
        if ((b2[f2 >> 2] | 0) > 0) {
          e3 = 0;
          do {
            Za(o);
            e3 = e3 + 1 | 0;
          } while ((e3 | 0) < (b2[f2 >> 2] | 0));
        }
        a3 = g2 + 4 | 0;
        b2[n >> 2] = b2[a3 >> 2];
        b2[n + 4 >> 2] = b2[a3 + 4 >> 2];
        b2[n + 8 >> 2] = b2[a3 + 8 >> 2];
        c3 = b2[16880 + (c3 << 2) >> 2] | 0;
        Qa(n, l ? c3 * 3 | 0 : c3);
        Oa(o, n, o);
        Ma(o);
        if (l) {
          e3 = ((b2[k >> 2] | 0) + (b2[o >> 2] | 0) + (b2[j >> 2] | 0) | 0) == (m | 0) ? 1 : 2;
        } else {
          e3 = 2;
        }
        o = e3;
        T = p2;
        return o | 0;
      }
      function yb(a3, b3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        var c3 = 0;
        do {
          c3 = xb(a3, b3, 0, 1) | 0;
        } while ((c3 | 0) == 2);
        return c3 | 0;
      }
      function zb(a3, c3, d3, f2, g2) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t2 = 0, u3 = 0, v3 = 0, w3 = 0, x2 = 0, y2 = 0, z2 = 0, A3 = 0, B3 = 0, C3 = 0, D3 = 0;
        B3 = T;
        T = T + 240 | 0;
        h = B3 + 224 | 0;
        x2 = B3 + 208 | 0;
        y2 = B3;
        z2 = B3 + 192 | 0;
        A3 = B3 + 176 | 0;
        s2 = B3 + 160 | 0;
        t2 = B3 + 144 | 0;
        u3 = B3 + 128 | 0;
        v3 = B3 + 112 | 0;
        w3 = B3 + 96 | 0;
        b2[h >> 2] = c3;
        b2[x2 >> 2] = b2[a3 >> 2];
        b2[x2 + 4 >> 2] = b2[a3 + 4 >> 2];
        b2[x2 + 8 >> 2] = b2[a3 + 8 >> 2];
        b2[x2 + 12 >> 2] = b2[a3 + 12 >> 2];
        Ab(x2, h, y2);
        b2[g2 >> 2] = 0;
        r2 = f2 + d3 + ((f2 | 0) == 6 & 1) | 0;
        if ((r2 | 0) <= (d3 | 0)) {
          T = B3;
          return;
        }
        k = b2[h >> 2] | 0;
        l = d3 + 6 | 0;
        m = 16960 + (k << 2) | 0;
        n = t2 + 8 | 0;
        o = u3 + 8 | 0;
        p2 = v3 + 8 | 0;
        q2 = z2 + 4 | 0;
        i = 0;
        j = d3;
        f2 = -1;
        a: while (1) {
          h = (j | 0) % 6 | 0;
          a3 = y2 + (h << 4) | 0;
          b2[z2 >> 2] = b2[a3 >> 2];
          b2[z2 + 4 >> 2] = b2[a3 + 4 >> 2];
          b2[z2 + 8 >> 2] = b2[a3 + 8 >> 2];
          b2[z2 + 12 >> 2] = b2[a3 + 12 >> 2];
          a3 = i;
          i = xb(z2, k, 0, 1) | 0;
          if ((j | 0) > (d3 | 0) & (Yb(c3) | 0) != 0 ? (a3 | 0) != 1 ? (b2[z2 >> 2] | 0) != (f2 | 0) : 0 : 0) {
            Na(y2 + (((h + 5 | 0) % 6 | 0) << 4) + 4 | 0, A3);
            Na(y2 + (h << 4) + 4 | 0, s2);
            C3 = +(b2[m >> 2] | 0);
            e2[t2 >> 3] = C3 * 3;
            e2[n >> 3] = 0;
            D3 = C3 * -1.5;
            e2[u3 >> 3] = D3;
            e2[o >> 3] = C3 * 2.598076211353316;
            e2[v3 >> 3] = D3;
            e2[p2 >> 3] = C3 * -2.598076211353316;
            h = b2[x2 >> 2] | 0;
            switch (b2[17040 + (h * 80 | 0) + (((f2 | 0) == (h | 0) ? b2[z2 >> 2] | 0 : f2) << 2) >> 2] | 0) {
              case 1: {
                a3 = u3;
                f2 = t2;
                break;
              }
              case 3: {
                a3 = v3;
                f2 = u3;
                break;
              }
              case 2: {
                a3 = t2;
                f2 = v3;
                break;
              }
              default: {
                a3 = 8;
                break a;
              }
            }
            nd(A3, s2, f2, a3, w3);
            if (!(od(A3, w3) | 0) ? !(od(s2, w3) | 0) : 0) {
              tb(w3, b2[x2 >> 2] | 0, k, 1, g2 + 8 + (b2[g2 >> 2] << 4) | 0);
              b2[g2 >> 2] = (b2[g2 >> 2] | 0) + 1;
            }
          }
          if ((j | 0) < (l | 0)) {
            Na(q2, A3);
            tb(A3, b2[z2 >> 2] | 0, k, 1, g2 + 8 + (b2[g2 >> 2] << 4) | 0);
            b2[g2 >> 2] = (b2[g2 >> 2] | 0) + 1;
          }
          j = j + 1 | 0;
          if ((j | 0) >= (r2 | 0)) {
            a3 = 3;
            break;
          } else {
            f2 = b2[z2 >> 2] | 0;
          }
        }
        if ((a3 | 0) == 3) {
          T = B3;
          return;
        } else if ((a3 | 0) == 8) {
          I(27054, 27017, 737, 27099);
        }
      }
      function Ab(a3, c3, d3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0;
        j = T;
        T = T + 160 | 0;
        e3 = j + 80 | 0;
        f2 = j;
        g2 = e3;
        h = 20368;
        i = g2 + 72 | 0;
        do {
          b2[g2 >> 2] = b2[h >> 2];
          g2 = g2 + 4 | 0;
          h = h + 4 | 0;
        } while ((g2 | 0) < (i | 0));
        g2 = f2;
        h = 20448;
        i = g2 + 72 | 0;
        do {
          b2[g2 >> 2] = b2[h >> 2];
          g2 = g2 + 4 | 0;
          h = h + 4 | 0;
        } while ((g2 | 0) < (i | 0));
        i = (Yb(b2[c3 >> 2] | 0) | 0) == 0;
        e3 = i ? e3 : f2;
        f2 = a3 + 4 | 0;
        bb(f2);
        cb(f2);
        if (Yb(b2[c3 >> 2] | 0) | 0) {
          Xa(f2);
          b2[c3 >> 2] = (b2[c3 >> 2] | 0) + 1;
        }
        b2[d3 >> 2] = b2[a3 >> 2];
        c3 = d3 + 4 | 0;
        Oa(f2, e3, c3);
        Ma(c3);
        b2[d3 + 16 >> 2] = b2[a3 >> 2];
        c3 = d3 + 20 | 0;
        Oa(f2, e3 + 12 | 0, c3);
        Ma(c3);
        b2[d3 + 32 >> 2] = b2[a3 >> 2];
        c3 = d3 + 36 | 0;
        Oa(f2, e3 + 24 | 0, c3);
        Ma(c3);
        b2[d3 + 48 >> 2] = b2[a3 >> 2];
        c3 = d3 + 52 | 0;
        Oa(f2, e3 + 36 | 0, c3);
        Ma(c3);
        b2[d3 + 64 >> 2] = b2[a3 >> 2];
        c3 = d3 + 68 | 0;
        Oa(f2, e3 + 48 | 0, c3);
        Ma(c3);
        b2[d3 + 80 >> 2] = b2[a3 >> 2];
        d3 = d3 + 84 | 0;
        Oa(f2, e3 + 60 | 0, d3);
        Ma(d3);
        T = j;
        return;
      }
      function Bb(a3, b3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        b3 = Td(a3 | 0, b3 | 0, 52) | 0;
        H() | 0;
        return b3 & 15 | 0;
      }
      function Cb(a3, b3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        b3 = Td(a3 | 0, b3 | 0, 45) | 0;
        H() | 0;
        return b3 & 127 | 0;
      }
      function Db(a3, c3, d3, e3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        if ((d3 + -1 | 0) >>> 0 > 14) {
          e3 = 4;
          return e3 | 0;
        }
        d3 = Td(a3 | 0, c3 | 0, (15 - d3 | 0) * 3 | 0) | 0;
        H() | 0;
        b2[e3 >> 2] = d3 & 7;
        e3 = 0;
        return e3 | 0;
      }
      function Eb(c3, d3, e3, f2) {
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0;
        if (c3 >>> 0 > 15) {
          f2 = 4;
          return f2 | 0;
        }
        if (d3 >>> 0 > 121) {
          f2 = 17;
          return f2 | 0;
        }
        i = Ud(c3 | 0, 0, 52) | 0;
        g2 = H() | 0;
        j = Ud(d3 | 0, 0, 45) | 0;
        g2 = g2 | (H() | 0) | 134225919;
        a: do {
          if ((c3 | 0) >= 1) {
            j = 1;
            i = (a2[20528 + d3 >> 0] | 0) != 0;
            h = -1;
            while (1) {
              d3 = b2[e3 + (j + -1 << 2) >> 2] | 0;
              if (d3 >>> 0 > 6) {
                g2 = 18;
                d3 = 10;
                break;
              }
              if (!((d3 | 0) == 0 | i ^ 1)) {
                if ((d3 | 0) == 1) {
                  g2 = 19;
                  d3 = 10;
                  break;
                } else {
                  i = 0;
                }
              }
              l = (15 - j | 0) * 3 | 0;
              k = Ud(7, 0, l | 0) | 0;
              g2 = g2 & ~(H() | 0);
              d3 = Ud(d3 | 0, ((d3 | 0) < 0) << 31 >> 31 | 0, l | 0) | 0;
              h = d3 | h & ~k;
              g2 = H() | 0 | g2;
              if ((j | 0) < (c3 | 0)) {
                j = j + 1 | 0;
              } else {
                break a;
              }
            }
            if ((d3 | 0) == 10) {
              return g2 | 0;
            }
          } else {
            h = -1;
          }
        } while (0);
        l = f2;
        b2[l >> 2] = h;
        b2[l + 4 >> 2] = g2;
        l = 0;
        return l | 0;
      }
      function Fb(b3, c3) {
        b3 = b3 | 0;
        c3 = c3 | 0;
        var d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0;
        if (!(true & (c3 & -16777216 | 0) == 134217728)) {
          b3 = 0;
          return b3 | 0;
        }
        e3 = Td(b3 | 0, c3 | 0, 52) | 0;
        H() | 0;
        e3 = e3 & 15;
        d3 = Td(b3 | 0, c3 | 0, 45) | 0;
        H() | 0;
        d3 = d3 & 127;
        if (d3 >>> 0 > 121) {
          b3 = 0;
          return b3 | 0;
        }
        h = (e3 ^ 15) * 3 | 0;
        f2 = Td(b3 | 0, c3 | 0, h | 0) | 0;
        h = Ud(f2 | 0, H() | 0, h | 0) | 0;
        f2 = H() | 0;
        g2 = Kd(-1227133514, -1171, h | 0, f2 | 0) | 0;
        if (!((h & 613566756 & g2 | 0) == 0 & (f2 & 4681 & (H() | 0) | 0) == 0)) {
          h = 0;
          return h | 0;
        }
        h = (e3 * 3 | 0) + 19 | 0;
        g2 = Ud(~b3 | 0, ~c3 | 0, h | 0) | 0;
        h = Td(g2 | 0, H() | 0, h | 0) | 0;
        if (!((e3 | 0) == 15 | (h | 0) == 0 & (H() | 0) == 0)) {
          h = 0;
          return h | 0;
        }
        if (!(a2[20528 + d3 >> 0] | 0)) {
          h = 1;
          return h | 0;
        }
        c3 = c3 & 8191;
        if ((b3 | 0) == 0 & (c3 | 0) == 0) {
          h = 1;
          return h | 0;
        } else {
          h = Vd(b3 | 0, c3 | 0, 0) | 0;
          H() | 0;
          return ((63 - h | 0) % 3 | 0 | 0) != 0 | 0;
        }
        return 0;
      }
      function Gb(b3, c3) {
        b3 = b3 | 0;
        c3 = c3 | 0;
        var d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0;
        if (((true & (c3 & -16777216 | 0) == 134217728 ? (e3 = Td(b3 | 0, c3 | 0, 52) | 0, H() | 0, e3 = e3 & 15, d3 = Td(b3 | 0, c3 | 0, 45) | 0, H() | 0, d3 = d3 & 127, d3 >>> 0 <= 121) : 0) ? (h = (e3 ^ 15) * 3 | 0, f2 = Td(b3 | 0, c3 | 0, h | 0) | 0, h = Ud(f2 | 0, H() | 0, h | 0) | 0, f2 = H() | 0, g2 = Kd(-1227133514, -1171, h | 0, f2 | 0) | 0, (h & 613566756 & g2 | 0) == 0 & (f2 & 4681 & (H() | 0) | 0) == 0) : 0) ? (h = (e3 * 3 | 0) + 19 | 0, g2 = Ud(~b3 | 0, ~c3 | 0, h | 0) | 0, h = Td(g2 | 0, H() | 0, h | 0) | 0, (e3 | 0) == 15 | (h | 0) == 0 & (H() | 0) == 0) : 0) {
          if (!(a2[20528 + d3 >> 0] | 0)) {
            h = 1;
            return h | 0;
          }
          d3 = c3 & 8191;
          if ((b3 | 0) == 0 & (d3 | 0) == 0) {
            h = 1;
            return h | 0;
          }
          h = Vd(b3 | 0, d3 | 0, 0) | 0;
          H() | 0;
          if ((63 - h | 0) % 3 | 0 | 0) {
            h = 1;
            return h | 0;
          }
        }
        if (mb(b3, c3) | 0) {
          h = 1;
          return h | 0;
        }
        h = (wd(b3, c3) | 0) != 0 & 1;
        return h | 0;
      }
      function Hb(a3, c3, d3, e3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0;
        f2 = Ud(c3 | 0, 0, 52) | 0;
        g2 = H() | 0;
        d3 = Ud(d3 | 0, 0, 45) | 0;
        d3 = g2 | (H() | 0) | 134225919;
        if ((c3 | 0) < 1) {
          g2 = -1;
          e3 = d3;
          c3 = a3;
          b2[c3 >> 2] = g2;
          a3 = a3 + 4 | 0;
          b2[a3 >> 2] = e3;
          return;
        }
        g2 = 1;
        f2 = -1;
        while (1) {
          h = (15 - g2 | 0) * 3 | 0;
          i = Ud(7, 0, h | 0) | 0;
          d3 = d3 & ~(H() | 0);
          h = Ud(e3 | 0, 0, h | 0) | 0;
          f2 = f2 & ~i | h;
          d3 = d3 | (H() | 0);
          if ((g2 | 0) == (c3 | 0)) {
            break;
          } else {
            g2 = g2 + 1 | 0;
          }
        }
        i = a3;
        h = i;
        b2[h >> 2] = f2;
        i = i + 4 | 0;
        b2[i >> 2] = d3;
        return;
      }
      function Ib(a3, c3, d3, e3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0;
        g2 = Td(a3 | 0, c3 | 0, 52) | 0;
        H() | 0;
        g2 = g2 & 15;
        if (d3 >>> 0 > 15) {
          e3 = 4;
          return e3 | 0;
        }
        if ((g2 | 0) < (d3 | 0)) {
          e3 = 12;
          return e3 | 0;
        }
        if ((g2 | 0) == (d3 | 0)) {
          b2[e3 >> 2] = a3;
          b2[e3 + 4 >> 2] = c3;
          e3 = 0;
          return e3 | 0;
        }
        f2 = Ud(d3 | 0, 0, 52) | 0;
        f2 = f2 | a3;
        a3 = H() | 0 | c3 & -15728641;
        if ((g2 | 0) > (d3 | 0)) {
          do {
            c3 = Ud(7, 0, (14 - d3 | 0) * 3 | 0) | 0;
            d3 = d3 + 1 | 0;
            f2 = c3 | f2;
            a3 = H() | 0 | a3;
          } while ((d3 | 0) < (g2 | 0));
        }
        b2[e3 >> 2] = f2;
        b2[e3 + 4 >> 2] = a3;
        e3 = 0;
        return e3 | 0;
      }
      function Jb(a3, c3, d3, e3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0;
        g2 = Td(a3 | 0, c3 | 0, 52) | 0;
        H() | 0;
        g2 = g2 & 15;
        if (!((d3 | 0) < 16 & (g2 | 0) <= (d3 | 0))) {
          e3 = 4;
          return e3 | 0;
        }
        f2 = d3 - g2 | 0;
        d3 = Td(a3 | 0, c3 | 0, 45) | 0;
        H() | 0;
        a: do {
          if (!(oa(d3 & 127) | 0)) {
            d3 = Rc(7, 0, f2, ((f2 | 0) < 0) << 31 >> 31) | 0;
            f2 = H() | 0;
          } else {
            b: do {
              if (g2 | 0) {
                d3 = 1;
                while (1) {
                  h = Ud(7, 0, (15 - d3 | 0) * 3 | 0) | 0;
                  if (!((h & a3 | 0) == 0 & ((H() | 0) & c3 | 0) == 0)) {
                    break;
                  }
                  if (d3 >>> 0 < g2 >>> 0) {
                    d3 = d3 + 1 | 0;
                  } else {
                    break b;
                  }
                }
                d3 = Rc(7, 0, f2, ((f2 | 0) < 0) << 31 >> 31) | 0;
                f2 = H() | 0;
                break a;
              }
            } while (0);
            d3 = Rc(7, 0, f2, ((f2 | 0) < 0) << 31 >> 31) | 0;
            d3 = Pd(d3 | 0, H() | 0, 5, 0) | 0;
            d3 = Jd(d3 | 0, H() | 0, -5, -1) | 0;
            d3 = Nd(d3 | 0, H() | 0, 6, 0) | 0;
            d3 = Jd(d3 | 0, H() | 0, 1, 0) | 0;
            f2 = H() | 0;
          }
        } while (0);
        h = e3;
        b2[h >> 2] = d3;
        b2[h + 4 >> 2] = f2;
        h = 0;
        return h | 0;
      }
      function Kb(a3, b3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        var c3 = 0, d3 = 0, e3 = 0;
        e3 = Td(a3 | 0, b3 | 0, 45) | 0;
        H() | 0;
        if (!(oa(e3 & 127) | 0)) {
          e3 = 0;
          return e3 | 0;
        }
        e3 = Td(a3 | 0, b3 | 0, 52) | 0;
        H() | 0;
        e3 = e3 & 15;
        a: do {
          if (!e3) {
            c3 = 0;
          } else {
            d3 = 1;
            while (1) {
              c3 = Td(a3 | 0, b3 | 0, (15 - d3 | 0) * 3 | 0) | 0;
              H() | 0;
              c3 = c3 & 7;
              if (c3 | 0) {
                break a;
              }
              if (d3 >>> 0 < e3 >>> 0) {
                d3 = d3 + 1 | 0;
              } else {
                c3 = 0;
                break;
              }
            }
          }
        } while (0);
        e3 = (c3 | 0) == 0 & 1;
        return e3 | 0;
      }
      function Lb(a3, c3, d3, e3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0;
        h = T;
        T = T + 16 | 0;
        g2 = h;
        ic(g2, a3, c3, d3);
        c3 = g2;
        a3 = b2[c3 >> 2] | 0;
        c3 = b2[c3 + 4 >> 2] | 0;
        if ((a3 | 0) == 0 & (c3 | 0) == 0) {
          T = h;
          return 0;
        }
        f2 = 0;
        d3 = 0;
        do {
          i = e3 + (f2 << 3) | 0;
          b2[i >> 2] = a3;
          b2[i + 4 >> 2] = c3;
          f2 = Jd(f2 | 0, d3 | 0, 1, 0) | 0;
          d3 = H() | 0;
          kc(g2);
          i = g2;
          a3 = b2[i >> 2] | 0;
          c3 = b2[i + 4 >> 2] | 0;
        } while (!((a3 | 0) == 0 & (c3 | 0) == 0));
        T = h;
        return 0;
      }
      function Mb(a3, b3, c3, d3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        if ((d3 | 0) < (c3 | 0)) {
          c3 = b3;
          d3 = a3;
          G2(c3 | 0);
          return d3 | 0;
        }
        c3 = Ud(-1, -1, ((d3 - c3 | 0) * 3 | 0) + 3 | 0) | 0;
        d3 = Ud(~c3 | 0, ~(H() | 0) | 0, (15 - d3 | 0) * 3 | 0) | 0;
        c3 = ~(H() | 0) & b3;
        d3 = ~d3 & a3;
        G2(c3 | 0);
        return d3 | 0;
      }
      function Nb(a3, c3, d3, e3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0;
        f2 = Td(a3 | 0, c3 | 0, 52) | 0;
        H() | 0;
        f2 = f2 & 15;
        if (!((d3 | 0) < 16 & (f2 | 0) <= (d3 | 0))) {
          e3 = 4;
          return e3 | 0;
        }
        if ((f2 | 0) < (d3 | 0)) {
          f2 = Ud(-1, -1, ((d3 + -1 - f2 | 0) * 3 | 0) + 3 | 0) | 0;
          f2 = Ud(~f2 | 0, ~(H() | 0) | 0, (15 - d3 | 0) * 3 | 0) | 0;
          c3 = ~(H() | 0) & c3;
          a3 = ~f2 & a3;
        }
        f2 = Ud(d3 | 0, 0, 52) | 0;
        d3 = c3 & -15728641 | (H() | 0);
        b2[e3 >> 2] = a3 | f2;
        b2[e3 + 4 >> 2] = d3;
        e3 = 0;
        return e3 | 0;
      }
      function Ob(a3, c3, d3, e3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t2 = 0, u3 = 0, v3 = 0, w3 = 0, x2 = 0, y2 = 0, z2 = 0, A3 = 0, B3 = 0, C3 = 0, D3 = 0, E3 = 0;
        if ((d3 | 0) == 0 & (e3 | 0) == 0) {
          E3 = 0;
          return E3 | 0;
        }
        f2 = a3;
        g2 = b2[f2 >> 2] | 0;
        f2 = b2[f2 + 4 >> 2] | 0;
        if (true & (f2 & 15728640 | 0) == 0) {
          if (!((e3 | 0) > 0 | (e3 | 0) == 0 & d3 >>> 0 > 0)) {
            E3 = 0;
            return E3 | 0;
          }
          E3 = c3;
          b2[E3 >> 2] = g2;
          b2[E3 + 4 >> 2] = f2;
          if ((d3 | 0) == 1 & (e3 | 0) == 0) {
            E3 = 0;
            return E3 | 0;
          }
          f2 = 1;
          g2 = 0;
          do {
            C3 = a3 + (f2 << 3) | 0;
            D3 = b2[C3 + 4 >> 2] | 0;
            E3 = c3 + (f2 << 3) | 0;
            b2[E3 >> 2] = b2[C3 >> 2];
            b2[E3 + 4 >> 2] = D3;
            f2 = Jd(f2 | 0, g2 | 0, 1, 0) | 0;
            g2 = H() | 0;
          } while ((g2 | 0) < (e3 | 0) | (g2 | 0) == (e3 | 0) & f2 >>> 0 < d3 >>> 0);
          f2 = 0;
          return f2 | 0;
        }
        B3 = d3 << 3;
        D3 = Gd(B3) | 0;
        if (!D3) {
          E3 = 13;
          return E3 | 0;
        }
        Zd(D3 | 0, a3 | 0, B3 | 0) | 0;
        C3 = Id(d3, 8) | 0;
        if (!C3) {
          Hd(D3);
          E3 = 13;
          return E3 | 0;
        }
        a: while (1) {
          f2 = D3;
          k = b2[f2 >> 2] | 0;
          f2 = b2[f2 + 4 >> 2] | 0;
          z2 = Td(k | 0, f2 | 0, 52) | 0;
          H() | 0;
          z2 = z2 & 15;
          A3 = z2 + -1 | 0;
          y2 = (z2 | 0) != 0;
          x2 = (e3 | 0) > 0 | (e3 | 0) == 0 & d3 >>> 0 > 0;
          b: do {
            if (y2 & x2) {
              t2 = Ud(A3 | 0, 0, 52) | 0;
              u3 = H() | 0;
              if (A3 >>> 0 > 15) {
                if (!((k | 0) == 0 & (f2 | 0) == 0)) {
                  E3 = 16;
                  break a;
                }
                g2 = 0;
                a3 = 0;
                while (1) {
                  g2 = Jd(g2 | 0, a3 | 0, 1, 0) | 0;
                  a3 = H() | 0;
                  if (!((a3 | 0) < (e3 | 0) | (a3 | 0) == (e3 | 0) & g2 >>> 0 < d3 >>> 0)) {
                    break b;
                  }
                  h = D3 + (g2 << 3) | 0;
                  w3 = b2[h >> 2] | 0;
                  h = b2[h + 4 >> 2] | 0;
                  if (!((w3 | 0) == 0 & (h | 0) == 0)) {
                    f2 = h;
                    E3 = 16;
                    break a;
                  }
                }
              }
              i = k;
              a3 = f2;
              g2 = 0;
              h = 0;
              while (1) {
                if (!((i | 0) == 0 & (a3 | 0) == 0)) {
                  if (!(true & (a3 & 117440512 | 0) == 0)) {
                    E3 = 21;
                    break a;
                  }
                  l = Td(i | 0, a3 | 0, 52) | 0;
                  H() | 0;
                  l = l & 15;
                  if ((l | 0) < (A3 | 0)) {
                    f2 = 12;
                    E3 = 27;
                    break a;
                  }
                  if ((l | 0) != (A3 | 0)) {
                    i = i | t2;
                    a3 = a3 & -15728641 | u3;
                    if (l >>> 0 >= z2 >>> 0) {
                      j = A3;
                      do {
                        w3 = Ud(7, 0, (14 - j | 0) * 3 | 0) | 0;
                        j = j + 1 | 0;
                        i = w3 | i;
                        a3 = H() | 0 | a3;
                      } while (j >>> 0 < l >>> 0);
                    }
                  }
                  n = Rd(i | 0, a3 | 0, d3 | 0, e3 | 0) | 0;
                  o = H() | 0;
                  j = C3 + (n << 3) | 0;
                  l = j;
                  m = b2[l >> 2] | 0;
                  l = b2[l + 4 >> 2] | 0;
                  if (!((m | 0) == 0 & (l | 0) == 0)) {
                    r2 = 0;
                    s2 = 0;
                    do {
                      if ((r2 | 0) > (e3 | 0) | (r2 | 0) == (e3 | 0) & s2 >>> 0 > d3 >>> 0) {
                        E3 = 31;
                        break a;
                      }
                      if ((m | 0) == (i | 0) & (l & -117440513 | 0) == (a3 | 0)) {
                        p2 = Td(m | 0, l | 0, 56) | 0;
                        H() | 0;
                        p2 = p2 & 7;
                        q2 = p2 + 1 | 0;
                        w3 = Td(m | 0, l | 0, 45) | 0;
                        H() | 0;
                        c: do {
                          if (!(oa(w3 & 127) | 0)) {
                            l = 7;
                          } else {
                            m = Td(m | 0, l | 0, 52) | 0;
                            H() | 0;
                            m = m & 15;
                            if (!m) {
                              l = 6;
                              break;
                            }
                            l = 1;
                            while (1) {
                              w3 = Ud(7, 0, (15 - l | 0) * 3 | 0) | 0;
                              if (!((w3 & i | 0) == 0 & ((H() | 0) & a3 | 0) == 0)) {
                                l = 7;
                                break c;
                              }
                              if (l >>> 0 < m >>> 0) {
                                l = l + 1 | 0;
                              } else {
                                l = 6;
                                break;
                              }
                            }
                          }
                        } while (0);
                        if ((p2 + 2 | 0) >>> 0 > l >>> 0) {
                          E3 = 41;
                          break a;
                        }
                        w3 = Ud(q2 | 0, 0, 56) | 0;
                        a3 = H() | 0 | a3 & -117440513;
                        v3 = j;
                        b2[v3 >> 2] = 0;
                        b2[v3 + 4 >> 2] = 0;
                        i = w3 | i;
                      } else {
                        n = Jd(n | 0, o | 0, 1, 0) | 0;
                        n = Qd(n | 0, H() | 0, d3 | 0, e3 | 0) | 0;
                        o = H() | 0;
                      }
                      s2 = Jd(s2 | 0, r2 | 0, 1, 0) | 0;
                      r2 = H() | 0;
                      j = C3 + (n << 3) | 0;
                      l = j;
                      m = b2[l >> 2] | 0;
                      l = b2[l + 4 >> 2] | 0;
                    } while (!((m | 0) == 0 & (l | 0) == 0));
                  }
                  w3 = j;
                  b2[w3 >> 2] = i;
                  b2[w3 + 4 >> 2] = a3;
                }
                g2 = Jd(g2 | 0, h | 0, 1, 0) | 0;
                h = H() | 0;
                if (!((h | 0) < (e3 | 0) | (h | 0) == (e3 | 0) & g2 >>> 0 < d3 >>> 0)) {
                  break b;
                }
                a3 = D3 + (g2 << 3) | 0;
                i = b2[a3 >> 2] | 0;
                a3 = b2[a3 + 4 >> 2] | 0;
              }
            }
          } while (0);
          w3 = Jd(d3 | 0, e3 | 0, 5, 0) | 0;
          v3 = H() | 0;
          if (v3 >>> 0 < 0 | (v3 | 0) == 0 & w3 >>> 0 < 11) {
            E3 = 85;
            break;
          }
          w3 = Nd(d3 | 0, e3 | 0, 6, 0) | 0;
          H() | 0;
          w3 = Id(w3, 8) | 0;
          if (!w3) {
            E3 = 48;
            break;
          }
          do {
            if (x2) {
              q2 = 0;
              a3 = 0;
              p2 = 0;
              r2 = 0;
              while (1) {
                l = C3 + (q2 << 3) | 0;
                h = l;
                g2 = b2[h >> 2] | 0;
                h = b2[h + 4 >> 2] | 0;
                if (!((g2 | 0) == 0 & (h | 0) == 0)) {
                  m = Td(g2 | 0, h | 0, 56) | 0;
                  H() | 0;
                  m = m & 7;
                  i = m + 1 | 0;
                  n = h & -117440513;
                  v3 = Td(g2 | 0, h | 0, 45) | 0;
                  H() | 0;
                  d: do {
                    if (oa(v3 & 127) | 0) {
                      o = Td(g2 | 0, h | 0, 52) | 0;
                      H() | 0;
                      o = o & 15;
                      if (o | 0) {
                        j = 1;
                        while (1) {
                          v3 = Ud(7, 0, (15 - j | 0) * 3 | 0) | 0;
                          if (!((g2 & v3 | 0) == 0 & (n & (H() | 0) | 0) == 0)) {
                            break d;
                          }
                          if (j >>> 0 < o >>> 0) {
                            j = j + 1 | 0;
                          } else {
                            break;
                          }
                        }
                      }
                      h = Ud(i | 0, 0, 56) | 0;
                      g2 = h | g2;
                      h = H() | 0 | n;
                      i = l;
                      b2[i >> 2] = g2;
                      b2[i + 4 >> 2] = h;
                      i = m + 2 | 0;
                    }
                  } while (0);
                  if ((i | 0) == 7) {
                    v3 = w3 + (a3 << 3) | 0;
                    b2[v3 >> 2] = g2;
                    b2[v3 + 4 >> 2] = h & -117440513;
                    a3 = Jd(a3 | 0, p2 | 0, 1, 0) | 0;
                    v3 = H() | 0;
                  } else {
                    v3 = p2;
                  }
                } else {
                  v3 = p2;
                }
                q2 = Jd(q2 | 0, r2 | 0, 1, 0) | 0;
                r2 = H() | 0;
                if (!((r2 | 0) < (e3 | 0) | (r2 | 0) == (e3 | 0) & q2 >>> 0 < d3 >>> 0)) {
                  break;
                } else {
                  p2 = v3;
                }
              }
              if (x2) {
                s2 = A3 >>> 0 > 15;
                t2 = Ud(A3 | 0, 0, 52) | 0;
                u3 = H() | 0;
                if (!y2) {
                  g2 = 0;
                  j = 0;
                  i = 0;
                  h = 0;
                  while (1) {
                    if (!((k | 0) == 0 & (f2 | 0) == 0)) {
                      A3 = c3 + (g2 << 3) | 0;
                      b2[A3 >> 2] = k;
                      b2[A3 + 4 >> 2] = f2;
                      g2 = Jd(g2 | 0, j | 0, 1, 0) | 0;
                      j = H() | 0;
                    }
                    i = Jd(i | 0, h | 0, 1, 0) | 0;
                    h = H() | 0;
                    if (!((h | 0) < (e3 | 0) | (h | 0) == (e3 | 0) & i >>> 0 < d3 >>> 0)) {
                      break;
                    }
                    f2 = D3 + (i << 3) | 0;
                    k = b2[f2 >> 2] | 0;
                    f2 = b2[f2 + 4 >> 2] | 0;
                  }
                  f2 = v3;
                  break;
                }
                g2 = 0;
                j = 0;
                h = 0;
                i = 0;
                while (1) {
                  do {
                    if (!((k | 0) == 0 & (f2 | 0) == 0)) {
                      o = Td(k | 0, f2 | 0, 52) | 0;
                      H() | 0;
                      o = o & 15;
                      if (s2 | (o | 0) < (A3 | 0)) {
                        E3 = 80;
                        break a;
                      }
                      if ((o | 0) != (A3 | 0)) {
                        l = k | t2;
                        m = f2 & -15728641 | u3;
                        if (o >>> 0 >= z2 >>> 0) {
                          n = A3;
                          do {
                            y2 = Ud(7, 0, (14 - n | 0) * 3 | 0) | 0;
                            n = n + 1 | 0;
                            l = y2 | l;
                            m = H() | 0 | m;
                          } while (n >>> 0 < o >>> 0);
                        }
                      } else {
                        l = k;
                        m = f2;
                      }
                      p2 = Rd(l | 0, m | 0, d3 | 0, e3 | 0) | 0;
                      n = 0;
                      o = 0;
                      r2 = H() | 0;
                      do {
                        if ((n | 0) > (e3 | 0) | (n | 0) == (e3 | 0) & o >>> 0 > d3 >>> 0) {
                          E3 = 81;
                          break a;
                        }
                        y2 = C3 + (p2 << 3) | 0;
                        q2 = b2[y2 + 4 >> 2] | 0;
                        if ((q2 & -117440513 | 0) == (m | 0) ? (b2[y2 >> 2] | 0) == (l | 0) : 0) {
                          E3 = 65;
                          break;
                        }
                        y2 = Jd(p2 | 0, r2 | 0, 1, 0) | 0;
                        p2 = Qd(y2 | 0, H() | 0, d3 | 0, e3 | 0) | 0;
                        r2 = H() | 0;
                        o = Jd(o | 0, n | 0, 1, 0) | 0;
                        n = H() | 0;
                        y2 = C3 + (p2 << 3) | 0;
                      } while (!((b2[y2 >> 2] | 0) == (l | 0) ? (b2[y2 + 4 >> 2] | 0) == (m | 0) : 0));
                      if ((E3 | 0) == 65 ? (E3 = 0, true & (q2 & 117440512 | 0) == 100663296) : 0) {
                        break;
                      }
                      y2 = c3 + (g2 << 3) | 0;
                      b2[y2 >> 2] = k;
                      b2[y2 + 4 >> 2] = f2;
                      g2 = Jd(g2 | 0, j | 0, 1, 0) | 0;
                      j = H() | 0;
                    }
                  } while (0);
                  h = Jd(h | 0, i | 0, 1, 0) | 0;
                  i = H() | 0;
                  if (!((i | 0) < (e3 | 0) | (i | 0) == (e3 | 0) & h >>> 0 < d3 >>> 0)) {
                    break;
                  }
                  f2 = D3 + (h << 3) | 0;
                  k = b2[f2 >> 2] | 0;
                  f2 = b2[f2 + 4 >> 2] | 0;
                }
                f2 = v3;
              } else {
                g2 = 0;
                f2 = v3;
              }
            } else {
              g2 = 0;
              a3 = 0;
              f2 = 0;
            }
          } while (0);
          _d(C3 | 0, 0, B3 | 0) | 0;
          Zd(D3 | 0, w3 | 0, a3 << 3 | 0) | 0;
          Hd(w3);
          if ((a3 | 0) == 0 & (f2 | 0) == 0) {
            E3 = 89;
            break;
          } else {
            c3 = c3 + (g2 << 3) | 0;
            e3 = f2;
            d3 = a3;
          }
        }
        if ((E3 | 0) == 16) {
          if (true & (f2 & 117440512 | 0) == 0) {
            f2 = 4;
            E3 = 27;
          } else {
            E3 = 21;
          }
        } else if ((E3 | 0) == 31) {
          I(27795, 27122, 620, 27132);
        } else if ((E3 | 0) == 41) {
          Hd(D3);
          Hd(C3);
          E3 = 10;
          return E3 | 0;
        } else if ((E3 | 0) == 48) {
          Hd(D3);
          Hd(C3);
          E3 = 13;
          return E3 | 0;
        } else if ((E3 | 0) == 80) {
          I(27795, 27122, 711, 27132);
        } else if ((E3 | 0) == 81) {
          I(27795, 27122, 723, 27132);
        } else if ((E3 | 0) == 85) {
          Zd(c3 | 0, D3 | 0, d3 << 3 | 0) | 0;
          E3 = 89;
        }
        if ((E3 | 0) == 21) {
          Hd(D3);
          Hd(C3);
          E3 = 5;
          return E3 | 0;
        } else if ((E3 | 0) == 27) {
          Hd(D3);
          Hd(C3);
          E3 = f2;
          return E3 | 0;
        } else if ((E3 | 0) == 89) {
          Hd(D3);
          Hd(C3);
          E3 = 0;
          return E3 | 0;
        }
        return 0;
      }
      function Pb(a3, c3, d3, e3, f2, g2, h) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        h = h | 0;
        var i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0;
        q2 = T;
        T = T + 16 | 0;
        p2 = q2;
        if (!((d3 | 0) > 0 | (d3 | 0) == 0 & c3 >>> 0 > 0)) {
          p2 = 0;
          T = q2;
          return p2 | 0;
        }
        if ((h | 0) >= 16) {
          p2 = 12;
          T = q2;
          return p2 | 0;
        }
        n = 0;
        o = 0;
        m = 0;
        i = 0;
        a: while (1) {
          k = a3 + (n << 3) | 0;
          j = b2[k >> 2] | 0;
          k = b2[k + 4 >> 2] | 0;
          l = Td(j | 0, k | 0, 52) | 0;
          H() | 0;
          if ((l & 15 | 0) > (h | 0)) {
            i = 12;
            j = 11;
            break;
          }
          ic(p2, j, k, h);
          l = p2;
          k = b2[l >> 2] | 0;
          l = b2[l + 4 >> 2] | 0;
          if ((k | 0) == 0 & (l | 0) == 0) {
            j = m;
          } else {
            j = m;
            do {
              if (!((i | 0) < (g2 | 0) | (i | 0) == (g2 | 0) & j >>> 0 < f2 >>> 0)) {
                j = 10;
                break a;
              }
              m = e3 + (j << 3) | 0;
              b2[m >> 2] = k;
              b2[m + 4 >> 2] = l;
              j = Jd(j | 0, i | 0, 1, 0) | 0;
              i = H() | 0;
              kc(p2);
              m = p2;
              k = b2[m >> 2] | 0;
              l = b2[m + 4 >> 2] | 0;
            } while (!((k | 0) == 0 & (l | 0) == 0));
          }
          n = Jd(n | 0, o | 0, 1, 0) | 0;
          o = H() | 0;
          if (!((o | 0) < (d3 | 0) | (o | 0) == (d3 | 0) & n >>> 0 < c3 >>> 0)) {
            i = 0;
            j = 11;
            break;
          } else {
            m = j;
          }
        }
        if ((j | 0) == 10) {
          p2 = 14;
          T = q2;
          return p2 | 0;
        } else if ((j | 0) == 11) {
          T = q2;
          return i | 0;
        }
        return 0;
      }
      function Qb(a3, c3, d3, e3, f2) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0;
        n = T;
        T = T + 16 | 0;
        m = n;
        a: do {
          if ((d3 | 0) > 0 | (d3 | 0) == 0 & c3 >>> 0 > 0) {
            k = 0;
            h = 0;
            g2 = 0;
            l = 0;
            while (1) {
              j = a3 + (k << 3) | 0;
              i = b2[j >> 2] | 0;
              j = b2[j + 4 >> 2] | 0;
              if (!((i | 0) == 0 & (j | 0) == 0)) {
                j = (Jb(i, j, e3, m) | 0) == 0;
                i = m;
                h = Jd(b2[i >> 2] | 0, b2[i + 4 >> 2] | 0, h | 0, g2 | 0) | 0;
                g2 = H() | 0;
                if (!j) {
                  g2 = 12;
                  break;
                }
              }
              k = Jd(k | 0, l | 0, 1, 0) | 0;
              l = H() | 0;
              if (!((l | 0) < (d3 | 0) | (l | 0) == (d3 | 0) & k >>> 0 < c3 >>> 0)) {
                break a;
              }
            }
            T = n;
            return g2 | 0;
          } else {
            h = 0;
            g2 = 0;
          }
        } while (0);
        b2[f2 >> 2] = h;
        b2[f2 + 4 >> 2] = g2;
        f2 = 0;
        T = n;
        return f2 | 0;
      }
      function Rb(a3, b3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        b3 = Td(a3 | 0, b3 | 0, 52) | 0;
        H() | 0;
        return b3 & 1 | 0;
      }
      function Sb(a3, b3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        var c3 = 0, d3 = 0, e3 = 0;
        e3 = Td(a3 | 0, b3 | 0, 52) | 0;
        H() | 0;
        e3 = e3 & 15;
        if (!e3) {
          e3 = 0;
          return e3 | 0;
        }
        d3 = 1;
        while (1) {
          c3 = Td(a3 | 0, b3 | 0, (15 - d3 | 0) * 3 | 0) | 0;
          H() | 0;
          c3 = c3 & 7;
          if (c3 | 0) {
            d3 = 5;
            break;
          }
          if (d3 >>> 0 < e3 >>> 0) {
            d3 = d3 + 1 | 0;
          } else {
            c3 = 0;
            d3 = 5;
            break;
          }
        }
        if ((d3 | 0) == 5) {
          return c3 | 0;
        }
        return 0;
      }
      function Tb(a3, b3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        i = Td(a3 | 0, b3 | 0, 52) | 0;
        H() | 0;
        i = i & 15;
        if (!i) {
          h = b3;
          i = a3;
          G2(h | 0);
          return i | 0;
        }
        h = 1;
        c3 = 0;
        while (1) {
          f2 = (15 - h | 0) * 3 | 0;
          d3 = Ud(7, 0, f2 | 0) | 0;
          e3 = H() | 0;
          g2 = Td(a3 | 0, b3 | 0, f2 | 0) | 0;
          H() | 0;
          f2 = Ud($a(g2 & 7) | 0, 0, f2 | 0) | 0;
          g2 = H() | 0;
          a3 = f2 | a3 & ~d3;
          b3 = g2 | b3 & ~e3;
          a: do {
            if (!c3) {
              if (!((f2 & d3 | 0) == 0 & (g2 & e3 | 0) == 0)) {
                d3 = Td(a3 | 0, b3 | 0, 52) | 0;
                H() | 0;
                d3 = d3 & 15;
                if (!d3) {
                  c3 = 1;
                } else {
                  c3 = 1;
                  b: while (1) {
                    g2 = Td(a3 | 0, b3 | 0, (15 - c3 | 0) * 3 | 0) | 0;
                    H() | 0;
                    switch (g2 & 7) {
                      case 1:
                        break b;
                      case 0:
                        break;
                      default: {
                        c3 = 1;
                        break a;
                      }
                    }
                    if (c3 >>> 0 < d3 >>> 0) {
                      c3 = c3 + 1 | 0;
                    } else {
                      c3 = 1;
                      break a;
                    }
                  }
                  c3 = 1;
                  while (1) {
                    g2 = (15 - c3 | 0) * 3 | 0;
                    e3 = Td(a3 | 0, b3 | 0, g2 | 0) | 0;
                    H() | 0;
                    f2 = Ud(7, 0, g2 | 0) | 0;
                    b3 = b3 & ~(H() | 0);
                    g2 = Ud($a(e3 & 7) | 0, 0, g2 | 0) | 0;
                    a3 = a3 & ~f2 | g2;
                    b3 = b3 | (H() | 0);
                    if (c3 >>> 0 < d3 >>> 0) {
                      c3 = c3 + 1 | 0;
                    } else {
                      c3 = 1;
                      break;
                    }
                  }
                }
              } else {
                c3 = 0;
              }
            }
          } while (0);
          if (h >>> 0 < i >>> 0) {
            h = h + 1 | 0;
          } else {
            break;
          }
        }
        G2(b3 | 0);
        return a3 | 0;
      }
      function Ub(a3, b3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0, g2 = 0;
        d3 = Td(a3 | 0, b3 | 0, 52) | 0;
        H() | 0;
        d3 = d3 & 15;
        if (!d3) {
          c3 = b3;
          d3 = a3;
          G2(c3 | 0);
          return d3 | 0;
        }
        c3 = 1;
        while (1) {
          f2 = (15 - c3 | 0) * 3 | 0;
          g2 = Td(a3 | 0, b3 | 0, f2 | 0) | 0;
          H() | 0;
          e3 = Ud(7, 0, f2 | 0) | 0;
          b3 = b3 & ~(H() | 0);
          f2 = Ud($a(g2 & 7) | 0, 0, f2 | 0) | 0;
          a3 = f2 | a3 & ~e3;
          b3 = H() | 0 | b3;
          if (c3 >>> 0 < d3 >>> 0) {
            c3 = c3 + 1 | 0;
          } else {
            break;
          }
        }
        G2(b3 | 0);
        return a3 | 0;
      }
      function Vb(a3, b3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        i = Td(a3 | 0, b3 | 0, 52) | 0;
        H() | 0;
        i = i & 15;
        if (!i) {
          h = b3;
          i = a3;
          G2(h | 0);
          return i | 0;
        }
        h = 1;
        c3 = 0;
        while (1) {
          f2 = (15 - h | 0) * 3 | 0;
          d3 = Ud(7, 0, f2 | 0) | 0;
          e3 = H() | 0;
          g2 = Td(a3 | 0, b3 | 0, f2 | 0) | 0;
          H() | 0;
          f2 = Ud(ab(g2 & 7) | 0, 0, f2 | 0) | 0;
          g2 = H() | 0;
          a3 = f2 | a3 & ~d3;
          b3 = g2 | b3 & ~e3;
          a: do {
            if (!c3) {
              if (!((f2 & d3 | 0) == 0 & (g2 & e3 | 0) == 0)) {
                d3 = Td(a3 | 0, b3 | 0, 52) | 0;
                H() | 0;
                d3 = d3 & 15;
                if (!d3) {
                  c3 = 1;
                } else {
                  c3 = 1;
                  b: while (1) {
                    g2 = Td(a3 | 0, b3 | 0, (15 - c3 | 0) * 3 | 0) | 0;
                    H() | 0;
                    switch (g2 & 7) {
                      case 1:
                        break b;
                      case 0:
                        break;
                      default: {
                        c3 = 1;
                        break a;
                      }
                    }
                    if (c3 >>> 0 < d3 >>> 0) {
                      c3 = c3 + 1 | 0;
                    } else {
                      c3 = 1;
                      break a;
                    }
                  }
                  c3 = 1;
                  while (1) {
                    e3 = (15 - c3 | 0) * 3 | 0;
                    f2 = Ud(7, 0, e3 | 0) | 0;
                    g2 = b3 & ~(H() | 0);
                    b3 = Td(a3 | 0, b3 | 0, e3 | 0) | 0;
                    H() | 0;
                    b3 = Ud(ab(b3 & 7) | 0, 0, e3 | 0) | 0;
                    a3 = a3 & ~f2 | b3;
                    b3 = g2 | (H() | 0);
                    if (c3 >>> 0 < d3 >>> 0) {
                      c3 = c3 + 1 | 0;
                    } else {
                      c3 = 1;
                      break;
                    }
                  }
                }
              } else {
                c3 = 0;
              }
            }
          } while (0);
          if (h >>> 0 < i >>> 0) {
            h = h + 1 | 0;
          } else {
            break;
          }
        }
        G2(b3 | 0);
        return a3 | 0;
      }
      function Wb(a3, b3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0, g2 = 0;
        d3 = Td(a3 | 0, b3 | 0, 52) | 0;
        H() | 0;
        d3 = d3 & 15;
        if (!d3) {
          c3 = b3;
          d3 = a3;
          G2(c3 | 0);
          return d3 | 0;
        }
        c3 = 1;
        while (1) {
          g2 = (15 - c3 | 0) * 3 | 0;
          f2 = Ud(7, 0, g2 | 0) | 0;
          e3 = b3 & ~(H() | 0);
          b3 = Td(a3 | 0, b3 | 0, g2 | 0) | 0;
          H() | 0;
          b3 = Ud(ab(b3 & 7) | 0, 0, g2 | 0) | 0;
          a3 = b3 | a3 & ~f2;
          b3 = H() | 0 | e3;
          if (c3 >>> 0 < d3 >>> 0) {
            c3 = c3 + 1 | 0;
          } else {
            break;
          }
        }
        G2(b3 | 0);
        return a3 | 0;
      }
      function Xb(a3, c3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        var d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0;
        j = T;
        T = T + 64 | 0;
        i = j + 40 | 0;
        e3 = j + 24 | 0;
        f2 = j + 12 | 0;
        g2 = j;
        Ud(c3 | 0, 0, 52) | 0;
        d3 = H() | 0 | 134225919;
        if (!c3) {
          if ((b2[a3 + 4 >> 2] | 0) > 2) {
            h = 0;
            i = 0;
            G2(h | 0);
            T = j;
            return i | 0;
          }
          if ((b2[a3 + 8 >> 2] | 0) > 2) {
            h = 0;
            i = 0;
            G2(h | 0);
            T = j;
            return i | 0;
          }
          if ((b2[a3 + 12 >> 2] | 0) > 2) {
            h = 0;
            i = 0;
            G2(h | 0);
            T = j;
            return i | 0;
          }
          Ud(qa(a3) | 0, 0, 45) | 0;
          h = H() | 0 | d3;
          i = -1;
          G2(h | 0);
          T = j;
          return i | 0;
        }
        b2[i >> 2] = b2[a3 >> 2];
        b2[i + 4 >> 2] = b2[a3 + 4 >> 2];
        b2[i + 8 >> 2] = b2[a3 + 8 >> 2];
        b2[i + 12 >> 2] = b2[a3 + 12 >> 2];
        h = i + 4 | 0;
        if ((c3 | 0) > 0) {
          a3 = -1;
          while (1) {
            b2[e3 >> 2] = b2[h >> 2];
            b2[e3 + 4 >> 2] = b2[h + 4 >> 2];
            b2[e3 + 8 >> 2] = b2[h + 8 >> 2];
            if (!(c3 & 1)) {
              Va(h);
              b2[f2 >> 2] = b2[h >> 2];
              b2[f2 + 4 >> 2] = b2[h + 4 >> 2];
              b2[f2 + 8 >> 2] = b2[h + 8 >> 2];
              Xa(f2);
            } else {
              Ua(h);
              b2[f2 >> 2] = b2[h >> 2];
              b2[f2 + 4 >> 2] = b2[h + 4 >> 2];
              b2[f2 + 8 >> 2] = b2[h + 8 >> 2];
              Wa(f2);
            }
            Pa(e3, f2, g2);
            Ma(g2);
            l = (15 - c3 | 0) * 3 | 0;
            k = Ud(7, 0, l | 0) | 0;
            d3 = d3 & ~(H() | 0);
            l = Ud(Ra(g2) | 0, 0, l | 0) | 0;
            a3 = l | a3 & ~k;
            d3 = H() | 0 | d3;
            if ((c3 | 0) > 1) {
              c3 = c3 + -1 | 0;
            } else {
              break;
            }
          }
        } else {
          a3 = -1;
        }
        a: do {
          if (((b2[h >> 2] | 0) <= 2 ? (b2[i + 8 >> 2] | 0) <= 2 : 0) ? (b2[i + 12 >> 2] | 0) <= 2 : 0) {
            e3 = qa(i) | 0;
            c3 = Ud(e3 | 0, 0, 45) | 0;
            c3 = c3 | a3;
            a3 = H() | 0 | d3 & -1040385;
            g2 = ra(i) | 0;
            if (!(oa(e3) | 0)) {
              if ((g2 | 0) <= 0) {
                break;
              }
              f2 = 0;
              while (1) {
                e3 = Td(c3 | 0, a3 | 0, 52) | 0;
                H() | 0;
                e3 = e3 & 15;
                if (e3) {
                  d3 = 1;
                  while (1) {
                    l = (15 - d3 | 0) * 3 | 0;
                    i = Td(c3 | 0, a3 | 0, l | 0) | 0;
                    H() | 0;
                    k = Ud(7, 0, l | 0) | 0;
                    a3 = a3 & ~(H() | 0);
                    l = Ud($a(i & 7) | 0, 0, l | 0) | 0;
                    c3 = c3 & ~k | l;
                    a3 = a3 | (H() | 0);
                    if (d3 >>> 0 < e3 >>> 0) {
                      d3 = d3 + 1 | 0;
                    } else {
                      break;
                    }
                  }
                }
                f2 = f2 + 1 | 0;
                if ((f2 | 0) == (g2 | 0)) {
                  break a;
                }
              }
            }
            f2 = Td(c3 | 0, a3 | 0, 52) | 0;
            H() | 0;
            f2 = f2 & 15;
            b: do {
              if (f2) {
                d3 = 1;
                c: while (1) {
                  l = Td(c3 | 0, a3 | 0, (15 - d3 | 0) * 3 | 0) | 0;
                  H() | 0;
                  switch (l & 7) {
                    case 1:
                      break c;
                    case 0:
                      break;
                    default:
                      break b;
                  }
                  if (d3 >>> 0 < f2 >>> 0) {
                    d3 = d3 + 1 | 0;
                  } else {
                    break b;
                  }
                }
                if (ua(e3, b2[i >> 2] | 0) | 0) {
                  d3 = 1;
                  while (1) {
                    i = (15 - d3 | 0) * 3 | 0;
                    k = Ud(7, 0, i | 0) | 0;
                    l = a3 & ~(H() | 0);
                    a3 = Td(c3 | 0, a3 | 0, i | 0) | 0;
                    H() | 0;
                    a3 = Ud(ab(a3 & 7) | 0, 0, i | 0) | 0;
                    c3 = c3 & ~k | a3;
                    a3 = l | (H() | 0);
                    if (d3 >>> 0 < f2 >>> 0) {
                      d3 = d3 + 1 | 0;
                    } else {
                      break;
                    }
                  }
                } else {
                  d3 = 1;
                  while (1) {
                    l = (15 - d3 | 0) * 3 | 0;
                    i = Td(c3 | 0, a3 | 0, l | 0) | 0;
                    H() | 0;
                    k = Ud(7, 0, l | 0) | 0;
                    a3 = a3 & ~(H() | 0);
                    l = Ud($a(i & 7) | 0, 0, l | 0) | 0;
                    c3 = c3 & ~k | l;
                    a3 = a3 | (H() | 0);
                    if (d3 >>> 0 < f2 >>> 0) {
                      d3 = d3 + 1 | 0;
                    } else {
                      break;
                    }
                  }
                }
              }
            } while (0);
            if ((g2 | 0) > 0) {
              d3 = 0;
              do {
                c3 = Tb(c3, a3) | 0;
                a3 = H() | 0;
                d3 = d3 + 1 | 0;
              } while ((d3 | 0) != (g2 | 0));
            }
          } else {
            c3 = 0;
            a3 = 0;
          }
        } while (0);
        k = a3;
        l = c3;
        G2(k | 0);
        T = j;
        return l | 0;
      }
      function Yb(a3) {
        a3 = a3 | 0;
        return (a3 | 0) % 2 | 0 | 0;
      }
      function Zb(a3, c3, d3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0;
        f2 = T;
        T = T + 16 | 0;
        e3 = f2;
        if (c3 >>> 0 > 15) {
          e3 = 4;
          T = f2;
          return e3 | 0;
        }
        if ((b2[a3 + 4 >> 2] & 2146435072 | 0) == 2146435072) {
          e3 = 3;
          T = f2;
          return e3 | 0;
        }
        if ((b2[a3 + 8 + 4 >> 2] & 2146435072 | 0) == 2146435072) {
          e3 = 3;
          T = f2;
          return e3 | 0;
        }
        qb(a3, c3, e3);
        c3 = Xb(e3, c3) | 0;
        e3 = H() | 0;
        b2[d3 >> 2] = c3;
        b2[d3 + 4 >> 2] = e3;
        if ((c3 | 0) == 0 & (e3 | 0) == 0) {
          I(27795, 27122, 1050, 27145);
        }
        e3 = 0;
        T = f2;
        return e3 | 0;
      }
      function _b(a3, c3, d3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0, g2 = 0, h = 0;
        f2 = d3 + 4 | 0;
        g2 = Td(a3 | 0, c3 | 0, 52) | 0;
        H() | 0;
        g2 = g2 & 15;
        h = Td(a3 | 0, c3 | 0, 45) | 0;
        H() | 0;
        e3 = (g2 | 0) == 0;
        if (!(oa(h & 127) | 0)) {
          if (e3) {
            h = 0;
            return h | 0;
          }
          if ((b2[f2 >> 2] | 0) == 0 ? (b2[d3 + 8 >> 2] | 0) == 0 : 0) {
            e3 = (b2[d3 + 12 >> 2] | 0) != 0 & 1;
          } else {
            e3 = 1;
          }
        } else if (e3) {
          h = 1;
          return h | 0;
        } else {
          e3 = 1;
        }
        d3 = 1;
        while (1) {
          if (!(d3 & 1)) {
            Xa(f2);
          } else {
            Wa(f2);
          }
          h = Td(a3 | 0, c3 | 0, (15 - d3 | 0) * 3 | 0) | 0;
          H() | 0;
          Ya(f2, h & 7);
          if (d3 >>> 0 < g2 >>> 0) {
            d3 = d3 + 1 | 0;
          } else {
            break;
          }
        }
        return e3 | 0;
      }
      function $b(a3, c3, d3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0;
        l = T;
        T = T + 16 | 0;
        j = l;
        k = Td(a3 | 0, c3 | 0, 45) | 0;
        H() | 0;
        k = k & 127;
        if (k >>> 0 > 121) {
          b2[d3 >> 2] = 0;
          b2[d3 + 4 >> 2] = 0;
          b2[d3 + 8 >> 2] = 0;
          b2[d3 + 12 >> 2] = 0;
          k = 5;
          T = l;
          return k | 0;
        }
        a: do {
          if ((oa(k) | 0) != 0 ? (g2 = Td(a3 | 0, c3 | 0, 52) | 0, H() | 0, g2 = g2 & 15, (g2 | 0) != 0) : 0) {
            e3 = 1;
            b: while (1) {
              i = Td(a3 | 0, c3 | 0, (15 - e3 | 0) * 3 | 0) | 0;
              H() | 0;
              switch (i & 7) {
                case 5:
                  break b;
                case 0:
                  break;
                default: {
                  e3 = c3;
                  break a;
                }
              }
              if (e3 >>> 0 < g2 >>> 0) {
                e3 = e3 + 1 | 0;
              } else {
                e3 = c3;
                break a;
              }
            }
            f2 = 1;
            e3 = c3;
            while (1) {
              c3 = (15 - f2 | 0) * 3 | 0;
              h = Ud(7, 0, c3 | 0) | 0;
              i = e3 & ~(H() | 0);
              e3 = Td(a3 | 0, e3 | 0, c3 | 0) | 0;
              H() | 0;
              e3 = Ud(ab(e3 & 7) | 0, 0, c3 | 0) | 0;
              a3 = a3 & ~h | e3;
              e3 = i | (H() | 0);
              if (f2 >>> 0 < g2 >>> 0) {
                f2 = f2 + 1 | 0;
              } else {
                break;
              }
            }
          } else {
            e3 = c3;
          }
        } while (0);
        i = 7696 + (k * 28 | 0) | 0;
        b2[d3 >> 2] = b2[i >> 2];
        b2[d3 + 4 >> 2] = b2[i + 4 >> 2];
        b2[d3 + 8 >> 2] = b2[i + 8 >> 2];
        b2[d3 + 12 >> 2] = b2[i + 12 >> 2];
        if (!(_b(a3, e3, d3) | 0)) {
          k = 0;
          T = l;
          return k | 0;
        }
        h = d3 + 4 | 0;
        b2[j >> 2] = b2[h >> 2];
        b2[j + 4 >> 2] = b2[h + 4 >> 2];
        b2[j + 8 >> 2] = b2[h + 8 >> 2];
        g2 = Td(a3 | 0, e3 | 0, 52) | 0;
        H() | 0;
        i = g2 & 15;
        if (!(g2 & 1)) {
          g2 = i;
        } else {
          Xa(h);
          g2 = i + 1 | 0;
        }
        if (!(oa(k) | 0)) {
          e3 = 0;
        } else {
          c: do {
            if (!i) {
              e3 = 0;
            } else {
              c3 = 1;
              while (1) {
                f2 = Td(a3 | 0, e3 | 0, (15 - c3 | 0) * 3 | 0) | 0;
                H() | 0;
                f2 = f2 & 7;
                if (f2 | 0) {
                  e3 = f2;
                  break c;
                }
                if (c3 >>> 0 < i >>> 0) {
                  c3 = c3 + 1 | 0;
                } else {
                  e3 = 0;
                  break;
                }
              }
            }
          } while (0);
          e3 = (e3 | 0) == 4 & 1;
        }
        if (!(xb(d3, g2, e3, 0) | 0)) {
          if ((g2 | 0) != (i | 0)) {
            b2[h >> 2] = b2[j >> 2];
            b2[h + 4 >> 2] = b2[j + 4 >> 2];
            b2[h + 8 >> 2] = b2[j + 8 >> 2];
          }
        } else {
          if (oa(k) | 0) {
            do {
            } while ((xb(d3, g2, 0, 0) | 0) != 0);
          }
          if ((g2 | 0) != (i | 0)) {
            Va(h);
          }
        }
        k = 0;
        T = l;
        return k | 0;
      }
      function ac(a3, b3, c3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        c3 = c3 | 0;
        var d3 = 0, e3 = 0, f2 = 0;
        f2 = T;
        T = T + 16 | 0;
        d3 = f2;
        e3 = $b(a3, b3, d3) | 0;
        if (e3 | 0) {
          T = f2;
          return e3 | 0;
        }
        e3 = Td(a3 | 0, b3 | 0, 52) | 0;
        H() | 0;
        ub(d3, e3 & 15, c3);
        e3 = 0;
        T = f2;
        return e3 | 0;
      }
      function bc(a3, b3, c3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        c3 = c3 | 0;
        var d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0;
        g2 = T;
        T = T + 16 | 0;
        f2 = g2;
        d3 = $b(a3, b3, f2) | 0;
        if (d3 | 0) {
          f2 = d3;
          T = g2;
          return f2 | 0;
        }
        d3 = Td(a3 | 0, b3 | 0, 45) | 0;
        H() | 0;
        d3 = (oa(d3 & 127) | 0) == 0;
        e3 = Td(a3 | 0, b3 | 0, 52) | 0;
        H() | 0;
        e3 = e3 & 15;
        a: do {
          if (!d3) {
            if (e3 | 0) {
              d3 = 1;
              while (1) {
                h = Ud(7, 0, (15 - d3 | 0) * 3 | 0) | 0;
                if (!((h & a3 | 0) == 0 & ((H() | 0) & b3 | 0) == 0)) {
                  break a;
                }
                if (d3 >>> 0 < e3 >>> 0) {
                  d3 = d3 + 1 | 0;
                } else {
                  break;
                }
              }
            }
            vb(f2, e3, 0, 5, c3);
            h = 0;
            T = g2;
            return h | 0;
          }
        } while (0);
        zb(f2, e3, 0, 6, c3);
        h = 0;
        T = g2;
        return h | 0;
      }
      function cc(a3, c3, d3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0, g2 = 0;
        f2 = Td(a3 | 0, c3 | 0, 45) | 0;
        H() | 0;
        if (!(oa(f2 & 127) | 0)) {
          f2 = 2;
          b2[d3 >> 2] = f2;
          return 0;
        }
        f2 = Td(a3 | 0, c3 | 0, 52) | 0;
        H() | 0;
        f2 = f2 & 15;
        if (!f2) {
          f2 = 5;
          b2[d3 >> 2] = f2;
          return 0;
        }
        e3 = 1;
        while (1) {
          g2 = Ud(7, 0, (15 - e3 | 0) * 3 | 0) | 0;
          if (!((g2 & a3 | 0) == 0 & ((H() | 0) & c3 | 0) == 0)) {
            e3 = 2;
            a3 = 6;
            break;
          }
          if (e3 >>> 0 < f2 >>> 0) {
            e3 = e3 + 1 | 0;
          } else {
            e3 = 5;
            a3 = 6;
            break;
          }
        }
        if ((a3 | 0) == 6) {
          b2[d3 >> 2] = e3;
          return 0;
        }
        return 0;
      }
      function dc(a3, c3, d3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0;
        m = T;
        T = T + 128 | 0;
        k = m + 112 | 0;
        g2 = m + 96 | 0;
        l = m;
        f2 = Td(a3 | 0, c3 | 0, 52) | 0;
        H() | 0;
        i = f2 & 15;
        b2[k >> 2] = i;
        h = Td(a3 | 0, c3 | 0, 45) | 0;
        H() | 0;
        h = h & 127;
        a: do {
          if (oa(h) | 0) {
            if (i | 0) {
              e3 = 1;
              while (1) {
                j = Ud(7, 0, (15 - e3 | 0) * 3 | 0) | 0;
                if (!((j & a3 | 0) == 0 & ((H() | 0) & c3 | 0) == 0)) {
                  f2 = 0;
                  break a;
                }
                if (e3 >>> 0 < i >>> 0) {
                  e3 = e3 + 1 | 0;
                } else {
                  break;
                }
              }
            }
            if (!(f2 & 1)) {
              j = Ud(i + 1 | 0, 0, 52) | 0;
              l = H() | 0 | c3 & -15728641;
              k = Ud(7, 0, (14 - i | 0) * 3 | 0) | 0;
              l = dc((j | a3) & ~k, l & ~(H() | 0), d3) | 0;
              T = m;
              return l | 0;
            } else {
              f2 = 1;
            }
          } else {
            f2 = 0;
          }
        } while (0);
        e3 = $b(a3, c3, g2) | 0;
        if (!e3) {
          if (f2) {
            wb(g2, k, l);
            j = 5;
          } else {
            Ab(g2, k, l);
            j = 6;
          }
          b: do {
            if (oa(h) | 0) {
              if (!i) {
                a3 = 5;
              } else {
                e3 = 1;
                while (1) {
                  h = Ud(7, 0, (15 - e3 | 0) * 3 | 0) | 0;
                  if (!((h & a3 | 0) == 0 & ((H() | 0) & c3 | 0) == 0)) {
                    a3 = 2;
                    break b;
                  }
                  if (e3 >>> 0 < i >>> 0) {
                    e3 = e3 + 1 | 0;
                  } else {
                    a3 = 5;
                    break;
                  }
                }
              }
            } else {
              a3 = 2;
            }
          } while (0);
          _d(d3 | 0, -1, a3 << 2 | 0) | 0;
          c: do {
            if (f2) {
              g2 = 0;
              while (1) {
                h = l + (g2 << 4) | 0;
                yb(h, b2[k >> 2] | 0) | 0;
                h = b2[h >> 2] | 0;
                i = b2[d3 >> 2] | 0;
                if ((i | 0) == -1 | (i | 0) == (h | 0)) {
                  e3 = d3;
                } else {
                  f2 = 0;
                  do {
                    f2 = f2 + 1 | 0;
                    if (f2 >>> 0 >= a3 >>> 0) {
                      e3 = 1;
                      break c;
                    }
                    e3 = d3 + (f2 << 2) | 0;
                    i = b2[e3 >> 2] | 0;
                  } while (!((i | 0) == -1 | (i | 0) == (h | 0)));
                }
                b2[e3 >> 2] = h;
                g2 = g2 + 1 | 0;
                if (g2 >>> 0 >= j >>> 0) {
                  e3 = 0;
                  break;
                }
              }
            } else {
              g2 = 0;
              while (1) {
                h = l + (g2 << 4) | 0;
                xb(h, b2[k >> 2] | 0, 0, 1) | 0;
                h = b2[h >> 2] | 0;
                i = b2[d3 >> 2] | 0;
                if ((i | 0) == -1 | (i | 0) == (h | 0)) {
                  e3 = d3;
                } else {
                  f2 = 0;
                  do {
                    f2 = f2 + 1 | 0;
                    if (f2 >>> 0 >= a3 >>> 0) {
                      e3 = 1;
                      break c;
                    }
                    e3 = d3 + (f2 << 2) | 0;
                    i = b2[e3 >> 2] | 0;
                  } while (!((i | 0) == -1 | (i | 0) == (h | 0)));
                }
                b2[e3 >> 2] = h;
                g2 = g2 + 1 | 0;
                if (g2 >>> 0 >= j >>> 0) {
                  e3 = 0;
                  break;
                }
              }
            }
          } while (0);
        }
        l = e3;
        T = m;
        return l | 0;
      }
      function ec() {
        return 12;
      }
      function fc(a3, c3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        var d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0;
        if (a3 >>> 0 > 15) {
          i = 4;
          return i | 0;
        }
        Ud(a3 | 0, 0, 52) | 0;
        i = H() | 0 | 134225919;
        if (!a3) {
          d3 = 0;
          e3 = 0;
          do {
            if (oa(e3) | 0) {
              Ud(e3 | 0, 0, 45) | 0;
              h = i | (H() | 0);
              a3 = c3 + (d3 << 3) | 0;
              b2[a3 >> 2] = -1;
              b2[a3 + 4 >> 2] = h;
              d3 = d3 + 1 | 0;
            }
            e3 = e3 + 1 | 0;
          } while ((e3 | 0) != 122);
          d3 = 0;
          return d3 | 0;
        }
        d3 = 0;
        h = 0;
        do {
          if (oa(h) | 0) {
            Ud(h | 0, 0, 45) | 0;
            e3 = 1;
            f2 = -1;
            g2 = i | (H() | 0);
            while (1) {
              j = Ud(7, 0, (15 - e3 | 0) * 3 | 0) | 0;
              f2 = f2 & ~j;
              g2 = g2 & ~(H() | 0);
              if ((e3 | 0) == (a3 | 0)) {
                break;
              } else {
                e3 = e3 + 1 | 0;
              }
            }
            j = c3 + (d3 << 3) | 0;
            b2[j >> 2] = f2;
            b2[j + 4 >> 2] = g2;
            d3 = d3 + 1 | 0;
          }
          h = h + 1 | 0;
        } while ((h | 0) != 122);
        d3 = 0;
        return d3 | 0;
      }
      function gc(a3, c3, d3, e3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t2 = 0;
        t2 = T;
        T = T + 16 | 0;
        r2 = t2;
        s2 = Td(a3 | 0, c3 | 0, 52) | 0;
        H() | 0;
        s2 = s2 & 15;
        if (d3 >>> 0 > 15) {
          s2 = 4;
          T = t2;
          return s2 | 0;
        }
        if ((s2 | 0) < (d3 | 0)) {
          s2 = 12;
          T = t2;
          return s2 | 0;
        }
        if ((s2 | 0) != (d3 | 0)) {
          g2 = Ud(d3 | 0, 0, 52) | 0;
          g2 = g2 | a3;
          i = H() | 0 | c3 & -15728641;
          if ((s2 | 0) > (d3 | 0)) {
            j = d3;
            do {
              q2 = Ud(7, 0, (14 - j | 0) * 3 | 0) | 0;
              j = j + 1 | 0;
              g2 = q2 | g2;
              i = H() | 0 | i;
            } while ((j | 0) < (s2 | 0));
            q2 = g2;
          } else {
            q2 = g2;
          }
        } else {
          q2 = a3;
          i = c3;
        }
        p2 = Td(q2 | 0, i | 0, 45) | 0;
        H() | 0;
        a: do {
          if (oa(p2 & 127) | 0) {
            j = Td(q2 | 0, i | 0, 52) | 0;
            H() | 0;
            j = j & 15;
            if (j | 0) {
              g2 = 1;
              while (1) {
                p2 = Ud(7, 0, (15 - g2 | 0) * 3 | 0) | 0;
                if (!((p2 & q2 | 0) == 0 & ((H() | 0) & i | 0) == 0)) {
                  k = 33;
                  break a;
                }
                if (g2 >>> 0 < j >>> 0) {
                  g2 = g2 + 1 | 0;
                } else {
                  break;
                }
              }
            }
            p2 = e3;
            b2[p2 >> 2] = 0;
            b2[p2 + 4 >> 2] = 0;
            if ((s2 | 0) > (d3 | 0)) {
              p2 = c3 & -15728641;
              o = s2;
              while (1) {
                n = o;
                o = o + -1 | 0;
                if (o >>> 0 > 15 | (s2 | 0) < (o | 0)) {
                  k = 19;
                  break;
                }
                if ((s2 | 0) != (o | 0)) {
                  g2 = Ud(o | 0, 0, 52) | 0;
                  g2 = g2 | a3;
                  j = H() | 0 | p2;
                  if ((s2 | 0) < (n | 0)) {
                    m = g2;
                  } else {
                    k = o;
                    do {
                      m = Ud(7, 0, (14 - k | 0) * 3 | 0) | 0;
                      k = k + 1 | 0;
                      g2 = m | g2;
                      j = H() | 0 | j;
                    } while ((k | 0) < (s2 | 0));
                    m = g2;
                  }
                } else {
                  m = a3;
                  j = c3;
                }
                l = Td(m | 0, j | 0, 45) | 0;
                H() | 0;
                if (!(oa(l & 127) | 0)) {
                  g2 = 0;
                } else {
                  l = Td(m | 0, j | 0, 52) | 0;
                  H() | 0;
                  l = l & 15;
                  b: do {
                    if (!l) {
                      g2 = 0;
                    } else {
                      k = 1;
                      while (1) {
                        g2 = Td(m | 0, j | 0, (15 - k | 0) * 3 | 0) | 0;
                        H() | 0;
                        g2 = g2 & 7;
                        if (g2 | 0) {
                          break b;
                        }
                        if (k >>> 0 < l >>> 0) {
                          k = k + 1 | 0;
                        } else {
                          g2 = 0;
                          break;
                        }
                      }
                    }
                  } while (0);
                  g2 = (g2 | 0) == 0 & 1;
                }
                j = Td(a3 | 0, c3 | 0, (15 - n | 0) * 3 | 0) | 0;
                H() | 0;
                j = j & 7;
                if ((j | 0) == 7) {
                  f2 = 5;
                  k = 42;
                  break;
                }
                g2 = (g2 | 0) != 0;
                if ((j | 0) == 1 & g2) {
                  f2 = 5;
                  k = 42;
                  break;
                }
                m = j + (((j | 0) != 0 & g2) << 31 >> 31) | 0;
                if (m | 0) {
                  k = s2 - n | 0;
                  k = Rc(7, 0, k, ((k | 0) < 0) << 31 >> 31) | 0;
                  l = H() | 0;
                  if (g2) {
                    g2 = Pd(k | 0, l | 0, 5, 0) | 0;
                    g2 = Jd(g2 | 0, H() | 0, -5, -1) | 0;
                    g2 = Nd(g2 | 0, H() | 0, 6, 0) | 0;
                    g2 = Jd(g2 | 0, H() | 0, 1, 0) | 0;
                    j = H() | 0;
                  } else {
                    g2 = k;
                    j = l;
                  }
                  n = m + -1 | 0;
                  n = Pd(k | 0, l | 0, n | 0, ((n | 0) < 0) << 31 >> 31 | 0) | 0;
                  n = Jd(g2 | 0, j | 0, n | 0, H() | 0) | 0;
                  m = H() | 0;
                  l = e3;
                  l = Jd(n | 0, m | 0, b2[l >> 2] | 0, b2[l + 4 >> 2] | 0) | 0;
                  m = H() | 0;
                  n = e3;
                  b2[n >> 2] = l;
                  b2[n + 4 >> 2] = m;
                }
                if ((o | 0) <= (d3 | 0)) {
                  k = 37;
                  break;
                }
              }
              if ((k | 0) == 19) {
                I(27795, 27122, 1367, 27158);
              } else if ((k | 0) == 37) {
                h = e3;
                f2 = b2[h + 4 >> 2] | 0;
                h = b2[h >> 2] | 0;
                break;
              } else if ((k | 0) == 42) {
                T = t2;
                return f2 | 0;
              }
            } else {
              f2 = 0;
              h = 0;
            }
          } else {
            k = 33;
          }
        } while (0);
        c: do {
          if ((k | 0) == 33) {
            p2 = e3;
            b2[p2 >> 2] = 0;
            b2[p2 + 4 >> 2] = 0;
            if ((s2 | 0) > (d3 | 0)) {
              g2 = s2;
              while (1) {
                f2 = Td(a3 | 0, c3 | 0, (15 - g2 | 0) * 3 | 0) | 0;
                H() | 0;
                f2 = f2 & 7;
                if ((f2 | 0) == 7) {
                  f2 = 5;
                  break;
                }
                h = s2 - g2 | 0;
                h = Rc(7, 0, h, ((h | 0) < 0) << 31 >> 31) | 0;
                f2 = Pd(h | 0, H() | 0, f2 | 0, 0) | 0;
                h = H() | 0;
                p2 = e3;
                h = Jd(b2[p2 >> 2] | 0, b2[p2 + 4 >> 2] | 0, f2 | 0, h | 0) | 0;
                f2 = H() | 0;
                p2 = e3;
                b2[p2 >> 2] = h;
                b2[p2 + 4 >> 2] = f2;
                g2 = g2 + -1 | 0;
                if ((g2 | 0) <= (d3 | 0)) {
                  break c;
                }
              }
              T = t2;
              return f2 | 0;
            } else {
              f2 = 0;
              h = 0;
            }
          }
        } while (0);
        if (Jb(q2, i, s2, r2) | 0) {
          I(27795, 27122, 1327, 27173);
        }
        s2 = r2;
        r2 = b2[s2 + 4 >> 2] | 0;
        if (((f2 | 0) > -1 | (f2 | 0) == -1 & h >>> 0 > 4294967295) & ((r2 | 0) > (f2 | 0) | ((r2 | 0) == (f2 | 0) ? (b2[s2 >> 2] | 0) >>> 0 > h >>> 0 : 0))) {
          s2 = 0;
          T = t2;
          return s2 | 0;
        } else {
          I(27795, 27122, 1407, 27158);
        }
        return 0;
      }
      function hc(a3, c3, d3, e3, f2, g2) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0;
        m = T;
        T = T + 16 | 0;
        h = m;
        if (f2 >>> 0 > 15) {
          g2 = 4;
          T = m;
          return g2 | 0;
        }
        i = Td(d3 | 0, e3 | 0, 52) | 0;
        H() | 0;
        i = i & 15;
        if ((i | 0) > (f2 | 0)) {
          g2 = 12;
          T = m;
          return g2 | 0;
        }
        if (Jb(d3, e3, f2, h) | 0) {
          I(27795, 27122, 1327, 27173);
        }
        l = h;
        k = b2[l + 4 >> 2] | 0;
        if (!(((c3 | 0) > -1 | (c3 | 0) == -1 & a3 >>> 0 > 4294967295) & ((k | 0) > (c3 | 0) | ((k | 0) == (c3 | 0) ? (b2[l >> 2] | 0) >>> 0 > a3 >>> 0 : 0)))) {
          g2 = 2;
          T = m;
          return g2 | 0;
        }
        l = f2 - i | 0;
        f2 = Ud(f2 | 0, 0, 52) | 0;
        j = H() | 0 | e3 & -15728641;
        k = g2;
        b2[k >> 2] = f2 | d3;
        b2[k + 4 >> 2] = j;
        k = Td(d3 | 0, e3 | 0, 45) | 0;
        H() | 0;
        a: do {
          if (oa(k & 127) | 0) {
            if (i | 0) {
              h = 1;
              while (1) {
                k = Ud(7, 0, (15 - h | 0) * 3 | 0) | 0;
                if (!((k & d3 | 0) == 0 & ((H() | 0) & e3 | 0) == 0)) {
                  break a;
                }
                if (h >>> 0 < i >>> 0) {
                  h = h + 1 | 0;
                } else {
                  break;
                }
              }
            }
            if ((l | 0) < 1) {
              g2 = 0;
              T = m;
              return g2 | 0;
            }
            k = i ^ 15;
            e3 = -1;
            j = 1;
            h = 1;
            while (1) {
              i = l - j | 0;
              i = Rc(7, 0, i, ((i | 0) < 0) << 31 >> 31) | 0;
              d3 = H() | 0;
              do {
                if (h) {
                  h = Pd(i | 0, d3 | 0, 5, 0) | 0;
                  h = Jd(h | 0, H() | 0, -5, -1) | 0;
                  h = Nd(h | 0, H() | 0, 6, 0) | 0;
                  f2 = H() | 0;
                  if ((c3 | 0) > (f2 | 0) | (c3 | 0) == (f2 | 0) & a3 >>> 0 > h >>> 0) {
                    c3 = Jd(a3 | 0, c3 | 0, -1, -1) | 0;
                    c3 = Kd(c3 | 0, H() | 0, h | 0, f2 | 0) | 0;
                    h = H() | 0;
                    n = g2;
                    p2 = b2[n >> 2] | 0;
                    n = b2[n + 4 >> 2] | 0;
                    q2 = (k + e3 | 0) * 3 | 0;
                    o = Ud(7, 0, q2 | 0) | 0;
                    n = n & ~(H() | 0);
                    e3 = Nd(c3 | 0, h | 0, i | 0, d3 | 0) | 0;
                    a3 = H() | 0;
                    f2 = Jd(e3 | 0, a3 | 0, 2, 0) | 0;
                    q2 = Ud(f2 | 0, H() | 0, q2 | 0) | 0;
                    n = H() | 0 | n;
                    f2 = g2;
                    b2[f2 >> 2] = q2 | p2 & ~o;
                    b2[f2 + 4 >> 2] = n;
                    a3 = Pd(e3 | 0, a3 | 0, i | 0, d3 | 0) | 0;
                    a3 = Kd(c3 | 0, h | 0, a3 | 0, H() | 0) | 0;
                    h = 0;
                    c3 = H() | 0;
                    break;
                  } else {
                    q2 = g2;
                    o = b2[q2 >> 2] | 0;
                    q2 = b2[q2 + 4 >> 2] | 0;
                    p2 = Ud(7, 0, (k + e3 | 0) * 3 | 0) | 0;
                    q2 = q2 & ~(H() | 0);
                    h = g2;
                    b2[h >> 2] = o & ~p2;
                    b2[h + 4 >> 2] = q2;
                    h = 1;
                    break;
                  }
                } else {
                  o = g2;
                  f2 = b2[o >> 2] | 0;
                  o = b2[o + 4 >> 2] | 0;
                  e3 = (k + e3 | 0) * 3 | 0;
                  n = Ud(7, 0, e3 | 0) | 0;
                  o = o & ~(H() | 0);
                  q2 = Nd(a3 | 0, c3 | 0, i | 0, d3 | 0) | 0;
                  h = H() | 0;
                  e3 = Ud(q2 | 0, h | 0, e3 | 0) | 0;
                  o = H() | 0 | o;
                  p2 = g2;
                  b2[p2 >> 2] = e3 | f2 & ~n;
                  b2[p2 + 4 >> 2] = o;
                  h = Pd(q2 | 0, h | 0, i | 0, d3 | 0) | 0;
                  a3 = Kd(a3 | 0, c3 | 0, h | 0, H() | 0) | 0;
                  h = 0;
                  c3 = H() | 0;
                }
              } while (0);
              if ((l | 0) > (j | 0)) {
                e3 = ~j;
                j = j + 1 | 0;
              } else {
                c3 = 0;
                break;
              }
            }
            T = m;
            return c3 | 0;
          }
        } while (0);
        if ((l | 0) < 1) {
          q2 = 0;
          T = m;
          return q2 | 0;
        }
        f2 = i ^ 15;
        h = 1;
        while (1) {
          p2 = l - h | 0;
          p2 = Rc(7, 0, p2, ((p2 | 0) < 0) << 31 >> 31) | 0;
          q2 = H() | 0;
          j = g2;
          d3 = b2[j >> 2] | 0;
          j = b2[j + 4 >> 2] | 0;
          i = (f2 - h | 0) * 3 | 0;
          e3 = Ud(7, 0, i | 0) | 0;
          j = j & ~(H() | 0);
          n = Nd(a3 | 0, c3 | 0, p2 | 0, q2 | 0) | 0;
          o = H() | 0;
          i = Ud(n | 0, o | 0, i | 0) | 0;
          j = H() | 0 | j;
          k = g2;
          b2[k >> 2] = i | d3 & ~e3;
          b2[k + 4 >> 2] = j;
          q2 = Pd(n | 0, o | 0, p2 | 0, q2 | 0) | 0;
          a3 = Kd(a3 | 0, c3 | 0, q2 | 0, H() | 0) | 0;
          c3 = H() | 0;
          if ((l | 0) <= (h | 0)) {
            c3 = 0;
            break;
          } else {
            h = h + 1 | 0;
          }
        }
        T = m;
        return c3 | 0;
      }
      function ic(a3, c3, d3, e3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0;
        f2 = Td(c3 | 0, d3 | 0, 52) | 0;
        H() | 0;
        f2 = f2 & 15;
        if ((c3 | 0) == 0 & (d3 | 0) == 0 | ((e3 | 0) > 15 | (f2 | 0) > (e3 | 0))) {
          g2 = -1;
          c3 = -1;
          d3 = 0;
          f2 = 0;
        } else {
          c3 = Mb(c3, d3, f2 + 1 | 0, e3) | 0;
          h = (H() | 0) & -15728641;
          d3 = Ud(e3 | 0, 0, 52) | 0;
          d3 = c3 | d3;
          h = h | (H() | 0);
          c3 = (Kb(d3, h) | 0) == 0;
          g2 = f2;
          c3 = c3 ? -1 : e3;
          f2 = h;
        }
        h = a3;
        b2[h >> 2] = d3;
        b2[h + 4 >> 2] = f2;
        b2[a3 + 8 >> 2] = g2;
        b2[a3 + 12 >> 2] = c3;
        return;
      }
      function jc(a3, c3, d3, e3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0;
        f2 = Td(a3 | 0, c3 | 0, 52) | 0;
        H() | 0;
        f2 = f2 & 15;
        g2 = e3 + 8 | 0;
        b2[g2 >> 2] = f2;
        if ((a3 | 0) == 0 & (c3 | 0) == 0 | ((d3 | 0) > 15 | (f2 | 0) > (d3 | 0))) {
          d3 = e3;
          b2[d3 >> 2] = 0;
          b2[d3 + 4 >> 2] = 0;
          b2[g2 >> 2] = -1;
          b2[e3 + 12 >> 2] = -1;
          return;
        }
        a3 = Mb(a3, c3, f2 + 1 | 0, d3) | 0;
        g2 = (H() | 0) & -15728641;
        f2 = Ud(d3 | 0, 0, 52) | 0;
        f2 = a3 | f2;
        g2 = g2 | (H() | 0);
        a3 = e3;
        b2[a3 >> 2] = f2;
        b2[a3 + 4 >> 2] = g2;
        a3 = e3 + 12 | 0;
        if (!(Kb(f2, g2) | 0)) {
          b2[a3 >> 2] = -1;
          return;
        } else {
          b2[a3 >> 2] = d3;
          return;
        }
      }
      function kc(a3) {
        a3 = a3 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0;
        d3 = a3;
        c3 = b2[d3 >> 2] | 0;
        d3 = b2[d3 + 4 >> 2] | 0;
        if ((c3 | 0) == 0 & (d3 | 0) == 0) {
          return;
        }
        e3 = Td(c3 | 0, d3 | 0, 52) | 0;
        H() | 0;
        e3 = e3 & 15;
        i = Ud(1, 0, (e3 ^ 15) * 3 | 0) | 0;
        c3 = Jd(i | 0, H() | 0, c3 | 0, d3 | 0) | 0;
        d3 = H() | 0;
        i = a3;
        b2[i >> 2] = c3;
        b2[i + 4 >> 2] = d3;
        i = a3 + 8 | 0;
        h = b2[i >> 2] | 0;
        if ((e3 | 0) < (h | 0)) {
          return;
        }
        j = a3 + 12 | 0;
        g2 = e3;
        while (1) {
          if ((g2 | 0) == (h | 0)) {
            e3 = 5;
            break;
          }
          k = (g2 | 0) == (b2[j >> 2] | 0);
          f2 = (15 - g2 | 0) * 3 | 0;
          e3 = Td(c3 | 0, d3 | 0, f2 | 0) | 0;
          H() | 0;
          e3 = e3 & 7;
          if (k & ((e3 | 0) == 1 & true)) {
            e3 = 7;
            break;
          }
          if (!((e3 | 0) == 7 & true)) {
            e3 = 10;
            break;
          }
          k = Ud(1, 0, f2 | 0) | 0;
          c3 = Jd(c3 | 0, d3 | 0, k | 0, H() | 0) | 0;
          d3 = H() | 0;
          k = a3;
          b2[k >> 2] = c3;
          b2[k + 4 >> 2] = d3;
          if ((g2 | 0) > (h | 0)) {
            g2 = g2 + -1 | 0;
          } else {
            e3 = 10;
            break;
          }
        }
        if ((e3 | 0) == 5) {
          k = a3;
          b2[k >> 2] = 0;
          b2[k + 4 >> 2] = 0;
          b2[i >> 2] = -1;
          b2[j >> 2] = -1;
          return;
        } else if ((e3 | 0) == 7) {
          h = Ud(1, 0, f2 | 0) | 0;
          h = Jd(c3 | 0, d3 | 0, h | 0, H() | 0) | 0;
          i = H() | 0;
          k = a3;
          b2[k >> 2] = h;
          b2[k + 4 >> 2] = i;
          b2[j >> 2] = g2 + -1;
          return;
        } else if ((e3 | 0) == 10) {
          return;
        }
      }
      function lc(a3) {
        a3 = +a3;
        var b3 = 0;
        b3 = a3 < 0 ? a3 + 6.283185307179586 : a3;
        return +(!(a3 >= 6.283185307179586) ? b3 : b3 + -6.283185307179586);
      }
      function mc(a3, b3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        if (!(+q(+(+e2[a3 >> 3] - +e2[b3 >> 3])) < 17453292519943298e-27)) {
          b3 = 0;
          return b3 | 0;
        }
        b3 = +q(+(+e2[a3 + 8 >> 3] - +e2[b3 + 8 >> 3])) < 17453292519943298e-27;
        return b3 | 0;
      }
      function nc(a3, b3) {
        a3 = +a3;
        b3 = b3 | 0;
        switch (b3 | 0) {
          case 1: {
            a3 = a3 < 0 ? a3 + 6.283185307179586 : a3;
            break;
          }
          case 2: {
            a3 = a3 > 0 ? a3 + -6.283185307179586 : a3;
            break;
          }
          default:
        }
        return +a3;
      }
      function oc(a3, b3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        var c3 = 0, d3 = 0, f2 = 0, g2 = 0;
        f2 = +e2[b3 >> 3];
        d3 = +e2[a3 >> 3];
        g2 = +u2(+((f2 - d3) * 0.5));
        c3 = +u2(+((+e2[b3 + 8 >> 3] - +e2[a3 + 8 >> 3]) * 0.5));
        c3 = g2 * g2 + c3 * (+t(+f2) * +t(+d3) * c3);
        return +(+z(+ +r(+c3), + +r(+(1 - c3))) * 2);
      }
      function pc(a3, b3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        var c3 = 0, d3 = 0, f2 = 0, g2 = 0;
        f2 = +e2[b3 >> 3];
        d3 = +e2[a3 >> 3];
        g2 = +u2(+((f2 - d3) * 0.5));
        c3 = +u2(+((+e2[b3 + 8 >> 3] - +e2[a3 + 8 >> 3]) * 0.5));
        c3 = g2 * g2 + c3 * (+t(+f2) * +t(+d3) * c3);
        return +(+z(+ +r(+c3), + +r(+(1 - c3))) * 2 * 6371.007180918475);
      }
      function qc(a3, b3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        var c3 = 0, d3 = 0, f2 = 0, g2 = 0;
        f2 = +e2[b3 >> 3];
        d3 = +e2[a3 >> 3];
        g2 = +u2(+((f2 - d3) * 0.5));
        c3 = +u2(+((+e2[b3 + 8 >> 3] - +e2[a3 + 8 >> 3]) * 0.5));
        c3 = g2 * g2 + c3 * (+t(+f2) * +t(+d3) * c3);
        return +(+z(+ +r(+c3), + +r(+(1 - c3))) * 2 * 6371.007180918475 * 1e3);
      }
      function rc(a3, b3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        var c3 = 0, d3 = 0, f2 = 0, g2 = 0, h = 0;
        g2 = +e2[b3 >> 3];
        d3 = +t(+g2);
        f2 = +e2[b3 + 8 >> 3] - +e2[a3 + 8 >> 3];
        h = d3 * +u2(+f2);
        c3 = +e2[a3 >> 3];
        return + +z(+h, +(+u2(+g2) * +t(+c3) - +t(+f2) * (d3 * +u2(+c3))));
      }
      function sc(a3, c3, d3, f2) {
        a3 = a3 | 0;
        c3 = +c3;
        d3 = +d3;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0;
        if (d3 < 1e-16) {
          b2[f2 >> 2] = b2[a3 >> 2];
          b2[f2 + 4 >> 2] = b2[a3 + 4 >> 2];
          b2[f2 + 8 >> 2] = b2[a3 + 8 >> 2];
          b2[f2 + 12 >> 2] = b2[a3 + 12 >> 2];
          return;
        }
        h = c3 < 0 ? c3 + 6.283185307179586 : c3;
        h = !(c3 >= 6.283185307179586) ? h : h + -6.283185307179586;
        do {
          if (h < 1e-16) {
            c3 = +e2[a3 >> 3] + d3;
            e2[f2 >> 3] = c3;
            g2 = f2;
          } else {
            g2 = +q(+(h + -3.141592653589793)) < 1e-16;
            c3 = +e2[a3 >> 3];
            if (g2) {
              c3 = c3 - d3;
              e2[f2 >> 3] = c3;
              g2 = f2;
              break;
            }
            i = +t(+d3);
            d3 = +u2(+d3);
            c3 = i * +u2(+c3) + +t(+h) * (d3 * +t(+c3));
            c3 = c3 > 1 ? 1 : c3;
            c3 = +x(+(c3 < -1 ? -1 : c3));
            e2[f2 >> 3] = c3;
            if (+q(+(c3 + -1.5707963267948966)) < 1e-16) {
              e2[f2 >> 3] = 1.5707963267948966;
              e2[f2 + 8 >> 3] = 0;
              return;
            }
            if (+q(+(c3 + 1.5707963267948966)) < 1e-16) {
              e2[f2 >> 3] = -1.5707963267948966;
              e2[f2 + 8 >> 3] = 0;
              return;
            }
            j = 1 / +t(+c3);
            h = d3 * +u2(+h) * j;
            d3 = +e2[a3 >> 3];
            c3 = j * ((i - +u2(+c3) * +u2(+d3)) / +t(+d3));
            i = h > 1 ? 1 : h;
            c3 = c3 > 1 ? 1 : c3;
            c3 = +e2[a3 + 8 >> 3] + +z(+(i < -1 ? -1 : i), +(c3 < -1 ? -1 : c3));
            if (c3 > 3.141592653589793) {
              do {
                c3 = c3 + -6.283185307179586;
              } while (c3 > 3.141592653589793);
            }
            if (c3 < -3.141592653589793) {
              do {
                c3 = c3 + 6.283185307179586;
              } while (c3 < -3.141592653589793);
            }
            e2[f2 + 8 >> 3] = c3;
            return;
          }
        } while (0);
        if (+q(+(c3 + -1.5707963267948966)) < 1e-16) {
          e2[g2 >> 3] = 1.5707963267948966;
          e2[f2 + 8 >> 3] = 0;
          return;
        }
        if (+q(+(c3 + 1.5707963267948966)) < 1e-16) {
          e2[g2 >> 3] = -1.5707963267948966;
          e2[f2 + 8 >> 3] = 0;
          return;
        }
        c3 = +e2[a3 + 8 >> 3];
        if (c3 > 3.141592653589793) {
          do {
            c3 = c3 + -6.283185307179586;
          } while (c3 > 3.141592653589793);
        }
        if (c3 < -3.141592653589793) {
          do {
            c3 = c3 + 6.283185307179586;
          } while (c3 < -3.141592653589793);
        }
        e2[f2 + 8 >> 3] = c3;
        return;
      }
      function tc(a3, b3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        if (a3 >>> 0 > 15) {
          b3 = 4;
          return b3 | 0;
        }
        e2[b3 >> 3] = +e2[20656 + (a3 << 3) >> 3];
        b3 = 0;
        return b3 | 0;
      }
      function uc(a3, b3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        if (a3 >>> 0 > 15) {
          b3 = 4;
          return b3 | 0;
        }
        e2[b3 >> 3] = +e2[20784 + (a3 << 3) >> 3];
        b3 = 0;
        return b3 | 0;
      }
      function vc(a3, b3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        if (a3 >>> 0 > 15) {
          b3 = 4;
          return b3 | 0;
        }
        e2[b3 >> 3] = +e2[20912 + (a3 << 3) >> 3];
        b3 = 0;
        return b3 | 0;
      }
      function wc(a3, b3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        if (a3 >>> 0 > 15) {
          b3 = 4;
          return b3 | 0;
        }
        e2[b3 >> 3] = +e2[21040 + (a3 << 3) >> 3];
        b3 = 0;
        return b3 | 0;
      }
      function xc(a3, c3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        var d3 = 0;
        if (a3 >>> 0 > 15) {
          c3 = 4;
          return c3 | 0;
        }
        d3 = Rc(7, 0, a3, ((a3 | 0) < 0) << 31 >> 31) | 0;
        d3 = Pd(d3 | 0, H() | 0, 120, 0) | 0;
        a3 = H() | 0;
        b2[c3 >> 2] = d3 | 2;
        b2[c3 + 4 >> 2] = a3;
        c3 = 0;
        return c3 | 0;
      }
      function yc(a3, b3, c3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        c3 = c3 | 0;
        var d3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0;
        n = +e2[b3 >> 3];
        l = +e2[a3 >> 3];
        j = +u2(+((n - l) * 0.5));
        g2 = +e2[b3 + 8 >> 3];
        k = +e2[a3 + 8 >> 3];
        h = +u2(+((g2 - k) * 0.5));
        i = +t(+l);
        m = +t(+n);
        h = j * j + h * (m * i * h);
        h = +z(+ +r(+h), + +r(+(1 - h))) * 2;
        j = +e2[c3 >> 3];
        n = +u2(+((j - n) * 0.5));
        d3 = +e2[c3 + 8 >> 3];
        g2 = +u2(+((d3 - g2) * 0.5));
        f2 = +t(+j);
        g2 = n * n + g2 * (m * f2 * g2);
        g2 = +z(+ +r(+g2), + +r(+(1 - g2))) * 2;
        j = +u2(+((l - j) * 0.5));
        d3 = +u2(+((k - d3) * 0.5));
        d3 = j * j + d3 * (i * f2 * d3);
        d3 = +z(+ +r(+d3), + +r(+(1 - d3))) * 2;
        f2 = (h + g2 + d3) * 0.5;
        return +(+y(+ +r(+(+v2(+(f2 * 0.5)) * +v2(+((f2 - h) * 0.5)) * +v2(+((f2 - g2) * 0.5)) * +v2(+((f2 - d3) * 0.5))))) * 4);
      }
      function zc(a3, c3, d3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0;
        j = T;
        T = T + 192 | 0;
        h = j + 168 | 0;
        i = j;
        g2 = ac(a3, c3, h) | 0;
        if (g2 | 0) {
          d3 = g2;
          T = j;
          return d3 | 0;
        }
        if (bc(a3, c3, i) | 0) {
          I(27795, 27190, 415, 27199);
        }
        c3 = b2[i >> 2] | 0;
        if ((c3 | 0) > 0) {
          f2 = +yc(i + 8 | 0, i + 8 + (((c3 | 0) != 1 & 1) << 4) | 0, h) + 0;
          if ((c3 | 0) != 1) {
            a3 = 1;
            do {
              g2 = a3;
              a3 = a3 + 1 | 0;
              f2 = f2 + +yc(i + 8 + (g2 << 4) | 0, i + 8 + (((a3 | 0) % (c3 | 0) | 0) << 4) | 0, h);
            } while ((a3 | 0) < (c3 | 0));
          }
        } else {
          f2 = 0;
        }
        e2[d3 >> 3] = f2;
        d3 = 0;
        T = j;
        return d3 | 0;
      }
      function Ac(a3, b3, c3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        c3 = c3 | 0;
        a3 = zc(a3, b3, c3) | 0;
        if (a3 | 0) {
          return a3 | 0;
        }
        e2[c3 >> 3] = +e2[c3 >> 3] * 6371.007180918475 * 6371.007180918475;
        return a3 | 0;
      }
      function Bc(a3, b3, c3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        c3 = c3 | 0;
        a3 = zc(a3, b3, c3) | 0;
        if (a3 | 0) {
          return a3 | 0;
        }
        e2[c3 >> 3] = +e2[c3 >> 3] * 6371.007180918475 * 6371.007180918475 * 1e3 * 1e3;
        return a3 | 0;
      }
      function Cc(a3, c3, d3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0;
        j = T;
        T = T + 176 | 0;
        i = j;
        a3 = pb(a3, c3, i) | 0;
        if (a3 | 0) {
          i = a3;
          T = j;
          return i | 0;
        }
        e2[d3 >> 3] = 0;
        a3 = b2[i >> 2] | 0;
        if ((a3 | 0) <= 1) {
          i = 0;
          T = j;
          return i | 0;
        }
        c3 = a3 + -1 | 0;
        a3 = 0;
        f2 = +e2[i + 8 >> 3];
        g2 = +e2[i + 16 >> 3];
        h = 0;
        do {
          a3 = a3 + 1 | 0;
          l = f2;
          f2 = +e2[i + 8 + (a3 << 4) >> 3];
          m = +u2(+((f2 - l) * 0.5));
          k = g2;
          g2 = +e2[i + 8 + (a3 << 4) + 8 >> 3];
          k = +u2(+((g2 - k) * 0.5));
          k = m * m + k * (+t(+f2) * +t(+l) * k);
          h = h + +z(+ +r(+k), + +r(+(1 - k))) * 2;
        } while ((a3 | 0) < (c3 | 0));
        e2[d3 >> 3] = h;
        i = 0;
        T = j;
        return i | 0;
      }
      function Dc(a3, c3, d3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0;
        j = T;
        T = T + 176 | 0;
        i = j;
        a3 = pb(a3, c3, i) | 0;
        if (a3 | 0) {
          i = a3;
          h = +e2[d3 >> 3];
          h = h * 6371.007180918475;
          e2[d3 >> 3] = h;
          T = j;
          return i | 0;
        }
        e2[d3 >> 3] = 0;
        a3 = b2[i >> 2] | 0;
        if ((a3 | 0) <= 1) {
          i = 0;
          h = 0;
          h = h * 6371.007180918475;
          e2[d3 >> 3] = h;
          T = j;
          return i | 0;
        }
        c3 = a3 + -1 | 0;
        a3 = 0;
        f2 = +e2[i + 8 >> 3];
        g2 = +e2[i + 16 >> 3];
        h = 0;
        do {
          a3 = a3 + 1 | 0;
          l = f2;
          f2 = +e2[i + 8 + (a3 << 4) >> 3];
          m = +u2(+((f2 - l) * 0.5));
          k = g2;
          g2 = +e2[i + 8 + (a3 << 4) + 8 >> 3];
          k = +u2(+((g2 - k) * 0.5));
          k = m * m + k * (+t(+l) * +t(+f2) * k);
          h = h + +z(+ +r(+k), + +r(+(1 - k))) * 2;
        } while ((a3 | 0) != (c3 | 0));
        e2[d3 >> 3] = h;
        i = 0;
        m = h;
        m = m * 6371.007180918475;
        e2[d3 >> 3] = m;
        T = j;
        return i | 0;
      }
      function Ec(a3, c3, d3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0;
        j = T;
        T = T + 176 | 0;
        i = j;
        a3 = pb(a3, c3, i) | 0;
        if (a3 | 0) {
          i = a3;
          h = +e2[d3 >> 3];
          h = h * 6371.007180918475;
          h = h * 1e3;
          e2[d3 >> 3] = h;
          T = j;
          return i | 0;
        }
        e2[d3 >> 3] = 0;
        a3 = b2[i >> 2] | 0;
        if ((a3 | 0) <= 1) {
          i = 0;
          h = 0;
          h = h * 6371.007180918475;
          h = h * 1e3;
          e2[d3 >> 3] = h;
          T = j;
          return i | 0;
        }
        c3 = a3 + -1 | 0;
        a3 = 0;
        f2 = +e2[i + 8 >> 3];
        g2 = +e2[i + 16 >> 3];
        h = 0;
        do {
          a3 = a3 + 1 | 0;
          l = f2;
          f2 = +e2[i + 8 + (a3 << 4) >> 3];
          m = +u2(+((f2 - l) * 0.5));
          k = g2;
          g2 = +e2[i + 8 + (a3 << 4) + 8 >> 3];
          k = +u2(+((g2 - k) * 0.5));
          k = m * m + k * (+t(+l) * +t(+f2) * k);
          h = h + +z(+ +r(+k), + +r(+(1 - k))) * 2;
        } while ((a3 | 0) != (c3 | 0));
        e2[d3 >> 3] = h;
        i = 0;
        m = h;
        m = m * 6371.007180918475;
        m = m * 1e3;
        e2[d3 >> 3] = m;
        T = j;
        return i | 0;
      }
      function Fc(a3) {
        a3 = a3 | 0;
        var c3 = 0, d3 = 0, e3 = 0;
        c3 = Id(1, 12) | 0;
        if (!c3) {
          I(27280, 27235, 49, 27293);
        }
        d3 = a3 + 4 | 0;
        e3 = b2[d3 >> 2] | 0;
        if (e3 | 0) {
          e3 = e3 + 8 | 0;
          b2[e3 >> 2] = c3;
          b2[d3 >> 2] = c3;
          return c3 | 0;
        }
        if (b2[a3 >> 2] | 0) {
          I(27310, 27235, 61, 27333);
        }
        e3 = a3;
        b2[e3 >> 2] = c3;
        b2[d3 >> 2] = c3;
        return c3 | 0;
      }
      function Gc(a3, c3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        var d3 = 0, e3 = 0;
        e3 = Gd(24) | 0;
        if (!e3) {
          I(27347, 27235, 78, 27361);
        }
        b2[e3 >> 2] = b2[c3 >> 2];
        b2[e3 + 4 >> 2] = b2[c3 + 4 >> 2];
        b2[e3 + 8 >> 2] = b2[c3 + 8 >> 2];
        b2[e3 + 12 >> 2] = b2[c3 + 12 >> 2];
        b2[e3 + 16 >> 2] = 0;
        c3 = a3 + 4 | 0;
        d3 = b2[c3 >> 2] | 0;
        if (d3 | 0) {
          b2[d3 + 16 >> 2] = e3;
          b2[c3 >> 2] = e3;
          return e3 | 0;
        }
        if (b2[a3 >> 2] | 0) {
          I(27376, 27235, 82, 27361);
        }
        b2[a3 >> 2] = e3;
        b2[c3 >> 2] = e3;
        return e3 | 0;
      }
      function Hc(a3) {
        a3 = a3 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0;
        if (!a3) {
          return;
        }
        e3 = 1;
        while (1) {
          c3 = b2[a3 >> 2] | 0;
          if (c3 | 0) {
            do {
              d3 = b2[c3 >> 2] | 0;
              if (d3 | 0) {
                do {
                  f2 = d3;
                  d3 = b2[d3 + 16 >> 2] | 0;
                  Hd(f2);
                } while ((d3 | 0) != 0);
              }
              f2 = c3;
              c3 = b2[c3 + 8 >> 2] | 0;
              Hd(f2);
            } while ((c3 | 0) != 0);
          }
          c3 = a3;
          a3 = b2[a3 + 8 >> 2] | 0;
          if (!e3) {
            Hd(c3);
          }
          if (!a3) {
            break;
          } else {
            e3 = 0;
          }
        }
        return;
      }
      function Ic(a3) {
        a3 = a3 | 0;
        var c3 = 0, d3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, r2 = 0, s2 = 0, t2 = 0, u3 = 0, v3 = 0, w3 = 0, x2 = 0, y2 = 0, z2 = 0, A3 = 0, B3 = 0, C3 = 0, D3 = 0, E3 = 0, F2 = 0, G3 = 0, H2 = 0, J2 = 0, K2 = 0;
        g2 = a3 + 8 | 0;
        if (b2[g2 >> 2] | 0) {
          K2 = 1;
          return K2 | 0;
        }
        f2 = b2[a3 >> 2] | 0;
        if (!f2) {
          K2 = 0;
          return K2 | 0;
        }
        c3 = f2;
        d3 = 0;
        do {
          d3 = d3 + 1 | 0;
          c3 = b2[c3 + 8 >> 2] | 0;
        } while ((c3 | 0) != 0);
        if (d3 >>> 0 < 2) {
          K2 = 0;
          return K2 | 0;
        }
        H2 = Gd(d3 << 2) | 0;
        if (!H2) {
          I(27396, 27235, 317, 27415);
        }
        G3 = Gd(d3 << 5) | 0;
        if (!G3) {
          I(27437, 27235, 321, 27415);
        }
        b2[a3 >> 2] = 0;
        z2 = a3 + 4 | 0;
        b2[z2 >> 2] = 0;
        b2[g2 >> 2] = 0;
        d3 = 0;
        F2 = 0;
        y2 = 0;
        n = 0;
        a: while (1) {
          m = b2[f2 >> 2] | 0;
          if (m) {
            h = 0;
            i = m;
            do {
              k = +e2[i + 8 >> 3];
              c3 = i;
              i = b2[i + 16 >> 2] | 0;
              l = (i | 0) == 0;
              g2 = l ? m : i;
              j = +e2[g2 + 8 >> 3];
              if (+q(+(k - j)) > 3.141592653589793) {
                K2 = 14;
                break;
              }
              h = h + (j - k) * (+e2[c3 >> 3] + +e2[g2 >> 3]);
            } while (!l);
            if ((K2 | 0) == 14) {
              K2 = 0;
              h = 0;
              c3 = m;
              do {
                x2 = +e2[c3 + 8 >> 3];
                E3 = c3 + 16 | 0;
                D3 = b2[E3 >> 2] | 0;
                D3 = (D3 | 0) == 0 ? m : D3;
                w3 = +e2[D3 + 8 >> 3];
                h = h + (+e2[c3 >> 3] + +e2[D3 >> 3]) * ((w3 < 0 ? w3 + 6.283185307179586 : w3) - (x2 < 0 ? x2 + 6.283185307179586 : x2));
                c3 = b2[((c3 | 0) == 0 ? f2 : E3) >> 2] | 0;
              } while ((c3 | 0) != 0);
            }
            if (h > 0) {
              b2[H2 + (F2 << 2) >> 2] = f2;
              F2 = F2 + 1 | 0;
              g2 = y2;
              c3 = n;
            } else {
              K2 = 19;
            }
          } else {
            K2 = 19;
          }
          if ((K2 | 0) == 19) {
            K2 = 0;
            do {
              if (!d3) {
                if (!n) {
                  if (!(b2[a3 >> 2] | 0)) {
                    g2 = z2;
                    i = a3;
                    c3 = f2;
                    d3 = a3;
                    break;
                  } else {
                    K2 = 27;
                    break a;
                  }
                } else {
                  g2 = z2;
                  i = n + 8 | 0;
                  c3 = f2;
                  d3 = a3;
                  break;
                }
              } else {
                c3 = d3 + 8 | 0;
                if (b2[c3 >> 2] | 0) {
                  K2 = 21;
                  break a;
                }
                d3 = Id(1, 12) | 0;
                if (!d3) {
                  K2 = 23;
                  break a;
                }
                b2[c3 >> 2] = d3;
                g2 = d3 + 4 | 0;
                i = d3;
                c3 = n;
              }
            } while (0);
            b2[i >> 2] = f2;
            b2[g2 >> 2] = f2;
            i = G3 + (y2 << 5) | 0;
            l = b2[f2 >> 2] | 0;
            if (l) {
              m = G3 + (y2 << 5) + 8 | 0;
              e2[m >> 3] = 17976931348623157e292;
              n = G3 + (y2 << 5) + 24 | 0;
              e2[n >> 3] = 17976931348623157e292;
              e2[i >> 3] = -17976931348623157e292;
              o = G3 + (y2 << 5) + 16 | 0;
              e2[o >> 3] = -17976931348623157e292;
              u3 = 17976931348623157e292;
              v3 = -17976931348623157e292;
              g2 = 0;
              p2 = l;
              k = 17976931348623157e292;
              s2 = 17976931348623157e292;
              t2 = -17976931348623157e292;
              j = -17976931348623157e292;
              while (1) {
                h = +e2[p2 >> 3];
                x2 = +e2[p2 + 8 >> 3];
                p2 = b2[p2 + 16 >> 2] | 0;
                r2 = (p2 | 0) == 0;
                w3 = +e2[(r2 ? l : p2) + 8 >> 3];
                if (h < k) {
                  e2[m >> 3] = h;
                  k = h;
                }
                if (x2 < s2) {
                  e2[n >> 3] = x2;
                  s2 = x2;
                }
                if (h > t2) {
                  e2[i >> 3] = h;
                } else {
                  h = t2;
                }
                if (x2 > j) {
                  e2[o >> 3] = x2;
                  j = x2;
                }
                u3 = x2 > 0 & x2 < u3 ? x2 : u3;
                v3 = x2 < 0 & x2 > v3 ? x2 : v3;
                g2 = g2 | +q(+(x2 - w3)) > 3.141592653589793;
                if (r2) {
                  break;
                } else {
                  t2 = h;
                }
              }
              if (g2) {
                e2[o >> 3] = v3;
                e2[n >> 3] = u3;
              }
            } else {
              b2[i >> 2] = 0;
              b2[i + 4 >> 2] = 0;
              b2[i + 8 >> 2] = 0;
              b2[i + 12 >> 2] = 0;
              b2[i + 16 >> 2] = 0;
              b2[i + 20 >> 2] = 0;
              b2[i + 24 >> 2] = 0;
              b2[i + 28 >> 2] = 0;
            }
            g2 = y2 + 1 | 0;
          }
          E3 = f2 + 8 | 0;
          f2 = b2[E3 >> 2] | 0;
          b2[E3 >> 2] = 0;
          if (!f2) {
            K2 = 45;
            break;
          } else {
            y2 = g2;
            n = c3;
          }
        }
        if ((K2 | 0) == 21) {
          I(27213, 27235, 35, 27247);
        } else if ((K2 | 0) == 23) {
          I(27267, 27235, 37, 27247);
        } else if ((K2 | 0) == 27) {
          I(27310, 27235, 61, 27333);
        } else if ((K2 | 0) == 45) {
          b: do {
            if ((F2 | 0) > 0) {
              E3 = (g2 | 0) == 0;
              C3 = g2 << 2;
              D3 = (a3 | 0) == 0;
              B3 = 0;
              c3 = 0;
              while (1) {
                A3 = b2[H2 + (B3 << 2) >> 2] | 0;
                if (!E3) {
                  y2 = Gd(C3) | 0;
                  if (!y2) {
                    K2 = 50;
                    break;
                  }
                  z2 = Gd(C3) | 0;
                  if (!z2) {
                    K2 = 52;
                    break;
                  }
                  c: do {
                    if (!D3) {
                      g2 = 0;
                      d3 = 0;
                      i = a3;
                      while (1) {
                        f2 = G3 + (g2 << 5) | 0;
                        if (Jc(b2[i >> 2] | 0, f2, b2[A3 >> 2] | 0) | 0) {
                          b2[y2 + (d3 << 2) >> 2] = i;
                          b2[z2 + (d3 << 2) >> 2] = f2;
                          r2 = d3 + 1 | 0;
                        } else {
                          r2 = d3;
                        }
                        i = b2[i + 8 >> 2] | 0;
                        if (!i) {
                          break;
                        } else {
                          g2 = g2 + 1 | 0;
                          d3 = r2;
                        }
                      }
                      if ((r2 | 0) > 0) {
                        f2 = b2[y2 >> 2] | 0;
                        if ((r2 | 0) == 1) {
                          d3 = f2;
                        } else {
                          o = 0;
                          p2 = -1;
                          d3 = f2;
                          n = f2;
                          while (1) {
                            l = b2[n >> 2] | 0;
                            f2 = 0;
                            i = 0;
                            while (1) {
                              g2 = b2[b2[y2 + (i << 2) >> 2] >> 2] | 0;
                              if ((g2 | 0) == (l | 0)) {
                                m = f2;
                              } else {
                                m = f2 + ((Jc(g2, b2[z2 + (i << 2) >> 2] | 0, b2[l >> 2] | 0) | 0) & 1) | 0;
                              }
                              i = i + 1 | 0;
                              if ((i | 0) == (r2 | 0)) {
                                break;
                              } else {
                                f2 = m;
                              }
                            }
                            g2 = (m | 0) > (p2 | 0);
                            d3 = g2 ? n : d3;
                            f2 = o + 1 | 0;
                            if ((f2 | 0) == (r2 | 0)) {
                              break c;
                            }
                            o = f2;
                            p2 = g2 ? m : p2;
                            n = b2[y2 + (f2 << 2) >> 2] | 0;
                          }
                        }
                      } else {
                        d3 = 0;
                      }
                    } else {
                      d3 = 0;
                    }
                  } while (0);
                  Hd(y2);
                  Hd(z2);
                  if (d3) {
                    g2 = d3 + 4 | 0;
                    f2 = b2[g2 >> 2] | 0;
                    if (!f2) {
                      if (b2[d3 >> 2] | 0) {
                        K2 = 70;
                        break;
                      }
                    } else {
                      d3 = f2 + 8 | 0;
                    }
                    b2[d3 >> 2] = A3;
                    b2[g2 >> 2] = A3;
                  } else {
                    K2 = 73;
                  }
                } else {
                  K2 = 73;
                }
                if ((K2 | 0) == 73) {
                  K2 = 0;
                  c3 = b2[A3 >> 2] | 0;
                  if (c3 | 0) {
                    do {
                      z2 = c3;
                      c3 = b2[c3 + 16 >> 2] | 0;
                      Hd(z2);
                    } while ((c3 | 0) != 0);
                  }
                  Hd(A3);
                  c3 = 1;
                }
                B3 = B3 + 1 | 0;
                if ((B3 | 0) >= (F2 | 0)) {
                  J2 = c3;
                  break b;
                }
              }
              if ((K2 | 0) == 50) {
                I(27452, 27235, 249, 27471);
              } else if ((K2 | 0) == 52) {
                I(27490, 27235, 252, 27471);
              } else if ((K2 | 0) == 70) {
                I(27310, 27235, 61, 27333);
              }
            } else {
              J2 = 0;
            }
          } while (0);
          Hd(H2);
          Hd(G3);
          K2 = J2;
          return K2 | 0;
        }
        return 0;
      }
      function Jc(a3, c3, d3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0;
        if (!(Ca(c3, d3) | 0)) {
          a3 = 0;
          return a3 | 0;
        }
        c3 = Aa(c3) | 0;
        f2 = +e2[d3 >> 3];
        g2 = +e2[d3 + 8 >> 3];
        g2 = c3 & g2 < 0 ? g2 + 6.283185307179586 : g2;
        a3 = b2[a3 >> 2] | 0;
        if (!a3) {
          a3 = 0;
          return a3 | 0;
        }
        if (c3) {
          c3 = 0;
          l = g2;
          d3 = a3;
          a: while (1) {
            while (1) {
              i = +e2[d3 >> 3];
              g2 = +e2[d3 + 8 >> 3];
              d3 = d3 + 16 | 0;
              m = b2[d3 >> 2] | 0;
              m = (m | 0) == 0 ? a3 : m;
              h = +e2[m >> 3];
              j = +e2[m + 8 >> 3];
              if (i > h) {
                k = i;
                i = j;
              } else {
                k = h;
                h = i;
                i = g2;
                g2 = j;
              }
              f2 = f2 == h | f2 == k ? f2 + 2220446049250313e-31 : f2;
              if (!(f2 < h | f2 > k)) {
                break;
              }
              d3 = b2[d3 >> 2] | 0;
              if (!d3) {
                d3 = 22;
                break a;
              }
            }
            j = i < 0 ? i + 6.283185307179586 : i;
            i = g2 < 0 ? g2 + 6.283185307179586 : g2;
            l = j == l | i == l ? l + -2220446049250313e-31 : l;
            k = j + (i - j) * ((f2 - h) / (k - h));
            if ((k < 0 ? k + 6.283185307179586 : k) > l) {
              c3 = c3 ^ 1;
            }
            d3 = b2[d3 >> 2] | 0;
            if (!d3) {
              d3 = 22;
              break;
            }
          }
          if ((d3 | 0) == 22) {
            return c3 | 0;
          }
        } else {
          c3 = 0;
          l = g2;
          d3 = a3;
          b: while (1) {
            while (1) {
              i = +e2[d3 >> 3];
              g2 = +e2[d3 + 8 >> 3];
              d3 = d3 + 16 | 0;
              m = b2[d3 >> 2] | 0;
              m = (m | 0) == 0 ? a3 : m;
              h = +e2[m >> 3];
              j = +e2[m + 8 >> 3];
              if (i > h) {
                k = i;
                i = j;
              } else {
                k = h;
                h = i;
                i = g2;
                g2 = j;
              }
              f2 = f2 == h | f2 == k ? f2 + 2220446049250313e-31 : f2;
              if (!(f2 < h | f2 > k)) {
                break;
              }
              d3 = b2[d3 >> 2] | 0;
              if (!d3) {
                d3 = 22;
                break b;
              }
            }
            l = i == l | g2 == l ? l + -2220446049250313e-31 : l;
            if (i + (g2 - i) * ((f2 - h) / (k - h)) > l) {
              c3 = c3 ^ 1;
            }
            d3 = b2[d3 >> 2] | 0;
            if (!d3) {
              d3 = 22;
              break;
            }
          }
          if ((d3 | 0) == 22) {
            return c3 | 0;
          }
        }
        return 0;
      }
      function Kc(c3, d3, e3, f2, g2) {
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t2 = 0, u3 = 0;
        u3 = T;
        T = T + 32 | 0;
        t2 = u3 + 16 | 0;
        s2 = u3;
        h = Td(c3 | 0, d3 | 0, 52) | 0;
        H() | 0;
        h = h & 15;
        p2 = Td(e3 | 0, f2 | 0, 52) | 0;
        H() | 0;
        if ((h | 0) != (p2 & 15 | 0)) {
          t2 = 12;
          T = u3;
          return t2 | 0;
        }
        l = Td(c3 | 0, d3 | 0, 45) | 0;
        H() | 0;
        l = l & 127;
        m = Td(e3 | 0, f2 | 0, 45) | 0;
        H() | 0;
        m = m & 127;
        if (l >>> 0 > 121 | m >>> 0 > 121) {
          t2 = 5;
          T = u3;
          return t2 | 0;
        }
        p2 = (l | 0) != (m | 0);
        if (p2) {
          j = wa(l, m) | 0;
          if ((j | 0) == 7) {
            t2 = 1;
            T = u3;
            return t2 | 0;
          }
          k = wa(m, l) | 0;
          if ((k | 0) == 7) {
            I(27514, 27538, 161, 27548);
          } else {
            q2 = j;
            i = k;
          }
        } else {
          q2 = 0;
          i = 0;
        }
        n = oa(l) | 0;
        o = oa(m) | 0;
        b2[t2 >> 2] = 0;
        b2[t2 + 4 >> 2] = 0;
        b2[t2 + 8 >> 2] = 0;
        b2[t2 + 12 >> 2] = 0;
        do {
          if (!q2) {
            _b(e3, f2, t2) | 0;
            if ((n | 0) != 0 & (o | 0) != 0) {
              if ((m | 0) != (l | 0)) {
                I(27621, 27538, 261, 27548);
              }
              i = Sb(c3, d3) | 0;
              h = Sb(e3, f2) | 0;
              if (!((i | 0) == 7 | (h | 0) == 7)) {
                if (!(a2[22e3 + (i * 7 | 0) + h >> 0] | 0)) {
                  i = b2[21168 + (i * 28 | 0) + (h << 2) >> 2] | 0;
                  if ((i | 0) > 0) {
                    j = t2 + 4 | 0;
                    h = 0;
                    do {
                      _a(j);
                      h = h + 1 | 0;
                    } while ((h | 0) != (i | 0));
                    r2 = 51;
                  } else {
                    r2 = 51;
                  }
                } else {
                  h = 1;
                }
              } else {
                h = 5;
              }
            } else {
              r2 = 51;
            }
          } else {
            m = b2[4272 + (l * 28 | 0) + (q2 << 2) >> 2] | 0;
            j = (m | 0) > 0;
            if (!o) {
              if (j) {
                l = 0;
                k = e3;
                j = f2;
                do {
                  k = Wb(k, j) | 0;
                  j = H() | 0;
                  i = ab(i) | 0;
                  l = l + 1 | 0;
                } while ((l | 0) != (m | 0));
                m = i;
                l = k;
                k = j;
              } else {
                m = i;
                l = e3;
                k = f2;
              }
            } else if (j) {
              l = 0;
              k = e3;
              j = f2;
              do {
                k = Vb(k, j) | 0;
                j = H() | 0;
                i = ab(i) | 0;
                if ((i | 0) == 1) {
                  i = ab(1) | 0;
                }
                l = l + 1 | 0;
              } while ((l | 0) != (m | 0));
              m = i;
              l = k;
              k = j;
            } else {
              m = i;
              l = e3;
              k = f2;
            }
            _b(l, k, t2) | 0;
            if (!p2) {
              I(27563, 27538, 191, 27548);
            }
            j = (n | 0) != 0;
            i = (o | 0) != 0;
            if (j & i) {
              I(27590, 27538, 192, 27548);
            }
            if (!j) {
              if (i) {
                i = Sb(l, k) | 0;
                if ((i | 0) == 7) {
                  h = 5;
                  break;
                }
                if (a2[22e3 + (i * 7 | 0) + m >> 0] | 0) {
                  h = 1;
                  break;
                }
                l = 0;
                k = b2[21168 + (m * 28 | 0) + (i << 2) >> 2] | 0;
              } else {
                l = 0;
                k = 0;
              }
            } else {
              i = Sb(c3, d3) | 0;
              if ((i | 0) == 7) {
                h = 5;
                break;
              }
              if (a2[22e3 + (i * 7 | 0) + q2 >> 0] | 0) {
                h = 1;
                break;
              }
              k = b2[21168 + (i * 28 | 0) + (q2 << 2) >> 2] | 0;
              l = k;
            }
            if ((l | k | 0) < 0) {
              h = 5;
            } else {
              if ((k | 0) > 0) {
                j = t2 + 4 | 0;
                i = 0;
                do {
                  _a(j);
                  i = i + 1 | 0;
                } while ((i | 0) != (k | 0));
              }
              b2[s2 >> 2] = 0;
              b2[s2 + 4 >> 2] = 0;
              b2[s2 + 8 >> 2] = 0;
              Ya(s2, q2);
              if (h | 0) {
                while (1) {
                  if (!(Yb(h) | 0)) {
                    Xa(s2);
                  } else {
                    Wa(s2);
                  }
                  if ((h | 0) > 1) {
                    h = h + -1 | 0;
                  } else {
                    break;
                  }
                }
              }
              if ((l | 0) > 0) {
                h = 0;
                do {
                  _a(s2);
                  h = h + 1 | 0;
                } while ((h | 0) != (l | 0));
              }
              r2 = t2 + 4 | 0;
              Oa(r2, s2, r2);
              Ma(r2);
              r2 = 51;
            }
          }
        } while (0);
        if ((r2 | 0) == 51) {
          h = t2 + 4 | 0;
          b2[g2 >> 2] = b2[h >> 2];
          b2[g2 + 4 >> 2] = b2[h + 4 >> 2];
          b2[g2 + 8 >> 2] = b2[h + 8 >> 2];
          h = 0;
        }
        t2 = h;
        T = u3;
        return t2 | 0;
      }
      function Lc(a3, c3, d3, e3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t2 = 0, u3 = 0;
        q2 = T;
        T = T + 48 | 0;
        k = q2 + 36 | 0;
        h = q2 + 24 | 0;
        i = q2 + 12 | 0;
        j = q2;
        f2 = Td(a3 | 0, c3 | 0, 52) | 0;
        H() | 0;
        f2 = f2 & 15;
        n = Td(a3 | 0, c3 | 0, 45) | 0;
        H() | 0;
        n = n & 127;
        if (n >>> 0 > 121) {
          e3 = 5;
          T = q2;
          return e3 | 0;
        }
        l = oa(n) | 0;
        Ud(f2 | 0, 0, 52) | 0;
        r2 = H() | 0 | 134225919;
        g2 = e3;
        b2[g2 >> 2] = -1;
        b2[g2 + 4 >> 2] = r2;
        if (!f2) {
          f2 = Ra(d3) | 0;
          if ((f2 | 0) == 7) {
            r2 = 1;
            T = q2;
            return r2 | 0;
          }
          f2 = va(n, f2) | 0;
          if ((f2 | 0) == 127) {
            r2 = 1;
            T = q2;
            return r2 | 0;
          }
          o = Ud(f2 | 0, 0, 45) | 0;
          p2 = H() | 0;
          n = e3;
          p2 = b2[n + 4 >> 2] & -1040385 | p2;
          r2 = e3;
          b2[r2 >> 2] = b2[n >> 2] | o;
          b2[r2 + 4 >> 2] = p2;
          r2 = 0;
          T = q2;
          return r2 | 0;
        }
        b2[k >> 2] = b2[d3 >> 2];
        b2[k + 4 >> 2] = b2[d3 + 4 >> 2];
        b2[k + 8 >> 2] = b2[d3 + 8 >> 2];
        d3 = f2;
        while (1) {
          g2 = d3;
          d3 = d3 + -1 | 0;
          b2[h >> 2] = b2[k >> 2];
          b2[h + 4 >> 2] = b2[k + 4 >> 2];
          b2[h + 8 >> 2] = b2[k + 8 >> 2];
          if (!(Yb(g2) | 0)) {
            f2 = Ta(k) | 0;
            if (f2 | 0) {
              d3 = 13;
              break;
            }
            b2[i >> 2] = b2[k >> 2];
            b2[i + 4 >> 2] = b2[k + 4 >> 2];
            b2[i + 8 >> 2] = b2[k + 8 >> 2];
            Xa(i);
          } else {
            f2 = Sa(k) | 0;
            if (f2 | 0) {
              d3 = 13;
              break;
            }
            b2[i >> 2] = b2[k >> 2];
            b2[i + 4 >> 2] = b2[k + 4 >> 2];
            b2[i + 8 >> 2] = b2[k + 8 >> 2];
            Wa(i);
          }
          Pa(h, i, j);
          Ma(j);
          f2 = e3;
          t2 = b2[f2 >> 2] | 0;
          f2 = b2[f2 + 4 >> 2] | 0;
          u3 = (15 - g2 | 0) * 3 | 0;
          s2 = Ud(7, 0, u3 | 0) | 0;
          f2 = f2 & ~(H() | 0);
          u3 = Ud(Ra(j) | 0, 0, u3 | 0) | 0;
          f2 = H() | 0 | f2;
          r2 = e3;
          b2[r2 >> 2] = u3 | t2 & ~s2;
          b2[r2 + 4 >> 2] = f2;
          if ((g2 | 0) <= 1) {
            d3 = 14;
            break;
          }
        }
        a: do {
          if ((d3 | 0) != 13) {
            if ((d3 | 0) == 14) {
              if (((b2[k >> 2] | 0) <= 1 ? (b2[k + 4 >> 2] | 0) <= 1 : 0) ? (b2[k + 8 >> 2] | 0) <= 1 : 0) {
                d3 = Ra(k) | 0;
                f2 = va(n, d3) | 0;
                if ((f2 | 0) == 127) {
                  j = 0;
                } else {
                  j = oa(f2) | 0;
                }
                b: do {
                  if (!d3) {
                    if ((l | 0) != 0 & (j | 0) != 0) {
                      d3 = Sb(a3, c3) | 0;
                      g2 = e3;
                      g2 = Sb(b2[g2 >> 2] | 0, b2[g2 + 4 >> 2] | 0) | 0;
                      if ((d3 | 0) == 7 | (g2 | 0) == 7) {
                        f2 = 5;
                        break a;
                      }
                      g2 = b2[21376 + (d3 * 28 | 0) + (g2 << 2) >> 2] | 0;
                      if ((g2 | 0) < 0) {
                        f2 = 5;
                        break a;
                      }
                      if (!g2) {
                        d3 = 59;
                      } else {
                        i = e3;
                        d3 = 0;
                        h = b2[i >> 2] | 0;
                        i = b2[i + 4 >> 2] | 0;
                        do {
                          h = Ub(h, i) | 0;
                          i = H() | 0;
                          u3 = e3;
                          b2[u3 >> 2] = h;
                          b2[u3 + 4 >> 2] = i;
                          d3 = d3 + 1 | 0;
                        } while ((d3 | 0) < (g2 | 0));
                        d3 = 58;
                      }
                    } else {
                      d3 = 58;
                    }
                  } else {
                    if (l) {
                      f2 = Sb(a3, c3) | 0;
                      if ((f2 | 0) == 7) {
                        f2 = 5;
                        break a;
                      }
                      g2 = b2[21376 + (f2 * 28 | 0) + (d3 << 2) >> 2] | 0;
                      if ((g2 | 0) > 0) {
                        f2 = d3;
                        d3 = 0;
                        do {
                          f2 = $a(f2) | 0;
                          d3 = d3 + 1 | 0;
                        } while ((d3 | 0) != (g2 | 0));
                      } else {
                        f2 = d3;
                      }
                      if ((f2 | 0) == 1) {
                        f2 = 9;
                        break a;
                      }
                      d3 = va(n, f2) | 0;
                      if ((d3 | 0) == 127) {
                        I(27648, 27538, 411, 27678);
                      }
                      if (!(oa(d3) | 0)) {
                        p2 = d3;
                        o = g2;
                        m = f2;
                      } else {
                        I(27693, 27538, 412, 27678);
                      }
                    } else {
                      p2 = f2;
                      o = 0;
                      m = d3;
                    }
                    i = b2[4272 + (n * 28 | 0) + (m << 2) >> 2] | 0;
                    if ((i | 0) <= -1) {
                      I(27724, 27538, 419, 27678);
                    }
                    if (!j) {
                      if ((o | 0) < 0) {
                        f2 = 5;
                        break a;
                      }
                      if (o | 0) {
                        g2 = e3;
                        f2 = 0;
                        d3 = b2[g2 >> 2] | 0;
                        g2 = b2[g2 + 4 >> 2] | 0;
                        do {
                          d3 = Ub(d3, g2) | 0;
                          g2 = H() | 0;
                          u3 = e3;
                          b2[u3 >> 2] = d3;
                          b2[u3 + 4 >> 2] = g2;
                          f2 = f2 + 1 | 0;
                        } while ((f2 | 0) < (o | 0));
                      }
                      if ((i | 0) <= 0) {
                        f2 = p2;
                        d3 = 58;
                        break;
                      }
                      g2 = e3;
                      f2 = 0;
                      d3 = b2[g2 >> 2] | 0;
                      g2 = b2[g2 + 4 >> 2] | 0;
                      while (1) {
                        d3 = Ub(d3, g2) | 0;
                        g2 = H() | 0;
                        u3 = e3;
                        b2[u3 >> 2] = d3;
                        b2[u3 + 4 >> 2] = g2;
                        f2 = f2 + 1 | 0;
                        if ((f2 | 0) == (i | 0)) {
                          f2 = p2;
                          d3 = 58;
                          break b;
                        }
                      }
                    }
                    h = wa(p2, n) | 0;
                    if ((h | 0) == 7) {
                      I(27514, 27538, 428, 27678);
                    }
                    f2 = e3;
                    d3 = b2[f2 >> 2] | 0;
                    f2 = b2[f2 + 4 >> 2] | 0;
                    if ((i | 0) > 0) {
                      g2 = 0;
                      do {
                        d3 = Ub(d3, f2) | 0;
                        f2 = H() | 0;
                        u3 = e3;
                        b2[u3 >> 2] = d3;
                        b2[u3 + 4 >> 2] = f2;
                        g2 = g2 + 1 | 0;
                      } while ((g2 | 0) != (i | 0));
                    }
                    f2 = Sb(d3, f2) | 0;
                    if ((f2 | 0) == 7) {
                      I(27795, 27538, 440, 27678);
                    }
                    d3 = pa(p2) | 0;
                    d3 = b2[(d3 ? 21792 : 21584) + (h * 28 | 0) + (f2 << 2) >> 2] | 0;
                    if ((d3 | 0) < 0) {
                      I(27795, 27538, 454, 27678);
                    }
                    if (!d3) {
                      f2 = p2;
                      d3 = 58;
                    } else {
                      h = e3;
                      f2 = 0;
                      g2 = b2[h >> 2] | 0;
                      h = b2[h + 4 >> 2] | 0;
                      do {
                        g2 = Tb(g2, h) | 0;
                        h = H() | 0;
                        u3 = e3;
                        b2[u3 >> 2] = g2;
                        b2[u3 + 4 >> 2] = h;
                        f2 = f2 + 1 | 0;
                      } while ((f2 | 0) < (d3 | 0));
                      f2 = p2;
                      d3 = 58;
                    }
                  }
                } while (0);
                if ((d3 | 0) == 58) {
                  if (j) {
                    d3 = 59;
                  }
                }
                if ((d3 | 0) == 59) {
                  u3 = e3;
                  if ((Sb(b2[u3 >> 2] | 0, b2[u3 + 4 >> 2] | 0) | 0) == 1) {
                    f2 = 9;
                    break;
                  }
                }
                u3 = e3;
                s2 = b2[u3 >> 2] | 0;
                u3 = b2[u3 + 4 >> 2] & -1040385;
                t2 = Ud(f2 | 0, 0, 45) | 0;
                u3 = u3 | (H() | 0);
                f2 = e3;
                b2[f2 >> 2] = s2 | t2;
                b2[f2 + 4 >> 2] = u3;
                f2 = 0;
              } else {
                f2 = 1;
              }
            }
          }
        } while (0);
        u3 = f2;
        T = q2;
        return u3 | 0;
      }
      function Mc(a3, b3, c3, d3, e3, f2) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0;
        h = T;
        T = T + 16 | 0;
        g2 = h;
        if (!e3) {
          a3 = Kc(a3, b3, c3, d3, g2) | 0;
          if (!a3) {
            eb(g2, f2);
            a3 = 0;
          }
        } else {
          a3 = 15;
        }
        T = h;
        return a3 | 0;
      }
      function Nc(a3, b3, c3, d3, e3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0;
        g2 = T;
        T = T + 16 | 0;
        f2 = g2;
        if (!d3) {
          c3 = fb(c3, f2) | 0;
          if (!c3) {
            c3 = Lc(a3, b3, f2, e3) | 0;
          }
        } else {
          c3 = 15;
        }
        T = g2;
        return c3 | 0;
      }
      function Oc(a3, c3, d3, e3, f2) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0;
        j = T;
        T = T + 32 | 0;
        h = j + 12 | 0;
        i = j;
        g2 = Kc(a3, c3, a3, c3, h) | 0;
        if (g2 | 0) {
          i = g2;
          T = j;
          return i | 0;
        }
        a3 = Kc(a3, c3, d3, e3, i) | 0;
        if (a3 | 0) {
          i = a3;
          T = j;
          return i | 0;
        }
        h = db(h, i) | 0;
        i = f2;
        b2[i >> 2] = h;
        b2[i + 4 >> 2] = ((h | 0) < 0) << 31 >> 31;
        i = 0;
        T = j;
        return i | 0;
      }
      function Pc(a3, c3, d3, e3, f2) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0;
        j = T;
        T = T + 32 | 0;
        h = j + 12 | 0;
        i = j;
        g2 = Kc(a3, c3, a3, c3, h) | 0;
        if (!g2) {
          g2 = Kc(a3, c3, d3, e3, i) | 0;
          if (!g2) {
            e3 = db(h, i) | 0;
            e3 = Jd(e3 | 0, ((e3 | 0) < 0) << 31 >> 31 | 0, 1, 0) | 0;
            h = H() | 0;
            i = f2;
            b2[i >> 2] = e3;
            b2[i + 4 >> 2] = h;
            i = 0;
            T = j;
            return i | 0;
          }
        }
        i = g2;
        T = j;
        return i | 0;
      }
      function Qc(a3, c3, d3, e3, f2) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, r2 = 0, s2 = 0, t2 = 0, u3 = 0, v3 = 0, w3 = 0, x2 = 0, y2 = 0, z2 = 0, A3 = 0;
        z2 = T;
        T = T + 48 | 0;
        x2 = z2 + 24 | 0;
        h = z2 + 12 | 0;
        y2 = z2;
        g2 = Kc(a3, c3, a3, c3, x2) | 0;
        if (!g2) {
          g2 = Kc(a3, c3, d3, e3, h) | 0;
          if (!g2) {
            v3 = db(x2, h) | 0;
            w3 = ((v3 | 0) < 0) << 31 >> 31;
            b2[x2 >> 2] = 0;
            b2[x2 + 4 >> 2] = 0;
            b2[x2 + 8 >> 2] = 0;
            b2[h >> 2] = 0;
            b2[h + 4 >> 2] = 0;
            b2[h + 8 >> 2] = 0;
            if (Kc(a3, c3, a3, c3, x2) | 0) {
              I(27795, 27538, 692, 27747);
            }
            if (Kc(a3, c3, d3, e3, h) | 0) {
              I(27795, 27538, 697, 27747);
            }
            gb(x2);
            gb(h);
            l = (v3 | 0) == 0 ? 0 : 1 / +(v3 | 0);
            d3 = b2[x2 >> 2] | 0;
            r2 = l * +((b2[h >> 2] | 0) - d3 | 0);
            s2 = x2 + 4 | 0;
            e3 = b2[s2 >> 2] | 0;
            t2 = l * +((b2[h + 4 >> 2] | 0) - e3 | 0);
            u3 = x2 + 8 | 0;
            g2 = b2[u3 >> 2] | 0;
            l = l * +((b2[h + 8 >> 2] | 0) - g2 | 0);
            b2[y2 >> 2] = d3;
            m = y2 + 4 | 0;
            b2[m >> 2] = e3;
            n = y2 + 8 | 0;
            b2[n >> 2] = g2;
            a: do {
              if ((v3 | 0) < 0) {
                g2 = 0;
              } else {
                o = 0;
                p2 = 0;
                while (1) {
                  j = +(p2 >>> 0) + 4294967296 * +(o | 0);
                  A3 = r2 * j + +(d3 | 0);
                  i = t2 * j + +(e3 | 0);
                  j = l * j + +(g2 | 0);
                  d3 = ~~+Yd(+A3);
                  h = ~~+Yd(+i);
                  g2 = ~~+Yd(+j);
                  A3 = +q(+(+(d3 | 0) - A3));
                  i = +q(+(+(h | 0) - i));
                  j = +q(+(+(g2 | 0) - j));
                  do {
                    if (!(A3 > i & A3 > j)) {
                      k = 0 - d3 | 0;
                      if (i > j) {
                        e3 = k - g2 | 0;
                        break;
                      } else {
                        e3 = h;
                        g2 = k - h | 0;
                        break;
                      }
                    } else {
                      d3 = 0 - (h + g2) | 0;
                      e3 = h;
                    }
                  } while (0);
                  b2[y2 >> 2] = d3;
                  b2[m >> 2] = e3;
                  b2[n >> 2] = g2;
                  hb(y2);
                  g2 = Lc(a3, c3, y2, f2 + (p2 << 3) | 0) | 0;
                  if (g2 | 0) {
                    break a;
                  }
                  if (!((o | 0) < (w3 | 0) | (o | 0) == (w3 | 0) & p2 >>> 0 < v3 >>> 0)) {
                    g2 = 0;
                    break a;
                  }
                  d3 = Jd(p2 | 0, o | 0, 1, 0) | 0;
                  e3 = H() | 0;
                  o = e3;
                  p2 = d3;
                  d3 = b2[x2 >> 2] | 0;
                  e3 = b2[s2 >> 2] | 0;
                  g2 = b2[u3 >> 2] | 0;
                }
              }
            } while (0);
            y2 = g2;
            T = z2;
            return y2 | 0;
          }
        }
        y2 = g2;
        T = z2;
        return y2 | 0;
      }
      function Rc(a3, b3, c3, d3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0, g2 = 0;
        if ((c3 | 0) == 0 & (d3 | 0) == 0) {
          e3 = 0;
          f2 = 1;
          G2(e3 | 0);
          return f2 | 0;
        }
        f2 = a3;
        e3 = b3;
        a3 = 1;
        b3 = 0;
        do {
          g2 = (c3 & 1 | 0) == 0 & true;
          a3 = Pd((g2 ? 1 : f2) | 0, (g2 ? 0 : e3) | 0, a3 | 0, b3 | 0) | 0;
          b3 = H() | 0;
          c3 = Sd(c3 | 0, d3 | 0, 1) | 0;
          d3 = H() | 0;
          f2 = Pd(f2 | 0, e3 | 0, f2 | 0, e3 | 0) | 0;
          e3 = H() | 0;
        } while (!((c3 | 0) == 0 & (d3 | 0) == 0));
        G2(b3 | 0);
        return a3 | 0;
      }
      function Sc(a3, c3, d3, f2) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0;
        j = T;
        T = T + 16 | 0;
        h = j;
        i = Td(a3 | 0, c3 | 0, 52) | 0;
        H() | 0;
        i = i & 15;
        do {
          if (!i) {
            g2 = Td(a3 | 0, c3 | 0, 45) | 0;
            H() | 0;
            g2 = g2 & 127;
            if (g2 >>> 0 > 121) {
              i = 5;
              T = j;
              return i | 0;
            } else {
              h = 22064 + (g2 << 5) | 0;
              b2[d3 >> 2] = b2[h >> 2];
              b2[d3 + 4 >> 2] = b2[h + 4 >> 2];
              b2[d3 + 8 >> 2] = b2[h + 8 >> 2];
              b2[d3 + 12 >> 2] = b2[h + 12 >> 2];
              b2[d3 + 16 >> 2] = b2[h + 16 >> 2];
              b2[d3 + 20 >> 2] = b2[h + 20 >> 2];
              b2[d3 + 24 >> 2] = b2[h + 24 >> 2];
              b2[d3 + 28 >> 2] = b2[h + 28 >> 2];
              break;
            }
          } else {
            g2 = ac(a3, c3, h) | 0;
            if (!g2) {
              l = +e2[h >> 3];
              k = 1 / +t(+l);
              m = +e2[25968 + (i << 3) >> 3];
              e2[d3 >> 3] = l + m;
              e2[d3 + 8 >> 3] = l - m;
              l = +e2[h + 8 >> 3];
              k = m * k;
              e2[d3 + 16 >> 3] = k + l;
              e2[d3 + 24 >> 3] = l - k;
              break;
            }
            i = g2;
            T = j;
            return i | 0;
          }
        } while (0);
        Ja(d3, f2 ? 1.4 : 1.1);
        f2 = 26096 + (i << 3) | 0;
        if ((b2[f2 >> 2] | 0) == (a3 | 0) ? (b2[f2 + 4 >> 2] | 0) == (c3 | 0) : 0) {
          e2[d3 >> 3] = 1.5707963267948966;
        }
        i = 26224 + (i << 3) | 0;
        if ((b2[i >> 2] | 0) == (a3 | 0) ? (b2[i + 4 >> 2] | 0) == (c3 | 0) : 0) {
          e2[d3 + 8 >> 3] = -1.5707963267948966;
        }
        if (!(+e2[d3 >> 3] == 1.5707963267948966) ? !(+e2[d3 + 8 >> 3] == -1.5707963267948966) : 0) {
          i = 0;
          T = j;
          return i | 0;
        }
        e2[d3 + 16 >> 3] = 3.141592653589793;
        e2[d3 + 24 >> 3] = -3.141592653589793;
        i = 0;
        T = j;
        return i | 0;
      }
      function Tc(c3, d3, e3, f2) {
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0;
        l = T;
        T = T + 48 | 0;
        i = l + 32 | 0;
        h = l + 40 | 0;
        j = l;
        Hb(i, 0, 0, 0);
        k = b2[i >> 2] | 0;
        i = b2[i + 4 >> 2] | 0;
        do {
          if (e3 >>> 0 <= 15) {
            g2 = _c(f2) | 0;
            if (g2 | 0) {
              f2 = j;
              b2[f2 >> 2] = 0;
              b2[f2 + 4 >> 2] = 0;
              b2[j + 8 >> 2] = g2;
              b2[j + 12 >> 2] = -1;
              f2 = j + 16 | 0;
              k = j + 29 | 0;
              b2[f2 >> 2] = 0;
              b2[f2 + 4 >> 2] = 0;
              b2[f2 + 8 >> 2] = 0;
              a2[f2 + 12 >> 0] = 0;
              a2[k >> 0] = a2[h >> 0] | 0;
              a2[k + 1 >> 0] = a2[h + 1 >> 0] | 0;
              a2[k + 2 >> 0] = a2[h + 2 >> 0] | 0;
              break;
            }
            g2 = Id((b2[d3 + 8 >> 2] | 0) + 1 | 0, 32) | 0;
            if (!g2) {
              f2 = j;
              b2[f2 >> 2] = 0;
              b2[f2 + 4 >> 2] = 0;
              b2[j + 8 >> 2] = 13;
              b2[j + 12 >> 2] = -1;
              f2 = j + 16 | 0;
              k = j + 29 | 0;
              b2[f2 >> 2] = 0;
              b2[f2 + 4 >> 2] = 0;
              b2[f2 + 8 >> 2] = 0;
              a2[f2 + 12 >> 0] = 0;
              a2[k >> 0] = a2[h >> 0] | 0;
              a2[k + 1 >> 0] = a2[h + 1 >> 0] | 0;
              a2[k + 2 >> 0] = a2[h + 2 >> 0] | 0;
              break;
            } else {
              $c(d3, g2);
              m = j;
              b2[m >> 2] = k;
              b2[m + 4 >> 2] = i;
              b2[j + 8 >> 2] = 0;
              b2[j + 12 >> 2] = e3;
              b2[j + 16 >> 2] = f2;
              b2[j + 20 >> 2] = d3;
              b2[j + 24 >> 2] = g2;
              a2[j + 28 >> 0] = 0;
              k = j + 29 | 0;
              a2[k >> 0] = a2[h >> 0] | 0;
              a2[k + 1 >> 0] = a2[h + 1 >> 0] | 0;
              a2[k + 2 >> 0] = a2[h + 2 >> 0] | 0;
              break;
            }
          } else {
            k = j;
            b2[k >> 2] = 0;
            b2[k + 4 >> 2] = 0;
            b2[j + 8 >> 2] = 4;
            b2[j + 12 >> 2] = -1;
            k = j + 16 | 0;
            m = j + 29 | 0;
            b2[k >> 2] = 0;
            b2[k + 4 >> 2] = 0;
            b2[k + 8 >> 2] = 0;
            a2[k + 12 >> 0] = 0;
            a2[m >> 0] = a2[h >> 0] | 0;
            a2[m + 1 >> 0] = a2[h + 1 >> 0] | 0;
            a2[m + 2 >> 0] = a2[h + 2 >> 0] | 0;
          }
        } while (0);
        Uc(j);
        b2[c3 >> 2] = b2[j >> 2];
        b2[c3 + 4 >> 2] = b2[j + 4 >> 2];
        b2[c3 + 8 >> 2] = b2[j + 8 >> 2];
        b2[c3 + 12 >> 2] = b2[j + 12 >> 2];
        b2[c3 + 16 >> 2] = b2[j + 16 >> 2];
        b2[c3 + 20 >> 2] = b2[j + 20 >> 2];
        b2[c3 + 24 >> 2] = b2[j + 24 >> 2];
        b2[c3 + 28 >> 2] = b2[j + 28 >> 2];
        T = l;
        return;
      }
      function Uc(c3) {
        c3 = c3 | 0;
        var d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t2 = 0, u3 = 0, v3 = 0, w3 = 0;
        w3 = T;
        T = T + 336 | 0;
        p2 = w3 + 168 | 0;
        q2 = w3;
        f2 = c3;
        e3 = b2[f2 >> 2] | 0;
        f2 = b2[f2 + 4 >> 2] | 0;
        if ((e3 | 0) == 0 & (f2 | 0) == 0) {
          T = w3;
          return;
        }
        d3 = c3 + 28 | 0;
        if (!(a2[d3 >> 0] | 0)) {
          a2[d3 >> 0] = 1;
        } else {
          e3 = Vc(e3, f2) | 0;
          f2 = H() | 0;
        }
        v3 = c3 + 20 | 0;
        if (!(b2[b2[v3 >> 2] >> 2] | 0)) {
          d3 = c3 + 24 | 0;
          e3 = b2[d3 >> 2] | 0;
          if (e3 | 0) {
            Hd(e3);
          }
          u3 = c3;
          b2[u3 >> 2] = 0;
          b2[u3 + 4 >> 2] = 0;
          b2[c3 + 8 >> 2] = 0;
          b2[v3 >> 2] = 0;
          b2[c3 + 12 >> 2] = -1;
          b2[c3 + 16 >> 2] = 0;
          b2[d3 >> 2] = 0;
          T = w3;
          return;
        }
        u3 = c3 + 16 | 0;
        d3 = b2[u3 >> 2] | 0;
        g2 = d3 & 15;
        a: do {
          if (!((e3 | 0) == 0 & (f2 | 0) == 0)) {
            r2 = c3 + 12 | 0;
            n = (g2 | 0) == 3;
            m = d3 & 255;
            k = (g2 | 1 | 0) == 3;
            o = c3 + 24 | 0;
            l = (g2 + -1 | 0) >>> 0 < 3;
            i = (g2 | 2 | 0) == 3;
            j = q2 + 8 | 0;
            b: while (1) {
              h = Td(e3 | 0, f2 | 0, 52) | 0;
              H() | 0;
              h = h & 15;
              if ((h | 0) == (b2[r2 >> 2] | 0)) {
                switch (m & 15) {
                  case 0:
                  case 2:
                  case 3: {
                    g2 = ac(e3, f2, p2) | 0;
                    if (g2 | 0) {
                      s2 = 15;
                      break b;
                    }
                    if (ad(b2[v3 >> 2] | 0, b2[o >> 2] | 0, p2) | 0) {
                      s2 = 19;
                      break b;
                    }
                    break;
                  }
                  default:
                }
                if (k ? (g2 = b2[(b2[v3 >> 2] | 0) + 4 >> 2] | 0, b2[p2 >> 2] = b2[g2 >> 2], b2[p2 + 4 >> 2] = b2[g2 + 4 >> 2], b2[p2 + 8 >> 2] = b2[g2 + 8 >> 2], b2[p2 + 12 >> 2] = b2[g2 + 12 >> 2], Ca(26832, p2) | 0) : 0) {
                  if (Zb(b2[(b2[v3 >> 2] | 0) + 4 >> 2] | 0, h, q2) | 0) {
                    s2 = 25;
                    break;
                  }
                  g2 = q2;
                  if ((b2[g2 >> 2] | 0) == (e3 | 0) ? (b2[g2 + 4 >> 2] | 0) == (f2 | 0) : 0) {
                    s2 = 29;
                    break;
                  }
                }
                if (l) {
                  g2 = bc(e3, f2, p2) | 0;
                  if (g2 | 0) {
                    s2 = 32;
                    break;
                  }
                  if (Sc(e3, f2, q2, 0) | 0) {
                    s2 = 36;
                    break;
                  }
                  if (i ? bd(b2[v3 >> 2] | 0, b2[o >> 2] | 0, p2, q2) | 0 : 0) {
                    s2 = 42;
                    break;
                  }
                  if (k ? dd(b2[v3 >> 2] | 0, b2[o >> 2] | 0, p2, q2) | 0 : 0) {
                    s2 = 42;
                    break;
                  }
                }
                if (n) {
                  d3 = Sc(e3, f2, p2, 1) | 0;
                  g2 = b2[o >> 2] | 0;
                  if (d3 | 0) {
                    s2 = 45;
                    break;
                  }
                  if (Da(g2, p2) | 0) {
                    Ga(q2, p2);
                    if (Fa(p2, b2[o >> 2] | 0) | 0) {
                      s2 = 53;
                      break;
                    }
                    if (ad(b2[v3 >> 2] | 0, b2[o >> 2] | 0, j) | 0) {
                      s2 = 53;
                      break;
                    }
                    if (dd(b2[v3 >> 2] | 0, b2[o >> 2] | 0, q2, p2) | 0) {
                      s2 = 53;
                      break;
                    }
                  }
                }
              }
              do {
                if ((h | 0) < (b2[r2 >> 2] | 0)) {
                  d3 = Sc(e3, f2, p2, 1) | 0;
                  g2 = b2[o >> 2] | 0;
                  if (d3 | 0) {
                    s2 = 58;
                    break b;
                  }
                  if (!(Da(g2, p2) | 0)) {
                    s2 = 73;
                    break;
                  }
                  if (Fa(b2[o >> 2] | 0, p2) | 0 ? (Ga(q2, p2), bd(b2[v3 >> 2] | 0, b2[o >> 2] | 0, q2, p2) | 0) : 0) {
                    s2 = 65;
                    break b;
                  }
                  e3 = Nb(e3, f2, h + 1 | 0, q2) | 0;
                  if (e3 | 0) {
                    s2 = 67;
                    break b;
                  }
                  f2 = q2;
                  e3 = b2[f2 >> 2] | 0;
                  f2 = b2[f2 + 4 >> 2] | 0;
                } else {
                  s2 = 73;
                }
              } while (0);
              if ((s2 | 0) == 73) {
                s2 = 0;
                e3 = Vc(e3, f2) | 0;
                f2 = H() | 0;
              }
              if ((e3 | 0) == 0 & (f2 | 0) == 0) {
                t2 = o;
                break a;
              }
            }
            switch (s2 | 0) {
              case 15: {
                d3 = b2[o >> 2] | 0;
                if (d3 | 0) {
                  Hd(d3);
                }
                s2 = c3;
                b2[s2 >> 2] = 0;
                b2[s2 + 4 >> 2] = 0;
                b2[v3 >> 2] = 0;
                b2[r2 >> 2] = -1;
                b2[u3 >> 2] = 0;
                b2[o >> 2] = 0;
                b2[c3 + 8 >> 2] = g2;
                s2 = 20;
                break;
              }
              case 19: {
                b2[c3 >> 2] = e3;
                b2[c3 + 4 >> 2] = f2;
                s2 = 20;
                break;
              }
              case 25: {
                I(27795, 27761, 470, 27772);
                break;
              }
              case 29: {
                b2[c3 >> 2] = e3;
                b2[c3 + 4 >> 2] = f2;
                T = w3;
                return;
              }
              case 32: {
                d3 = b2[o >> 2] | 0;
                if (d3 | 0) {
                  Hd(d3);
                }
                t2 = c3;
                b2[t2 >> 2] = 0;
                b2[t2 + 4 >> 2] = 0;
                b2[v3 >> 2] = 0;
                b2[r2 >> 2] = -1;
                b2[u3 >> 2] = 0;
                b2[o >> 2] = 0;
                b2[c3 + 8 >> 2] = g2;
                T = w3;
                return;
              }
              case 36: {
                I(27795, 27761, 493, 27772);
                break;
              }
              case 42: {
                b2[c3 >> 2] = e3;
                b2[c3 + 4 >> 2] = f2;
                T = w3;
                return;
              }
              case 45: {
                if (g2 | 0) {
                  Hd(g2);
                }
                s2 = c3;
                b2[s2 >> 2] = 0;
                b2[s2 + 4 >> 2] = 0;
                b2[v3 >> 2] = 0;
                b2[r2 >> 2] = -1;
                b2[u3 >> 2] = 0;
                b2[o >> 2] = 0;
                b2[c3 + 8 >> 2] = d3;
                s2 = 55;
                break;
              }
              case 53: {
                b2[c3 >> 2] = e3;
                b2[c3 + 4 >> 2] = f2;
                s2 = 55;
                break;
              }
              case 58: {
                if (g2 | 0) {
                  Hd(g2);
                }
                s2 = c3;
                b2[s2 >> 2] = 0;
                b2[s2 + 4 >> 2] = 0;
                b2[v3 >> 2] = 0;
                b2[r2 >> 2] = -1;
                b2[u3 >> 2] = 0;
                b2[o >> 2] = 0;
                b2[c3 + 8 >> 2] = d3;
                s2 = 71;
                break;
              }
              case 65: {
                b2[c3 >> 2] = e3;
                b2[c3 + 4 >> 2] = f2;
                s2 = 71;
                break;
              }
              case 67: {
                d3 = b2[o >> 2] | 0;
                if (d3 | 0) {
                  Hd(d3);
                }
                t2 = c3;
                b2[t2 >> 2] = 0;
                b2[t2 + 4 >> 2] = 0;
                b2[v3 >> 2] = 0;
                b2[r2 >> 2] = -1;
                b2[u3 >> 2] = 0;
                b2[o >> 2] = 0;
                b2[c3 + 8 >> 2] = e3;
                T = w3;
                return;
              }
            }
            if ((s2 | 0) == 20) {
              T = w3;
              return;
            } else if ((s2 | 0) == 55) {
              T = w3;
              return;
            } else if ((s2 | 0) == 71) {
              T = w3;
              return;
            }
          } else {
            t2 = c3 + 24 | 0;
          }
        } while (0);
        d3 = b2[t2 >> 2] | 0;
        if (d3 | 0) {
          Hd(d3);
        }
        s2 = c3;
        b2[s2 >> 2] = 0;
        b2[s2 + 4 >> 2] = 0;
        b2[c3 + 8 >> 2] = 0;
        b2[v3 >> 2] = 0;
        b2[c3 + 12 >> 2] = -1;
        b2[u3 >> 2] = 0;
        b2[t2 >> 2] = 0;
        T = w3;
        return;
      }
      function Vc(a3, c3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        var d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0;
        m = T;
        T = T + 16 | 0;
        l = m;
        e3 = Td(a3 | 0, c3 | 0, 52) | 0;
        H() | 0;
        e3 = e3 & 15;
        d3 = Td(a3 | 0, c3 | 0, 45) | 0;
        H() | 0;
        do {
          if (e3) {
            while (1) {
              d3 = Ud(e3 + 4095 | 0, 0, 52) | 0;
              f2 = H() | 0 | c3 & -15728641;
              g2 = (15 - e3 | 0) * 3 | 0;
              h = Ud(7, 0, g2 | 0) | 0;
              i = H() | 0;
              d3 = d3 | a3 | h;
              f2 = f2 | i;
              j = Td(a3 | 0, c3 | 0, g2 | 0) | 0;
              H() | 0;
              j = j & 7;
              e3 = e3 + -1 | 0;
              if (j >>> 0 < 6) {
                break;
              }
              if (!e3) {
                k = 4;
                break;
              } else {
                c3 = f2;
                a3 = d3;
              }
            }
            if ((k | 0) == 4) {
              d3 = Td(d3 | 0, f2 | 0, 45) | 0;
              H() | 0;
              break;
            }
            l = (j | 0) == 0 & (Kb(d3, f2) | 0) != 0;
            l = Ud((l ? 2 : 1) + j | 0, 0, g2 | 0) | 0;
            k = H() | 0 | c3 & ~i;
            l = l | a3 & ~h;
            G2(k | 0);
            T = m;
            return l | 0;
          }
        } while (0);
        d3 = d3 & 127;
        if (d3 >>> 0 > 120) {
          k = 0;
          l = 0;
          G2(k | 0);
          T = m;
          return l | 0;
        }
        Hb(l, 0, d3 + 1 | 0, 0);
        k = b2[l + 4 >> 2] | 0;
        l = b2[l >> 2] | 0;
        G2(k | 0);
        T = m;
        return l | 0;
      }
      function Wc(a3, c3, d3, e3, f2, g2) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0;
        r2 = T;
        T = T + 160 | 0;
        m = r2 + 80 | 0;
        i = r2 + 64 | 0;
        n = r2 + 112 | 0;
        q2 = r2;
        Tc(m, a3, c3, d3);
        k = m;
        ic(i, b2[k >> 2] | 0, b2[k + 4 >> 2] | 0, c3);
        k = i;
        j = b2[k >> 2] | 0;
        k = b2[k + 4 >> 2] | 0;
        h = b2[m + 8 >> 2] | 0;
        o = n + 4 | 0;
        b2[o >> 2] = b2[m >> 2];
        b2[o + 4 >> 2] = b2[m + 4 >> 2];
        b2[o + 8 >> 2] = b2[m + 8 >> 2];
        b2[o + 12 >> 2] = b2[m + 12 >> 2];
        b2[o + 16 >> 2] = b2[m + 16 >> 2];
        b2[o + 20 >> 2] = b2[m + 20 >> 2];
        b2[o + 24 >> 2] = b2[m + 24 >> 2];
        b2[o + 28 >> 2] = b2[m + 28 >> 2];
        o = q2;
        b2[o >> 2] = j;
        b2[o + 4 >> 2] = k;
        o = q2 + 8 | 0;
        b2[o >> 2] = h;
        a3 = q2 + 12 | 0;
        c3 = n;
        d3 = a3 + 36 | 0;
        do {
          b2[a3 >> 2] = b2[c3 >> 2];
          a3 = a3 + 4 | 0;
          c3 = c3 + 4 | 0;
        } while ((a3 | 0) < (d3 | 0));
        n = q2 + 48 | 0;
        b2[n >> 2] = b2[i >> 2];
        b2[n + 4 >> 2] = b2[i + 4 >> 2];
        b2[n + 8 >> 2] = b2[i + 8 >> 2];
        b2[n + 12 >> 2] = b2[i + 12 >> 2];
        if ((j | 0) == 0 & (k | 0) == 0) {
          q2 = h;
          T = r2;
          return q2 | 0;
        }
        d3 = q2 + 16 | 0;
        l = q2 + 24 | 0;
        m = q2 + 28 | 0;
        h = 0;
        i = 0;
        c3 = j;
        a3 = k;
        do {
          if (!((h | 0) < (f2 | 0) | (h | 0) == (f2 | 0) & i >>> 0 < e3 >>> 0)) {
            p2 = 4;
            break;
          }
          k = i;
          i = Jd(i | 0, h | 0, 1, 0) | 0;
          h = H() | 0;
          k = g2 + (k << 3) | 0;
          b2[k >> 2] = c3;
          b2[k + 4 >> 2] = a3;
          kc(n);
          a3 = n;
          c3 = b2[a3 >> 2] | 0;
          a3 = b2[a3 + 4 >> 2] | 0;
          if ((c3 | 0) == 0 & (a3 | 0) == 0) {
            Uc(d3);
            c3 = d3;
            a3 = b2[c3 >> 2] | 0;
            c3 = b2[c3 + 4 >> 2] | 0;
            if ((a3 | 0) == 0 & (c3 | 0) == 0) {
              p2 = 10;
              break;
            }
            jc(a3, c3, b2[m >> 2] | 0, n);
            a3 = n;
            c3 = b2[a3 >> 2] | 0;
            a3 = b2[a3 + 4 >> 2] | 0;
          }
          k = q2;
          b2[k >> 2] = c3;
          b2[k + 4 >> 2] = a3;
        } while (!((c3 | 0) == 0 & (a3 | 0) == 0));
        if ((p2 | 0) == 4) {
          a3 = q2 + 40 | 0;
          c3 = b2[a3 >> 2] | 0;
          if (c3 | 0) {
            Hd(c3);
          }
          p2 = q2 + 16 | 0;
          b2[p2 >> 2] = 0;
          b2[p2 + 4 >> 2] = 0;
          b2[l >> 2] = 0;
          b2[q2 + 36 >> 2] = 0;
          b2[m >> 2] = -1;
          b2[q2 + 32 >> 2] = 0;
          b2[a3 >> 2] = 0;
          jc(0, 0, 0, n);
          b2[q2 >> 2] = 0;
          b2[q2 + 4 >> 2] = 0;
          b2[o >> 2] = 0;
          q2 = 14;
          T = r2;
          return q2 | 0;
        } else if ((p2 | 0) == 10) {
          b2[q2 >> 2] = 0;
          b2[q2 + 4 >> 2] = 0;
          b2[o >> 2] = b2[l >> 2];
        }
        q2 = b2[o >> 2] | 0;
        T = r2;
        return q2 | 0;
      }
      function Xc(c3, d3, f2, g2) {
        c3 = c3 | 0;
        d3 = d3 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, r2 = 0;
        o = T;
        T = T + 48 | 0;
        l = o + 32 | 0;
        k = o + 40 | 0;
        m = o;
        if (!(b2[c3 >> 2] | 0)) {
          n = g2;
          b2[n >> 2] = 0;
          b2[n + 4 >> 2] = 0;
          n = 0;
          T = o;
          return n | 0;
        }
        Hb(l, 0, 0, 0);
        j = l;
        h = b2[j >> 2] | 0;
        j = b2[j + 4 >> 2] | 0;
        do {
          if (d3 >>> 0 > 15) {
            n = m;
            b2[n >> 2] = 0;
            b2[n + 4 >> 2] = 0;
            b2[m + 8 >> 2] = 4;
            b2[m + 12 >> 2] = -1;
            n = m + 16 | 0;
            f2 = m + 29 | 0;
            b2[n >> 2] = 0;
            b2[n + 4 >> 2] = 0;
            b2[n + 8 >> 2] = 0;
            a2[n + 12 >> 0] = 0;
            a2[f2 >> 0] = a2[k >> 0] | 0;
            a2[f2 + 1 >> 0] = a2[k + 1 >> 0] | 0;
            a2[f2 + 2 >> 0] = a2[k + 2 >> 0] | 0;
            f2 = 4;
            n = 9;
          } else {
            f2 = _c(f2) | 0;
            if (f2 | 0) {
              l = m;
              b2[l >> 2] = 0;
              b2[l + 4 >> 2] = 0;
              b2[m + 8 >> 2] = f2;
              b2[m + 12 >> 2] = -1;
              l = m + 16 | 0;
              n = m + 29 | 0;
              b2[l >> 2] = 0;
              b2[l + 4 >> 2] = 0;
              b2[l + 8 >> 2] = 0;
              a2[l + 12 >> 0] = 0;
              a2[n >> 0] = a2[k >> 0] | 0;
              a2[n + 1 >> 0] = a2[k + 1 >> 0] | 0;
              a2[n + 2 >> 0] = a2[k + 2 >> 0] | 0;
              n = 9;
              break;
            }
            f2 = Id((b2[c3 + 8 >> 2] | 0) + 1 | 0, 32) | 0;
            if (!f2) {
              n = m;
              b2[n >> 2] = 0;
              b2[n + 4 >> 2] = 0;
              b2[m + 8 >> 2] = 13;
              b2[m + 12 >> 2] = -1;
              n = m + 16 | 0;
              f2 = m + 29 | 0;
              b2[n >> 2] = 0;
              b2[n + 4 >> 2] = 0;
              b2[n + 8 >> 2] = 0;
              a2[n + 12 >> 0] = 0;
              a2[f2 >> 0] = a2[k >> 0] | 0;
              a2[f2 + 1 >> 0] = a2[k + 1 >> 0] | 0;
              a2[f2 + 2 >> 0] = a2[k + 2 >> 0] | 0;
              f2 = 13;
              n = 9;
              break;
            }
            $c(c3, f2);
            r2 = m;
            b2[r2 >> 2] = h;
            b2[r2 + 4 >> 2] = j;
            j = m + 8 | 0;
            b2[j >> 2] = 0;
            b2[m + 12 >> 2] = d3;
            b2[m + 20 >> 2] = c3;
            b2[m + 24 >> 2] = f2;
            a2[m + 28 >> 0] = 0;
            h = m + 29 | 0;
            a2[h >> 0] = a2[k >> 0] | 0;
            a2[h + 1 >> 0] = a2[k + 1 >> 0] | 0;
            a2[h + 2 >> 0] = a2[k + 2 >> 0] | 0;
            b2[m + 16 >> 2] = 3;
            p2 = +Ba(f2);
            p2 = p2 * +za(f2);
            i = +q(+ +e2[f2 >> 3]);
            i = p2 / +t(+ +Xd(+i, + +q(+ +e2[f2 + 8 >> 3]))) * 6371.007180918475 * 6371.007180918475;
            h = m + 12 | 0;
            f2 = b2[h >> 2] | 0;
            a: do {
              if ((f2 | 0) > 0) {
                do {
                  tc(f2 + -1 | 0, l) | 0;
                  if (!(i / +e2[l >> 3] > 10)) {
                    break a;
                  }
                  r2 = b2[h >> 2] | 0;
                  f2 = r2 + -1 | 0;
                  b2[h >> 2] = f2;
                } while ((r2 | 0) > 1);
              }
            } while (0);
            Uc(m);
            h = g2;
            b2[h >> 2] = 0;
            b2[h + 4 >> 2] = 0;
            h = m;
            f2 = b2[h >> 2] | 0;
            h = b2[h + 4 >> 2] | 0;
            if (!((f2 | 0) == 0 & (h | 0) == 0)) {
              do {
                Jb(f2, h, d3, l) | 0;
                k = l;
                c3 = g2;
                k = Jd(b2[c3 >> 2] | 0, b2[c3 + 4 >> 2] | 0, b2[k >> 2] | 0, b2[k + 4 >> 2] | 0) | 0;
                c3 = H() | 0;
                r2 = g2;
                b2[r2 >> 2] = k;
                b2[r2 + 4 >> 2] = c3;
                Uc(m);
                r2 = m;
                f2 = b2[r2 >> 2] | 0;
                h = b2[r2 + 4 >> 2] | 0;
              } while (!((f2 | 0) == 0 & (h | 0) == 0));
            }
            f2 = b2[j >> 2] | 0;
          }
        } while (0);
        r2 = f2;
        T = o;
        return r2 | 0;
      }
      function Yc(a3, c3, d3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0;
        if (!(Ca(c3, d3) | 0)) {
          o = 0;
          return o | 0;
        }
        c3 = Aa(c3) | 0;
        f2 = +e2[d3 >> 3];
        g2 = +e2[d3 + 8 >> 3];
        g2 = c3 & g2 < 0 ? g2 + 6.283185307179586 : g2;
        o = b2[a3 >> 2] | 0;
        if ((o | 0) <= 0) {
          o = 0;
          return o | 0;
        }
        n = b2[a3 + 4 >> 2] | 0;
        if (c3) {
          c3 = 0;
          m = g2;
          d3 = -1;
          a3 = 0;
          a: while (1) {
            l = a3;
            while (1) {
              i = +e2[n + (l << 4) >> 3];
              g2 = +e2[n + (l << 4) + 8 >> 3];
              a3 = (d3 + 2 | 0) % (o | 0) | 0;
              h = +e2[n + (a3 << 4) >> 3];
              j = +e2[n + (a3 << 4) + 8 >> 3];
              if (i > h) {
                k = i;
                i = j;
              } else {
                k = h;
                h = i;
                i = g2;
                g2 = j;
              }
              f2 = f2 == h | f2 == k ? f2 + 2220446049250313e-31 : f2;
              if (!(f2 < h | f2 > k)) {
                break;
              }
              d3 = l + 1 | 0;
              if ((d3 | 0) >= (o | 0)) {
                d3 = 22;
                break a;
              } else {
                a3 = l;
                l = d3;
                d3 = a3;
              }
            }
            j = i < 0 ? i + 6.283185307179586 : i;
            i = g2 < 0 ? g2 + 6.283185307179586 : g2;
            m = j == m | i == m ? m + -2220446049250313e-31 : m;
            k = j + (i - j) * ((f2 - h) / (k - h));
            if ((k < 0 ? k + 6.283185307179586 : k) > m) {
              c3 = c3 ^ 1;
            }
            a3 = l + 1 | 0;
            if ((a3 | 0) >= (o | 0)) {
              d3 = 22;
              break;
            } else {
              d3 = l;
            }
          }
          if ((d3 | 0) == 22) {
            return c3 | 0;
          }
        } else {
          c3 = 0;
          m = g2;
          d3 = -1;
          a3 = 0;
          b: while (1) {
            l = a3;
            while (1) {
              i = +e2[n + (l << 4) >> 3];
              g2 = +e2[n + (l << 4) + 8 >> 3];
              a3 = (d3 + 2 | 0) % (o | 0) | 0;
              h = +e2[n + (a3 << 4) >> 3];
              j = +e2[n + (a3 << 4) + 8 >> 3];
              if (i > h) {
                k = i;
                i = j;
              } else {
                k = h;
                h = i;
                i = g2;
                g2 = j;
              }
              f2 = f2 == h | f2 == k ? f2 + 2220446049250313e-31 : f2;
              if (!(f2 < h | f2 > k)) {
                break;
              }
              d3 = l + 1 | 0;
              if ((d3 | 0) >= (o | 0)) {
                d3 = 22;
                break b;
              } else {
                a3 = l;
                l = d3;
                d3 = a3;
              }
            }
            m = i == m | g2 == m ? m + -2220446049250313e-31 : m;
            if (i + (g2 - i) * ((f2 - h) / (k - h)) > m) {
              c3 = c3 ^ 1;
            }
            a3 = l + 1 | 0;
            if ((a3 | 0) >= (o | 0)) {
              d3 = 22;
              break;
            } else {
              d3 = l;
            }
          }
          if ((d3 | 0) == 22) {
            return c3 | 0;
          }
        }
        return 0;
      }
      function Zc(a3, c3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        var d3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, r2 = 0, s2 = 0, t2 = 0, u3 = 0, v3 = 0;
        r2 = b2[a3 >> 2] | 0;
        if (!r2) {
          b2[c3 >> 2] = 0;
          b2[c3 + 4 >> 2] = 0;
          b2[c3 + 8 >> 2] = 0;
          b2[c3 + 12 >> 2] = 0;
          b2[c3 + 16 >> 2] = 0;
          b2[c3 + 20 >> 2] = 0;
          b2[c3 + 24 >> 2] = 0;
          b2[c3 + 28 >> 2] = 0;
          return;
        }
        s2 = c3 + 8 | 0;
        e2[s2 >> 3] = 17976931348623157e292;
        t2 = c3 + 24 | 0;
        e2[t2 >> 3] = 17976931348623157e292;
        e2[c3 >> 3] = -17976931348623157e292;
        u3 = c3 + 16 | 0;
        e2[u3 >> 3] = -17976931348623157e292;
        if ((r2 | 0) <= 0) {
          return;
        }
        o = b2[a3 + 4 >> 2] | 0;
        l = 17976931348623157e292;
        m = -17976931348623157e292;
        n = 0;
        a3 = -1;
        h = 17976931348623157e292;
        i = 17976931348623157e292;
        k = -17976931348623157e292;
        f2 = -17976931348623157e292;
        p2 = 0;
        while (1) {
          d3 = +e2[o + (p2 << 4) >> 3];
          j = +e2[o + (p2 << 4) + 8 >> 3];
          a3 = a3 + 2 | 0;
          g2 = +e2[o + (((a3 | 0) == (r2 | 0) ? 0 : a3) << 4) + 8 >> 3];
          if (d3 < h) {
            e2[s2 >> 3] = d3;
            h = d3;
          }
          if (j < i) {
            e2[t2 >> 3] = j;
            i = j;
          }
          if (d3 > k) {
            e2[c3 >> 3] = d3;
          } else {
            d3 = k;
          }
          if (j > f2) {
            e2[u3 >> 3] = j;
            f2 = j;
          }
          l = j > 0 & j < l ? j : l;
          m = j < 0 & j > m ? j : m;
          n = n | +q(+(j - g2)) > 3.141592653589793;
          a3 = p2 + 1 | 0;
          if ((a3 | 0) == (r2 | 0)) {
            break;
          } else {
            v3 = p2;
            k = d3;
            p2 = a3;
            a3 = v3;
          }
        }
        if (!n) {
          return;
        }
        e2[u3 >> 3] = m;
        e2[t2 >> 3] = l;
        return;
      }
      function _c(a3) {
        a3 = a3 | 0;
        return (a3 >>> 0 < 4 ? 0 : 15) | 0;
      }
      function $c(a3, c3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        var d3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, r2 = 0, s2 = 0, t2 = 0, u3 = 0, v3 = 0, w3 = 0, x2 = 0, y2 = 0, z2 = 0, A3 = 0;
        r2 = b2[a3 >> 2] | 0;
        if (r2) {
          s2 = c3 + 8 | 0;
          e2[s2 >> 3] = 17976931348623157e292;
          t2 = c3 + 24 | 0;
          e2[t2 >> 3] = 17976931348623157e292;
          e2[c3 >> 3] = -17976931348623157e292;
          u3 = c3 + 16 | 0;
          e2[u3 >> 3] = -17976931348623157e292;
          if ((r2 | 0) > 0) {
            g2 = b2[a3 + 4 >> 2] | 0;
            o = 17976931348623157e292;
            p2 = -17976931348623157e292;
            f2 = 0;
            d3 = -1;
            k = 17976931348623157e292;
            l = 17976931348623157e292;
            n = -17976931348623157e292;
            i = -17976931348623157e292;
            v3 = 0;
            while (1) {
              h = +e2[g2 + (v3 << 4) >> 3];
              m = +e2[g2 + (v3 << 4) + 8 >> 3];
              z2 = d3 + 2 | 0;
              j = +e2[g2 + (((z2 | 0) == (r2 | 0) ? 0 : z2) << 4) + 8 >> 3];
              if (h < k) {
                e2[s2 >> 3] = h;
                k = h;
              }
              if (m < l) {
                e2[t2 >> 3] = m;
                l = m;
              }
              if (h > n) {
                e2[c3 >> 3] = h;
              } else {
                h = n;
              }
              if (m > i) {
                e2[u3 >> 3] = m;
                i = m;
              }
              o = m > 0 & m < o ? m : o;
              p2 = m < 0 & m > p2 ? m : p2;
              f2 = f2 | +q(+(m - j)) > 3.141592653589793;
              d3 = v3 + 1 | 0;
              if ((d3 | 0) == (r2 | 0)) {
                break;
              } else {
                z2 = v3;
                n = h;
                v3 = d3;
                d3 = z2;
              }
            }
            if (f2) {
              e2[u3 >> 3] = p2;
              e2[t2 >> 3] = o;
            }
          }
        } else {
          b2[c3 >> 2] = 0;
          b2[c3 + 4 >> 2] = 0;
          b2[c3 + 8 >> 2] = 0;
          b2[c3 + 12 >> 2] = 0;
          b2[c3 + 16 >> 2] = 0;
          b2[c3 + 20 >> 2] = 0;
          b2[c3 + 24 >> 2] = 0;
          b2[c3 + 28 >> 2] = 0;
        }
        z2 = a3 + 8 | 0;
        d3 = b2[z2 >> 2] | 0;
        if ((d3 | 0) <= 0) {
          return;
        }
        y2 = a3 + 12 | 0;
        x2 = 0;
        do {
          g2 = b2[y2 >> 2] | 0;
          f2 = x2;
          x2 = x2 + 1 | 0;
          t2 = c3 + (x2 << 5) | 0;
          u3 = b2[g2 + (f2 << 3) >> 2] | 0;
          if (u3) {
            v3 = c3 + (x2 << 5) + 8 | 0;
            e2[v3 >> 3] = 17976931348623157e292;
            a3 = c3 + (x2 << 5) + 24 | 0;
            e2[a3 >> 3] = 17976931348623157e292;
            e2[t2 >> 3] = -17976931348623157e292;
            w3 = c3 + (x2 << 5) + 16 | 0;
            e2[w3 >> 3] = -17976931348623157e292;
            if ((u3 | 0) > 0) {
              r2 = b2[g2 + (f2 << 3) + 4 >> 2] | 0;
              o = 17976931348623157e292;
              p2 = -17976931348623157e292;
              g2 = 0;
              f2 = -1;
              s2 = 0;
              k = 17976931348623157e292;
              l = 17976931348623157e292;
              m = -17976931348623157e292;
              i = -17976931348623157e292;
              while (1) {
                h = +e2[r2 + (s2 << 4) >> 3];
                n = +e2[r2 + (s2 << 4) + 8 >> 3];
                f2 = f2 + 2 | 0;
                j = +e2[r2 + (((f2 | 0) == (u3 | 0) ? 0 : f2) << 4) + 8 >> 3];
                if (h < k) {
                  e2[v3 >> 3] = h;
                  k = h;
                }
                if (n < l) {
                  e2[a3 >> 3] = n;
                  l = n;
                }
                if (h > m) {
                  e2[t2 >> 3] = h;
                } else {
                  h = m;
                }
                if (n > i) {
                  e2[w3 >> 3] = n;
                  i = n;
                }
                o = n > 0 & n < o ? n : o;
                p2 = n < 0 & n > p2 ? n : p2;
                g2 = g2 | +q(+(n - j)) > 3.141592653589793;
                f2 = s2 + 1 | 0;
                if ((f2 | 0) == (u3 | 0)) {
                  break;
                } else {
                  A3 = s2;
                  s2 = f2;
                  m = h;
                  f2 = A3;
                }
              }
              if (g2) {
                e2[w3 >> 3] = p2;
                e2[a3 >> 3] = o;
              }
            }
          } else {
            b2[t2 >> 2] = 0;
            b2[t2 + 4 >> 2] = 0;
            b2[t2 + 8 >> 2] = 0;
            b2[t2 + 12 >> 2] = 0;
            b2[t2 + 16 >> 2] = 0;
            b2[t2 + 20 >> 2] = 0;
            b2[t2 + 24 >> 2] = 0;
            b2[t2 + 28 >> 2] = 0;
            d3 = b2[z2 >> 2] | 0;
          }
        } while ((x2 | 0) < (d3 | 0));
        return;
      }
      function ad(a3, c3, d3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0, g2 = 0;
        if (!(Yc(a3, c3, d3) | 0)) {
          f2 = 0;
          return f2 | 0;
        }
        f2 = a3 + 8 | 0;
        if ((b2[f2 >> 2] | 0) <= 0) {
          f2 = 1;
          return f2 | 0;
        }
        e3 = a3 + 12 | 0;
        a3 = 0;
        while (1) {
          g2 = a3;
          a3 = a3 + 1 | 0;
          if (Yc((b2[e3 >> 2] | 0) + (g2 << 3) | 0, c3 + (a3 << 5) | 0, d3) | 0) {
            a3 = 0;
            e3 = 6;
            break;
          }
          if ((a3 | 0) >= (b2[f2 >> 2] | 0)) {
            a3 = 1;
            e3 = 6;
            break;
          }
        }
        if ((e3 | 0) == 6) {
          return a3 | 0;
        }
        return 0;
      }
      function bd(a3, c3, d3, e3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0;
        k = T;
        T = T + 16 | 0;
        i = k;
        h = d3 + 8 | 0;
        if (!(Yc(a3, c3, h) | 0)) {
          j = 0;
          T = k;
          return j | 0;
        }
        j = a3 + 8 | 0;
        a: do {
          if ((b2[j >> 2] | 0) > 0) {
            g2 = a3 + 12 | 0;
            f2 = 0;
            while (1) {
              l = f2;
              f2 = f2 + 1 | 0;
              if (Yc((b2[g2 >> 2] | 0) + (l << 3) | 0, c3 + (f2 << 5) | 0, h) | 0) {
                f2 = 0;
                break;
              }
              if ((f2 | 0) >= (b2[j >> 2] | 0)) {
                break a;
              }
            }
            T = k;
            return f2 | 0;
          }
        } while (0);
        if (cd(a3, c3, d3, e3) | 0) {
          l = 0;
          T = k;
          return l | 0;
        }
        b2[i >> 2] = b2[d3 >> 2];
        b2[i + 4 >> 2] = h;
        f2 = b2[j >> 2] | 0;
        b: do {
          if ((f2 | 0) > 0) {
            a3 = a3 + 12 | 0;
            h = 0;
            g2 = f2;
            while (1) {
              f2 = b2[a3 >> 2] | 0;
              if ((b2[f2 + (h << 3) >> 2] | 0) > 0) {
                if (Yc(i, e3, b2[f2 + (h << 3) + 4 >> 2] | 0) | 0) {
                  f2 = 0;
                  break b;
                }
                f2 = h + 1 | 0;
                if (cd((b2[a3 >> 2] | 0) + (h << 3) | 0, c3 + (f2 << 5) | 0, d3, e3) | 0) {
                  f2 = 0;
                  break b;
                }
                g2 = b2[j >> 2] | 0;
              } else {
                f2 = h + 1 | 0;
              }
              if ((f2 | 0) < (g2 | 0)) {
                h = f2;
              } else {
                f2 = 1;
                break;
              }
            }
          } else {
            f2 = 1;
          }
        } while (0);
        l = f2;
        T = k;
        return l | 0;
      }
      function cd(a3, c3, d3, f2) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t2 = 0, u3 = 0, v3 = 0, w3 = 0, x2 = 0, y2 = 0, z2 = 0, A3 = 0;
        y2 = T;
        T = T + 176 | 0;
        u3 = y2 + 172 | 0;
        g2 = y2 + 168 | 0;
        v3 = y2;
        if (!(Da(c3, f2) | 0)) {
          a3 = 0;
          T = y2;
          return a3 | 0;
        }
        Ea(c3, f2, u3, g2);
        Zd(v3 | 0, d3 | 0, 168) | 0;
        if ((b2[d3 >> 2] | 0) > 0) {
          c3 = 0;
          do {
            z2 = v3 + 8 + (c3 << 4) + 8 | 0;
            t2 = +nc(+e2[z2 >> 3], b2[g2 >> 2] | 0);
            e2[z2 >> 3] = t2;
            c3 = c3 + 1 | 0;
          } while ((c3 | 0) < (b2[d3 >> 2] | 0));
        }
        r2 = +e2[f2 >> 3];
        s2 = +e2[f2 + 8 >> 3];
        t2 = +nc(+e2[f2 + 16 >> 3], b2[g2 >> 2] | 0);
        p2 = +nc(+e2[f2 + 24 >> 3], b2[g2 >> 2] | 0);
        a: do {
          if ((b2[a3 >> 2] | 0) > 0) {
            f2 = a3 + 4 | 0;
            g2 = b2[v3 >> 2] | 0;
            if ((g2 | 0) <= 0) {
              c3 = 0;
              while (1) {
                c3 = c3 + 1 | 0;
                if ((c3 | 0) >= (b2[a3 >> 2] | 0)) {
                  c3 = 0;
                  break a;
                }
              }
            }
            d3 = 0;
            while (1) {
              c3 = b2[f2 >> 2] | 0;
              o = +e2[c3 + (d3 << 4) >> 3];
              q2 = +nc(+e2[c3 + (d3 << 4) + 8 >> 3], b2[u3 >> 2] | 0);
              c3 = b2[f2 >> 2] | 0;
              d3 = d3 + 1 | 0;
              z2 = (d3 | 0) % (b2[a3 >> 2] | 0) | 0;
              h = +e2[c3 + (z2 << 4) >> 3];
              i = +nc(+e2[c3 + (z2 << 4) + 8 >> 3], b2[u3 >> 2] | 0);
              if (((!(o >= r2) | !(h >= r2) ? !(o <= s2) | !(h <= s2) : 0) ? !(q2 <= p2) | !(i <= p2) : 0) ? !(q2 >= t2) | !(i >= t2) : 0) {
                n = h - o;
                l = i - q2;
                c3 = 0;
                do {
                  A3 = c3;
                  c3 = c3 + 1 | 0;
                  z2 = (c3 | 0) == (g2 | 0) ? 0 : c3;
                  h = +e2[v3 + 8 + (A3 << 4) + 8 >> 3];
                  i = +e2[v3 + 8 + (z2 << 4) + 8 >> 3] - h;
                  j = +e2[v3 + 8 + (A3 << 4) >> 3];
                  k = +e2[v3 + 8 + (z2 << 4) >> 3] - j;
                  m = n * i - l * k;
                  if ((m != 0 ? (w3 = q2 - h, x2 = o - j, k = (w3 * k - i * x2) / m, !(k < 0 | k > 1)) : 0) ? (m = (n * w3 - l * x2) / m, m >= 0 & m <= 1) : 0) {
                    c3 = 1;
                    break a;
                  }
                } while ((c3 | 0) < (g2 | 0));
              }
              if ((d3 | 0) >= (b2[a3 >> 2] | 0)) {
                c3 = 0;
                break;
              }
            }
          } else {
            c3 = 0;
          }
        } while (0);
        A3 = c3;
        T = y2;
        return A3 | 0;
      }
      function dd(a3, c3, d3, e3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0;
        if (cd(a3, c3, d3, e3) | 0) {
          g2 = 1;
          return g2 | 0;
        }
        g2 = a3 + 8 | 0;
        if ((b2[g2 >> 2] | 0) <= 0) {
          g2 = 0;
          return g2 | 0;
        }
        f2 = a3 + 12 | 0;
        a3 = 0;
        while (1) {
          h = a3;
          a3 = a3 + 1 | 0;
          if (cd((b2[f2 >> 2] | 0) + (h << 3) | 0, c3 + (a3 << 5) | 0, d3, e3) | 0) {
            a3 = 1;
            f2 = 6;
            break;
          }
          if ((a3 | 0) >= (b2[g2 >> 2] | 0)) {
            a3 = 0;
            f2 = 6;
            break;
          }
        }
        if ((f2 | 0) == 6) {
          return a3 | 0;
        }
        return 0;
      }
      function ed() {
        return 8;
      }
      function fd() {
        return 16;
      }
      function gd() {
        return 168;
      }
      function hd() {
        return 8;
      }
      function id() {
        return 16;
      }
      function jd() {
        return 12;
      }
      function kd() {
        return 8;
      }
      function ld(a3) {
        a3 = a3 | 0;
        return +(+((b2[a3 >> 2] | 0) >>> 0) + 4294967296 * +(b2[a3 + 4 >> 2] | 0));
      }
      function md(a3) {
        a3 = a3 | 0;
        var b3 = 0, c3 = 0;
        c3 = +e2[a3 >> 3];
        b3 = +e2[a3 + 8 >> 3];
        return + +r(+(c3 * c3 + b3 * b3));
      }
      function nd(a3, b3, c3, d3, f2) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0;
        k = +e2[a3 >> 3];
        j = +e2[b3 >> 3] - k;
        i = +e2[a3 + 8 >> 3];
        h = +e2[b3 + 8 >> 3] - i;
        m = +e2[c3 >> 3];
        g2 = +e2[d3 >> 3] - m;
        n = +e2[c3 + 8 >> 3];
        l = +e2[d3 + 8 >> 3] - n;
        g2 = (g2 * (i - n) - (k - m) * l) / (j * l - h * g2);
        e2[f2 >> 3] = k + j * g2;
        e2[f2 + 8 >> 3] = i + h * g2;
        return;
      }
      function od(a3, b3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        if (!(+q(+(+e2[a3 >> 3] - +e2[b3 >> 3])) < 11920928955078125e-23)) {
          b3 = 0;
          return b3 | 0;
        }
        b3 = +q(+(+e2[a3 + 8 >> 3] - +e2[b3 + 8 >> 3])) < 11920928955078125e-23;
        return b3 | 0;
      }
      function pd(a3, b3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        var c3 = 0, d3 = 0, f2 = 0;
        f2 = +e2[a3 >> 3] - +e2[b3 >> 3];
        d3 = +e2[a3 + 8 >> 3] - +e2[b3 + 8 >> 3];
        c3 = +e2[a3 + 16 >> 3] - +e2[b3 + 16 >> 3];
        return +(f2 * f2 + d3 * d3 + c3 * c3);
      }
      function qd(a3, b3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        var c3 = 0, d3 = 0, f2 = 0;
        c3 = +e2[a3 >> 3];
        d3 = +t(+c3);
        c3 = +u2(+c3);
        e2[b3 + 16 >> 3] = c3;
        c3 = +e2[a3 + 8 >> 3];
        f2 = d3 * +t(+c3);
        e2[b3 >> 3] = f2;
        c3 = d3 * +u2(+c3);
        e2[b3 + 8 >> 3] = c3;
        return;
      }
      function rd(a3, c3, d3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0, g2 = 0;
        g2 = T;
        T = T + 16 | 0;
        f2 = g2;
        e3 = Kb(a3, c3) | 0;
        if ((d3 + -1 | 0) >>> 0 > 5) {
          f2 = -1;
          T = g2;
          return f2 | 0;
        }
        e3 = (e3 | 0) != 0;
        if ((d3 | 0) == 1 & e3) {
          f2 = -1;
          T = g2;
          return f2 | 0;
        }
        do {
          if (!(sd(a3, c3, f2) | 0)) {
            if (e3) {
              e3 = ((b2[26352 + (d3 << 2) >> 2] | 0) + 5 - (b2[f2 >> 2] | 0) | 0) % 5 | 0;
              break;
            } else {
              e3 = ((b2[26384 + (d3 << 2) >> 2] | 0) + 6 - (b2[f2 >> 2] | 0) | 0) % 6 | 0;
              break;
            }
          } else {
            e3 = -1;
          }
        } while (0);
        f2 = e3;
        T = g2;
        return f2 | 0;
      }
      function sd(a3, c3, d3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0;
        l = T;
        T = T + 32 | 0;
        i = l + 16 | 0;
        j = l;
        e3 = $b(a3, c3, i) | 0;
        if (e3 | 0) {
          d3 = e3;
          T = l;
          return d3 | 0;
        }
        g2 = Cb(a3, c3) | 0;
        k = Sb(a3, c3) | 0;
        sa(g2, j);
        e3 = ta(g2, b2[i >> 2] | 0) | 0;
        do {
          if (oa(g2) | 0) {
            do {
              switch (g2 | 0) {
                case 4: {
                  f2 = 0;
                  break;
                }
                case 14: {
                  f2 = 1;
                  break;
                }
                case 24: {
                  f2 = 2;
                  break;
                }
                case 38: {
                  f2 = 3;
                  break;
                }
                case 49: {
                  f2 = 4;
                  break;
                }
                case 58: {
                  f2 = 5;
                  break;
                }
                case 63: {
                  f2 = 6;
                  break;
                }
                case 72: {
                  f2 = 7;
                  break;
                }
                case 83: {
                  f2 = 8;
                  break;
                }
                case 97: {
                  f2 = 9;
                  break;
                }
                case 107: {
                  f2 = 10;
                  break;
                }
                case 117: {
                  f2 = 11;
                  break;
                }
                default:
                  I(27795, 27797, 75, 27806);
              }
            } while (0);
            h = b2[26416 + (f2 * 24 | 0) + 8 >> 2] | 0;
            c3 = b2[26416 + (f2 * 24 | 0) + 16 >> 2] | 0;
            a3 = b2[i >> 2] | 0;
            if ((a3 | 0) != (b2[j >> 2] | 0)) {
              j = pa(g2) | 0;
              a3 = b2[i >> 2] | 0;
              if (j | (a3 | 0) == (c3 | 0)) {
                e3 = (e3 + 1 | 0) % 6 | 0;
              }
            }
            if ((k | 0) == 3 & (a3 | 0) == (c3 | 0)) {
              e3 = (e3 + 5 | 0) % 6 | 0;
              break;
            }
            if ((k | 0) == 5 & (a3 | 0) == (h | 0)) {
              e3 = (e3 + 1 | 0) % 6 | 0;
            }
          }
        } while (0);
        b2[d3 >> 2] = e3;
        d3 = 0;
        T = l;
        return d3 | 0;
      }
      function td(a3, c3, d3, e3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t2 = 0, u3 = 0;
        u3 = T;
        T = T + 32 | 0;
        t2 = u3 + 24 | 0;
        r2 = u3 + 20 | 0;
        p2 = u3 + 8 | 0;
        o = u3 + 16 | 0;
        n = u3;
        j = (Kb(a3, c3) | 0) == 0;
        j = j ? 6 : 5;
        l = Td(a3 | 0, c3 | 0, 52) | 0;
        H() | 0;
        l = l & 15;
        if (j >>> 0 <= d3 >>> 0) {
          e3 = 2;
          T = u3;
          return e3 | 0;
        }
        m = (l | 0) == 0;
        if (!m ? (q2 = Ud(7, 0, (l ^ 15) * 3 | 0) | 0, (q2 & a3 | 0) == 0 & ((H() | 0) & c3 | 0) == 0) : 0) {
          f2 = d3;
        } else {
          g2 = 4;
        }
        a: do {
          if ((g2 | 0) == 4) {
            f2 = (Kb(a3, c3) | 0) != 0;
            if (((f2 ? 4 : 5) | 0) < (d3 | 0)) {
              e3 = 1;
              T = u3;
              return e3 | 0;
            }
            if (sd(a3, c3, t2) | 0) {
              e3 = 1;
              T = u3;
              return e3 | 0;
            }
            g2 = (b2[t2 >> 2] | 0) + d3 | 0;
            if (f2) {
              f2 = 26704 + (((g2 | 0) % 5 | 0) << 2) | 0;
            } else {
              f2 = 26736 + (((g2 | 0) % 6 | 0) << 2) | 0;
            }
            q2 = b2[f2 >> 2] | 0;
            if ((q2 | 0) == 7) {
              e3 = 1;
              T = u3;
              return e3 | 0;
            }
            b2[r2 >> 2] = 0;
            f2 = ea(a3, c3, q2, r2, p2) | 0;
            do {
              if (!f2) {
                i = p2;
                k = b2[i >> 2] | 0;
                i = b2[i + 4 >> 2] | 0;
                h = i >>> 0 < c3 >>> 0 | (i | 0) == (c3 | 0) & k >>> 0 < a3 >>> 0;
                g2 = h ? k : a3;
                h = h ? i : c3;
                if (!m ? (m = Ud(7, 0, (l ^ 15) * 3 | 0) | 0, (k & m | 0) == 0 & (i & (H() | 0) | 0) == 0) : 0) {
                  f2 = d3;
                } else {
                  i = (d3 + -1 + j | 0) % (j | 0) | 0;
                  f2 = Kb(a3, c3) | 0;
                  if ((i | 0) < 0) {
                    I(27795, 27797, 248, 27822);
                  }
                  j = (f2 | 0) != 0;
                  if (((j ? 4 : 5) | 0) < (i | 0)) {
                    I(27795, 27797, 248, 27822);
                  }
                  if (sd(a3, c3, t2) | 0) {
                    I(27795, 27797, 248, 27822);
                  }
                  f2 = (b2[t2 >> 2] | 0) + i | 0;
                  if (j) {
                    f2 = 26704 + (((f2 | 0) % 5 | 0) << 2) | 0;
                  } else {
                    f2 = 26736 + (((f2 | 0) % 6 | 0) << 2) | 0;
                  }
                  i = b2[f2 >> 2] | 0;
                  if ((i | 0) == 7) {
                    I(27795, 27797, 248, 27822);
                  }
                  b2[o >> 2] = 0;
                  f2 = ea(a3, c3, i, o, n) | 0;
                  if (f2 | 0) {
                    break;
                  }
                  k = n;
                  j = b2[k >> 2] | 0;
                  k = b2[k + 4 >> 2] | 0;
                  do {
                    if (k >>> 0 < h >>> 0 | (k | 0) == (h | 0) & j >>> 0 < g2 >>> 0) {
                      if (!(Kb(j, k) | 0)) {
                        g2 = b2[26800 + ((((b2[o >> 2] | 0) + (b2[26768 + (i << 2) >> 2] | 0) | 0) % 6 | 0) << 2) >> 2] | 0;
                      } else {
                        g2 = ia(j, k, a3, c3) | 0;
                      }
                      f2 = Kb(j, k) | 0;
                      if ((g2 + -1 | 0) >>> 0 > 5) {
                        f2 = -1;
                        g2 = j;
                        h = k;
                        break;
                      }
                      f2 = (f2 | 0) != 0;
                      if ((g2 | 0) == 1 & f2) {
                        f2 = -1;
                        g2 = j;
                        h = k;
                        break;
                      }
                      do {
                        if (!(sd(j, k, t2) | 0)) {
                          if (f2) {
                            f2 = ((b2[26352 + (g2 << 2) >> 2] | 0) + 5 - (b2[t2 >> 2] | 0) | 0) % 5 | 0;
                            break;
                          } else {
                            f2 = ((b2[26384 + (g2 << 2) >> 2] | 0) + 6 - (b2[t2 >> 2] | 0) | 0) % 6 | 0;
                            break;
                          }
                        } else {
                          f2 = -1;
                        }
                      } while (0);
                      g2 = j;
                      h = k;
                    } else {
                      f2 = d3;
                    }
                  } while (0);
                  i = p2;
                  k = b2[i >> 2] | 0;
                  i = b2[i + 4 >> 2] | 0;
                }
                if ((g2 | 0) == (k | 0) & (h | 0) == (i | 0)) {
                  j = (Kb(k, i) | 0) != 0;
                  if (j) {
                    a3 = ia(k, i, a3, c3) | 0;
                  } else {
                    a3 = b2[26800 + ((((b2[r2 >> 2] | 0) + (b2[26768 + (q2 << 2) >> 2] | 0) | 0) % 6 | 0) << 2) >> 2] | 0;
                  }
                  f2 = Kb(k, i) | 0;
                  if ((a3 + -1 | 0) >>> 0 <= 5 ? (s2 = (f2 | 0) != 0, !((a3 | 0) == 1 & s2)) : 0) {
                    do {
                      if (!(sd(k, i, t2) | 0)) {
                        if (s2) {
                          f2 = ((b2[26352 + (a3 << 2) >> 2] | 0) + 5 - (b2[t2 >> 2] | 0) | 0) % 5 | 0;
                          break;
                        } else {
                          f2 = ((b2[26384 + (a3 << 2) >> 2] | 0) + 6 - (b2[t2 >> 2] | 0) | 0) % 6 | 0;
                          break;
                        }
                      } else {
                        f2 = -1;
                      }
                    } while (0);
                  } else {
                    f2 = -1;
                  }
                  f2 = f2 + 1 | 0;
                  f2 = (f2 | 0) == 6 | j & (f2 | 0) == 5 ? 0 : f2;
                }
                c3 = h;
                a3 = g2;
                break a;
              }
            } while (0);
            e3 = f2;
            T = u3;
            return e3 | 0;
          }
        } while (0);
        s2 = Ud(f2 | 0, 0, 56) | 0;
        t2 = H() | 0 | c3 & -2130706433 | 536870912;
        b2[e3 >> 2] = s2 | a3;
        b2[e3 + 4 >> 2] = t2;
        e3 = 0;
        T = u3;
        return e3 | 0;
      }
      function ud(a3, c3, d3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0, g2 = 0;
        g2 = (Kb(a3, c3) | 0) == 0;
        e3 = td(a3, c3, 0, d3) | 0;
        f2 = (e3 | 0) == 0;
        if (g2) {
          if (!f2) {
            g2 = e3;
            return g2 | 0;
          }
          e3 = td(a3, c3, 1, d3 + 8 | 0) | 0;
          if (e3 | 0) {
            g2 = e3;
            return g2 | 0;
          }
          e3 = td(a3, c3, 2, d3 + 16 | 0) | 0;
          if (e3 | 0) {
            g2 = e3;
            return g2 | 0;
          }
          e3 = td(a3, c3, 3, d3 + 24 | 0) | 0;
          if (e3 | 0) {
            g2 = e3;
            return g2 | 0;
          }
          e3 = td(a3, c3, 4, d3 + 32 | 0) | 0;
          if (!e3) {
            return td(a3, c3, 5, d3 + 40 | 0) | 0;
          } else {
            g2 = e3;
            return g2 | 0;
          }
        }
        if (!f2) {
          g2 = e3;
          return g2 | 0;
        }
        e3 = td(a3, c3, 1, d3 + 8 | 0) | 0;
        if (e3 | 0) {
          g2 = e3;
          return g2 | 0;
        }
        e3 = td(a3, c3, 2, d3 + 16 | 0) | 0;
        if (e3 | 0) {
          g2 = e3;
          return g2 | 0;
        }
        e3 = td(a3, c3, 3, d3 + 24 | 0) | 0;
        if (e3 | 0) {
          g2 = e3;
          return g2 | 0;
        }
        e3 = td(a3, c3, 4, d3 + 32 | 0) | 0;
        if (e3 | 0) {
          g2 = e3;
          return g2 | 0;
        }
        g2 = d3 + 40 | 0;
        b2[g2 >> 2] = 0;
        b2[g2 + 4 >> 2] = 0;
        g2 = 0;
        return g2 | 0;
      }
      function vd(a3, c3, d3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0;
        j = T;
        T = T + 192 | 0;
        f2 = j;
        g2 = j + 168 | 0;
        h = Td(a3 | 0, c3 | 0, 56) | 0;
        H() | 0;
        h = h & 7;
        i = c3 & -2130706433 | 134217728;
        e3 = $b(a3, i, g2) | 0;
        if (e3 | 0) {
          i = e3;
          T = j;
          return i | 0;
        }
        c3 = Td(a3 | 0, c3 | 0, 52) | 0;
        H() | 0;
        c3 = c3 & 15;
        if (!(Kb(a3, i) | 0)) {
          zb(g2, c3, h, 1, f2);
        } else {
          vb(g2, c3, h, 1, f2);
        }
        i = f2 + 8 | 0;
        b2[d3 >> 2] = b2[i >> 2];
        b2[d3 + 4 >> 2] = b2[i + 4 >> 2];
        b2[d3 + 8 >> 2] = b2[i + 8 >> 2];
        b2[d3 + 12 >> 2] = b2[i + 12 >> 2];
        i = 0;
        T = j;
        return i | 0;
      }
      function wd(a3, c3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        var d3 = 0, e3 = 0, f2 = 0, g2 = 0;
        f2 = T;
        T = T + 16 | 0;
        d3 = f2;
        if (!(true & (c3 & 2013265920 | 0) == 536870912)) {
          e3 = 0;
          T = f2;
          return e3 | 0;
        }
        e3 = c3 & -2130706433 | 134217728;
        if (!(Fb(a3, e3) | 0)) {
          e3 = 0;
          T = f2;
          return e3 | 0;
        }
        g2 = Td(a3 | 0, c3 | 0, 56) | 0;
        H() | 0;
        g2 = (td(a3, e3, g2 & 7, d3) | 0) == 0;
        e3 = d3;
        e3 = g2 & ((b2[e3 >> 2] | 0) == (a3 | 0) ? (b2[e3 + 4 >> 2] | 0) == (c3 | 0) : 0) & 1;
        T = f2;
        return e3 | 0;
      }
      function xd(a3, c3, d3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0;
        if ((c3 | 0) > 0) {
          e3 = Id(c3, 4) | 0;
          b2[a3 >> 2] = e3;
          if (!e3) {
            I(27835, 27858, 40, 27872);
          }
        } else {
          b2[a3 >> 2] = 0;
        }
        b2[a3 + 4 >> 2] = c3;
        b2[a3 + 8 >> 2] = 0;
        b2[a3 + 12 >> 2] = d3;
        return;
      }
      function yd(a3) {
        a3 = a3 | 0;
        var c3 = 0, d3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0;
        g2 = a3 + 4 | 0;
        h = a3 + 12 | 0;
        i = a3 + 8 | 0;
        a: while (1) {
          d3 = b2[g2 >> 2] | 0;
          c3 = 0;
          while (1) {
            if ((c3 | 0) >= (d3 | 0)) {
              break a;
            }
            f2 = b2[a3 >> 2] | 0;
            j = b2[f2 + (c3 << 2) >> 2] | 0;
            if (!j) {
              c3 = c3 + 1 | 0;
            } else {
              break;
            }
          }
          c3 = f2 + (~~(+q(+(+s(10, + +(15 - (b2[h >> 2] | 0) | 0)) * (+e2[j >> 3] + +e2[j + 8 >> 3]))) % +(d3 | 0)) >>> 0 << 2) | 0;
          d3 = b2[c3 >> 2] | 0;
          b: do {
            if (d3 | 0) {
              f2 = j + 32 | 0;
              if ((d3 | 0) == (j | 0)) {
                b2[c3 >> 2] = b2[f2 >> 2];
              } else {
                d3 = d3 + 32 | 0;
                c3 = b2[d3 >> 2] | 0;
                if (!c3) {
                  break;
                }
                while (1) {
                  if ((c3 | 0) == (j | 0)) {
                    break;
                  }
                  d3 = c3 + 32 | 0;
                  c3 = b2[d3 >> 2] | 0;
                  if (!c3) {
                    break b;
                  }
                }
                b2[d3 >> 2] = b2[f2 >> 2];
              }
              Hd(j);
              b2[i >> 2] = (b2[i >> 2] | 0) + -1;
            }
          } while (0);
        }
        Hd(b2[a3 >> 2] | 0);
        return;
      }
      function zd(a3) {
        a3 = a3 | 0;
        var c3 = 0, d3 = 0, e3 = 0;
        e3 = b2[a3 + 4 >> 2] | 0;
        d3 = 0;
        while (1) {
          if ((d3 | 0) >= (e3 | 0)) {
            c3 = 0;
            d3 = 4;
            break;
          }
          c3 = b2[(b2[a3 >> 2] | 0) + (d3 << 2) >> 2] | 0;
          if (!c3) {
            d3 = d3 + 1 | 0;
          } else {
            d3 = 4;
            break;
          }
        }
        if ((d3 | 0) == 4) {
          return c3 | 0;
        }
        return 0;
      }
      function Ad(a3, c3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        var d3 = 0, f2 = 0, g2 = 0, h = 0;
        d3 = ~~(+q(+(+s(10, + +(15 - (b2[a3 + 12 >> 2] | 0) | 0)) * (+e2[c3 >> 3] + +e2[c3 + 8 >> 3]))) % +(b2[a3 + 4 >> 2] | 0)) >>> 0;
        d3 = (b2[a3 >> 2] | 0) + (d3 << 2) | 0;
        f2 = b2[d3 >> 2] | 0;
        if (!f2) {
          h = 1;
          return h | 0;
        }
        h = c3 + 32 | 0;
        do {
          if ((f2 | 0) != (c3 | 0)) {
            d3 = b2[f2 + 32 >> 2] | 0;
            if (!d3) {
              h = 1;
              return h | 0;
            }
            g2 = d3;
            while (1) {
              if ((g2 | 0) == (c3 | 0)) {
                g2 = 8;
                break;
              }
              d3 = b2[g2 + 32 >> 2] | 0;
              if (!d3) {
                d3 = 1;
                g2 = 10;
                break;
              } else {
                f2 = g2;
                g2 = d3;
              }
            }
            if ((g2 | 0) == 8) {
              b2[f2 + 32 >> 2] = b2[h >> 2];
              break;
            } else if ((g2 | 0) == 10) {
              return d3 | 0;
            }
          } else {
            b2[d3 >> 2] = b2[h >> 2];
          }
        } while (0);
        Hd(c3);
        h = a3 + 8 | 0;
        b2[h >> 2] = (b2[h >> 2] | 0) + -1;
        h = 0;
        return h | 0;
      }
      function Bd(a3, c3, d3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0;
        h = Gd(40) | 0;
        if (!h) {
          I(27888, 27858, 98, 27901);
        }
        b2[h >> 2] = b2[c3 >> 2];
        b2[h + 4 >> 2] = b2[c3 + 4 >> 2];
        b2[h + 8 >> 2] = b2[c3 + 8 >> 2];
        b2[h + 12 >> 2] = b2[c3 + 12 >> 2];
        g2 = h + 16 | 0;
        b2[g2 >> 2] = b2[d3 >> 2];
        b2[g2 + 4 >> 2] = b2[d3 + 4 >> 2];
        b2[g2 + 8 >> 2] = b2[d3 + 8 >> 2];
        b2[g2 + 12 >> 2] = b2[d3 + 12 >> 2];
        b2[h + 32 >> 2] = 0;
        g2 = ~~(+q(+(+s(10, + +(15 - (b2[a3 + 12 >> 2] | 0) | 0)) * (+e2[c3 >> 3] + +e2[c3 + 8 >> 3]))) % +(b2[a3 + 4 >> 2] | 0)) >>> 0;
        g2 = (b2[a3 >> 2] | 0) + (g2 << 2) | 0;
        f2 = b2[g2 >> 2] | 0;
        do {
          if (!f2) {
            b2[g2 >> 2] = h;
          } else {
            while (1) {
              if (mc(f2, c3) | 0 ? mc(f2 + 16 | 0, d3) | 0 : 0) {
                break;
              }
              g2 = b2[f2 + 32 >> 2] | 0;
              f2 = (g2 | 0) == 0 ? f2 : g2;
              if (!(b2[f2 + 32 >> 2] | 0)) {
                i = 10;
                break;
              }
            }
            if ((i | 0) == 10) {
              b2[f2 + 32 >> 2] = h;
              break;
            }
            Hd(h);
            i = f2;
            return i | 0;
          }
        } while (0);
        i = a3 + 8 | 0;
        b2[i >> 2] = (b2[i >> 2] | 0) + 1;
        i = h;
        return i | 0;
      }
      function Cd(a3, c3, d3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var f2 = 0, g2 = 0;
        g2 = ~~(+q(+(+s(10, + +(15 - (b2[a3 + 12 >> 2] | 0) | 0)) * (+e2[c3 >> 3] + +e2[c3 + 8 >> 3]))) % +(b2[a3 + 4 >> 2] | 0)) >>> 0;
        g2 = b2[(b2[a3 >> 2] | 0) + (g2 << 2) >> 2] | 0;
        if (!g2) {
          d3 = 0;
          return d3 | 0;
        }
        if (!d3) {
          a3 = g2;
          while (1) {
            if (mc(a3, c3) | 0) {
              f2 = 10;
              break;
            }
            a3 = b2[a3 + 32 >> 2] | 0;
            if (!a3) {
              a3 = 0;
              f2 = 10;
              break;
            }
          }
          if ((f2 | 0) == 10) {
            return a3 | 0;
          }
        }
        a3 = g2;
        while (1) {
          if (mc(a3, c3) | 0 ? mc(a3 + 16 | 0, d3) | 0 : 0) {
            f2 = 10;
            break;
          }
          a3 = b2[a3 + 32 >> 2] | 0;
          if (!a3) {
            a3 = 0;
            f2 = 10;
            break;
          }
        }
        if ((f2 | 0) == 10) {
          return a3 | 0;
        }
        return 0;
      }
      function Dd(a3, c3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        var d3 = 0;
        d3 = ~~(+q(+(+s(10, + +(15 - (b2[a3 + 12 >> 2] | 0) | 0)) * (+e2[c3 >> 3] + +e2[c3 + 8 >> 3]))) % +(b2[a3 + 4 >> 2] | 0)) >>> 0;
        a3 = b2[(b2[a3 >> 2] | 0) + (d3 << 2) >> 2] | 0;
        if (!a3) {
          d3 = 0;
          return d3 | 0;
        }
        while (1) {
          if (mc(a3, c3) | 0) {
            c3 = 5;
            break;
          }
          a3 = b2[a3 + 32 >> 2] | 0;
          if (!a3) {
            a3 = 0;
            c3 = 5;
            break;
          }
        }
        if ((c3 | 0) == 5) {
          return a3 | 0;
        }
        return 0;
      }
      function Ed() {
        return 27920;
      }
      function Fd(a3) {
        a3 = +a3;
        return ~~+$d(+a3) | 0;
      }
      function Gd(a3) {
        a3 = a3 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t2 = 0, u3 = 0, v3 = 0, w3 = 0;
        w3 = T;
        T = T + 16 | 0;
        n = w3;
        do {
          if (a3 >>> 0 < 245) {
            k = a3 >>> 0 < 11 ? 16 : a3 + 11 & -8;
            a3 = k >>> 3;
            m = b2[6981] | 0;
            d3 = m >>> a3;
            if (d3 & 3 | 0) {
              c3 = (d3 & 1 ^ 1) + a3 | 0;
              a3 = 27964 + (c3 << 1 << 2) | 0;
              d3 = a3 + 8 | 0;
              e3 = b2[d3 >> 2] | 0;
              f2 = e3 + 8 | 0;
              g2 = b2[f2 >> 2] | 0;
              if ((g2 | 0) == (a3 | 0)) {
                b2[6981] = m & ~(1 << c3);
              } else {
                b2[g2 + 12 >> 2] = a3;
                b2[d3 >> 2] = g2;
              }
              v3 = c3 << 3;
              b2[e3 + 4 >> 2] = v3 | 3;
              v3 = e3 + v3 + 4 | 0;
              b2[v3 >> 2] = b2[v3 >> 2] | 1;
              v3 = f2;
              T = w3;
              return v3 | 0;
            }
            l = b2[6983] | 0;
            if (k >>> 0 > l >>> 0) {
              if (d3 | 0) {
                c3 = 2 << a3;
                c3 = d3 << a3 & (c3 | 0 - c3);
                c3 = (c3 & 0 - c3) + -1 | 0;
                i = c3 >>> 12 & 16;
                c3 = c3 >>> i;
                d3 = c3 >>> 5 & 8;
                c3 = c3 >>> d3;
                g2 = c3 >>> 2 & 4;
                c3 = c3 >>> g2;
                a3 = c3 >>> 1 & 2;
                c3 = c3 >>> a3;
                e3 = c3 >>> 1 & 1;
                e3 = (d3 | i | g2 | a3 | e3) + (c3 >>> e3) | 0;
                c3 = 27964 + (e3 << 1 << 2) | 0;
                a3 = c3 + 8 | 0;
                g2 = b2[a3 >> 2] | 0;
                i = g2 + 8 | 0;
                d3 = b2[i >> 2] | 0;
                if ((d3 | 0) == (c3 | 0)) {
                  a3 = m & ~(1 << e3);
                  b2[6981] = a3;
                } else {
                  b2[d3 + 12 >> 2] = c3;
                  b2[a3 >> 2] = d3;
                  a3 = m;
                }
                v3 = e3 << 3;
                h = v3 - k | 0;
                b2[g2 + 4 >> 2] = k | 3;
                f2 = g2 + k | 0;
                b2[f2 + 4 >> 2] = h | 1;
                b2[g2 + v3 >> 2] = h;
                if (l | 0) {
                  e3 = b2[6986] | 0;
                  c3 = l >>> 3;
                  d3 = 27964 + (c3 << 1 << 2) | 0;
                  c3 = 1 << c3;
                  if (!(a3 & c3)) {
                    b2[6981] = a3 | c3;
                    c3 = d3;
                    a3 = d3 + 8 | 0;
                  } else {
                    a3 = d3 + 8 | 0;
                    c3 = b2[a3 >> 2] | 0;
                  }
                  b2[a3 >> 2] = e3;
                  b2[c3 + 12 >> 2] = e3;
                  b2[e3 + 8 >> 2] = c3;
                  b2[e3 + 12 >> 2] = d3;
                }
                b2[6983] = h;
                b2[6986] = f2;
                v3 = i;
                T = w3;
                return v3 | 0;
              }
              g2 = b2[6982] | 0;
              if (g2) {
                d3 = (g2 & 0 - g2) + -1 | 0;
                f2 = d3 >>> 12 & 16;
                d3 = d3 >>> f2;
                e3 = d3 >>> 5 & 8;
                d3 = d3 >>> e3;
                h = d3 >>> 2 & 4;
                d3 = d3 >>> h;
                i = d3 >>> 1 & 2;
                d3 = d3 >>> i;
                j = d3 >>> 1 & 1;
                j = b2[28228 + ((e3 | f2 | h | i | j) + (d3 >>> j) << 2) >> 2] | 0;
                d3 = j;
                i = j;
                j = (b2[j + 4 >> 2] & -8) - k | 0;
                while (1) {
                  a3 = b2[d3 + 16 >> 2] | 0;
                  if (!a3) {
                    a3 = b2[d3 + 20 >> 2] | 0;
                    if (!a3) {
                      break;
                    }
                  }
                  h = (b2[a3 + 4 >> 2] & -8) - k | 0;
                  f2 = h >>> 0 < j >>> 0;
                  d3 = a3;
                  i = f2 ? a3 : i;
                  j = f2 ? h : j;
                }
                h = i + k | 0;
                if (h >>> 0 > i >>> 0) {
                  f2 = b2[i + 24 >> 2] | 0;
                  c3 = b2[i + 12 >> 2] | 0;
                  do {
                    if ((c3 | 0) == (i | 0)) {
                      a3 = i + 20 | 0;
                      c3 = b2[a3 >> 2] | 0;
                      if (!c3) {
                        a3 = i + 16 | 0;
                        c3 = b2[a3 >> 2] | 0;
                        if (!c3) {
                          d3 = 0;
                          break;
                        }
                      }
                      while (1) {
                        e3 = c3 + 20 | 0;
                        d3 = b2[e3 >> 2] | 0;
                        if (!d3) {
                          e3 = c3 + 16 | 0;
                          d3 = b2[e3 >> 2] | 0;
                          if (!d3) {
                            break;
                          } else {
                            c3 = d3;
                            a3 = e3;
                          }
                        } else {
                          c3 = d3;
                          a3 = e3;
                        }
                      }
                      b2[a3 >> 2] = 0;
                      d3 = c3;
                    } else {
                      d3 = b2[i + 8 >> 2] | 0;
                      b2[d3 + 12 >> 2] = c3;
                      b2[c3 + 8 >> 2] = d3;
                      d3 = c3;
                    }
                  } while (0);
                  do {
                    if (f2 | 0) {
                      c3 = b2[i + 28 >> 2] | 0;
                      a3 = 28228 + (c3 << 2) | 0;
                      if ((i | 0) == (b2[a3 >> 2] | 0)) {
                        b2[a3 >> 2] = d3;
                        if (!d3) {
                          b2[6982] = g2 & ~(1 << c3);
                          break;
                        }
                      } else {
                        v3 = f2 + 16 | 0;
                        b2[((b2[v3 >> 2] | 0) == (i | 0) ? v3 : f2 + 20 | 0) >> 2] = d3;
                        if (!d3) {
                          break;
                        }
                      }
                      b2[d3 + 24 >> 2] = f2;
                      c3 = b2[i + 16 >> 2] | 0;
                      if (c3 | 0) {
                        b2[d3 + 16 >> 2] = c3;
                        b2[c3 + 24 >> 2] = d3;
                      }
                      c3 = b2[i + 20 >> 2] | 0;
                      if (c3 | 0) {
                        b2[d3 + 20 >> 2] = c3;
                        b2[c3 + 24 >> 2] = d3;
                      }
                    }
                  } while (0);
                  if (j >>> 0 < 16) {
                    v3 = j + k | 0;
                    b2[i + 4 >> 2] = v3 | 3;
                    v3 = i + v3 + 4 | 0;
                    b2[v3 >> 2] = b2[v3 >> 2] | 1;
                  } else {
                    b2[i + 4 >> 2] = k | 3;
                    b2[h + 4 >> 2] = j | 1;
                    b2[h + j >> 2] = j;
                    if (l | 0) {
                      e3 = b2[6986] | 0;
                      c3 = l >>> 3;
                      d3 = 27964 + (c3 << 1 << 2) | 0;
                      c3 = 1 << c3;
                      if (!(c3 & m)) {
                        b2[6981] = c3 | m;
                        c3 = d3;
                        a3 = d3 + 8 | 0;
                      } else {
                        a3 = d3 + 8 | 0;
                        c3 = b2[a3 >> 2] | 0;
                      }
                      b2[a3 >> 2] = e3;
                      b2[c3 + 12 >> 2] = e3;
                      b2[e3 + 8 >> 2] = c3;
                      b2[e3 + 12 >> 2] = d3;
                    }
                    b2[6983] = j;
                    b2[6986] = h;
                  }
                  v3 = i + 8 | 0;
                  T = w3;
                  return v3 | 0;
                } else {
                  m = k;
                }
              } else {
                m = k;
              }
            } else {
              m = k;
            }
          } else if (a3 >>> 0 <= 4294967231) {
            a3 = a3 + 11 | 0;
            k = a3 & -8;
            e3 = b2[6982] | 0;
            if (e3) {
              f2 = 0 - k | 0;
              a3 = a3 >>> 8;
              if (a3) {
                if (k >>> 0 > 16777215) {
                  j = 31;
                } else {
                  m = (a3 + 1048320 | 0) >>> 16 & 8;
                  q2 = a3 << m;
                  i = (q2 + 520192 | 0) >>> 16 & 4;
                  q2 = q2 << i;
                  j = (q2 + 245760 | 0) >>> 16 & 2;
                  j = 14 - (i | m | j) + (q2 << j >>> 15) | 0;
                  j = k >>> (j + 7 | 0) & 1 | j << 1;
                }
              } else {
                j = 0;
              }
              d3 = b2[28228 + (j << 2) >> 2] | 0;
              a: do {
                if (!d3) {
                  d3 = 0;
                  a3 = 0;
                  q2 = 61;
                } else {
                  a3 = 0;
                  i = k << ((j | 0) == 31 ? 0 : 25 - (j >>> 1) | 0);
                  g2 = 0;
                  while (1) {
                    h = (b2[d3 + 4 >> 2] & -8) - k | 0;
                    if (h >>> 0 < f2 >>> 0) {
                      if (!h) {
                        a3 = d3;
                        f2 = 0;
                        q2 = 65;
                        break a;
                      } else {
                        a3 = d3;
                        f2 = h;
                      }
                    }
                    q2 = b2[d3 + 20 >> 2] | 0;
                    d3 = b2[d3 + 16 + (i >>> 31 << 2) >> 2] | 0;
                    g2 = (q2 | 0) == 0 | (q2 | 0) == (d3 | 0) ? g2 : q2;
                    if (!d3) {
                      d3 = g2;
                      q2 = 61;
                      break;
                    } else {
                      i = i << 1;
                    }
                  }
                }
              } while (0);
              if ((q2 | 0) == 61) {
                if ((d3 | 0) == 0 & (a3 | 0) == 0) {
                  a3 = 2 << j;
                  a3 = (a3 | 0 - a3) & e3;
                  if (!a3) {
                    m = k;
                    break;
                  }
                  m = (a3 & 0 - a3) + -1 | 0;
                  h = m >>> 12 & 16;
                  m = m >>> h;
                  g2 = m >>> 5 & 8;
                  m = m >>> g2;
                  i = m >>> 2 & 4;
                  m = m >>> i;
                  j = m >>> 1 & 2;
                  m = m >>> j;
                  d3 = m >>> 1 & 1;
                  a3 = 0;
                  d3 = b2[28228 + ((g2 | h | i | j | d3) + (m >>> d3) << 2) >> 2] | 0;
                }
                if (!d3) {
                  i = a3;
                  h = f2;
                } else {
                  q2 = 65;
                }
              }
              if ((q2 | 0) == 65) {
                g2 = d3;
                while (1) {
                  m = (b2[g2 + 4 >> 2] & -8) - k | 0;
                  d3 = m >>> 0 < f2 >>> 0;
                  f2 = d3 ? m : f2;
                  a3 = d3 ? g2 : a3;
                  d3 = b2[g2 + 16 >> 2] | 0;
                  if (!d3) {
                    d3 = b2[g2 + 20 >> 2] | 0;
                  }
                  if (!d3) {
                    i = a3;
                    h = f2;
                    break;
                  } else {
                    g2 = d3;
                  }
                }
              }
              if (((i | 0) != 0 ? h >>> 0 < ((b2[6983] | 0) - k | 0) >>> 0 : 0) ? (l = i + k | 0, l >>> 0 > i >>> 0) : 0) {
                g2 = b2[i + 24 >> 2] | 0;
                c3 = b2[i + 12 >> 2] | 0;
                do {
                  if ((c3 | 0) == (i | 0)) {
                    a3 = i + 20 | 0;
                    c3 = b2[a3 >> 2] | 0;
                    if (!c3) {
                      a3 = i + 16 | 0;
                      c3 = b2[a3 >> 2] | 0;
                      if (!c3) {
                        c3 = 0;
                        break;
                      }
                    }
                    while (1) {
                      f2 = c3 + 20 | 0;
                      d3 = b2[f2 >> 2] | 0;
                      if (!d3) {
                        f2 = c3 + 16 | 0;
                        d3 = b2[f2 >> 2] | 0;
                        if (!d3) {
                          break;
                        } else {
                          c3 = d3;
                          a3 = f2;
                        }
                      } else {
                        c3 = d3;
                        a3 = f2;
                      }
                    }
                    b2[a3 >> 2] = 0;
                  } else {
                    v3 = b2[i + 8 >> 2] | 0;
                    b2[v3 + 12 >> 2] = c3;
                    b2[c3 + 8 >> 2] = v3;
                  }
                } while (0);
                do {
                  if (g2) {
                    a3 = b2[i + 28 >> 2] | 0;
                    d3 = 28228 + (a3 << 2) | 0;
                    if ((i | 0) == (b2[d3 >> 2] | 0)) {
                      b2[d3 >> 2] = c3;
                      if (!c3) {
                        e3 = e3 & ~(1 << a3);
                        b2[6982] = e3;
                        break;
                      }
                    } else {
                      v3 = g2 + 16 | 0;
                      b2[((b2[v3 >> 2] | 0) == (i | 0) ? v3 : g2 + 20 | 0) >> 2] = c3;
                      if (!c3) {
                        break;
                      }
                    }
                    b2[c3 + 24 >> 2] = g2;
                    a3 = b2[i + 16 >> 2] | 0;
                    if (a3 | 0) {
                      b2[c3 + 16 >> 2] = a3;
                      b2[a3 + 24 >> 2] = c3;
                    }
                    a3 = b2[i + 20 >> 2] | 0;
                    if (a3) {
                      b2[c3 + 20 >> 2] = a3;
                      b2[a3 + 24 >> 2] = c3;
                    }
                  }
                } while (0);
                b: do {
                  if (h >>> 0 < 16) {
                    v3 = h + k | 0;
                    b2[i + 4 >> 2] = v3 | 3;
                    v3 = i + v3 + 4 | 0;
                    b2[v3 >> 2] = b2[v3 >> 2] | 1;
                  } else {
                    b2[i + 4 >> 2] = k | 3;
                    b2[l + 4 >> 2] = h | 1;
                    b2[l + h >> 2] = h;
                    c3 = h >>> 3;
                    if (h >>> 0 < 256) {
                      d3 = 27964 + (c3 << 1 << 2) | 0;
                      a3 = b2[6981] | 0;
                      c3 = 1 << c3;
                      if (!(a3 & c3)) {
                        b2[6981] = a3 | c3;
                        c3 = d3;
                        a3 = d3 + 8 | 0;
                      } else {
                        a3 = d3 + 8 | 0;
                        c3 = b2[a3 >> 2] | 0;
                      }
                      b2[a3 >> 2] = l;
                      b2[c3 + 12 >> 2] = l;
                      b2[l + 8 >> 2] = c3;
                      b2[l + 12 >> 2] = d3;
                      break;
                    }
                    c3 = h >>> 8;
                    if (c3) {
                      if (h >>> 0 > 16777215) {
                        d3 = 31;
                      } else {
                        u3 = (c3 + 1048320 | 0) >>> 16 & 8;
                        v3 = c3 << u3;
                        t2 = (v3 + 520192 | 0) >>> 16 & 4;
                        v3 = v3 << t2;
                        d3 = (v3 + 245760 | 0) >>> 16 & 2;
                        d3 = 14 - (t2 | u3 | d3) + (v3 << d3 >>> 15) | 0;
                        d3 = h >>> (d3 + 7 | 0) & 1 | d3 << 1;
                      }
                    } else {
                      d3 = 0;
                    }
                    c3 = 28228 + (d3 << 2) | 0;
                    b2[l + 28 >> 2] = d3;
                    a3 = l + 16 | 0;
                    b2[a3 + 4 >> 2] = 0;
                    b2[a3 >> 2] = 0;
                    a3 = 1 << d3;
                    if (!(e3 & a3)) {
                      b2[6982] = e3 | a3;
                      b2[c3 >> 2] = l;
                      b2[l + 24 >> 2] = c3;
                      b2[l + 12 >> 2] = l;
                      b2[l + 8 >> 2] = l;
                      break;
                    }
                    c3 = b2[c3 >> 2] | 0;
                    c: do {
                      if ((b2[c3 + 4 >> 2] & -8 | 0) != (h | 0)) {
                        e3 = h << ((d3 | 0) == 31 ? 0 : 25 - (d3 >>> 1) | 0);
                        while (1) {
                          d3 = c3 + 16 + (e3 >>> 31 << 2) | 0;
                          a3 = b2[d3 >> 2] | 0;
                          if (!a3) {
                            break;
                          }
                          if ((b2[a3 + 4 >> 2] & -8 | 0) == (h | 0)) {
                            c3 = a3;
                            break c;
                          } else {
                            e3 = e3 << 1;
                            c3 = a3;
                          }
                        }
                        b2[d3 >> 2] = l;
                        b2[l + 24 >> 2] = c3;
                        b2[l + 12 >> 2] = l;
                        b2[l + 8 >> 2] = l;
                        break b;
                      }
                    } while (0);
                    u3 = c3 + 8 | 0;
                    v3 = b2[u3 >> 2] | 0;
                    b2[v3 + 12 >> 2] = l;
                    b2[u3 >> 2] = l;
                    b2[l + 8 >> 2] = v3;
                    b2[l + 12 >> 2] = c3;
                    b2[l + 24 >> 2] = 0;
                  }
                } while (0);
                v3 = i + 8 | 0;
                T = w3;
                return v3 | 0;
              } else {
                m = k;
              }
            } else {
              m = k;
            }
          } else {
            m = -1;
          }
        } while (0);
        d3 = b2[6983] | 0;
        if (d3 >>> 0 >= m >>> 0) {
          c3 = d3 - m | 0;
          a3 = b2[6986] | 0;
          if (c3 >>> 0 > 15) {
            v3 = a3 + m | 0;
            b2[6986] = v3;
            b2[6983] = c3;
            b2[v3 + 4 >> 2] = c3 | 1;
            b2[a3 + d3 >> 2] = c3;
            b2[a3 + 4 >> 2] = m | 3;
          } else {
            b2[6983] = 0;
            b2[6986] = 0;
            b2[a3 + 4 >> 2] = d3 | 3;
            v3 = a3 + d3 + 4 | 0;
            b2[v3 >> 2] = b2[v3 >> 2] | 1;
          }
          v3 = a3 + 8 | 0;
          T = w3;
          return v3 | 0;
        }
        h = b2[6984] | 0;
        if (h >>> 0 > m >>> 0) {
          t2 = h - m | 0;
          b2[6984] = t2;
          v3 = b2[6987] | 0;
          u3 = v3 + m | 0;
          b2[6987] = u3;
          b2[u3 + 4 >> 2] = t2 | 1;
          b2[v3 + 4 >> 2] = m | 3;
          v3 = v3 + 8 | 0;
          T = w3;
          return v3 | 0;
        }
        if (!(b2[7099] | 0)) {
          b2[7101] = 4096;
          b2[7100] = 4096;
          b2[7102] = -1;
          b2[7103] = -1;
          b2[7104] = 0;
          b2[7092] = 0;
          b2[7099] = n & -16 ^ 1431655768;
          a3 = 4096;
        } else {
          a3 = b2[7101] | 0;
        }
        i = m + 48 | 0;
        j = m + 47 | 0;
        g2 = a3 + j | 0;
        f2 = 0 - a3 | 0;
        k = g2 & f2;
        if (k >>> 0 <= m >>> 0) {
          v3 = 0;
          T = w3;
          return v3 | 0;
        }
        a3 = b2[7091] | 0;
        if (a3 | 0 ? (l = b2[7089] | 0, n = l + k | 0, n >>> 0 <= l >>> 0 | n >>> 0 > a3 >>> 0) : 0) {
          v3 = 0;
          T = w3;
          return v3 | 0;
        }
        d: do {
          if (!(b2[7092] & 4)) {
            d3 = b2[6987] | 0;
            e: do {
              if (d3) {
                e3 = 28372;
                while (1) {
                  n = b2[e3 >> 2] | 0;
                  if (n >>> 0 <= d3 >>> 0 ? (n + (b2[e3 + 4 >> 2] | 0) | 0) >>> 0 > d3 >>> 0 : 0) {
                    break;
                  }
                  a3 = b2[e3 + 8 >> 2] | 0;
                  if (!a3) {
                    q2 = 128;
                    break e;
                  } else {
                    e3 = a3;
                  }
                }
                c3 = g2 - h & f2;
                if (c3 >>> 0 < 2147483647) {
                  a3 = ae(c3 | 0) | 0;
                  if ((a3 | 0) == ((b2[e3 >> 2] | 0) + (b2[e3 + 4 >> 2] | 0) | 0)) {
                    if ((a3 | 0) != (-1 | 0)) {
                      h = c3;
                      g2 = a3;
                      q2 = 145;
                      break d;
                    }
                  } else {
                    e3 = a3;
                    q2 = 136;
                  }
                } else {
                  c3 = 0;
                }
              } else {
                q2 = 128;
              }
            } while (0);
            do {
              if ((q2 | 0) == 128) {
                d3 = ae(0) | 0;
                if ((d3 | 0) != (-1 | 0) ? (c3 = d3, o = b2[7100] | 0, p2 = o + -1 | 0, c3 = ((p2 & c3 | 0) == 0 ? 0 : (p2 + c3 & 0 - o) - c3 | 0) + k | 0, o = b2[7089] | 0, p2 = c3 + o | 0, c3 >>> 0 > m >>> 0 & c3 >>> 0 < 2147483647) : 0) {
                  n = b2[7091] | 0;
                  if (n | 0 ? p2 >>> 0 <= o >>> 0 | p2 >>> 0 > n >>> 0 : 0) {
                    c3 = 0;
                    break;
                  }
                  a3 = ae(c3 | 0) | 0;
                  if ((a3 | 0) == (d3 | 0)) {
                    h = c3;
                    g2 = d3;
                    q2 = 145;
                    break d;
                  } else {
                    e3 = a3;
                    q2 = 136;
                  }
                } else {
                  c3 = 0;
                }
              }
            } while (0);
            do {
              if ((q2 | 0) == 136) {
                d3 = 0 - c3 | 0;
                if (!(i >>> 0 > c3 >>> 0 & (c3 >>> 0 < 2147483647 & (e3 | 0) != (-1 | 0)))) {
                  if ((e3 | 0) == (-1 | 0)) {
                    c3 = 0;
                    break;
                  } else {
                    h = c3;
                    g2 = e3;
                    q2 = 145;
                    break d;
                  }
                }
                a3 = b2[7101] | 0;
                a3 = j - c3 + a3 & 0 - a3;
                if (a3 >>> 0 >= 2147483647) {
                  h = c3;
                  g2 = e3;
                  q2 = 145;
                  break d;
                }
                if ((ae(a3 | 0) | 0) == (-1 | 0)) {
                  ae(d3 | 0) | 0;
                  c3 = 0;
                  break;
                } else {
                  h = a3 + c3 | 0;
                  g2 = e3;
                  q2 = 145;
                  break d;
                }
              }
            } while (0);
            b2[7092] = b2[7092] | 4;
            q2 = 143;
          } else {
            c3 = 0;
            q2 = 143;
          }
        } while (0);
        if (((q2 | 0) == 143 ? k >>> 0 < 2147483647 : 0) ? (t2 = ae(k | 0) | 0, p2 = ae(0) | 0, r2 = p2 - t2 | 0, s2 = r2 >>> 0 > (m + 40 | 0) >>> 0, !((t2 | 0) == (-1 | 0) | s2 ^ 1 | t2 >>> 0 < p2 >>> 0 & ((t2 | 0) != (-1 | 0) & (p2 | 0) != (-1 | 0)) ^ 1)) : 0) {
          h = s2 ? r2 : c3;
          g2 = t2;
          q2 = 145;
        }
        if ((q2 | 0) == 145) {
          c3 = (b2[7089] | 0) + h | 0;
          b2[7089] = c3;
          if (c3 >>> 0 > (b2[7090] | 0) >>> 0) {
            b2[7090] = c3;
          }
          j = b2[6987] | 0;
          f: do {
            if (j) {
              c3 = 28372;
              while (1) {
                a3 = b2[c3 >> 2] | 0;
                d3 = b2[c3 + 4 >> 2] | 0;
                if ((g2 | 0) == (a3 + d3 | 0)) {
                  q2 = 154;
                  break;
                }
                e3 = b2[c3 + 8 >> 2] | 0;
                if (!e3) {
                  break;
                } else {
                  c3 = e3;
                }
              }
              if (((q2 | 0) == 154 ? (u3 = c3 + 4 | 0, (b2[c3 + 12 >> 2] & 8 | 0) == 0) : 0) ? g2 >>> 0 > j >>> 0 & a3 >>> 0 <= j >>> 0 : 0) {
                b2[u3 >> 2] = d3 + h;
                v3 = (b2[6984] | 0) + h | 0;
                t2 = j + 8 | 0;
                t2 = (t2 & 7 | 0) == 0 ? 0 : 0 - t2 & 7;
                u3 = j + t2 | 0;
                t2 = v3 - t2 | 0;
                b2[6987] = u3;
                b2[6984] = t2;
                b2[u3 + 4 >> 2] = t2 | 1;
                b2[j + v3 + 4 >> 2] = 40;
                b2[6988] = b2[7103];
                break;
              }
              if (g2 >>> 0 < (b2[6985] | 0) >>> 0) {
                b2[6985] = g2;
              }
              d3 = g2 + h | 0;
              c3 = 28372;
              while (1) {
                if ((b2[c3 >> 2] | 0) == (d3 | 0)) {
                  q2 = 162;
                  break;
                }
                a3 = b2[c3 + 8 >> 2] | 0;
                if (!a3) {
                  break;
                } else {
                  c3 = a3;
                }
              }
              if ((q2 | 0) == 162 ? (b2[c3 + 12 >> 2] & 8 | 0) == 0 : 0) {
                b2[c3 >> 2] = g2;
                l = c3 + 4 | 0;
                b2[l >> 2] = (b2[l >> 2] | 0) + h;
                l = g2 + 8 | 0;
                l = g2 + ((l & 7 | 0) == 0 ? 0 : 0 - l & 7) | 0;
                c3 = d3 + 8 | 0;
                c3 = d3 + ((c3 & 7 | 0) == 0 ? 0 : 0 - c3 & 7) | 0;
                k = l + m | 0;
                i = c3 - l - m | 0;
                b2[l + 4 >> 2] = m | 3;
                g: do {
                  if ((j | 0) == (c3 | 0)) {
                    v3 = (b2[6984] | 0) + i | 0;
                    b2[6984] = v3;
                    b2[6987] = k;
                    b2[k + 4 >> 2] = v3 | 1;
                  } else {
                    if ((b2[6986] | 0) == (c3 | 0)) {
                      v3 = (b2[6983] | 0) + i | 0;
                      b2[6983] = v3;
                      b2[6986] = k;
                      b2[k + 4 >> 2] = v3 | 1;
                      b2[k + v3 >> 2] = v3;
                      break;
                    }
                    a3 = b2[c3 + 4 >> 2] | 0;
                    if ((a3 & 3 | 0) == 1) {
                      h = a3 & -8;
                      e3 = a3 >>> 3;
                      h: do {
                        if (a3 >>> 0 < 256) {
                          a3 = b2[c3 + 8 >> 2] | 0;
                          d3 = b2[c3 + 12 >> 2] | 0;
                          if ((d3 | 0) == (a3 | 0)) {
                            b2[6981] = b2[6981] & ~(1 << e3);
                            break;
                          } else {
                            b2[a3 + 12 >> 2] = d3;
                            b2[d3 + 8 >> 2] = a3;
                            break;
                          }
                        } else {
                          g2 = b2[c3 + 24 >> 2] | 0;
                          a3 = b2[c3 + 12 >> 2] | 0;
                          do {
                            if ((a3 | 0) == (c3 | 0)) {
                              d3 = c3 + 16 | 0;
                              e3 = d3 + 4 | 0;
                              a3 = b2[e3 >> 2] | 0;
                              if (!a3) {
                                a3 = b2[d3 >> 2] | 0;
                                if (!a3) {
                                  a3 = 0;
                                  break;
                                }
                              } else {
                                d3 = e3;
                              }
                              while (1) {
                                f2 = a3 + 20 | 0;
                                e3 = b2[f2 >> 2] | 0;
                                if (!e3) {
                                  f2 = a3 + 16 | 0;
                                  e3 = b2[f2 >> 2] | 0;
                                  if (!e3) {
                                    break;
                                  } else {
                                    a3 = e3;
                                    d3 = f2;
                                  }
                                } else {
                                  a3 = e3;
                                  d3 = f2;
                                }
                              }
                              b2[d3 >> 2] = 0;
                            } else {
                              v3 = b2[c3 + 8 >> 2] | 0;
                              b2[v3 + 12 >> 2] = a3;
                              b2[a3 + 8 >> 2] = v3;
                            }
                          } while (0);
                          if (!g2) {
                            break;
                          }
                          d3 = b2[c3 + 28 >> 2] | 0;
                          e3 = 28228 + (d3 << 2) | 0;
                          do {
                            if ((b2[e3 >> 2] | 0) != (c3 | 0)) {
                              v3 = g2 + 16 | 0;
                              b2[((b2[v3 >> 2] | 0) == (c3 | 0) ? v3 : g2 + 20 | 0) >> 2] = a3;
                              if (!a3) {
                                break h;
                              }
                            } else {
                              b2[e3 >> 2] = a3;
                              if (a3 | 0) {
                                break;
                              }
                              b2[6982] = b2[6982] & ~(1 << d3);
                              break h;
                            }
                          } while (0);
                          b2[a3 + 24 >> 2] = g2;
                          d3 = c3 + 16 | 0;
                          e3 = b2[d3 >> 2] | 0;
                          if (e3 | 0) {
                            b2[a3 + 16 >> 2] = e3;
                            b2[e3 + 24 >> 2] = a3;
                          }
                          d3 = b2[d3 + 4 >> 2] | 0;
                          if (!d3) {
                            break;
                          }
                          b2[a3 + 20 >> 2] = d3;
                          b2[d3 + 24 >> 2] = a3;
                        }
                      } while (0);
                      c3 = c3 + h | 0;
                      f2 = h + i | 0;
                    } else {
                      f2 = i;
                    }
                    c3 = c3 + 4 | 0;
                    b2[c3 >> 2] = b2[c3 >> 2] & -2;
                    b2[k + 4 >> 2] = f2 | 1;
                    b2[k + f2 >> 2] = f2;
                    c3 = f2 >>> 3;
                    if (f2 >>> 0 < 256) {
                      d3 = 27964 + (c3 << 1 << 2) | 0;
                      a3 = b2[6981] | 0;
                      c3 = 1 << c3;
                      if (!(a3 & c3)) {
                        b2[6981] = a3 | c3;
                        c3 = d3;
                        a3 = d3 + 8 | 0;
                      } else {
                        a3 = d3 + 8 | 0;
                        c3 = b2[a3 >> 2] | 0;
                      }
                      b2[a3 >> 2] = k;
                      b2[c3 + 12 >> 2] = k;
                      b2[k + 8 >> 2] = c3;
                      b2[k + 12 >> 2] = d3;
                      break;
                    }
                    c3 = f2 >>> 8;
                    do {
                      if (!c3) {
                        e3 = 0;
                      } else {
                        if (f2 >>> 0 > 16777215) {
                          e3 = 31;
                          break;
                        }
                        u3 = (c3 + 1048320 | 0) >>> 16 & 8;
                        v3 = c3 << u3;
                        t2 = (v3 + 520192 | 0) >>> 16 & 4;
                        v3 = v3 << t2;
                        e3 = (v3 + 245760 | 0) >>> 16 & 2;
                        e3 = 14 - (t2 | u3 | e3) + (v3 << e3 >>> 15) | 0;
                        e3 = f2 >>> (e3 + 7 | 0) & 1 | e3 << 1;
                      }
                    } while (0);
                    c3 = 28228 + (e3 << 2) | 0;
                    b2[k + 28 >> 2] = e3;
                    a3 = k + 16 | 0;
                    b2[a3 + 4 >> 2] = 0;
                    b2[a3 >> 2] = 0;
                    a3 = b2[6982] | 0;
                    d3 = 1 << e3;
                    if (!(a3 & d3)) {
                      b2[6982] = a3 | d3;
                      b2[c3 >> 2] = k;
                      b2[k + 24 >> 2] = c3;
                      b2[k + 12 >> 2] = k;
                      b2[k + 8 >> 2] = k;
                      break;
                    }
                    c3 = b2[c3 >> 2] | 0;
                    i: do {
                      if ((b2[c3 + 4 >> 2] & -8 | 0) != (f2 | 0)) {
                        e3 = f2 << ((e3 | 0) == 31 ? 0 : 25 - (e3 >>> 1) | 0);
                        while (1) {
                          d3 = c3 + 16 + (e3 >>> 31 << 2) | 0;
                          a3 = b2[d3 >> 2] | 0;
                          if (!a3) {
                            break;
                          }
                          if ((b2[a3 + 4 >> 2] & -8 | 0) == (f2 | 0)) {
                            c3 = a3;
                            break i;
                          } else {
                            e3 = e3 << 1;
                            c3 = a3;
                          }
                        }
                        b2[d3 >> 2] = k;
                        b2[k + 24 >> 2] = c3;
                        b2[k + 12 >> 2] = k;
                        b2[k + 8 >> 2] = k;
                        break g;
                      }
                    } while (0);
                    u3 = c3 + 8 | 0;
                    v3 = b2[u3 >> 2] | 0;
                    b2[v3 + 12 >> 2] = k;
                    b2[u3 >> 2] = k;
                    b2[k + 8 >> 2] = v3;
                    b2[k + 12 >> 2] = c3;
                    b2[k + 24 >> 2] = 0;
                  }
                } while (0);
                v3 = l + 8 | 0;
                T = w3;
                return v3 | 0;
              }
              c3 = 28372;
              while (1) {
                a3 = b2[c3 >> 2] | 0;
                if (a3 >>> 0 <= j >>> 0 ? (v3 = a3 + (b2[c3 + 4 >> 2] | 0) | 0, v3 >>> 0 > j >>> 0) : 0) {
                  break;
                }
                c3 = b2[c3 + 8 >> 2] | 0;
              }
              f2 = v3 + -47 | 0;
              a3 = f2 + 8 | 0;
              a3 = f2 + ((a3 & 7 | 0) == 0 ? 0 : 0 - a3 & 7) | 0;
              f2 = j + 16 | 0;
              a3 = a3 >>> 0 < f2 >>> 0 ? j : a3;
              c3 = a3 + 8 | 0;
              d3 = h + -40 | 0;
              t2 = g2 + 8 | 0;
              t2 = (t2 & 7 | 0) == 0 ? 0 : 0 - t2 & 7;
              u3 = g2 + t2 | 0;
              t2 = d3 - t2 | 0;
              b2[6987] = u3;
              b2[6984] = t2;
              b2[u3 + 4 >> 2] = t2 | 1;
              b2[g2 + d3 + 4 >> 2] = 40;
              b2[6988] = b2[7103];
              d3 = a3 + 4 | 0;
              b2[d3 >> 2] = 27;
              b2[c3 >> 2] = b2[7093];
              b2[c3 + 4 >> 2] = b2[7094];
              b2[c3 + 8 >> 2] = b2[7095];
              b2[c3 + 12 >> 2] = b2[7096];
              b2[7093] = g2;
              b2[7094] = h;
              b2[7096] = 0;
              b2[7095] = c3;
              c3 = a3 + 24 | 0;
              do {
                u3 = c3;
                c3 = c3 + 4 | 0;
                b2[c3 >> 2] = 7;
              } while ((u3 + 8 | 0) >>> 0 < v3 >>> 0);
              if ((a3 | 0) != (j | 0)) {
                g2 = a3 - j | 0;
                b2[d3 >> 2] = b2[d3 >> 2] & -2;
                b2[j + 4 >> 2] = g2 | 1;
                b2[a3 >> 2] = g2;
                c3 = g2 >>> 3;
                if (g2 >>> 0 < 256) {
                  d3 = 27964 + (c3 << 1 << 2) | 0;
                  a3 = b2[6981] | 0;
                  c3 = 1 << c3;
                  if (!(a3 & c3)) {
                    b2[6981] = a3 | c3;
                    c3 = d3;
                    a3 = d3 + 8 | 0;
                  } else {
                    a3 = d3 + 8 | 0;
                    c3 = b2[a3 >> 2] | 0;
                  }
                  b2[a3 >> 2] = j;
                  b2[c3 + 12 >> 2] = j;
                  b2[j + 8 >> 2] = c3;
                  b2[j + 12 >> 2] = d3;
                  break;
                }
                c3 = g2 >>> 8;
                if (c3) {
                  if (g2 >>> 0 > 16777215) {
                    e3 = 31;
                  } else {
                    u3 = (c3 + 1048320 | 0) >>> 16 & 8;
                    v3 = c3 << u3;
                    t2 = (v3 + 520192 | 0) >>> 16 & 4;
                    v3 = v3 << t2;
                    e3 = (v3 + 245760 | 0) >>> 16 & 2;
                    e3 = 14 - (t2 | u3 | e3) + (v3 << e3 >>> 15) | 0;
                    e3 = g2 >>> (e3 + 7 | 0) & 1 | e3 << 1;
                  }
                } else {
                  e3 = 0;
                }
                d3 = 28228 + (e3 << 2) | 0;
                b2[j + 28 >> 2] = e3;
                b2[j + 20 >> 2] = 0;
                b2[f2 >> 2] = 0;
                c3 = b2[6982] | 0;
                a3 = 1 << e3;
                if (!(c3 & a3)) {
                  b2[6982] = c3 | a3;
                  b2[d3 >> 2] = j;
                  b2[j + 24 >> 2] = d3;
                  b2[j + 12 >> 2] = j;
                  b2[j + 8 >> 2] = j;
                  break;
                }
                c3 = b2[d3 >> 2] | 0;
                j: do {
                  if ((b2[c3 + 4 >> 2] & -8 | 0) != (g2 | 0)) {
                    e3 = g2 << ((e3 | 0) == 31 ? 0 : 25 - (e3 >>> 1) | 0);
                    while (1) {
                      d3 = c3 + 16 + (e3 >>> 31 << 2) | 0;
                      a3 = b2[d3 >> 2] | 0;
                      if (!a3) {
                        break;
                      }
                      if ((b2[a3 + 4 >> 2] & -8 | 0) == (g2 | 0)) {
                        c3 = a3;
                        break j;
                      } else {
                        e3 = e3 << 1;
                        c3 = a3;
                      }
                    }
                    b2[d3 >> 2] = j;
                    b2[j + 24 >> 2] = c3;
                    b2[j + 12 >> 2] = j;
                    b2[j + 8 >> 2] = j;
                    break f;
                  }
                } while (0);
                u3 = c3 + 8 | 0;
                v3 = b2[u3 >> 2] | 0;
                b2[v3 + 12 >> 2] = j;
                b2[u3 >> 2] = j;
                b2[j + 8 >> 2] = v3;
                b2[j + 12 >> 2] = c3;
                b2[j + 24 >> 2] = 0;
              }
            } else {
              v3 = b2[6985] | 0;
              if ((v3 | 0) == 0 | g2 >>> 0 < v3 >>> 0) {
                b2[6985] = g2;
              }
              b2[7093] = g2;
              b2[7094] = h;
              b2[7096] = 0;
              b2[6990] = b2[7099];
              b2[6989] = -1;
              b2[6994] = 27964;
              b2[6993] = 27964;
              b2[6996] = 27972;
              b2[6995] = 27972;
              b2[6998] = 27980;
              b2[6997] = 27980;
              b2[7e3] = 27988;
              b2[6999] = 27988;
              b2[7002] = 27996;
              b2[7001] = 27996;
              b2[7004] = 28004;
              b2[7003] = 28004;
              b2[7006] = 28012;
              b2[7005] = 28012;
              b2[7008] = 28020;
              b2[7007] = 28020;
              b2[7010] = 28028;
              b2[7009] = 28028;
              b2[7012] = 28036;
              b2[7011] = 28036;
              b2[7014] = 28044;
              b2[7013] = 28044;
              b2[7016] = 28052;
              b2[7015] = 28052;
              b2[7018] = 28060;
              b2[7017] = 28060;
              b2[7020] = 28068;
              b2[7019] = 28068;
              b2[7022] = 28076;
              b2[7021] = 28076;
              b2[7024] = 28084;
              b2[7023] = 28084;
              b2[7026] = 28092;
              b2[7025] = 28092;
              b2[7028] = 28100;
              b2[7027] = 28100;
              b2[7030] = 28108;
              b2[7029] = 28108;
              b2[7032] = 28116;
              b2[7031] = 28116;
              b2[7034] = 28124;
              b2[7033] = 28124;
              b2[7036] = 28132;
              b2[7035] = 28132;
              b2[7038] = 28140;
              b2[7037] = 28140;
              b2[7040] = 28148;
              b2[7039] = 28148;
              b2[7042] = 28156;
              b2[7041] = 28156;
              b2[7044] = 28164;
              b2[7043] = 28164;
              b2[7046] = 28172;
              b2[7045] = 28172;
              b2[7048] = 28180;
              b2[7047] = 28180;
              b2[7050] = 28188;
              b2[7049] = 28188;
              b2[7052] = 28196;
              b2[7051] = 28196;
              b2[7054] = 28204;
              b2[7053] = 28204;
              b2[7056] = 28212;
              b2[7055] = 28212;
              v3 = h + -40 | 0;
              t2 = g2 + 8 | 0;
              t2 = (t2 & 7 | 0) == 0 ? 0 : 0 - t2 & 7;
              u3 = g2 + t2 | 0;
              t2 = v3 - t2 | 0;
              b2[6987] = u3;
              b2[6984] = t2;
              b2[u3 + 4 >> 2] = t2 | 1;
              b2[g2 + v3 + 4 >> 2] = 40;
              b2[6988] = b2[7103];
            }
          } while (0);
          c3 = b2[6984] | 0;
          if (c3 >>> 0 > m >>> 0) {
            t2 = c3 - m | 0;
            b2[6984] = t2;
            v3 = b2[6987] | 0;
            u3 = v3 + m | 0;
            b2[6987] = u3;
            b2[u3 + 4 >> 2] = t2 | 1;
            b2[v3 + 4 >> 2] = m | 3;
            v3 = v3 + 8 | 0;
            T = w3;
            return v3 | 0;
          }
        }
        v3 = Ed() | 0;
        b2[v3 >> 2] = 12;
        v3 = 0;
        T = w3;
        return v3 | 0;
      }
      function Hd(a3) {
        a3 = a3 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0;
        if (!a3) {
          return;
        }
        d3 = a3 + -8 | 0;
        f2 = b2[6985] | 0;
        a3 = b2[a3 + -4 >> 2] | 0;
        c3 = a3 & -8;
        j = d3 + c3 | 0;
        do {
          if (!(a3 & 1)) {
            e3 = b2[d3 >> 2] | 0;
            if (!(a3 & 3)) {
              return;
            }
            h = d3 + (0 - e3) | 0;
            g2 = e3 + c3 | 0;
            if (h >>> 0 < f2 >>> 0) {
              return;
            }
            if ((b2[6986] | 0) == (h | 0)) {
              a3 = j + 4 | 0;
              c3 = b2[a3 >> 2] | 0;
              if ((c3 & 3 | 0) != 3) {
                i = h;
                c3 = g2;
                break;
              }
              b2[6983] = g2;
              b2[a3 >> 2] = c3 & -2;
              b2[h + 4 >> 2] = g2 | 1;
              b2[h + g2 >> 2] = g2;
              return;
            }
            d3 = e3 >>> 3;
            if (e3 >>> 0 < 256) {
              a3 = b2[h + 8 >> 2] | 0;
              c3 = b2[h + 12 >> 2] | 0;
              if ((c3 | 0) == (a3 | 0)) {
                b2[6981] = b2[6981] & ~(1 << d3);
                i = h;
                c3 = g2;
                break;
              } else {
                b2[a3 + 12 >> 2] = c3;
                b2[c3 + 8 >> 2] = a3;
                i = h;
                c3 = g2;
                break;
              }
            }
            f2 = b2[h + 24 >> 2] | 0;
            a3 = b2[h + 12 >> 2] | 0;
            do {
              if ((a3 | 0) == (h | 0)) {
                c3 = h + 16 | 0;
                d3 = c3 + 4 | 0;
                a3 = b2[d3 >> 2] | 0;
                if (!a3) {
                  a3 = b2[c3 >> 2] | 0;
                  if (!a3) {
                    a3 = 0;
                    break;
                  }
                } else {
                  c3 = d3;
                }
                while (1) {
                  e3 = a3 + 20 | 0;
                  d3 = b2[e3 >> 2] | 0;
                  if (!d3) {
                    e3 = a3 + 16 | 0;
                    d3 = b2[e3 >> 2] | 0;
                    if (!d3) {
                      break;
                    } else {
                      a3 = d3;
                      c3 = e3;
                    }
                  } else {
                    a3 = d3;
                    c3 = e3;
                  }
                }
                b2[c3 >> 2] = 0;
              } else {
                i = b2[h + 8 >> 2] | 0;
                b2[i + 12 >> 2] = a3;
                b2[a3 + 8 >> 2] = i;
              }
            } while (0);
            if (f2) {
              c3 = b2[h + 28 >> 2] | 0;
              d3 = 28228 + (c3 << 2) | 0;
              if ((b2[d3 >> 2] | 0) == (h | 0)) {
                b2[d3 >> 2] = a3;
                if (!a3) {
                  b2[6982] = b2[6982] & ~(1 << c3);
                  i = h;
                  c3 = g2;
                  break;
                }
              } else {
                i = f2 + 16 | 0;
                b2[((b2[i >> 2] | 0) == (h | 0) ? i : f2 + 20 | 0) >> 2] = a3;
                if (!a3) {
                  i = h;
                  c3 = g2;
                  break;
                }
              }
              b2[a3 + 24 >> 2] = f2;
              c3 = h + 16 | 0;
              d3 = b2[c3 >> 2] | 0;
              if (d3 | 0) {
                b2[a3 + 16 >> 2] = d3;
                b2[d3 + 24 >> 2] = a3;
              }
              c3 = b2[c3 + 4 >> 2] | 0;
              if (c3) {
                b2[a3 + 20 >> 2] = c3;
                b2[c3 + 24 >> 2] = a3;
                i = h;
                c3 = g2;
              } else {
                i = h;
                c3 = g2;
              }
            } else {
              i = h;
              c3 = g2;
            }
          } else {
            i = d3;
            h = d3;
          }
        } while (0);
        if (h >>> 0 >= j >>> 0) {
          return;
        }
        a3 = j + 4 | 0;
        e3 = b2[a3 >> 2] | 0;
        if (!(e3 & 1)) {
          return;
        }
        if (!(e3 & 2)) {
          if ((b2[6987] | 0) == (j | 0)) {
            j = (b2[6984] | 0) + c3 | 0;
            b2[6984] = j;
            b2[6987] = i;
            b2[i + 4 >> 2] = j | 1;
            if ((i | 0) != (b2[6986] | 0)) {
              return;
            }
            b2[6986] = 0;
            b2[6983] = 0;
            return;
          }
          if ((b2[6986] | 0) == (j | 0)) {
            j = (b2[6983] | 0) + c3 | 0;
            b2[6983] = j;
            b2[6986] = h;
            b2[i + 4 >> 2] = j | 1;
            b2[h + j >> 2] = j;
            return;
          }
          f2 = (e3 & -8) + c3 | 0;
          d3 = e3 >>> 3;
          do {
            if (e3 >>> 0 < 256) {
              c3 = b2[j + 8 >> 2] | 0;
              a3 = b2[j + 12 >> 2] | 0;
              if ((a3 | 0) == (c3 | 0)) {
                b2[6981] = b2[6981] & ~(1 << d3);
                break;
              } else {
                b2[c3 + 12 >> 2] = a3;
                b2[a3 + 8 >> 2] = c3;
                break;
              }
            } else {
              g2 = b2[j + 24 >> 2] | 0;
              a3 = b2[j + 12 >> 2] | 0;
              do {
                if ((a3 | 0) == (j | 0)) {
                  c3 = j + 16 | 0;
                  d3 = c3 + 4 | 0;
                  a3 = b2[d3 >> 2] | 0;
                  if (!a3) {
                    a3 = b2[c3 >> 2] | 0;
                    if (!a3) {
                      d3 = 0;
                      break;
                    }
                  } else {
                    c3 = d3;
                  }
                  while (1) {
                    e3 = a3 + 20 | 0;
                    d3 = b2[e3 >> 2] | 0;
                    if (!d3) {
                      e3 = a3 + 16 | 0;
                      d3 = b2[e3 >> 2] | 0;
                      if (!d3) {
                        break;
                      } else {
                        a3 = d3;
                        c3 = e3;
                      }
                    } else {
                      a3 = d3;
                      c3 = e3;
                    }
                  }
                  b2[c3 >> 2] = 0;
                  d3 = a3;
                } else {
                  d3 = b2[j + 8 >> 2] | 0;
                  b2[d3 + 12 >> 2] = a3;
                  b2[a3 + 8 >> 2] = d3;
                  d3 = a3;
                }
              } while (0);
              if (g2 | 0) {
                a3 = b2[j + 28 >> 2] | 0;
                c3 = 28228 + (a3 << 2) | 0;
                if ((b2[c3 >> 2] | 0) == (j | 0)) {
                  b2[c3 >> 2] = d3;
                  if (!d3) {
                    b2[6982] = b2[6982] & ~(1 << a3);
                    break;
                  }
                } else {
                  e3 = g2 + 16 | 0;
                  b2[((b2[e3 >> 2] | 0) == (j | 0) ? e3 : g2 + 20 | 0) >> 2] = d3;
                  if (!d3) {
                    break;
                  }
                }
                b2[d3 + 24 >> 2] = g2;
                a3 = j + 16 | 0;
                c3 = b2[a3 >> 2] | 0;
                if (c3 | 0) {
                  b2[d3 + 16 >> 2] = c3;
                  b2[c3 + 24 >> 2] = d3;
                }
                a3 = b2[a3 + 4 >> 2] | 0;
                if (a3 | 0) {
                  b2[d3 + 20 >> 2] = a3;
                  b2[a3 + 24 >> 2] = d3;
                }
              }
            }
          } while (0);
          b2[i + 4 >> 2] = f2 | 1;
          b2[h + f2 >> 2] = f2;
          if ((i | 0) == (b2[6986] | 0)) {
            b2[6983] = f2;
            return;
          }
        } else {
          b2[a3 >> 2] = e3 & -2;
          b2[i + 4 >> 2] = c3 | 1;
          b2[h + c3 >> 2] = c3;
          f2 = c3;
        }
        a3 = f2 >>> 3;
        if (f2 >>> 0 < 256) {
          d3 = 27964 + (a3 << 1 << 2) | 0;
          c3 = b2[6981] | 0;
          a3 = 1 << a3;
          if (!(c3 & a3)) {
            b2[6981] = c3 | a3;
            a3 = d3;
            c3 = d3 + 8 | 0;
          } else {
            c3 = d3 + 8 | 0;
            a3 = b2[c3 >> 2] | 0;
          }
          b2[c3 >> 2] = i;
          b2[a3 + 12 >> 2] = i;
          b2[i + 8 >> 2] = a3;
          b2[i + 12 >> 2] = d3;
          return;
        }
        a3 = f2 >>> 8;
        if (a3) {
          if (f2 >>> 0 > 16777215) {
            e3 = 31;
          } else {
            h = (a3 + 1048320 | 0) >>> 16 & 8;
            j = a3 << h;
            g2 = (j + 520192 | 0) >>> 16 & 4;
            j = j << g2;
            e3 = (j + 245760 | 0) >>> 16 & 2;
            e3 = 14 - (g2 | h | e3) + (j << e3 >>> 15) | 0;
            e3 = f2 >>> (e3 + 7 | 0) & 1 | e3 << 1;
          }
        } else {
          e3 = 0;
        }
        a3 = 28228 + (e3 << 2) | 0;
        b2[i + 28 >> 2] = e3;
        b2[i + 20 >> 2] = 0;
        b2[i + 16 >> 2] = 0;
        c3 = b2[6982] | 0;
        d3 = 1 << e3;
        a: do {
          if (!(c3 & d3)) {
            b2[6982] = c3 | d3;
            b2[a3 >> 2] = i;
            b2[i + 24 >> 2] = a3;
            b2[i + 12 >> 2] = i;
            b2[i + 8 >> 2] = i;
          } else {
            a3 = b2[a3 >> 2] | 0;
            b: do {
              if ((b2[a3 + 4 >> 2] & -8 | 0) != (f2 | 0)) {
                e3 = f2 << ((e3 | 0) == 31 ? 0 : 25 - (e3 >>> 1) | 0);
                while (1) {
                  d3 = a3 + 16 + (e3 >>> 31 << 2) | 0;
                  c3 = b2[d3 >> 2] | 0;
                  if (!c3) {
                    break;
                  }
                  if ((b2[c3 + 4 >> 2] & -8 | 0) == (f2 | 0)) {
                    a3 = c3;
                    break b;
                  } else {
                    e3 = e3 << 1;
                    a3 = c3;
                  }
                }
                b2[d3 >> 2] = i;
                b2[i + 24 >> 2] = a3;
                b2[i + 12 >> 2] = i;
                b2[i + 8 >> 2] = i;
                break a;
              }
            } while (0);
            h = a3 + 8 | 0;
            j = b2[h >> 2] | 0;
            b2[j + 12 >> 2] = i;
            b2[h >> 2] = i;
            b2[i + 8 >> 2] = j;
            b2[i + 12 >> 2] = a3;
            b2[i + 24 >> 2] = 0;
          }
        } while (0);
        j = (b2[6989] | 0) + -1 | 0;
        b2[6989] = j;
        if (j | 0) {
          return;
        }
        a3 = 28380;
        while (1) {
          a3 = b2[a3 >> 2] | 0;
          if (!a3) {
            break;
          } else {
            a3 = a3 + 8 | 0;
          }
        }
        b2[6989] = -1;
        return;
      }
      function Id(a3, c3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        var d3 = 0;
        if (a3) {
          d3 = B2(c3, a3) | 0;
          if ((c3 | a3) >>> 0 > 65535) {
            d3 = ((d3 >>> 0) / (a3 >>> 0) | 0 | 0) == (c3 | 0) ? d3 : -1;
          }
        } else {
          d3 = 0;
        }
        a3 = Gd(d3) | 0;
        if (!a3) {
          return a3 | 0;
        }
        if (!(b2[a3 + -4 >> 2] & 3)) {
          return a3 | 0;
        }
        _d(a3 | 0, 0, d3 | 0) | 0;
        return a3 | 0;
      }
      function Jd(a3, b3, c3, d3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        c3 = a3 + c3 >>> 0;
        return (G2(b3 + d3 + (c3 >>> 0 < a3 >>> 0 | 0) >>> 0 | 0), c3 | 0) | 0;
      }
      function Kd(a3, b3, c3, d3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        d3 = b3 - d3 - (c3 >>> 0 > a3 >>> 0 | 0) >>> 0;
        return (G2(d3 | 0), a3 - c3 >>> 0 | 0) | 0;
      }
      function Ld(a3) {
        a3 = a3 | 0;
        return (a3 ? 31 - (E2(a3 ^ a3 - 1) | 0) | 0 : 32) | 0;
      }
      function Md(a3, c3, d3, e3, f2) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0;
        l = a3;
        j = c3;
        k = j;
        h = d3;
        n = e3;
        i = n;
        if (!k) {
          g2 = (f2 | 0) != 0;
          if (!i) {
            if (g2) {
              b2[f2 >> 2] = (l >>> 0) % (h >>> 0);
              b2[f2 + 4 >> 2] = 0;
            }
            n = 0;
            f2 = (l >>> 0) / (h >>> 0) >>> 0;
            return (G2(n | 0), f2) | 0;
          } else {
            if (!g2) {
              n = 0;
              f2 = 0;
              return (G2(n | 0), f2) | 0;
            }
            b2[f2 >> 2] = a3 | 0;
            b2[f2 + 4 >> 2] = c3 & 0;
            n = 0;
            f2 = 0;
            return (G2(n | 0), f2) | 0;
          }
        }
        g2 = (i | 0) == 0;
        do {
          if (h) {
            if (!g2) {
              g2 = (E2(i | 0) | 0) - (E2(k | 0) | 0) | 0;
              if (g2 >>> 0 <= 31) {
                m = g2 + 1 | 0;
                i = 31 - g2 | 0;
                c3 = g2 - 31 >> 31;
                h = m;
                a3 = l >>> (m >>> 0) & c3 | k << i;
                c3 = k >>> (m >>> 0) & c3;
                g2 = 0;
                i = l << i;
                break;
              }
              if (!f2) {
                n = 0;
                f2 = 0;
                return (G2(n | 0), f2) | 0;
              }
              b2[f2 >> 2] = a3 | 0;
              b2[f2 + 4 >> 2] = j | c3 & 0;
              n = 0;
              f2 = 0;
              return (G2(n | 0), f2) | 0;
            }
            g2 = h - 1 | 0;
            if (g2 & h | 0) {
              i = (E2(h | 0) | 0) + 33 - (E2(k | 0) | 0) | 0;
              p2 = 64 - i | 0;
              m = 32 - i | 0;
              j = m >> 31;
              o = i - 32 | 0;
              c3 = o >> 31;
              h = i;
              a3 = m - 1 >> 31 & k >>> (o >>> 0) | (k << m | l >>> (i >>> 0)) & c3;
              c3 = c3 & k >>> (i >>> 0);
              g2 = l << p2 & j;
              i = (k << p2 | l >>> (o >>> 0)) & j | l << m & i - 33 >> 31;
              break;
            }
            if (f2 | 0) {
              b2[f2 >> 2] = g2 & l;
              b2[f2 + 4 >> 2] = 0;
            }
            if ((h | 0) == 1) {
              o = j | c3 & 0;
              p2 = a3 | 0 | 0;
              return (G2(o | 0), p2) | 0;
            } else {
              p2 = Ld(h | 0) | 0;
              o = k >>> (p2 >>> 0) | 0;
              p2 = k << 32 - p2 | l >>> (p2 >>> 0) | 0;
              return (G2(o | 0), p2) | 0;
            }
          } else {
            if (g2) {
              if (f2 | 0) {
                b2[f2 >> 2] = (k >>> 0) % (h >>> 0);
                b2[f2 + 4 >> 2] = 0;
              }
              o = 0;
              p2 = (k >>> 0) / (h >>> 0) >>> 0;
              return (G2(o | 0), p2) | 0;
            }
            if (!l) {
              if (f2 | 0) {
                b2[f2 >> 2] = 0;
                b2[f2 + 4 >> 2] = (k >>> 0) % (i >>> 0);
              }
              o = 0;
              p2 = (k >>> 0) / (i >>> 0) >>> 0;
              return (G2(o | 0), p2) | 0;
            }
            g2 = i - 1 | 0;
            if (!(g2 & i)) {
              if (f2 | 0) {
                b2[f2 >> 2] = a3 | 0;
                b2[f2 + 4 >> 2] = g2 & k | c3 & 0;
              }
              o = 0;
              p2 = k >>> ((Ld(i | 0) | 0) >>> 0);
              return (G2(o | 0), p2) | 0;
            }
            g2 = (E2(i | 0) | 0) - (E2(k | 0) | 0) | 0;
            if (g2 >>> 0 <= 30) {
              c3 = g2 + 1 | 0;
              i = 31 - g2 | 0;
              h = c3;
              a3 = k << i | l >>> (c3 >>> 0);
              c3 = k >>> (c3 >>> 0);
              g2 = 0;
              i = l << i;
              break;
            }
            if (!f2) {
              o = 0;
              p2 = 0;
              return (G2(o | 0), p2) | 0;
            }
            b2[f2 >> 2] = a3 | 0;
            b2[f2 + 4 >> 2] = j | c3 & 0;
            o = 0;
            p2 = 0;
            return (G2(o | 0), p2) | 0;
          }
        } while (0);
        if (!h) {
          k = i;
          j = 0;
          i = 0;
        } else {
          m = d3 | 0 | 0;
          l = n | e3 & 0;
          k = Jd(m | 0, l | 0, -1, -1) | 0;
          d3 = H() | 0;
          j = i;
          i = 0;
          do {
            e3 = j;
            j = g2 >>> 31 | j << 1;
            g2 = i | g2 << 1;
            e3 = a3 << 1 | e3 >>> 31 | 0;
            n = a3 >>> 31 | c3 << 1 | 0;
            Kd(k | 0, d3 | 0, e3 | 0, n | 0) | 0;
            p2 = H() | 0;
            o = p2 >> 31 | ((p2 | 0) < 0 ? -1 : 0) << 1;
            i = o & 1;
            a3 = Kd(e3 | 0, n | 0, o & m | 0, (((p2 | 0) < 0 ? -1 : 0) >> 31 | ((p2 | 0) < 0 ? -1 : 0) << 1) & l | 0) | 0;
            c3 = H() | 0;
            h = h - 1 | 0;
          } while ((h | 0) != 0);
          k = j;
          j = 0;
        }
        h = 0;
        if (f2 | 0) {
          b2[f2 >> 2] = a3;
          b2[f2 + 4 >> 2] = c3;
        }
        o = (g2 | 0) >>> 31 | (k | h) << 1 | (h << 1 | g2 >>> 31) & 0 | j;
        p2 = (g2 << 1 | 0 >>> 31) & -2 | i;
        return (G2(o | 0), p2) | 0;
      }
      function Nd(a3, b3, c3, d3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0;
        j = b3 >> 31 | ((b3 | 0) < 0 ? -1 : 0) << 1;
        i = ((b3 | 0) < 0 ? -1 : 0) >> 31 | ((b3 | 0) < 0 ? -1 : 0) << 1;
        f2 = d3 >> 31 | ((d3 | 0) < 0 ? -1 : 0) << 1;
        e3 = ((d3 | 0) < 0 ? -1 : 0) >> 31 | ((d3 | 0) < 0 ? -1 : 0) << 1;
        h = Kd(j ^ a3 | 0, i ^ b3 | 0, j | 0, i | 0) | 0;
        g2 = H() | 0;
        a3 = f2 ^ j;
        b3 = e3 ^ i;
        return Kd((Md(h, g2, Kd(f2 ^ c3 | 0, e3 ^ d3 | 0, f2 | 0, e3 | 0) | 0, H() | 0, 0) | 0) ^ a3 | 0, (H() | 0) ^ b3 | 0, a3 | 0, b3 | 0) | 0;
      }
      function Od(a3, b3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0;
        f2 = a3 & 65535;
        e3 = b3 & 65535;
        c3 = B2(e3, f2) | 0;
        d3 = a3 >>> 16;
        a3 = (c3 >>> 16) + (B2(e3, d3) | 0) | 0;
        e3 = b3 >>> 16;
        b3 = B2(e3, f2) | 0;
        return (G2((a3 >>> 16) + (B2(e3, d3) | 0) + (((a3 & 65535) + b3 | 0) >>> 16) | 0), a3 + b3 << 16 | c3 & 65535 | 0) | 0;
      }
      function Pd(a3, b3, c3, d3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0;
        e3 = a3;
        f2 = c3;
        c3 = Od(e3, f2) | 0;
        a3 = H() | 0;
        return (G2((B2(b3, f2) | 0) + (B2(d3, e3) | 0) + a3 | a3 & 0 | 0), c3 | 0 | 0) | 0;
      }
      function Qd(a3, c3, d3, e3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0;
        f2 = T;
        T = T + 16 | 0;
        i = f2 | 0;
        h = c3 >> 31 | ((c3 | 0) < 0 ? -1 : 0) << 1;
        g2 = ((c3 | 0) < 0 ? -1 : 0) >> 31 | ((c3 | 0) < 0 ? -1 : 0) << 1;
        k = e3 >> 31 | ((e3 | 0) < 0 ? -1 : 0) << 1;
        j = ((e3 | 0) < 0 ? -1 : 0) >> 31 | ((e3 | 0) < 0 ? -1 : 0) << 1;
        a3 = Kd(h ^ a3 | 0, g2 ^ c3 | 0, h | 0, g2 | 0) | 0;
        c3 = H() | 0;
        Md(a3, c3, Kd(k ^ d3 | 0, j ^ e3 | 0, k | 0, j | 0) | 0, H() | 0, i) | 0;
        e3 = Kd(b2[i >> 2] ^ h | 0, b2[i + 4 >> 2] ^ g2 | 0, h | 0, g2 | 0) | 0;
        d3 = H() | 0;
        T = f2;
        return (G2(d3 | 0), e3) | 0;
      }
      function Rd(a3, c3, d3, e3) {
        a3 = a3 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0;
        g2 = T;
        T = T + 16 | 0;
        f2 = g2 | 0;
        Md(a3, c3, d3, e3, f2) | 0;
        T = g2;
        return (G2(b2[f2 + 4 >> 2] | 0), b2[f2 >> 2] | 0) | 0;
      }
      function Sd(a3, b3, c3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        c3 = c3 | 0;
        if ((c3 | 0) < 32) {
          G2(b3 >> c3 | 0);
          return a3 >>> c3 | (b3 & (1 << c3) - 1) << 32 - c3;
        }
        G2(((b3 | 0) < 0 ? -1 : 0) | 0);
        return b3 >> c3 - 32 | 0;
      }
      function Td(a3, b3, c3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        c3 = c3 | 0;
        if ((c3 | 0) < 32) {
          G2(b3 >>> c3 | 0);
          return a3 >>> c3 | (b3 & (1 << c3) - 1) << 32 - c3;
        }
        G2(0);
        return b3 >>> c3 - 32 | 0;
      }
      function Ud(a3, b3, c3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        c3 = c3 | 0;
        if ((c3 | 0) < 32) {
          G2(b3 << c3 | (a3 & (1 << c3) - 1 << 32 - c3) >>> 32 - c3 | 0);
          return a3 << c3;
        }
        G2(a3 << c3 - 32 | 0);
        return 0;
      }
      function Vd(a3, b3, c3) {
        a3 = a3 | 0;
        b3 = b3 | 0;
        c3 = c3 | 0;
        b3 = E2(b3) | 0;
        if ((b3 | 0) == 32) {
          b3 = b3 + (E2(a3) | 0) | 0;
        }
        G2(0);
        return b3 | 0;
      }
      function Wd(a3, b3) {
        a3 = +a3;
        b3 = +b3;
        if (a3 != a3) {
          return +b3;
        }
        if (b3 != b3) {
          return +a3;
        }
        return +D2(+a3, +b3);
      }
      function Xd(a3, b3) {
        a3 = +a3;
        b3 = +b3;
        if (a3 != a3) {
          return +b3;
        }
        if (b3 != b3) {
          return +a3;
        }
        return +C2(+a3, +b3);
      }
      function Yd(a3) {
        a3 = +a3;
        return a3 >= 0 ? +p(a3 + 0.5) : +A2(a3 - 0.5);
      }
      function Zd(c3, d3, e3) {
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0;
        if ((e3 | 0) >= 8192) {
          L2(c3 | 0, d3 | 0, e3 | 0) | 0;
          return c3 | 0;
        }
        h = c3 | 0;
        g2 = c3 + e3 | 0;
        if ((c3 & 3) == (d3 & 3)) {
          while (c3 & 3) {
            if (!e3) {
              return h | 0;
            }
            a2[c3 >> 0] = a2[d3 >> 0] | 0;
            c3 = c3 + 1 | 0;
            d3 = d3 + 1 | 0;
            e3 = e3 - 1 | 0;
          }
          e3 = g2 & -4 | 0;
          f2 = e3 - 64 | 0;
          while ((c3 | 0) <= (f2 | 0)) {
            b2[c3 >> 2] = b2[d3 >> 2];
            b2[c3 + 4 >> 2] = b2[d3 + 4 >> 2];
            b2[c3 + 8 >> 2] = b2[d3 + 8 >> 2];
            b2[c3 + 12 >> 2] = b2[d3 + 12 >> 2];
            b2[c3 + 16 >> 2] = b2[d3 + 16 >> 2];
            b2[c3 + 20 >> 2] = b2[d3 + 20 >> 2];
            b2[c3 + 24 >> 2] = b2[d3 + 24 >> 2];
            b2[c3 + 28 >> 2] = b2[d3 + 28 >> 2];
            b2[c3 + 32 >> 2] = b2[d3 + 32 >> 2];
            b2[c3 + 36 >> 2] = b2[d3 + 36 >> 2];
            b2[c3 + 40 >> 2] = b2[d3 + 40 >> 2];
            b2[c3 + 44 >> 2] = b2[d3 + 44 >> 2];
            b2[c3 + 48 >> 2] = b2[d3 + 48 >> 2];
            b2[c3 + 52 >> 2] = b2[d3 + 52 >> 2];
            b2[c3 + 56 >> 2] = b2[d3 + 56 >> 2];
            b2[c3 + 60 >> 2] = b2[d3 + 60 >> 2];
            c3 = c3 + 64 | 0;
            d3 = d3 + 64 | 0;
          }
          while ((c3 | 0) < (e3 | 0)) {
            b2[c3 >> 2] = b2[d3 >> 2];
            c3 = c3 + 4 | 0;
            d3 = d3 + 4 | 0;
          }
        } else {
          e3 = g2 - 4 | 0;
          while ((c3 | 0) < (e3 | 0)) {
            a2[c3 >> 0] = a2[d3 >> 0] | 0;
            a2[c3 + 1 >> 0] = a2[d3 + 1 >> 0] | 0;
            a2[c3 + 2 >> 0] = a2[d3 + 2 >> 0] | 0;
            a2[c3 + 3 >> 0] = a2[d3 + 3 >> 0] | 0;
            c3 = c3 + 4 | 0;
            d3 = d3 + 4 | 0;
          }
        }
        while ((c3 | 0) < (g2 | 0)) {
          a2[c3 >> 0] = a2[d3 >> 0] | 0;
          c3 = c3 + 1 | 0;
          d3 = d3 + 1 | 0;
        }
        return h | 0;
      }
      function _d(c3, d3, e3) {
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0;
        h = c3 + e3 | 0;
        d3 = d3 & 255;
        if ((e3 | 0) >= 67) {
          while (c3 & 3) {
            a2[c3 >> 0] = d3;
            c3 = c3 + 1 | 0;
          }
          f2 = h & -4 | 0;
          i = d3 | d3 << 8 | d3 << 16 | d3 << 24;
          g2 = f2 - 64 | 0;
          while ((c3 | 0) <= (g2 | 0)) {
            b2[c3 >> 2] = i;
            b2[c3 + 4 >> 2] = i;
            b2[c3 + 8 >> 2] = i;
            b2[c3 + 12 >> 2] = i;
            b2[c3 + 16 >> 2] = i;
            b2[c3 + 20 >> 2] = i;
            b2[c3 + 24 >> 2] = i;
            b2[c3 + 28 >> 2] = i;
            b2[c3 + 32 >> 2] = i;
            b2[c3 + 36 >> 2] = i;
            b2[c3 + 40 >> 2] = i;
            b2[c3 + 44 >> 2] = i;
            b2[c3 + 48 >> 2] = i;
            b2[c3 + 52 >> 2] = i;
            b2[c3 + 56 >> 2] = i;
            b2[c3 + 60 >> 2] = i;
            c3 = c3 + 64 | 0;
          }
          while ((c3 | 0) < (f2 | 0)) {
            b2[c3 >> 2] = i;
            c3 = c3 + 4 | 0;
          }
        }
        while ((c3 | 0) < (h | 0)) {
          a2[c3 >> 0] = d3;
          c3 = c3 + 1 | 0;
        }
        return h - e3 | 0;
      }
      function $d(a3) {
        a3 = +a3;
        return a3 >= 0 ? +p(a3 + 0.5) : +A2(a3 - 0.5);
      }
      function ae(a3) {
        a3 = a3 | 0;
        var c3 = 0, d3 = 0, e3 = 0;
        e3 = K() | 0;
        d3 = b2[g >> 2] | 0;
        c3 = d3 + a3 | 0;
        if ((a3 | 0) > 0 & (c3 | 0) < (d3 | 0) | (c3 | 0) < 0) {
          N(c3 | 0) | 0;
          J(12);
          return -1;
        }
        if ((c3 | 0) > (e3 | 0)) {
          if (!(M(c3 | 0) | 0)) {
            J(12);
            return -1;
          }
        }
        b2[g >> 2] = c3;
        return d3 | 0;
      }
      return {
        ___divdi3: Nd,
        ___muldi3: Pd,
        ___remdi3: Qd,
        ___uremdi3: Rd,
        _areNeighborCells: ib,
        _bitshift64Ashr: Sd,
        _bitshift64Lshr: Td,
        _bitshift64Shl: Ud,
        _calloc: Id,
        _cellAreaKm2: Ac,
        _cellAreaM2: Bc,
        _cellAreaRads2: zc,
        _cellToBoundary: bc,
        _cellToCenterChild: Nb,
        _cellToChildPos: gc,
        _cellToChildren: Lb,
        _cellToChildrenSize: Jb,
        _cellToLatLng: ac,
        _cellToLocalIj: Mc,
        _cellToParent: Ib,
        _cellToVertex: td,
        _cellToVertexes: ud,
        _cellsToDirectedEdge: jb,
        _cellsToLinkedMultiPolygon: na,
        _childPosToCell: hc,
        _compactCells: Ob,
        _constructCell: Eb,
        _destroyLinkedMultiPolygon: Hc,
        _directedEdgeToBoundary: pb,
        _directedEdgeToCells: nb,
        _edgeLengthKm: Dc,
        _edgeLengthM: Ec,
        _edgeLengthRads: Cc,
        _emscripten_replace_memory: W2,
        _free: Hd,
        _getBaseCellNumber: Cb,
        _getDirectedEdgeDestination: lb,
        _getDirectedEdgeOrigin: kb,
        _getHexagonAreaAvgKm2: tc,
        _getHexagonAreaAvgM2: uc,
        _getHexagonEdgeLengthAvgKm: vc,
        _getHexagonEdgeLengthAvgM: wc,
        _getIcosahedronFaces: dc,
        _getIndexDigit: Db,
        _getNumCells: xc,
        _getPentagons: fc,
        _getRes0Cells: ya,
        _getResolution: Bb,
        _greatCircleDistanceKm: pc,
        _greatCircleDistanceM: qc,
        _greatCircleDistanceRads: oc,
        _gridDisk: aa,
        _gridDiskDistances: ba,
        _gridDistance: Oc,
        _gridPathCells: Qc,
        _gridPathCellsSize: Pc,
        _gridRing: fa,
        _gridRingUnsafe: ga,
        _i64Add: Jd,
        _i64Subtract: Kd,
        _isPentagon: Kb,
        _isResClassIII: Rb,
        _isValidCell: Fb,
        _isValidDirectedEdge: mb,
        _isValidIndex: Gb,
        _isValidVertex: wd,
        _latLngToCell: Zb,
        _llvm_ctlz_i64: Vd,
        _llvm_maxnum_f64: Wd,
        _llvm_minnum_f64: Xd,
        _llvm_round_f64: Yd,
        _localIjToCell: Nc,
        _malloc: Gd,
        _maxFaceCount: cc,
        _maxGridDiskSize: $,
        _maxPolygonToCellsSize: ja,
        _maxPolygonToCellsSizeExperimental: Xc,
        _memcpy: Zd,
        _memset: _d,
        _originToDirectedEdges: ob,
        _pentagonCount: ec,
        _polygonToCells: la,
        _polygonToCellsExperimental: Wc,
        _readInt64AsDoubleFromPointer: ld,
        _res0CellCount: xa,
        _round: $d,
        _sbrk: ae,
        _sizeOfCellBoundary: gd,
        _sizeOfCoordIJ: kd,
        _sizeOfGeoLoop: hd,
        _sizeOfGeoPolygon: id,
        _sizeOfH3Index: ed,
        _sizeOfLatLng: fd,
        _sizeOfLinkedGeoPolygon: jd,
        _uncompactCells: Pb,
        _uncompactCellsSize: Qb,
        _vertexToLatLng: vd,
        establishStackSpace: _,
        stackAlloc: X,
        stackRestore: Z,
        stackSave: Y
      };
    })(asmGlobalArg, asmLibraryArg, buffer)
  );
  var ___divdi3 = Module["___divdi3"] = asm["___divdi3"];
  var ___muldi3 = Module["___muldi3"] = asm["___muldi3"];
  var ___remdi3 = Module["___remdi3"] = asm["___remdi3"];
  var ___uremdi3 = Module["___uremdi3"] = asm["___uremdi3"];
  var _areNeighborCells = Module["_areNeighborCells"] = asm["_areNeighborCells"];
  var _bitshift64Ashr = Module["_bitshift64Ashr"] = asm["_bitshift64Ashr"];
  var _bitshift64Lshr = Module["_bitshift64Lshr"] = asm["_bitshift64Lshr"];
  var _bitshift64Shl = Module["_bitshift64Shl"] = asm["_bitshift64Shl"];
  var _calloc = Module["_calloc"] = asm["_calloc"];
  var _cellAreaKm2 = Module["_cellAreaKm2"] = asm["_cellAreaKm2"];
  var _cellAreaM2 = Module["_cellAreaM2"] = asm["_cellAreaM2"];
  var _cellAreaRads2 = Module["_cellAreaRads2"] = asm["_cellAreaRads2"];
  var _cellToBoundary = Module["_cellToBoundary"] = asm["_cellToBoundary"];
  var _cellToCenterChild = Module["_cellToCenterChild"] = asm["_cellToCenterChild"];
  var _cellToChildPos = Module["_cellToChildPos"] = asm["_cellToChildPos"];
  var _cellToChildren = Module["_cellToChildren"] = asm["_cellToChildren"];
  var _cellToChildrenSize = Module["_cellToChildrenSize"] = asm["_cellToChildrenSize"];
  var _cellToLatLng = Module["_cellToLatLng"] = asm["_cellToLatLng"];
  var _cellToLocalIj = Module["_cellToLocalIj"] = asm["_cellToLocalIj"];
  var _cellToParent = Module["_cellToParent"] = asm["_cellToParent"];
  var _cellToVertex = Module["_cellToVertex"] = asm["_cellToVertex"];
  var _cellToVertexes = Module["_cellToVertexes"] = asm["_cellToVertexes"];
  var _cellsToDirectedEdge = Module["_cellsToDirectedEdge"] = asm["_cellsToDirectedEdge"];
  var _cellsToLinkedMultiPolygon = Module["_cellsToLinkedMultiPolygon"] = asm["_cellsToLinkedMultiPolygon"];
  var _childPosToCell = Module["_childPosToCell"] = asm["_childPosToCell"];
  var _compactCells = Module["_compactCells"] = asm["_compactCells"];
  var _constructCell = Module["_constructCell"] = asm["_constructCell"];
  var _destroyLinkedMultiPolygon = Module["_destroyLinkedMultiPolygon"] = asm["_destroyLinkedMultiPolygon"];
  var _directedEdgeToBoundary = Module["_directedEdgeToBoundary"] = asm["_directedEdgeToBoundary"];
  var _directedEdgeToCells = Module["_directedEdgeToCells"] = asm["_directedEdgeToCells"];
  var _edgeLengthKm = Module["_edgeLengthKm"] = asm["_edgeLengthKm"];
  var _edgeLengthM = Module["_edgeLengthM"] = asm["_edgeLengthM"];
  var _edgeLengthRads = Module["_edgeLengthRads"] = asm["_edgeLengthRads"];
  var _emscripten_replace_memory = Module["_emscripten_replace_memory"] = asm["_emscripten_replace_memory"];
  var _free = Module["_free"] = asm["_free"];
  var _getBaseCellNumber = Module["_getBaseCellNumber"] = asm["_getBaseCellNumber"];
  var _getDirectedEdgeDestination = Module["_getDirectedEdgeDestination"] = asm["_getDirectedEdgeDestination"];
  var _getDirectedEdgeOrigin = Module["_getDirectedEdgeOrigin"] = asm["_getDirectedEdgeOrigin"];
  var _getHexagonAreaAvgKm2 = Module["_getHexagonAreaAvgKm2"] = asm["_getHexagonAreaAvgKm2"];
  var _getHexagonAreaAvgM2 = Module["_getHexagonAreaAvgM2"] = asm["_getHexagonAreaAvgM2"];
  var _getHexagonEdgeLengthAvgKm = Module["_getHexagonEdgeLengthAvgKm"] = asm["_getHexagonEdgeLengthAvgKm"];
  var _getHexagonEdgeLengthAvgM = Module["_getHexagonEdgeLengthAvgM"] = asm["_getHexagonEdgeLengthAvgM"];
  var _getIcosahedronFaces = Module["_getIcosahedronFaces"] = asm["_getIcosahedronFaces"];
  var _getIndexDigit = Module["_getIndexDigit"] = asm["_getIndexDigit"];
  var _getNumCells = Module["_getNumCells"] = asm["_getNumCells"];
  var _getPentagons = Module["_getPentagons"] = asm["_getPentagons"];
  var _getRes0Cells = Module["_getRes0Cells"] = asm["_getRes0Cells"];
  var _getResolution = Module["_getResolution"] = asm["_getResolution"];
  var _greatCircleDistanceKm = Module["_greatCircleDistanceKm"] = asm["_greatCircleDistanceKm"];
  var _greatCircleDistanceM = Module["_greatCircleDistanceM"] = asm["_greatCircleDistanceM"];
  var _greatCircleDistanceRads = Module["_greatCircleDistanceRads"] = asm["_greatCircleDistanceRads"];
  var _gridDisk = Module["_gridDisk"] = asm["_gridDisk"];
  var _gridDiskDistances = Module["_gridDiskDistances"] = asm["_gridDiskDistances"];
  var _gridDistance = Module["_gridDistance"] = asm["_gridDistance"];
  var _gridPathCells = Module["_gridPathCells"] = asm["_gridPathCells"];
  var _gridPathCellsSize = Module["_gridPathCellsSize"] = asm["_gridPathCellsSize"];
  var _gridRing = Module["_gridRing"] = asm["_gridRing"];
  var _gridRingUnsafe = Module["_gridRingUnsafe"] = asm["_gridRingUnsafe"];
  var _i64Add = Module["_i64Add"] = asm["_i64Add"];
  var _i64Subtract = Module["_i64Subtract"] = asm["_i64Subtract"];
  var _isPentagon = Module["_isPentagon"] = asm["_isPentagon"];
  var _isResClassIII = Module["_isResClassIII"] = asm["_isResClassIII"];
  var _isValidCell = Module["_isValidCell"] = asm["_isValidCell"];
  var _isValidDirectedEdge = Module["_isValidDirectedEdge"] = asm["_isValidDirectedEdge"];
  var _isValidIndex = Module["_isValidIndex"] = asm["_isValidIndex"];
  var _isValidVertex = Module["_isValidVertex"] = asm["_isValidVertex"];
  var _latLngToCell = Module["_latLngToCell"] = asm["_latLngToCell"];
  var _llvm_ctlz_i64 = Module["_llvm_ctlz_i64"] = asm["_llvm_ctlz_i64"];
  var _llvm_maxnum_f64 = Module["_llvm_maxnum_f64"] = asm["_llvm_maxnum_f64"];
  var _llvm_minnum_f64 = Module["_llvm_minnum_f64"] = asm["_llvm_minnum_f64"];
  var _llvm_round_f64 = Module["_llvm_round_f64"] = asm["_llvm_round_f64"];
  var _localIjToCell = Module["_localIjToCell"] = asm["_localIjToCell"];
  var _malloc = Module["_malloc"] = asm["_malloc"];
  var _maxFaceCount = Module["_maxFaceCount"] = asm["_maxFaceCount"];
  var _maxGridDiskSize = Module["_maxGridDiskSize"] = asm["_maxGridDiskSize"];
  var _maxPolygonToCellsSize = Module["_maxPolygonToCellsSize"] = asm["_maxPolygonToCellsSize"];
  var _maxPolygonToCellsSizeExperimental = Module["_maxPolygonToCellsSizeExperimental"] = asm["_maxPolygonToCellsSizeExperimental"];
  var _memcpy = Module["_memcpy"] = asm["_memcpy"];
  var _memset = Module["_memset"] = asm["_memset"];
  var _originToDirectedEdges = Module["_originToDirectedEdges"] = asm["_originToDirectedEdges"];
  var _pentagonCount = Module["_pentagonCount"] = asm["_pentagonCount"];
  var _polygonToCells = Module["_polygonToCells"] = asm["_polygonToCells"];
  var _polygonToCellsExperimental = Module["_polygonToCellsExperimental"] = asm["_polygonToCellsExperimental"];
  var _readInt64AsDoubleFromPointer = Module["_readInt64AsDoubleFromPointer"] = asm["_readInt64AsDoubleFromPointer"];
  var _res0CellCount = Module["_res0CellCount"] = asm["_res0CellCount"];
  var _round = Module["_round"] = asm["_round"];
  var _sbrk = Module["_sbrk"] = asm["_sbrk"];
  var _sizeOfCellBoundary = Module["_sizeOfCellBoundary"] = asm["_sizeOfCellBoundary"];
  var _sizeOfCoordIJ = Module["_sizeOfCoordIJ"] = asm["_sizeOfCoordIJ"];
  var _sizeOfGeoLoop = Module["_sizeOfGeoLoop"] = asm["_sizeOfGeoLoop"];
  var _sizeOfGeoPolygon = Module["_sizeOfGeoPolygon"] = asm["_sizeOfGeoPolygon"];
  var _sizeOfH3Index = Module["_sizeOfH3Index"] = asm["_sizeOfH3Index"];
  var _sizeOfLatLng = Module["_sizeOfLatLng"] = asm["_sizeOfLatLng"];
  var _sizeOfLinkedGeoPolygon = Module["_sizeOfLinkedGeoPolygon"] = asm["_sizeOfLinkedGeoPolygon"];
  var _uncompactCells = Module["_uncompactCells"] = asm["_uncompactCells"];
  var _uncompactCellsSize = Module["_uncompactCellsSize"] = asm["_uncompactCellsSize"];
  var _vertexToLatLng = Module["_vertexToLatLng"] = asm["_vertexToLatLng"];
  var establishStackSpace = Module["establishStackSpace"] = asm["establishStackSpace"];
  var stackAlloc = Module["stackAlloc"] = asm["stackAlloc"];
  var stackRestore = Module["stackRestore"] = asm["stackRestore"];
  var stackSave = Module["stackSave"] = asm["stackSave"];
  Module["asm"] = asm;
  Module["cwrap"] = cwrap;
  Module["setValue"] = setValue;
  Module["getValue"] = getValue;
  if (memoryInitializer) {
    if (!isDataURI(memoryInitializer)) {
      memoryInitializer = locateFile(memoryInitializer);
    }
    {
      addRunDependency("memory initializer");
      var applyMemoryInitializer = function(data) {
        if (data.byteLength) {
          data = new Uint8Array(data);
        }
        HEAPU8.set(data, GLOBAL_BASE);
        if (Module["memoryInitializerRequest"]) {
          delete Module["memoryInitializerRequest"].response;
        }
        removeRunDependency("memory initializer");
      };
      var doBrowserLoad = function() {
        readAsync(memoryInitializer, applyMemoryInitializer, function() {
          throw "could not load memory initializer " + memoryInitializer;
        });
      };
      var memoryInitializerBytes = tryParseAsDataURI(memoryInitializer);
      if (memoryInitializerBytes) {
        applyMemoryInitializer(memoryInitializerBytes.buffer);
      } else if (Module["memoryInitializerRequest"]) {
        var useRequest = function() {
          var request = Module["memoryInitializerRequest"];
          var response = request.response;
          if (request.status !== 200 && request.status !== 0) {
            var data = tryParseAsDataURI(Module["memoryInitializerRequestURL"]);
            if (data) {
              response = data.buffer;
            } else {
              console.warn("a problem seems to have happened with Module.memoryInitializerRequest, status: " + request.status + ", retrying " + memoryInitializer);
              doBrowserLoad();
              return;
            }
          }
          applyMemoryInitializer(response);
        };
        if (Module["memoryInitializerRequest"].response) {
          setTimeout(useRequest, 0);
        } else {
          Module["memoryInitializerRequest"].addEventListener("load", useRequest);
        }
      } else {
        doBrowserLoad();
      }
    }
  }
  var calledRun;
  dependenciesFulfilled = function runCaller() {
    if (!calledRun) {
      run();
    }
    if (!calledRun) {
      dependenciesFulfilled = runCaller;
    }
  };
  function run(args) {
    args = args || arguments_;
    if (runDependencies > 0) {
      return;
    }
    preRun();
    if (runDependencies > 0) {
      return;
    }
    function doRun() {
      if (calledRun) {
        return;
      }
      calledRun = true;
      if (ABORT) {
        return;
      }
      initRuntime();
      preMain();
      if (Module["onRuntimeInitialized"]) {
        Module["onRuntimeInitialized"]();
      }
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(function() {
        setTimeout(function() {
          Module["setStatus"]("");
        }, 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  Module["run"] = run;
  function abort(what) {
    if (Module["onAbort"]) {
      Module["onAbort"](what);
    }
    what += "";
    out(what);
    err(what);
    ABORT = true;
    throw "abort(" + what + "). Build with -s ASSERTIONS=1 for more info.";
  }
  Module["abort"] = abort;
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function") {
      Module["preInit"] = [Module["preInit"]];
    }
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  run();
  return libh32;
})(typeof libh3 === "object" ? libh3 : {});
var NUMBER = "number";
var H3_ERROR = NUMBER;
var BOOLEAN = NUMBER;
var H3_LOWER = NUMBER;
var H3_UPPER = NUMBER;
var RESOLUTION = NUMBER;
var POINTER = NUMBER;
var BINDINGS = [
  // The size functions are inserted via build/sizes.h
  ["sizeOfH3Index", NUMBER],
  ["sizeOfLatLng", NUMBER],
  ["sizeOfCellBoundary", NUMBER],
  ["sizeOfGeoLoop", NUMBER],
  ["sizeOfGeoPolygon", NUMBER],
  ["sizeOfLinkedGeoPolygon", NUMBER],
  ["sizeOfCoordIJ", NUMBER],
  ["readInt64AsDoubleFromPointer", NUMBER],
  // The remaining functions are defined in the core lib in h3Api.h
  ["isValidCell", BOOLEAN, [H3_LOWER, H3_UPPER]],
  ["isValidIndex", BOOLEAN, [H3_LOWER, H3_UPPER]],
  ["latLngToCell", H3_ERROR, [NUMBER, NUMBER, RESOLUTION, POINTER]],
  ["cellToLatLng", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["cellToBoundary", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["maxGridDiskSize", H3_ERROR, [NUMBER, POINTER]],
  ["gridDisk", H3_ERROR, [H3_LOWER, H3_UPPER, NUMBER, POINTER]],
  ["gridDiskDistances", H3_ERROR, [H3_LOWER, H3_UPPER, NUMBER, POINTER, POINTER]],
  ["gridRing", H3_ERROR, [H3_LOWER, H3_UPPER, NUMBER, POINTER]],
  ["gridRingUnsafe", H3_ERROR, [H3_LOWER, H3_UPPER, NUMBER, POINTER]],
  ["maxPolygonToCellsSize", H3_ERROR, [POINTER, RESOLUTION, NUMBER, POINTER]],
  ["polygonToCells", H3_ERROR, [POINTER, RESOLUTION, NUMBER, POINTER]],
  ["maxPolygonToCellsSizeExperimental", H3_ERROR, [POINTER, RESOLUTION, NUMBER, POINTER]],
  ["polygonToCellsExperimental", H3_ERROR, [POINTER, RESOLUTION, NUMBER, NUMBER, NUMBER, POINTER]],
  ["cellsToLinkedMultiPolygon", H3_ERROR, [POINTER, NUMBER, POINTER]],
  ["destroyLinkedMultiPolygon", null, [POINTER]],
  ["compactCells", H3_ERROR, [POINTER, POINTER, NUMBER, NUMBER]],
  ["uncompactCells", H3_ERROR, [POINTER, NUMBER, NUMBER, POINTER, NUMBER, RESOLUTION]],
  ["uncompactCellsSize", H3_ERROR, [POINTER, NUMBER, NUMBER, RESOLUTION, POINTER]],
  ["isPentagon", BOOLEAN, [H3_LOWER, H3_UPPER]],
  ["isResClassIII", BOOLEAN, [H3_LOWER, H3_UPPER]],
  ["getBaseCellNumber", NUMBER, [H3_LOWER, H3_UPPER]],
  ["getResolution", NUMBER, [H3_LOWER, H3_UPPER]],
  ["getIndexDigit", NUMBER, [H3_LOWER, H3_UPPER, NUMBER]],
  ["constructCell", H3_ERROR, [NUMBER, NUMBER, POINTER, POINTER]],
  ["maxFaceCount", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["getIcosahedronFaces", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["cellToParent", H3_ERROR, [H3_LOWER, H3_UPPER, RESOLUTION, POINTER]],
  ["cellToChildren", H3_ERROR, [H3_LOWER, H3_UPPER, RESOLUTION, POINTER]],
  ["cellToCenterChild", H3_ERROR, [H3_LOWER, H3_UPPER, RESOLUTION, POINTER]],
  ["cellToChildrenSize", H3_ERROR, [H3_LOWER, H3_UPPER, RESOLUTION, POINTER]],
  ["cellToChildPos", H3_ERROR, [H3_LOWER, H3_UPPER, RESOLUTION, POINTER]],
  ["childPosToCell", H3_ERROR, [NUMBER, NUMBER, H3_LOWER, H3_UPPER, RESOLUTION, POINTER]],
  ["areNeighborCells", H3_ERROR, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER, POINTER]],
  ["cellsToDirectedEdge", H3_ERROR, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER, POINTER]],
  ["getDirectedEdgeOrigin", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["getDirectedEdgeDestination", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["isValidDirectedEdge", BOOLEAN, [H3_LOWER, H3_UPPER]],
  ["directedEdgeToCells", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["originToDirectedEdges", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["directedEdgeToBoundary", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["gridDistance", H3_ERROR, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER, POINTER]],
  ["gridPathCells", H3_ERROR, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER, POINTER]],
  ["gridPathCellsSize", H3_ERROR, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER, POINTER]],
  ["cellToLocalIj", H3_ERROR, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER, NUMBER, POINTER]],
  ["localIjToCell", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER, NUMBER, POINTER]],
  ["getHexagonAreaAvgM2", H3_ERROR, [RESOLUTION, POINTER]],
  ["getHexagonAreaAvgKm2", H3_ERROR, [RESOLUTION, POINTER]],
  ["getHexagonEdgeLengthAvgM", H3_ERROR, [RESOLUTION, POINTER]],
  ["getHexagonEdgeLengthAvgKm", H3_ERROR, [RESOLUTION, POINTER]],
  ["greatCircleDistanceM", NUMBER, [POINTER, POINTER]],
  ["greatCircleDistanceKm", NUMBER, [POINTER, POINTER]],
  ["greatCircleDistanceRads", NUMBER, [POINTER, POINTER]],
  ["cellAreaM2", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["cellAreaKm2", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["cellAreaRads2", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["edgeLengthM", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["edgeLengthKm", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["edgeLengthRads", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["getNumCells", H3_ERROR, [RESOLUTION, POINTER]],
  ["getRes0Cells", H3_ERROR, [POINTER]],
  ["res0CellCount", NUMBER],
  ["getPentagons", H3_ERROR, [NUMBER, POINTER]],
  ["pentagonCount", NUMBER],
  ["cellToVertex", H3_ERROR, [H3_LOWER, H3_UPPER, NUMBER, POINTER]],
  ["cellToVertexes", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["vertexToLatLng", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["isValidVertex", BOOLEAN, [H3_LOWER, H3_UPPER]]
];
var E_SUCCESS = 0;
var E_FAILED = 1;
var E_DOMAIN = 2;
var E_LATLNG_DOMAIN = 3;
var E_RES_DOMAIN = 4;
var E_CELL_INVALID = 5;
var E_DIR_EDGE_INVALID = 6;
var E_UNDIR_EDGE_INVALID = 7;
var E_VERTEX_INVALID = 8;
var E_PENTAGON = 9;
var E_DUPLICATE_INPUT = 10;
var E_NOT_NEIGHBORS = 11;
var E_RES_MISMATCH = 12;
var E_MEMORY_ALLOC = 13;
var E_MEMORY_BOUNDS = 14;
var E_OPTION_INVALID = 15;
var E_INDEX_INVALID = 16;
var E_BASE_CELL_DOMAIN = 17;
var E_DIGIT_DOMAIN = 18;
var E_DELETED_DIGIT = 19;
var H3_ERROR_MSGS = {};
H3_ERROR_MSGS[E_SUCCESS] = "Success";
H3_ERROR_MSGS[E_FAILED] = "The operation failed but a more specific error is not available";
H3_ERROR_MSGS[E_DOMAIN] = "Argument was outside of acceptable range";
H3_ERROR_MSGS[E_LATLNG_DOMAIN] = "Latitude or longitude arguments were outside of acceptable range";
H3_ERROR_MSGS[E_RES_DOMAIN] = "Resolution argument was outside of acceptable range";
H3_ERROR_MSGS[E_CELL_INVALID] = "Cell argument was not valid";
H3_ERROR_MSGS[E_DIR_EDGE_INVALID] = "Directed edge argument was not valid";
H3_ERROR_MSGS[E_UNDIR_EDGE_INVALID] = "Undirected edge argument was not valid";
H3_ERROR_MSGS[E_VERTEX_INVALID] = "Vertex argument was not valid";
H3_ERROR_MSGS[E_PENTAGON] = "Pentagon distortion was encountered";
H3_ERROR_MSGS[E_DUPLICATE_INPUT] = "Duplicate input";
H3_ERROR_MSGS[E_NOT_NEIGHBORS] = "Cell arguments were not neighbors";
H3_ERROR_MSGS[E_RES_MISMATCH] = "Cell arguments had incompatible resolutions";
H3_ERROR_MSGS[E_MEMORY_ALLOC] = "Memory allocation failed";
H3_ERROR_MSGS[E_MEMORY_BOUNDS] = "Bounds of provided memory were insufficient";
H3_ERROR_MSGS[E_OPTION_INVALID] = "Mode or flags argument was not valid";
H3_ERROR_MSGS[E_INDEX_INVALID] = "Index argument was not valid";
H3_ERROR_MSGS[E_BASE_CELL_DOMAIN] = "Base cell number was outside of acceptable range";
H3_ERROR_MSGS[E_DIGIT_DOMAIN] = "Child indexing digits invalid";
H3_ERROR_MSGS[E_DELETED_DIGIT] = "Child indexing digits refer to a deleted subsequence";
var E_UNKNOWN_UNIT = 1e3;
var E_ARRAY_LENGTH = 1001;
var E_NULL_INDEX = 1002;
var JS_ERROR_MESSAGES = {};
JS_ERROR_MESSAGES[E_UNKNOWN_UNIT] = "Unknown unit";
JS_ERROR_MESSAGES[E_ARRAY_LENGTH] = "Array length out of bounds";
JS_ERROR_MESSAGES[E_NULL_INDEX] = "Got unexpected null value for H3 index";
var UNKNOWN_ERROR_MSG = "Unknown error";
function createError(messages, errCode, meta) {
  var hasValue = meta && "value" in meta;
  var err = new Error((messages[errCode] || UNKNOWN_ERROR_MSG) + " (code: " + errCode + (hasValue ? ", value: " + meta.value : "") + ")");
  err.code = errCode;
  return err;
}
function H3LibraryError(errCode, value) {
  var meta = arguments.length === 2 ? {
    value
  } : {};
  return createError(H3_ERROR_MSGS, errCode, meta);
}
function JSBindingError(errCode, value) {
  var meta = arguments.length === 2 ? {
    value
  } : {};
  return createError(JS_ERROR_MESSAGES, errCode, meta);
}
function throwIfError(errCode) {
  if (errCode !== 0) {
    throw H3LibraryError(errCode);
  }
}
var H3 = {};
BINDINGS.forEach(function bind(def) {
  H3[def[0]] = libh3.cwrap.apply(libh3, def);
});
var BASE_16 = 16;
var SZ_INT = 4;
var SZ_PTR = 4;
var SZ_DBL = 8;
var SZ_INT64 = 8;
var SZ_H3INDEX = H3.sizeOfH3Index();
var SZ_LATLNG = H3.sizeOfLatLng();
var SZ_CELLBOUNDARY = H3.sizeOfCellBoundary();
var SZ_GEOPOLYGON = H3.sizeOfGeoPolygon();
var SZ_GEOLOOP = H3.sizeOfGeoLoop();
var SZ_LINKED_GEOPOLYGON = H3.sizeOfLinkedGeoPolygon();
var SZ_COORDIJ = H3.sizeOfCoordIJ();
var UNITS = {
  m: "m",
  m2: "m2",
  km: "km",
  km2: "km2",
  rads: "rads",
  rads2: "rads2"
};
function validateRes(res) {
  if (typeof res !== "number" || res < 0 || res > 15 || Math.floor(res) !== res) {
    throw H3LibraryError(E_RES_DOMAIN, res);
  }
  return res;
}
function validateH3Index(h3Index) {
  if (!h3Index) {
    throw JSBindingError(E_NULL_INDEX);
  }
  return h3Index;
}
var MAX_JS_ARRAY_LENGTH = Math.pow(2, 32) - 1;
var INVALID_HEXIDECIMAL_CHAR = /[^0-9a-fA-F]/;
function h3IndexToSplitLong(h3Index) {
  if (Array.isArray(h3Index) && h3Index.length === 2 && Number.isInteger(h3Index[0]) && Number.isInteger(h3Index[1])) {
    return h3Index;
  }
  if (typeof h3Index !== "string" || INVALID_HEXIDECIMAL_CHAR.test(h3Index)) {
    return [0, 0];
  }
  var upper = parseInt(h3Index.substring(0, h3Index.length - 8), BASE_16);
  var lower = parseInt(h3Index.substring(h3Index.length - 8), BASE_16);
  return [lower, upper];
}
function hexFrom32Bit(num) {
  if (num >= 0) {
    return num.toString(BASE_16);
  }
  num = num & 2147483647;
  var tempStr = zeroPad(8, num.toString(BASE_16));
  var topNum = (parseInt(tempStr[0], BASE_16) + 8).toString(BASE_16);
  tempStr = topNum + tempStr.substring(1);
  return tempStr;
}
function splitLongToH3Index(lower, upper) {
  return hexFrom32Bit(upper) + zeroPad(8, hexFrom32Bit(lower));
}
function zeroPad(fullLen, numStr) {
  var numZeroes = fullLen - numStr.length;
  var outStr = "";
  for (var i = 0; i < numZeroes; i++) {
    outStr += "0";
  }
  outStr = outStr + numStr;
  return outStr;
}
var UPPER_BIT_DIVISOR = Math.pow(2, 32);
function readH3IndexFromPointer(cAddress, offset) {
  if (offset === void 0) offset = 0;
  var lower = libh3.getValue(cAddress + SZ_H3INDEX * offset, "i32");
  var upper = libh3.getValue(cAddress + SZ_H3INDEX * offset + SZ_INT, "i32");
  return upper ? splitLongToH3Index(lower, upper) : null;
}
function readDoubleFromPointer(cAddress, offset) {
  if (offset === void 0) offset = 0;
  return libh3.getValue(cAddress + SZ_DBL * offset, "double");
}
function readInt64AsDoubleFromPointer(cAddress) {
  return H3.readInt64AsDoubleFromPointer(cAddress);
}
function storeH3Index(h3Index, cAddress, offset) {
  libh3.HEAPU32.set(h3IndexToSplitLong(h3Index), cAddress / SZ_INT + 2 * offset);
}
function storeArrayOfH3Indexes(cAddress, hexagons) {
  var count = hexagons.length;
  for (var i = 0; i < count; i++) {
    storeH3Index(hexagons[i], cAddress, i);
  }
}
function readSingleCoord(cAddress) {
  return radsToDegs(libh3.getValue(cAddress, "double"));
}
function readLatLng(cAddress) {
  return [readSingleCoord(cAddress), readSingleCoord(cAddress + SZ_DBL)];
}
function readLatLngGeoJson(cAddress) {
  return [readSingleCoord(cAddress + SZ_DBL), readSingleCoord(cAddress)];
}
function readCellBoundary(cellBoundary, geoJsonCoords, closedLoop) {
  var numVerts = libh3.getValue(cellBoundary, "i32");
  var vertsPos = cellBoundary + SZ_DBL;
  var out = [];
  var readCoord = geoJsonCoords ? readLatLngGeoJson : readLatLng;
  for (var i = 0; i < numVerts * 2; i += 2) {
    out.push(readCoord(vertsPos + SZ_DBL * i));
  }
  if (closedLoop) {
    out.push(out[0]);
  }
  return out;
}
function readMultiPolygon(polygon, formatAsGeoJson) {
  var output = [];
  var readCoord = formatAsGeoJson ? readLatLngGeoJson : readLatLng;
  var loops;
  var loop;
  var coords;
  var coord;
  while (polygon) {
    output.push(loops = []);
    loop = libh3.getValue(polygon, "i8*");
    while (loop) {
      loops.push(coords = []);
      coord = libh3.getValue(loop, "i8*");
      while (coord) {
        coords.push(readCoord(coord));
        coord = libh3.getValue(coord + SZ_DBL * 2, "i8*");
      }
      if (formatAsGeoJson) {
        coords.push(coords[0]);
      }
      loop = libh3.getValue(loop + SZ_PTR * 2, "i8*");
    }
    polygon = libh3.getValue(polygon + SZ_PTR * 2, "i8*");
  }
  return output;
}
function isPentagon(h3Index) {
  var ref = h3IndexToSplitLong(h3Index);
  var lower = ref[0];
  var upper = ref[1];
  return Boolean(H3.isPentagon(lower, upper));
}
function getResolution2(h3Index) {
  var ref = h3IndexToSplitLong(h3Index);
  var lower = ref[0];
  var upper = ref[1];
  if (!H3.isValidCell(lower, upper)) {
    return -1;
  }
  return H3.getResolution(lower, upper);
}
function latLngToCell(lat, lng, res) {
  var latLng = libh3._malloc(SZ_LATLNG);
  libh3.HEAPF64.set([lat, lng].map(degsToRads), latLng / SZ_DBL);
  var h3Index = libh3._malloc(SZ_H3INDEX);
  try {
    throwIfError(H3.latLngToCell(latLng, res, h3Index));
    return validateH3Index(readH3IndexFromPointer(h3Index));
  } finally {
    libh3._free(h3Index);
    libh3._free(latLng);
  }
}
function cellToLatLng(h3Index) {
  var latLng = libh3._malloc(SZ_LATLNG);
  var ref = h3IndexToSplitLong(h3Index);
  var lower = ref[0];
  var upper = ref[1];
  try {
    throwIfError(H3.cellToLatLng(lower, upper, latLng));
    return readLatLng(latLng);
  } finally {
    libh3._free(latLng);
  }
}
function cellToBoundary2(h3Index, formatAsGeoJson) {
  var cellBoundary = libh3._malloc(SZ_CELLBOUNDARY);
  var ref = h3IndexToSplitLong(h3Index);
  var lower = ref[0];
  var upper = ref[1];
  try {
    throwIfError(H3.cellToBoundary(lower, upper, cellBoundary));
    return readCellBoundary(cellBoundary, formatAsGeoJson, formatAsGeoJson);
  } finally {
    libh3._free(cellBoundary);
  }
}
function cellsToMultiPolygon(h3Indexes, formatAsGeoJson) {
  if (!h3Indexes || !h3Indexes.length) {
    return [];
  }
  var indexCount = h3Indexes.length;
  var set6 = libh3._calloc(indexCount, SZ_H3INDEX);
  storeArrayOfH3Indexes(set6, h3Indexes);
  var polygon = libh3._calloc(SZ_LINKED_GEOPOLYGON);
  try {
    throwIfError(H3.cellsToLinkedMultiPolygon(set6, indexCount, polygon));
    return readMultiPolygon(polygon, formatAsGeoJson);
  } finally {
    H3.destroyLinkedMultiPolygon(polygon);
    libh3._free(polygon);
    libh3._free(set6);
  }
}
function gridDistance(origin, destination) {
  var ref = h3IndexToSplitLong(origin);
  var oLower = ref[0];
  var oUpper = ref[1];
  var ref$1 = h3IndexToSplitLong(destination);
  var dLower = ref$1[0];
  var dUpper = ref$1[1];
  var countPtr = libh3._malloc(SZ_INT64);
  try {
    throwIfError(H3.gridDistance(oLower, oUpper, dLower, dUpper, countPtr));
    return readInt64AsDoubleFromPointer(countPtr);
  } finally {
    libh3._free(countPtr);
  }
}
function getHexagonEdgeLengthAvg(res, unit) {
  validateRes(res);
  var out = libh3._malloc(SZ_DBL);
  try {
    switch (unit) {
      case UNITS.m:
        throwIfError(H3.getHexagonEdgeLengthAvgM(res, out));
        break;
      case UNITS.km:
        throwIfError(H3.getHexagonEdgeLengthAvgKm(res, out));
        break;
      default:
        throw JSBindingError(E_UNKNOWN_UNIT, unit);
    }
    return readDoubleFromPointer(out);
  } finally {
    libh3._free(out);
  }
}
function degsToRads(deg) {
  return deg * Math.PI / 180;
}
function radsToDegs(rad) {
  return rad * 180 / Math.PI;
}

// node_modules/@deck.gl/geo-layers/dist/h3-layers/h3-utils.js
function normalizeLongitudes2(vertices, refLng) {
  refLng = refLng === void 0 ? vertices[0][0] : refLng;
  for (const pt of vertices) {
    const deltaLng = pt[0] - refLng;
    if (deltaLng > 180) {
      pt[0] -= 360;
    } else if (deltaLng < -180) {
      pt[0] += 360;
    }
  }
}
function scalePolygon(hexId, vertices, factor) {
  const [lat, lng] = cellToLatLng(hexId);
  const actualCount = vertices.length;
  normalizeLongitudes2(vertices, lng);
  const vertexCount = vertices[0] === vertices[actualCount - 1] ? actualCount - 1 : actualCount;
  for (let i = 0; i < vertexCount; i++) {
    vertices[i][0] = lerp(lng, vertices[i][0], factor);
    vertices[i][1] = lerp(lat, vertices[i][1], factor);
  }
}
function getHexagonCentroid(getHexagon, object, objectInfo) {
  const hexagonId = getHexagon(object, objectInfo);
  const [lat, lng] = cellToLatLng(hexagonId);
  return [lng, lat];
}
function h3ToPolygon(hexId, coverage = 1) {
  const vertices = cellToBoundary2(hexId, true);
  if (coverage !== 1) {
    scalePolygon(hexId, vertices, coverage);
  } else {
    normalizeLongitudes2(vertices);
  }
  return vertices;
}
function flattenPolygon(vertices) {
  const positions = new Float64Array(vertices.length * 2);
  let i = 0;
  for (const pt of vertices) {
    positions[i++] = pt[0];
    positions[i++] = pt[1];
  }
  return positions;
}

// node_modules/@deck.gl/geo-layers/dist/a5-layer/a5-layer.js
var defaultProps17 = {
  getPentagon: { type: "accessor", value: (d2) => d2.pentagon }
};
var A5Layer = class extends GeoCellLayer_default {
  indexToBounds() {
    const { data, getPentagon } = this.props;
    return {
      data,
      _normalize: false,
      _windingOrder: "CCW",
      positionFormat: "XY",
      getPolygon: (x, objectInfo) => {
        const pentagon = getPentagon(x, objectInfo);
        const boundary = cellToBoundary(typeof pentagon === "string" ? hexToU64(pentagon) : pentagon, { closedRing: true, segments: "auto" });
        return flattenPolygon(boundary);
      }
    };
  }
};
A5Layer.layerName = "A5Layer";
A5Layer.defaultProps = defaultProps17;
var a5_layer_default = A5Layer;

// node_modules/@loaders.gl/xml/dist/sax-ts/sax.js
var DEFAULT_SAX_EVENTS = {
  ontext: () => {
  },
  onprocessinginstruction: () => {
  },
  onsgmldeclaration: () => {
  },
  ondoctype: () => {
  },
  oncomment: () => {
  },
  onopentagstart: () => {
  },
  onattribute: () => {
  },
  onopentag: () => {
  },
  onclosetag: () => {
  },
  onopencdata: () => {
  },
  oncdata: () => {
  },
  onclosecdata: () => {
  },
  onerror: () => {
  },
  onend: () => {
  },
  onready: () => {
  },
  onscript: () => {
  },
  onopennamespace: () => {
  },
  onclosenamespace: () => {
  }
};
var DEFAULT_SAX_PARSER_OPTIONS = {
  ...DEFAULT_SAX_EVENTS,
  strict: false,
  MAX_BUFFER_LENGTH: 64 * 1024,
  lowercase: false,
  lowercasetags: false,
  noscript: false,
  strictEntities: false,
  xmlns: void 0,
  position: void 0,
  trim: void 0,
  normalize: void 0
};
var ENTITIES = {
  amp: "&",
  gt: ">",
  lt: "<",
  quot: '"',
  apos: "'",
  AElig: 198,
  Aacute: 193,
  Acirc: 194,
  Agrave: 192,
  Aring: 197,
  Atilde: 195,
  Auml: 196,
  Ccedil: 199,
  ETH: 208,
  Eacute: 201,
  Ecirc: 202,
  Egrave: 200,
  Euml: 203,
  Iacute: 205,
  Icirc: 206,
  Igrave: 204,
  Iuml: 207,
  Ntilde: 209,
  Oacute: 211,
  Ocirc: 212,
  Ograve: 210,
  Oslash: 216,
  Otilde: 213,
  Ouml: 214,
  THORN: 222,
  Uacute: 218,
  Ucirc: 219,
  Ugrave: 217,
  Uuml: 220,
  Yacute: 221,
  aacute: 225,
  acirc: 226,
  aelig: 230,
  agrave: 224,
  aring: 229,
  atilde: 227,
  auml: 228,
  ccedil: 231,
  eacute: 233,
  ecirc: 234,
  egrave: 232,
  eth: 240,
  euml: 235,
  iacute: 237,
  icirc: 238,
  igrave: 236,
  iuml: 239,
  ntilde: 241,
  oacute: 243,
  ocirc: 244,
  ograve: 242,
  oslash: 248,
  otilde: 245,
  ouml: 246,
  szlig: 223,
  thorn: 254,
  uacute: 250,
  ucirc: 251,
  ugrave: 249,
  uuml: 252,
  yacute: 253,
  yuml: 255,
  copy: 169,
  reg: 174,
  nbsp: 160,
  iexcl: 161,
  cent: 162,
  pound: 163,
  curren: 164,
  yen: 165,
  brvbar: 166,
  sect: 167,
  uml: 168,
  ordf: 170,
  laquo: 171,
  not: 172,
  shy: 173,
  macr: 175,
  deg: 176,
  plusmn: 177,
  sup1: 185,
  sup2: 178,
  sup3: 179,
  acute: 180,
  micro: 181,
  para: 182,
  middot: 183,
  cedil: 184,
  ordm: 186,
  raquo: 187,
  frac14: 188,
  frac12: 189,
  frac34: 190,
  iquest: 191,
  times: 215,
  divide: 247,
  OElig: 338,
  oelig: 339,
  Scaron: 352,
  scaron: 353,
  Yuml: 376,
  fnof: 402,
  circ: 710,
  tilde: 732,
  Alpha: 913,
  Beta: 914,
  Gamma: 915,
  Delta: 916,
  Epsilon: 917,
  Zeta: 918,
  Eta: 919,
  Theta: 920,
  Iota: 921,
  Kappa: 922,
  Lambda: 923,
  Mu: 924,
  Nu: 925,
  Xi: 926,
  Omicron: 927,
  Pi: 928,
  Rho: 929,
  Sigma: 931,
  Tau: 932,
  Upsilon: 933,
  Phi: 934,
  Chi: 935,
  Psi: 936,
  Omega: 937,
  alpha: 945,
  beta: 946,
  gamma: 947,
  delta: 948,
  epsilon: 949,
  zeta: 950,
  eta: 951,
  theta: 952,
  iota: 953,
  kappa: 954,
  lambda: 955,
  mu: 956,
  nu: 957,
  xi: 958,
  omicron: 959,
  pi: 960,
  rho: 961,
  sigmaf: 962,
  sigma: 963,
  tau: 964,
  upsilon: 965,
  phi: 966,
  chi: 967,
  psi: 968,
  omega: 969,
  thetasym: 977,
  upsih: 978,
  piv: 982,
  ensp: 8194,
  emsp: 8195,
  thinsp: 8201,
  zwnj: 8204,
  zwj: 8205,
  lrm: 8206,
  rlm: 8207,
  ndash: 8211,
  mdash: 8212,
  lsquo: 8216,
  rsquo: 8217,
  sbquo: 8218,
  ldquo: 8220,
  rdquo: 8221,
  bdquo: 8222,
  dagger: 8224,
  Dagger: 8225,
  bull: 8226,
  hellip: 8230,
  permil: 8240,
  prime: 8242,
  Prime: 8243,
  lsaquo: 8249,
  rsaquo: 8250,
  oline: 8254,
  frasl: 8260,
  euro: 8364,
  image: 8465,
  weierp: 8472,
  real: 8476,
  trade: 8482,
  alefsym: 8501,
  larr: 8592,
  uarr: 8593,
  rarr: 8594,
  darr: 8595,
  harr: 8596,
  crarr: 8629,
  lArr: 8656,
  uArr: 8657,
  rArr: 8658,
  dArr: 8659,
  hArr: 8660,
  forall: 8704,
  part: 8706,
  exist: 8707,
  empty: 8709,
  nabla: 8711,
  isin: 8712,
  notin: 8713,
  ni: 8715,
  prod: 8719,
  sum: 8721,
  minus: 8722,
  lowast: 8727,
  radic: 8730,
  prop: 8733,
  infin: 8734,
  ang: 8736,
  and: 8743,
  or: 8744,
  cap: 8745,
  cup: 8746,
  int: 8747,
  there4: 8756,
  sim: 8764,
  cong: 8773,
  asymp: 8776,
  ne: 8800,
  equiv: 8801,
  le: 8804,
  ge: 8805,
  sub: 8834,
  sup: 8835,
  nsub: 8836,
  sube: 8838,
  supe: 8839,
  oplus: 8853,
  otimes: 8855,
  perp: 8869,
  sdot: 8901,
  lceil: 8968,
  rceil: 8969,
  lfloor: 8970,
  rfloor: 8971,
  lang: 9001,
  rang: 9002,
  loz: 9674,
  spades: 9824,
  clubs: 9827,
  hearts: 9829,
  diams: 9830
};
Object.keys(ENTITIES).forEach((key) => {
  const e2 = ENTITIES[key];
  ENTITIES[key] = typeof e2 === "number" ? String.fromCharCode(e2) : e2;
});

// node_modules/@loaders.gl/xml/dist/lib/xml-utils/uncapitalize.js
function uncapitalize(str5) {
  return typeof str5 === "string" ? str5.charAt(0).toLowerCase() + str5.slice(1) : str5;
}
function uncapitalizeKeys(object) {
  if (Array.isArray(object)) {
    return object.map((element) => uncapitalizeKeys(element));
  }
  if (object && typeof object === "object") {
    const newObject = {};
    for (const [key, value] of Object.entries(object)) {
      newObject[uncapitalize(key)] = uncapitalizeKeys(value);
    }
    return newObject;
  }
  return object;
}

// node_modules/@loaders.gl/xml/dist/lib/parsers/parse-xml.js
var import_fast_xml_parser = __toESM(require_fxp(), 1);
function parseXMLSync(text, options) {
  if ((options == null ? void 0 : options._parser) && options._parser !== "fast-xml-parser") {
    throw new Error(options == null ? void 0 : options._parser);
  }
  const fastXMLOptions = {
    // Default FastXML options
    // https://github.com/NaturalIntelligence/fast-xml-parser/blob/master/docs/v4/2.XMLparseOptions.md#allowbooleanattributes
    allowBooleanAttributes: true,
    // https://github.com/NaturalIntelligence/fast-xml-parser/blob/master/docs/v4/2.XMLparseOptions.md#ignoredeclaration
    ignoreDeclaration: true,
    // https://github.com/NaturalIntelligence/fast-xml-parser/blob/master/docs/v4/2.XMLparseOptions.md#removensprefix
    removeNSPrefix: options == null ? void 0 : options.removeNSPrefix,
    // https://github.com/NaturalIntelligence/fast-xml-parser/blob/master/docs/v4/2.XMLparseOptions.md#textnodename
    textNodeName: options == null ? void 0 : options.textNodeName,
    // Let's application specify keys that are always arrays
    isArray: (name, jpath, isLeafNode, isAttribute) => {
      var _a;
      const array = Boolean((_a = options == null ? void 0 : options.arrayPaths) == null ? void 0 : _a.some((path) => jpath === path));
      return array;
    },
    // Application overrides
    ...options == null ? void 0 : options._fastXML
  };
  const xml = fastParseXML(text, fastXMLOptions);
  return (options == null ? void 0 : options.uncapitalizeKeys) ? uncapitalizeKeys(xml) : xml;
}
function fastParseXML(text, options) {
  const parser = new import_fast_xml_parser.XMLParser({
    ignoreAttributes: false,
    attributeNamePrefix: "",
    ...options
  });
  const parsedXML = parser.parse(text);
  return parsedXML;
}

// node_modules/@loaders.gl/xml/dist/xml-loader.js
var VERSION = true ? "4.3.3" : "latest";
var XMLLoader = {
  dataType: null,
  batchType: null,
  name: "XML",
  id: "xml",
  module: "xml",
  version: VERSION,
  worker: false,
  extensions: ["xml"],
  mimeTypes: ["application/xml", "text/xml"],
  testText: testXMLFile,
  options: {
    xml: {
      _parser: "fast-xml-parser",
      uncapitalizeKeys: false,
      removeNSPrefix: false,
      textNodeName: "value",
      arrayPaths: []
    }
  },
  parse: async (arrayBuffer, options) => parseXMLSync(new TextDecoder().decode(arrayBuffer), {
    ...XMLLoader.options.xml,
    ...options == null ? void 0 : options.xml
  }),
  parseTextSync: (text, options) => parseXMLSync(text, { ...XMLLoader.options.xml, ...options == null ? void 0 : options.xml })
};
function testXMLFile(text) {
  return text.startsWith("<?xml");
}

// node_modules/@loaders.gl/xml/dist/html-loader.js
var HTMLLoader = {
  ...XMLLoader,
  name: "HTML",
  id: "html",
  extensions: ["html", "htm"],
  mimeTypes: ["text/html"],
  testText: testHTMLFile,
  parse: async (arrayBuffer, options) => parseTextSync(new TextDecoder().decode(arrayBuffer), options),
  parseTextSync: (text, options) => parseTextSync(text, options)
};
function testHTMLFile(text) {
  return text.startsWith("<html");
}
function parseTextSync(text, options) {
  var _a, _b;
  options = mergeLoaderOptions(options, {
    xml: {
      _parser: "fast-xml-parser",
      _fastXML: {
        htmlEntities: true
      }
    }
  });
  return (_b = (_a = XMLLoader).parseTextSync) == null ? void 0 : _b.call(_a, text, options);
}

// node_modules/@loaders.gl/wms/dist/lib/parsers/wms/parse-wms-error.js
function parseWMSError(text, options) {
  var _a, _b, _c, _d;
  const parsedXML = (_b = (_a = XMLLoader).parseTextSync) == null ? void 0 : _b.call(_a, text, options);
  const serviceExceptionXML = ((_c = parsedXML == null ? void 0 : parsedXML.ServiceExceptionReport) == null ? void 0 : _c.ServiceException) || ((_d = parsedXML == null ? void 0 : parsedXML["ogc:ServiceExceptionReport"]) == null ? void 0 : _d["ogc:ServiceException"]);
  const message = typeof serviceExceptionXML === "string" ? serviceExceptionXML : serviceExceptionXML.value || serviceExceptionXML.code || "Unknown error";
  return message;
}

// node_modules/@loaders.gl/wms/dist/wms-error-loader.js
var VERSION2 = true ? "4.3.3" : "latest";
var WMSErrorLoader = {
  dataType: null,
  batchType: null,
  id: "wms-error",
  name: "WMS Error",
  module: "wms",
  version: VERSION2,
  worker: false,
  extensions: ["xml"],
  mimeTypes: ["application/vnd.ogc.se_xml", "application/xml", "text/xml"],
  testText: testXMLFile2,
  options: {
    wms: {
      throwOnError: false
    }
  },
  parse: async (arrayBuffer, options) => parseTextSync2(new TextDecoder().decode(arrayBuffer), options),
  parseSync: (arrayBuffer, options) => parseTextSync2(new TextDecoder().decode(arrayBuffer), options),
  parseTextSync: (text, options) => parseTextSync2(text, options)
};
function testXMLFile2(text) {
  return text.startsWith("<?xml");
}
function parseTextSync2(text, options) {
  const wmsOptions = { ...WMSErrorLoader.options.wms, ...options == null ? void 0 : options.wms };
  const error = parseWMSError(text, wmsOptions);
  const message = wmsOptions.minimalErrors ? error : `WMS Service error: ${error}`;
  if (wmsOptions.throwOnError) {
    throw new Error(message);
  }
  return message;
}

// node_modules/@loaders.gl/wms/dist/lib/parsers/xml/parse-xml-helpers.js
function getXMLArray(xmlValue) {
  if (Array.isArray(xmlValue)) {
    return xmlValue;
  }
  if (xmlValue) {
    return [xmlValue];
  }
  return [];
}
function getXMLStringArray(xmlValue) {
  const xmlArray = getXMLArray(xmlValue);
  if (xmlArray.length > 0 && xmlArray.every((_) => typeof _ === "string")) {
    return xmlArray;
  }
  return [];
}
function getXMLFloat(xmlValue, defaultValue = void 0) {
  switch (typeof xmlValue) {
    case "number":
      return xmlValue;
    case "string":
      return parseFloat(xmlValue);
    default:
      return void 0;
  }
}
function getXMLInteger(xmlValue, defaultValue = void 0) {
  switch (typeof xmlValue) {
    case "number":
      return xmlValue;
    case "string":
      return parseInt(xmlValue, 10);
    default:
      return void 0;
  }
}
function getXMLBoolean(xmlValue) {
  switch (xmlValue) {
    case "true":
      return true;
    case "false":
      return false;
    case "1":
      return true;
    case "0":
      return false;
    default:
      return false;
  }
}

// node_modules/@loaders.gl/wms/dist/lib/parsers/wms/parse-wms-capabilities.js
function parseWMSCapabilities(xmlText, options) {
  var _a, _b;
  const parsedXML = (_b = (_a = XMLLoader).parseTextSync) == null ? void 0 : _b.call(_a, xmlText, options);
  const xmlCapabilities = parsedXML.WMT_MS_Capabilities || parsedXML.WMS_Capabilities || parsedXML;
  const capabilities = extractCapabilities(xmlCapabilities);
  if (options == null ? void 0 : options.inheritedLayerProps) {
    for (const layer of capabilities.layers) {
      addInheritedLayerProps(layer, null);
    }
  }
  if (options == null ? void 0 : options.includeRawJSON) {
    capabilities.json = xmlCapabilities;
  }
  if (options == null ? void 0 : options.includeXMLText) {
    capabilities.xml = xmlText;
  }
  return capabilities;
}
function extractCapabilities(xml) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;
  const capabilities = {
    version: String(xml.version || ""),
    name: String(((_a = xml.Service) == null ? void 0 : _a.Name) || "unnamed"),
    title: ((_b = xml.Service) == null ? void 0 : _b.Title) ? String((_c = xml.Service) == null ? void 0 : _c.Title) : void 0,
    abstract: ((_d = xml.Service) == null ? void 0 : _d.Abstract) ? String((_e = xml.Service) == null ? void 0 : _e.Abstract) : void 0,
    keywords: getXMLStringArray((_g = (_f = xml.Service) == null ? void 0 : _f.KeywordList) == null ? void 0 : _g.Keyword),
    fees: ((_h = xml.Service) == null ? void 0 : _h.Fees) ? JSON.stringify((_i = xml.Service) == null ? void 0 : _i.Fees) : void 0,
    accessConstraints: ((_j = xml.Service) == null ? void 0 : _j.AccessConstraints) ? JSON.stringify((_k = xml.Service) == null ? void 0 : _k.AccessConstraints) : void 0,
    layerLimit: getXMLInteger((_l = xml.Service) == null ? void 0 : _l.LayerLimit),
    maxWidth: getXMLInteger((_m = xml.Service) == null ? void 0 : _m.maxWidth),
    maxHeight: getXMLInteger((_n = xml.Service) == null ? void 0 : _n.maxHeight),
    layers: [],
    requests: extractRequests((_o = xml.Capability) == null ? void 0 : _o.Request),
    exceptions: extractExceptions(xml.Exception)
    // contact field is a mess of largely irrelevant information, put it last
    // contact: xml.Service?.Contact ? JSON.stringify(xml.Service?.Contact) : undefined,
  };
  const xmlLayers = getXMLArray((_p = xml.Capability) == null ? void 0 : _p.Layer);
  for (const xmlSubLayer of xmlLayers) {
    capabilities.layers.push(extractLayer(xmlSubLayer));
  }
  for (const [key, value] of Object.entries(capabilities)) {
    if (value === void 0) {
      delete capabilities[key];
    }
  }
  return capabilities;
}
function extractRequests(xmlRequests) {
  const requests = {};
  for (const [name, xmlRequest] of Object.entries(xmlRequests || {})) {
    const mimeTypes = getXMLStringArray(xmlRequest == null ? void 0 : xmlRequest.Format);
    requests[name] = { mimeTypes };
  }
  return requests;
}
function extractExceptions(xmlException) {
  const xmlExceptionFormats = getXMLArray(xmlException == null ? void 0 : xmlException.Format);
  if (xmlExceptionFormats.length > 0) {
    return {
      mimeTypes: getXMLStringArray(xmlException)
    };
  }
  return void 0;
}
function extractLayer(xmlLayer) {
  var _a;
  const layer = {
    // All layers must have a title
    title: String((xmlLayer == null ? void 0 : xmlLayer.Title) || ""),
    // Name is required only if renderable
    name: (xmlLayer == null ? void 0 : xmlLayer.Name) && String(xmlLayer == null ? void 0 : xmlLayer.Name),
    abstract: (xmlLayer == null ? void 0 : xmlLayer.Name) && String(xmlLayer == null ? void 0 : xmlLayer.Abstract),
    keywords: getXMLStringArray((_a = xmlLayer.KeywordList) == null ? void 0 : _a.Keyword)
  };
  const crs2 = (xmlLayer == null ? void 0 : xmlLayer.CRS) || (xmlLayer == null ? void 0 : xmlLayer.SRS);
  if (crs2 && Array.isArray(crs2) && crs2.every((_) => typeof _ === "string")) {
    layer.crs = crs2;
  }
  let geographicBoundingBox = (xmlLayer == null ? void 0 : xmlLayer.EX_GeographicBoundingBox) && extractEXBoundingBox(xmlLayer == null ? void 0 : xmlLayer.EX_GeographicBoundingBox);
  if (geographicBoundingBox) {
    layer.geographicBoundingBox = geographicBoundingBox;
  }
  geographicBoundingBox = (xmlLayer == null ? void 0 : xmlLayer.LatLonBoundingBox) && extractLatLonBoundingBox(xmlLayer == null ? void 0 : xmlLayer.LatLonBoundingBox);
  if (geographicBoundingBox) {
    layer.geographicBoundingBox = geographicBoundingBox;
  }
  const boundingBoxes = (xmlLayer == null ? void 0 : xmlLayer.BoundingBox) && extractWMSBoundingBoxes(xmlLayer == null ? void 0 : xmlLayer.BoundingBox);
  if (boundingBoxes && boundingBoxes.length > 0) {
    layer.boundingBoxes = boundingBoxes;
  }
  const xmlDimensions = getXMLArray(xmlLayer == null ? void 0 : xmlLayer.Dimension);
  const dimensions = xmlDimensions.map((xml) => extractDimension(xml));
  if (dimensions.length) {
    layer.dimensions = dimensions;
  }
  if (xmlLayer == null ? void 0 : xmlLayer.opaque) {
    layer.opaque = getXMLBoolean(xmlLayer == null ? void 0 : xmlLayer.opaque);
  }
  if (xmlLayer == null ? void 0 : xmlLayer.cascaded) {
    layer.cascaded = getXMLBoolean(xmlLayer == null ? void 0 : xmlLayer.cascaded);
  }
  if (xmlLayer == null ? void 0 : xmlLayer.queryable) {
    layer.queryable = getXMLBoolean(xmlLayer == null ? void 0 : xmlLayer.queryable);
  }
  const xmlLayers = getXMLArray(xmlLayer == null ? void 0 : xmlLayer.Layer);
  const layers = [];
  for (const xmlSubLayer of xmlLayers) {
    layers.push(extractLayer(xmlSubLayer));
  }
  if (layers.length > 0) {
    layer.layers = layers;
  }
  for (const [key, value] of Object.entries(layer)) {
    if (value === void 0) {
      delete layer[key];
    }
  }
  return layer;
}
function extractEXBoundingBox(xmlBoundingBox) {
  const { westBoundLongitude: w2, northBoundLatitude: n, eastBoundLongitude: e2, southBoundLatitude: s } = xmlBoundingBox;
  return [
    [w2, s],
    [e2, n]
  ];
}
function extractLatLonBoundingBox(xmlBoundingBox) {
  const { minx, miny, maxx, maxy } = xmlBoundingBox;
  return [
    [minx, miny],
    [maxx, maxy]
  ];
}
function extractWMSBoundingBoxes(xmlBoundingBoxes) {
  const xmlBoxes = getXMLArray(xmlBoundingBoxes);
  return xmlBoxes.map((xmlBox) => extractWMSBoundingBox(xmlBox));
}
function extractWMSBoundingBox(xmlBoundingBox) {
  const { CRS: CRS2, SRS, minx, miny, maxx, maxy, resx, resy } = xmlBoundingBox;
  const boundingBox = {
    // CRS in 1.3.0, SRS in 1.1.1
    crs: CRS2 || SRS,
    boundingBox: [
      [getXMLFloat(minx), getXMLFloat(miny)],
      [getXMLFloat(maxx), getXMLFloat(maxy)]
    ]
  };
  if (resx) {
    boundingBox.xResolution = resx;
  }
  if (resy) {
    boundingBox.yResolution = resy;
  }
  return boundingBox;
}
function extractDimension(xmlDimension) {
  const { name, units, value: extent } = xmlDimension;
  const dimension = { name, units, extent };
  if (xmlDimension.unitSymbol) {
    dimension.unitSymbol = xmlDimension.unitSymbol;
  }
  if (xmlDimension.default) {
    dimension.defaultValue = xmlDimension.default;
  }
  if (xmlDimension.multipleValues) {
    dimension.multipleValues = getXMLBoolean(xmlDimension.multipleValues);
  }
  if (xmlDimension.nearestValue) {
    dimension.nearestValue = getXMLBoolean(xmlDimension.nearestValue);
  }
  if (xmlDimension.current) {
    dimension.current = getXMLBoolean(xmlDimension.current);
  }
  return dimension;
}
function addInheritedLayerProps(layer, parent) {
  if ((parent == null ? void 0 : parent.geographicBoundingBox) && !layer.geographicBoundingBox) {
    layer.geographicBoundingBox = [...parent.geographicBoundingBox];
  }
  if ((parent == null ? void 0 : parent.crs) && !layer.crs) {
    layer.crs = [...parent.crs];
  }
  if ((parent == null ? void 0 : parent.boundingBoxes) && !layer.boundingBoxes) {
    layer.boundingBoxes = [...parent.boundingBoxes];
  }
  if ((parent == null ? void 0 : parent.dimensions) && !layer.dimensions) {
    layer.dimensions = [...parent.dimensions];
  }
  for (const subLayer of layer.layers || []) {
    addInheritedLayerProps(subLayer, layer);
  }
}

// node_modules/@loaders.gl/wms/dist/wms-capabilities-loader.js
var VERSION3 = true ? "4.3.3" : "latest";
var WMSCapabilitiesLoader = {
  dataType: null,
  batchType: null,
  id: "wms-capabilities",
  name: "WMS Capabilities",
  module: "wms",
  version: VERSION3,
  worker: false,
  extensions: ["xml"],
  mimeTypes: ["application/vnd.ogc.wms_xml", "application/xml", "text/xml"],
  testText: testXMLFile3,
  options: {
    wms: {}
  },
  parse: async (arrayBuffer, options) => (
    // TODO pass in XML options
    parseWMSCapabilities(new TextDecoder().decode(arrayBuffer), options == null ? void 0 : options.wms)
  ),
  parseTextSync: (text, options) => (
    // TODO pass in XML options
    parseWMSCapabilities(text, options == null ? void 0 : options.wms)
  )
};
function testXMLFile3(text) {
  return text.startsWith("<?xml");
}

// node_modules/@loaders.gl/wms/dist/lib/parsers/wms/parse-wms-features.js
function parseWMSFeatureInfo(text, options) {
  var _a, _b, _c;
  const parsedXML = (_b = (_a = XMLLoader).parseTextSync) == null ? void 0 : _b.call(_a, text, options);
  const xmlFeatureInfo = ((_c = parsedXML.FeatureInfoResponse) == null ? void 0 : _c.FIELDS) || [];
  const xmlFeatures = Array.isArray(xmlFeatureInfo) ? xmlFeatureInfo : [xmlFeatureInfo];
  return {
    features: xmlFeatures.map((xmlFeature) => extractFeature(xmlFeature))
  };
}
function extractFeature(xmlFeature) {
  const xmlFields = xmlFeature || {};
  return {
    attributes: xmlFields,
    type: "",
    bounds: { bottom: 0, top: 0, left: 0, right: 0 }
  };
}

// node_modules/@loaders.gl/wms/dist/wip/wms-feature-info-loader.js
var WMSFeatureInfoLoader = {
  ...WMSCapabilitiesLoader,
  dataType: null,
  id: "wms-feature-info",
  name: "WMS FeatureInfo",
  parse: async (arrayBuffer, options) => parseWMSFeatureInfo(new TextDecoder().decode(arrayBuffer), options),
  parseTextSync: (text, options) => parseWMSFeatureInfo(text, options)
};

// node_modules/@loaders.gl/wms/dist/lib/parsers/wms/parse-wms-layer-description.js
function parseWMSLayerDescription(text, options) {
  var _a, _b;
  const parsedXML = (_b = (_a = XMLLoader).parseTextSync) == null ? void 0 : _b.call(_a, text, options);
  return parsedXML;
}

// node_modules/@loaders.gl/wms/dist/wip/wms-layer-description-loader.js
var WMSLayerDescriptionLoader = {
  ...WMSCapabilitiesLoader,
  dataType: null,
  id: "wms-layer-description",
  name: "WMS DescribeLayer",
  parse: async (arrayBuffer, options) => parseWMSLayerDescription(new TextDecoder().decode(arrayBuffer), options),
  parseTextSync: (text, options) => parseWMSLayerDescription(text, options)
};

// node_modules/@loaders.gl/wms/dist/lib/parsers/gml/deep-strict-equal.js
var pSlice = Array.prototype.slice;

// node_modules/@turf/helpers/main.es.js
var earthRadius = 63710088e-1;
var factors = {
  meters: earthRadius,
  metres: earthRadius,
  millimeters: earthRadius * 1e3,
  millimetres: earthRadius * 1e3,
  centimeters: earthRadius * 100,
  centimetres: earthRadius * 100,
  kilometers: earthRadius / 1e3,
  kilometres: earthRadius / 1e3,
  miles: earthRadius / 1609.344,
  nauticalmiles: earthRadius / 1852,
  inches: earthRadius * 39.37,
  yards: earthRadius / 1.0936,
  feet: earthRadius * 3.28084,
  radians: 1,
  degrees: earthRadius / 111325
};
var unitsFactors = {
  meters: 1,
  metres: 1,
  millimeters: 1e3,
  millimetres: 1e3,
  centimeters: 100,
  centimetres: 100,
  kilometers: 1 / 1e3,
  kilometres: 1 / 1e3,
  miles: 1 / 1609.344,
  nauticalmiles: 1 / 1852,
  inches: 39.37,
  yards: 1 / 1.0936,
  feet: 3.28084,
  radians: 1 / earthRadius,
  degrees: 1 / 111325
};

// node_modules/@loaders.gl/wms/dist/services/ogc/wms-service.js
var WMSSource = {
  name: "Web Map Service (OGC WMS)",
  id: "wms",
  module: "wms",
  version: "0.0.0",
  extensions: [],
  mimeTypes: [],
  options: {
    wms: {
      // TODO - add options here
    }
  },
  type: "wms",
  fromUrl: true,
  fromBlob: false,
  testURL: (url) => url.toLowerCase().includes("wms"),
  createDataSource: (url, props) => new WMSImageSource(url, props)
};
var WMSImageSource = class extends ImageSource {
  /** Create a WMSImageSource */
  constructor(url, props) {
    var _a, _b, _c;
    super(props);
    /** Base URL to the service */
    __publicField(this, "url");
    __publicField(this, "data");
    /** In WMS 1.3.0, replaces references to EPSG:4326 with CRS:84. But not always supported. Default: false */
    __publicField(this, "substituteCRS84");
    /** In WMS 1.3.0, flips x,y (lng, lat) coordinates for the supplied coordinate systems. Default: ['ESPG:4326'] */
    __publicField(this, "flipCRS");
    /** Default static WMS parameters */
    __publicField(this, "wmsParameters");
    /** Default static vendor parameters */
    __publicField(this, "vendorParameters");
    __publicField(this, "capabilities", null);
    this.url = url;
    this.data = url;
    this.substituteCRS84 = ((_a = props.wms) == null ? void 0 : _a.substituteCRS84) ?? props.substituteCRS84 ?? false;
    this.flipCRS = ["EPSG:4326"];
    this.wmsParameters = {
      layers: void 0,
      query_layers: void 0,
      styles: void 0,
      version: "1.3.0",
      crs: "EPSG:4326",
      format: "image/png",
      info_format: "text/plain",
      transparent: void 0,
      time: void 0,
      elevation: void 0,
      ...props.wmsParameters,
      // deprecated
      ...(_b = props.wms) == null ? void 0 : _b.wmsParameters
    };
    this.vendorParameters = ((_c = props.wms) == null ? void 0 : _c.vendorParameters) || props.vendorParameters || {};
  }
  // ImageSource implementation
  async getMetadata() {
    const capabilities = await this.getCapabilities();
    return this.normalizeMetadata(capabilities);
  }
  async getImage(parameters2) {
    const { boundingBox, bbox, ...rest } = parameters2;
    const wmsParameters = {
      bbox: boundingBox ? [...boundingBox[0], ...boundingBox[1]] : bbox,
      ...rest
    };
    return await this.getMap(wmsParameters);
  }
  normalizeMetadata(capabilities) {
    return capabilities;
  }
  // WMS Service API Stubs
  /** Get Capabilities */
  async getCapabilities(wmsParameters, vendorParameters) {
    const url = this.getCapabilitiesURL(wmsParameters, vendorParameters);
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this._checkResponse(response, arrayBuffer);
    const capabilities = await WMSCapabilitiesLoader.parse(arrayBuffer, this.loadOptions);
    this.capabilities = capabilities;
    return capabilities;
  }
  /** Get a map image */
  async getMap(wmsParameters, vendorParameters) {
    const url = this.getMapURL(wmsParameters, vendorParameters);
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this._checkResponse(response, arrayBuffer);
    try {
      return await ImageLoader.parse(arrayBuffer, this.loadOptions);
    } catch {
      throw this._parseError(arrayBuffer);
    }
  }
  /** Get Feature Info for a coordinate */
  async getFeatureInfo(wmsParameters, vendorParameters) {
    const url = this.getFeatureInfoURL(wmsParameters, vendorParameters);
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this._checkResponse(response, arrayBuffer);
    return await WMSFeatureInfoLoader.parse(arrayBuffer, this.loadOptions);
  }
  /** Get Feature Info for a coordinate */
  async getFeatureInfoText(wmsParameters, vendorParameters) {
    const url = this.getFeatureInfoURL(wmsParameters, vendorParameters);
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this._checkResponse(response, arrayBuffer);
    return new TextDecoder().decode(arrayBuffer);
  }
  /** Get more information about a layer */
  async describeLayer(wmsParameters, vendorParameters) {
    const url = this.describeLayerURL(wmsParameters, vendorParameters);
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this._checkResponse(response, arrayBuffer);
    return await WMSLayerDescriptionLoader.parse(arrayBuffer, this.loadOptions);
  }
  /** Get an image with a semantic legend */
  async getLegendGraphic(wmsParameters, vendorParameters) {
    const url = this.getLegendGraphicURL(wmsParameters, vendorParameters);
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this._checkResponse(response, arrayBuffer);
    try {
      return await ImageLoader.parse(arrayBuffer, this.loadOptions);
    } catch {
      throw this._parseError(arrayBuffer);
    }
  }
  // Typed URL creators
  // For applications that want full control of fetching and parsing
  /** Generate a URL for the GetCapabilities request */
  getCapabilitiesURL(wmsParameters, vendorParameters) {
    const options = {
      version: this.wmsParameters.version,
      ...wmsParameters
    };
    return this._getWMSUrl("GetCapabilities", options, vendorParameters);
  }
  /** Generate a URL for the GetMap request */
  getMapURL(wmsParameters, vendorParameters) {
    wmsParameters = this._getWMS130Parameters(wmsParameters);
    const options = {
      version: this.wmsParameters.version,
      format: this.wmsParameters.format,
      transparent: this.wmsParameters.transparent,
      time: this.wmsParameters.time,
      elevation: this.wmsParameters.elevation,
      layers: this.wmsParameters.layers,
      styles: this.wmsParameters.styles,
      crs: this.wmsParameters.crs,
      // bbox: [-77.87304, 40.78975, -77.85828, 40.80228],
      // width: 1200,
      // height: 900,
      ...wmsParameters
    };
    return this._getWMSUrl("GetMap", options, vendorParameters);
  }
  /** Generate a URL for the GetFeatureInfo request */
  getFeatureInfoURL(wmsParameters, vendorParameters) {
    wmsParameters = this._getWMS130Parameters(wmsParameters);
    const { boundingBox, bbox } = wmsParameters;
    wmsParameters.bbox = boundingBox ? [...boundingBox[0], ...boundingBox[1]] : bbox;
    const options = {
      version: this.wmsParameters.version,
      // query_layers: [],
      // format: this.wmsParameters.format,
      info_format: this.wmsParameters.info_format,
      layers: this.wmsParameters.layers,
      query_layers: this.wmsParameters.query_layers,
      styles: this.wmsParameters.styles,
      crs: this.wmsParameters.crs,
      // bbox: [-77.87304, 40.78975, -77.85828, 40.80228],
      // width: 1200,
      // height: 900,
      // x: undefined!,
      // y: undefined!,
      ...wmsParameters
    };
    return this._getWMSUrl("GetFeatureInfo", options, vendorParameters);
  }
  /** Generate a URL for the GetFeatureInfo request */
  describeLayerURL(wmsParameters, vendorParameters) {
    const options = {
      version: this.wmsParameters.version,
      ...wmsParameters
    };
    return this._getWMSUrl("DescribeLayer", options, vendorParameters);
  }
  getLegendGraphicURL(wmsParameters, vendorParameters) {
    const options = {
      version: this.wmsParameters.version,
      // format?
      ...wmsParameters
    };
    return this._getWMSUrl("GetLegendGraphic", options, vendorParameters);
  }
  // INTERNAL METHODS
  _parseWMSUrl(url) {
    const [baseUrl, search] = url.split("?");
    const searchParams = search.split("&");
    const parameters2 = {};
    for (const parameter of searchParams) {
      const [key, value] = parameter.split("=");
      parameters2[key] = value;
    }
    return { url: baseUrl, parameters: parameters2 };
  }
  /**
   * Generate a URL with parameters
   * @note case _getWMSUrl may need to be overridden to handle certain backends?
   * @note at the moment, only URLs with parameters are supported (no XML payloads)
   * */
  _getWMSUrl(request, wmsParameters, vendorParameters) {
    let url = this.url;
    let first = true;
    const allParameters = {
      service: "WMS",
      version: wmsParameters.version,
      request,
      ...wmsParameters,
      ...this.vendorParameters,
      ...vendorParameters
    };
    const IGNORE_EMPTY_KEYS = ["transparent", "time", "elevation"];
    for (const [key, value] of Object.entries(allParameters)) {
      if (!IGNORE_EMPTY_KEYS.includes(key) || value) {
        url += first ? "?" : "&";
        first = false;
        url += this._getURLParameter(key, value, wmsParameters);
      }
    }
    return encodeURI(url);
  }
  _getWMS130Parameters(wmsParameters) {
    const newParameters = { ...wmsParameters };
    if (newParameters.srs) {
      newParameters.crs = newParameters.crs || newParameters.srs;
      delete newParameters.srs;
    }
    return newParameters;
  }
  // eslint-disable-next-line complexity
  _getURLParameter(key, value, wmsParameters) {
    switch (key) {
      case "crs":
        if (wmsParameters.version !== "1.3.0") {
          key = "srs";
        } else if (this.substituteCRS84 && value === "EPSG:4326") {
          value = "CRS:84";
        }
        break;
      case "srs":
        if (wmsParameters.version === "1.3.0") {
          key = "crs";
        }
        break;
      case "bbox":
        const bbox = this._flipBoundingBox(value, wmsParameters);
        if (bbox) {
          value = bbox;
        }
        break;
      case "x":
        if (wmsParameters.version === "1.3.0") {
          key = "i";
        }
        break;
      case "y":
        if (wmsParameters.version === "1.3.0") {
          key = "j";
        }
        break;
      default:
    }
    key = key.toUpperCase();
    return Array.isArray(value) ? `${key}=${value.join(",")}` : `${key}=${value ? String(value) : ""}`;
  }
  /** Coordinate order is flipped for certain CRS in WMS 1.3.0 */
  _flipBoundingBox(bboxValue, wmsParameters) {
    if (!Array.isArray(bboxValue) || bboxValue.length !== 4) {
      return null;
    }
    const flipCoordinates = (
      // Only affects WMS 1.3.0
      wmsParameters.version === "1.3.0" && // Flip if we are dealing with a CRS that was flipped in 1.3.0
      this.flipCRS.includes(wmsParameters.crs || "") && // Don't flip if we are substituting EPSG:4326 with CRS:84
      !(this.substituteCRS84 && wmsParameters.crs === "EPSG:4326")
    );
    const bbox = bboxValue;
    return flipCoordinates ? [bbox[1], bbox[0], bbox[3], bbox[2]] : bbox;
  }
  /** Fetches an array buffer and checks the response (boilerplate reduction) */
  async _fetchArrayBuffer(url) {
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this._checkResponse(response, arrayBuffer);
    return arrayBuffer;
  }
  /** Checks for and parses a WMS XML formatted ServiceError and throws an exception */
  _checkResponse(response, arrayBuffer) {
    var _a, _b;
    const contentType = response.headers["content-type"];
    if (!response.ok || WMSErrorLoader.mimeTypes.includes(contentType)) {
      const loadOptions = mergeLoaderOptions(this.loadOptions, {
        wms: { throwOnError: true }
      });
      const error = (_b = (_a = WMSErrorLoader).parseSync) == null ? void 0 : _b.call(_a, arrayBuffer, loadOptions);
      throw new Error(error);
    }
  }
  /** Error situation detected */
  _parseError(arrayBuffer) {
    var _a, _b;
    const error = (_b = (_a = WMSErrorLoader).parseSync) == null ? void 0 : _b.call(_a, arrayBuffer, this.loadOptions);
    return new Error(error);
  }
};

// node_modules/@loaders.gl/wms/dist/services/arcgis/arcgis-image-server.js
var ArcGISImageServerSource = {
  name: "ArcGISImageServer",
  id: "arcgis-image-server",
  module: "wms",
  version: "0.0.0",
  extensions: [],
  mimeTypes: [],
  options: {
    "arcgis-image-server": {
      // TODO - add options here
    }
  },
  type: "arcgis-image-server",
  fromUrl: true,
  fromBlob: false,
  testURL: (url) => url.toLowerCase().includes("ImageServer"),
  createDataSource: (url, props) => new ArcGISImageSource(url, props)
};
var ArcGISImageSource = class extends ImageSource {
  constructor(url, props) {
    super(props);
    __publicField(this, "url");
    __publicField(this, "data");
    this.url = url;
    this.data = url;
  }
  // ImageSource (normalized endpoints)
  async getMetadata() {
    return await this.metadata();
  }
  async getImage(parameters2) {
    throw new Error("not implemented");
  }
  // ImageServer endpoints
  async metadata() {
    throw new Error("not implemented");
  }
  /**
   * Form a URL to an ESRI ImageServer
   // https://sampleserver6.arcgisonline.com/arcgis/rest/services/NLCDLandCover2001/ImageServer/exportImage?bbox=${bounds[0]},${bounds[1]},${bounds[2]},${bounds[3]}&bboxSR=4326&size=${width},${height}&imageSR=102100&time=&format=jpgpng&pixelType=U8&noData=&noDataInterpretation=esriNoDataMatchAny&interpolation=+RSP_NearestNeighbor&compression=&compressionQuality=&bandIds=&mosaicRule=&renderingRule=&f=image`,
   */
  exportImage(options) {
    throw new Error("not implemented");
  }
  // URL creators
  metadataURL(options) {
    return `${this.url}?f=pjson`;
  }
  /**
   * Form a URL to an ESRI ImageServer
   // https://sampleserver6.arcgisonline.com/arcgis/rest/services/NLCDLandCover2001/ImageServer/exportImage?
   //   bbox=${bounds[0]},${bounds[1]},${bounds[2]},${bounds[3]}&bboxSR=4326&
   //   size=${width},${height}&imageSR=102100&time=&format=jpgpng&pixelType=U8&
   //   noData=&noDataInterpretation=esriNoDataMatchAny&interpolation=+RSP_NearestNeighbor&compression=&
   //   compressionQuality=&bandIds=&mosaicRule=&renderingRule=&
   //   f=image
   */
  exportImageURL(options) {
    const bbox = `bbox=${options.bbox[0]},${options.bbox[1]},${options.bbox[2]},${options.bbox[3]}`;
    const size = `size=${options.width},${options.height}`;
    const arcgisOptions = { ...options, bbox, size };
    delete arcgisOptions.width;
    delete arcgisOptions.height;
    return this.getUrl("exportImage", arcgisOptions);
  }
  // INTERNAL METHODS
  /**
   * @note protected, since perhaps getWMSUrl may need to be overridden to handle certain backends?
   * @note if override is common, maybe add a callback prop?
   * */
  getUrl(path, options, extra) {
    let url = `${this.url}/${path}`;
    let first = true;
    for (const [key, value] of Object.entries(options)) {
      url += first ? "?" : "&";
      first = false;
      if (Array.isArray(value)) {
        url += `${key.toUpperCase()}=${value.join(",")}`;
      } else {
        url += `${key.toUpperCase()}=${value ? String(value) : ""}`;
      }
    }
    return url;
  }
  /** Checks for and parses a WMS XML formatted ServiceError and throws an exception */
  async checkResponse(response) {
    if (!response.ok) {
      throw new Error("error");
    }
  }
};

// node_modules/@loaders.gl/wms/dist/lib/deprecated/create-image-source.js
var SOURCES = [WMSSource, ArcGISImageServerSource];
function createImageSource(props, sources = SOURCES) {
  const { type = "auto" } = props;
  const source = type === "auto" ? guessSourceType(props.url, sources) : getSourceOfType(type, sources);
  if (!source) {
    throw new Error("Not a valid image source type");
  }
  return source.createDataSource(props.url, props);
}
function getSourceOfType(type, sources) {
  for (const source of sources) {
    if (source.type === type) {
      return source;
    }
  }
  return null;
}
function guessSourceType(url, sources) {
  for (const source of sources) {
    if (source.testURL && source.testURL(url)) {
      return source;
    }
  }
  return null;
}

// node_modules/@deck.gl/geo-layers/dist/wms-layer/utils.js
var HALF_EARTH_CIRCUMFERENCE = 6378137 * Math.PI;
function WGS84ToPseudoMercator(coord) {
  const mercator = lngLatToWorld(coord);
  mercator[0] = (mercator[0] / 256 - 1) * HALF_EARTH_CIRCUMFERENCE;
  mercator[1] = (mercator[1] / 256 - 1) * HALF_EARTH_CIRCUMFERENCE;
  return mercator;
}

// node_modules/@deck.gl/geo-layers/dist/wms-layer/wms-layer.js
var defaultProps18 = {
  id: "imagery-layer",
  data: "",
  serviceType: "auto",
  srs: "auto",
  layers: { type: "array", compare: true, value: [] },
  onMetadataLoad: { type: "function", value: () => {
  } },
  // eslint-disable-next-line
  onMetadataLoadError: { type: "function", value: console.error },
  onImageLoadStart: { type: "function", value: () => {
  } },
  onImageLoad: { type: "function", value: () => {
  } },
  onImageLoadError: {
    type: "function",
    compare: false,
    // eslint-disable-next-line
    value: (requestId, error) => console.error(error, requestId)
  }
};
var WMSLayer = class extends composite_layer_default {
  /** Returns true if all async resources are loaded */
  get isLoaded() {
    var _a;
    return ((_a = this.state) == null ? void 0 : _a.loadCounter) === 0 && super.isLoaded;
  }
  /** Lets deck.gl know that we want viewport change events */
  shouldUpdateState() {
    return true;
  }
  initializeState() {
    this.state._nextRequestId = 0;
    this.state.lastRequestId = -1;
    this.state.loadCounter = 0;
  }
  updateState({ changeFlags, props, oldProps }) {
    const { viewport } = this.context;
    if (changeFlags.dataChanged || props.serviceType !== oldProps.serviceType) {
      this.state.imageSource = this._createImageSource(props);
      this._loadMetadata();
      this.debounce(() => this.loadImage(viewport, "image source changed"), 0);
    } else if (!deepEqual(props.layers, oldProps.layers, 1)) {
      this.debounce(() => this.loadImage(viewport, "layers changed"), 0);
    } else if (changeFlags.viewportChanged) {
      this.debounce(() => this.loadImage(viewport, "viewport changed"));
    }
  }
  finalizeState() {
  }
  renderLayers() {
    const { bounds, image, lastRequestParameters } = this.state;
    return image && new bitmap_layer_default({
      ...this.getSubLayerProps({ id: "bitmap" }),
      _imageCoordinateSystem: lastRequestParameters.srs === "EPSG:4326" ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN,
      bounds,
      image
    });
  }
  async getFeatureInfoText(x, y) {
    var _a, _b;
    const { lastRequestParameters } = this.state;
    if (lastRequestParameters) {
      const featureInfo = await ((_b = (_a = this.state.imageSource).getFeatureInfoText) == null ? void 0 : _b.call(_a, {
        ...lastRequestParameters,
        query_layers: lastRequestParameters.layers,
        x,
        y,
        info_format: "application/vnd.ogc.gml"
      }));
      return featureInfo;
    }
    return "";
  }
  _createImageSource(props) {
    if (props.data instanceof ImageSource) {
      return props.data;
    }
    if (typeof props.data === "string") {
      return createImageSource({
        url: props.data,
        loadOptions: props.loadOptions,
        type: props.serviceType
      });
    }
    throw new Error("invalid image source in props.data");
  }
  /** Run a getMetadata on the image service */
  async _loadMetadata() {
    var _a, _b;
    const { imageSource } = this.state;
    try {
      this.state.loadCounter++;
      const metadata = await imageSource.getMetadata();
      if (this.state.imageSource === imageSource) {
        (_a = this.getCurrentLayer()) == null ? void 0 : _a.props.onMetadataLoad(metadata);
      }
    } catch (error) {
      (_b = this.getCurrentLayer()) == null ? void 0 : _b.props.onMetadataLoadError(error);
    } finally {
      this.state.loadCounter--;
    }
  }
  /** Load an image */
  async loadImage(viewport, reason) {
    var _a, _b;
    const { layers, serviceType } = this.props;
    if (serviceType === "wms" && layers.length === 0) {
      return;
    }
    const bounds = viewport.getBounds();
    const { width, height } = viewport;
    const requestId = this.getRequestId();
    let { srs } = this.props;
    if (srs === "auto") {
      srs = viewport.resolution ? "EPSG:4326" : "EPSG:3857";
    }
    const requestParams = {
      width,
      height,
      boundingBox: [
        [bounds[0], bounds[1]],
        [bounds[2], bounds[3]]
      ],
      layers,
      crs: srs
    };
    if (srs === "EPSG:3857") {
      const min3 = WGS84ToPseudoMercator([bounds[0], bounds[1]]);
      const max3 = WGS84ToPseudoMercator([bounds[2], bounds[3]]);
      requestParams.boundingBox = [min3, max3];
    }
    try {
      this.state.loadCounter++;
      this.props.onImageLoadStart(requestId);
      const image = await this.state.imageSource.getImage(requestParams);
      if (this.state.lastRequestId < requestId) {
        (_a = this.getCurrentLayer()) == null ? void 0 : _a.props.onImageLoad(requestId);
        this.setState({
          image,
          bounds,
          lastRequestParameters: requestParams,
          lastRequestId: requestId
        });
      }
    } catch (error) {
      this.raiseError(error, "Load image");
      (_b = this.getCurrentLayer()) == null ? void 0 : _b.props.onImageLoadError(requestId, error);
    } finally {
      this.state.loadCounter--;
    }
  }
  // HELPERS
  /** Global counter for issuing unique request ids */
  getRequestId() {
    return this.state._nextRequestId++;
  }
  /** Runs an action in the future, cancels it if the new action is issued before it executes */
  debounce(fn, ms = 500) {
    clearTimeout(this.state._timeoutId);
    this.state._timeoutId = setTimeout(() => fn(), ms);
  }
};
WMSLayer.layerName = "WMSLayer";
WMSLayer.defaultProps = defaultProps18;

// node_modules/@deck.gl/geo-layers/dist/great-circle-layer/great-circle-layer.js
var defaultProps19 = {
  getHeight: { type: "accessor", value: 0 },
  greatCircle: true
};
var GreatCircleLayer = class extends arc_layer_default {
};
GreatCircleLayer.layerName = "GreatCircleLayer";
GreatCircleLayer.defaultProps = defaultProps19;
var great_circle_layer_default = GreatCircleLayer;

// node_modules/@deck.gl/geo-layers/dist/s2-layer/s2-geometry.js
var import_long = __toESM(require_long(), 1);
var FACE_BITS = 3;
var MAX_LEVEL = 30;
var POS_BITS = 2 * MAX_LEVEL + 1;
var RADIAN_TO_DEGREE = 180 / Math.PI;
function IJToST(ij, order, offsets) {
  const maxSize = 1 << order;
  return [(ij[0] + offsets[0]) / maxSize, (ij[1] + offsets[1]) / maxSize];
}
function singleSTtoUV(st) {
  if (st >= 0.5) {
    return 1 / 3 * (4 * st * st - 1);
  }
  return 1 / 3 * (1 - 4 * (1 - st) * (1 - st));
}
function STToUV(st) {
  return [singleSTtoUV(st[0]), singleSTtoUV(st[1])];
}
function FaceUVToXYZ(face, [u2, v2]) {
  switch (face) {
    case 0:
      return [1, u2, v2];
    case 1:
      return [-u2, 1, v2];
    case 2:
      return [-u2, -v2, 1];
    case 3:
      return [-1, -v2, -u2];
    case 4:
      return [v2, -1, -u2];
    case 5:
      return [v2, u2, -1];
    default:
      throw new Error("Invalid face");
  }
}
function XYZToLngLat([x, y, z]) {
  const lat = Math.atan2(z, Math.sqrt(x * x + y * y));
  const lng = Math.atan2(y, x);
  return [lng * RADIAN_TO_DEGREE, lat * RADIAN_TO_DEGREE];
}
function toHilbertQuadkey(idS) {
  let bin = import_long.default.fromString(idS, true, 10).toString(2);
  while (bin.length < FACE_BITS + POS_BITS) {
    bin = "0" + bin;
  }
  const lsbIndex = bin.lastIndexOf("1");
  const faceB = bin.substring(0, 3);
  const posB = bin.substring(3, lsbIndex);
  const levelN = posB.length / 2;
  const faceS = import_long.default.fromString(faceB, true, 2).toString(10);
  let posS = import_long.default.fromString(posB, true, 2).toString(4);
  while (posS.length < levelN) {
    posS = "0" + posS;
  }
  return `${faceS}/${posS}`;
}
function rotateAndFlipQuadrant(n, point2, rx, ry) {
  if (ry === 0) {
    if (rx === 1) {
      point2[0] = n - 1 - point2[0];
      point2[1] = n - 1 - point2[1];
    }
    const x = point2[0];
    point2[0] = point2[1];
    point2[1] = x;
  }
}
function FromHilbertQuadKey(hilbertQuadkey) {
  const parts = hilbertQuadkey.split("/");
  const face = parseInt(parts[0], 10);
  const position = parts[1];
  const maxLevel = position.length;
  const point2 = [0, 0];
  let level;
  for (let i = maxLevel - 1; i >= 0; i--) {
    level = maxLevel - i;
    const bit = position[i];
    let rx = 0;
    let ry = 0;
    if (bit === "1") {
      ry = 1;
    } else if (bit === "2") {
      rx = 1;
      ry = 1;
    } else if (bit === "3") {
      rx = 1;
    }
    const val = Math.pow(2, level - 1);
    rotateAndFlipQuadrant(val, point2, rx, ry);
    point2[0] += val * rx;
    point2[1] += val * ry;
  }
  if (face % 2 === 1) {
    const t = point2[0];
    point2[0] = point2[1];
    point2[1] = t;
  }
  return { face, ij: point2, level };
}

// node_modules/@deck.gl/geo-layers/dist/s2-layer/s2-utils.js
var import_long2 = __toESM(require_long(), 1);
function getIdFromToken(token) {
  const paddedToken = token.padEnd(16, "0");
  return import_long2.default.fromString(paddedToken, 16);
}
var MAX_RESOLUTION2 = 100;
function getGeoBounds({ face, ij, level }) {
  const offsets = [
    [0, 0],
    [0, 1],
    [1, 1],
    [1, 0],
    [0, 0]
  ];
  const resolution = Math.max(1, Math.ceil(MAX_RESOLUTION2 * Math.pow(2, -level)));
  const result = new Float64Array(4 * resolution * 2 + 2);
  let ptIndex = 0;
  let prevLng = 0;
  for (let i = 0; i < 4; i++) {
    const offset = offsets[i].slice(0);
    const nextOffset = offsets[i + 1];
    const stepI = (nextOffset[0] - offset[0]) / resolution;
    const stepJ = (nextOffset[1] - offset[1]) / resolution;
    for (let j = 0; j < resolution; j++) {
      offset[0] += stepI;
      offset[1] += stepJ;
      const st = IJToST(ij, level, offset);
      const uv = STToUV(st);
      const xyz = FaceUVToXYZ(face, uv);
      const lngLat = XYZToLngLat(xyz);
      if (Math.abs(lngLat[1]) > 89.999) {
        lngLat[0] = prevLng;
      }
      const deltaLng = lngLat[0] - prevLng;
      lngLat[0] += deltaLng > 180 ? -360 : deltaLng < -180 ? 360 : 0;
      result[ptIndex++] = lngLat[0];
      result[ptIndex++] = lngLat[1];
      prevLng = lngLat[0];
    }
  }
  result[ptIndex++] = result[0];
  result[ptIndex++] = result[1];
  return result;
}
function getS2QuadKey(token) {
  if (typeof token === "string") {
    if (token.indexOf("/") > 0) {
      return token;
    }
    token = getIdFromToken(token);
  }
  return toHilbertQuadkey(token.toString());
}
function getS2Polygon(token) {
  const key = getS2QuadKey(token);
  const s2cell = FromHilbertQuadKey(key);
  return getGeoBounds(s2cell);
}

// node_modules/@deck.gl/geo-layers/dist/s2-layer/s2-layer.js
var defaultProps20 = {
  getS2Token: { type: "accessor", value: (d2) => d2.token }
};
var S2Layer = class extends GeoCellLayer_default {
  indexToBounds() {
    const { data, getS2Token } = this.props;
    return {
      data,
      _normalize: false,
      positionFormat: "XY",
      getPolygon: (x, objectInfo) => getS2Polygon(getS2Token(x, objectInfo))
    };
  }
};
S2Layer.layerName = "S2Layer";
S2Layer.defaultProps = defaultProps20;
var s2_layer_default = S2Layer;

// node_modules/@deck.gl/geo-layers/dist/quadkey-layer/quadkey-utils.js
var TILE_SIZE = 512;
function quadkeyToWorldBounds(quadkey, coverage) {
  let x = 0;
  let y = 0;
  let mask = 1 << quadkey.length;
  const scale7 = mask / TILE_SIZE;
  for (let i = 0; i < quadkey.length; i++) {
    mask >>= 1;
    const q = parseInt(quadkey[i]);
    if (q % 2)
      x |= mask;
    if (q > 1)
      y |= mask;
  }
  return [
    [x / scale7, TILE_SIZE - y / scale7],
    [(x + coverage) / scale7, TILE_SIZE - (y + coverage) / scale7]
  ];
}
function getQuadkeyPolygon(quadkey, coverage = 1) {
  const [topLeft, bottomRight] = quadkeyToWorldBounds(quadkey, coverage);
  const [w2, n] = worldToLngLat(topLeft);
  const [e2, s] = worldToLngLat(bottomRight);
  return [e2, n, e2, s, w2, s, w2, n, e2, n];
}

// node_modules/@deck.gl/geo-layers/dist/quadkey-layer/quadkey-layer.js
var defaultProps21 = {
  getQuadkey: { type: "accessor", value: (d2) => d2.quadkey }
};
var QuadkeyLayer = class extends GeoCellLayer_default {
  indexToBounds() {
    const { data, extruded, getQuadkey } = this.props;
    const coverage = extruded ? 0.99 : 1;
    return {
      data,
      _normalize: false,
      positionFormat: "XY",
      getPolygon: (x, objectInfo) => getQuadkeyPolygon(getQuadkey(x, objectInfo), coverage),
      updateTriggers: { getPolygon: coverage }
    };
  }
};
QuadkeyLayer.layerName = "QuadkeyLayer";
QuadkeyLayer.defaultProps = defaultProps21;
var quadkey_layer_default = QuadkeyLayer;

// node_modules/@deck.gl/geo-layers/dist/tileset-2d/tile-2d-header.js
var Tile2DHeader = class {
  constructor(index) {
    this.index = index;
    this.isVisible = false;
    this.isSelected = false;
    this.parent = null;
    this.children = [];
    this.content = null;
    this._loader = void 0;
    this._abortController = null;
    this._loaderId = 0;
    this._isLoaded = false;
    this._isCancelled = false;
    this._needsReload = false;
  }
  /** @deprecated use `boundingBox` instead */
  get bbox() {
    return this._bbox;
  }
  // TODO - remove in v9
  set bbox(value) {
    if (this._bbox)
      return;
    this._bbox = value;
    if ("west" in value) {
      this.boundingBox = [
        [value.west, value.south],
        [value.east, value.north]
      ];
    } else {
      this.boundingBox = [
        [value.left, value.top],
        [value.right, value.bottom]
      ];
    }
  }
  get data() {
    return this.isLoading && this._loader ? this._loader.then(() => this.data) : this.content;
  }
  get isLoaded() {
    return this._isLoaded && !this._needsReload;
  }
  get isLoading() {
    return Boolean(this._loader) && !this._isCancelled;
  }
  get needsReload() {
    return this._needsReload || this._isCancelled;
  }
  get byteLength() {
    const result = this.content ? this.content.byteLength : 0;
    if (!Number.isFinite(result)) {
      console.error("byteLength not defined in tile data");
    }
    return result;
  }
  /* eslint-disable max-statements */
  async _loadData({ getData, requestScheduler, onLoad, onError }) {
    const { index, id, bbox, userData, zoom } = this;
    const loaderId = this._loaderId;
    this._abortController = new AbortController();
    const { signal } = this._abortController;
    const requestToken = await requestScheduler.scheduleRequest(this, (tile) => {
      return tile.isSelected ? 1 : -1;
    });
    if (!requestToken) {
      this._isCancelled = true;
      return;
    }
    if (this._isCancelled) {
      requestToken.done();
      return;
    }
    let tileData = null;
    let error;
    try {
      tileData = await getData({ index, id, bbox, userData, zoom, signal });
    } catch (err) {
      error = err || true;
    } finally {
      requestToken.done();
    }
    if (loaderId !== this._loaderId) {
      return;
    }
    this._loader = void 0;
    this.content = tileData;
    if (this._isCancelled && !tileData) {
      this._isLoaded = false;
      return;
    }
    this._isLoaded = true;
    this._isCancelled = false;
    if (error) {
      onError(error, this);
    } else {
      onLoad(this);
    }
  }
  loadData(opts) {
    this._isLoaded = false;
    this._isCancelled = false;
    this._needsReload = false;
    this._loaderId++;
    this._loader = this._loadData(opts);
    return this._loader;
  }
  setNeedsReload() {
    if (this.isLoading) {
      this.abort();
      this._loader = void 0;
    }
    this._needsReload = true;
  }
  abort() {
    var _a;
    if (this.isLoaded) {
      return;
    }
    this._isCancelled = true;
    (_a = this._abortController) == null ? void 0 : _a.abort();
  }
};

// node_modules/@deck.gl/geo-layers/dist/tileset-2d/tile-2d-traversal.js
var TILE_SIZE2 = 512;
var MAX_MAPS = 3;
var REF_POINTS_5 = [
  [0.5, 0.5],
  [0, 0],
  [0, 1],
  [1, 0],
  [1, 1]
];
var REF_POINTS_9 = REF_POINTS_5.concat([
  [0, 0.5],
  [0.5, 0],
  [1, 0.5],
  [0.5, 1]
]);
var REF_POINTS_11 = REF_POINTS_9.concat([
  [0.25, 0.5],
  [0.75, 0.5]
]);
var OSMNode = class _OSMNode {
  constructor(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  get children() {
    if (!this._children) {
      const x = this.x * 2;
      const y = this.y * 2;
      const z = this.z + 1;
      this._children = [
        new _OSMNode(x, y, z),
        new _OSMNode(x, y + 1, z),
        new _OSMNode(x + 1, y, z),
        new _OSMNode(x + 1, y + 1, z)
      ];
    }
    return this._children;
  }
  // eslint-disable-next-line complexity
  update(params) {
    const { viewport, cullingVolume, elevationBounds, minZ, maxZ, bounds, offset, project } = params;
    const boundingVolume = this.getBoundingVolume(elevationBounds, offset, project);
    if (bounds && !this.insideBounds(bounds)) {
      return false;
    }
    const isInside = cullingVolume.computeVisibility(boundingVolume);
    if (isInside < 0) {
      return false;
    }
    if (!this.childVisible) {
      let { z } = this;
      if (z < maxZ && z >= minZ) {
        const distance3 = boundingVolume.distanceTo(viewport.cameraPosition) * viewport.scale / viewport.height;
        z += Math.floor(Math.log2(distance3));
      }
      if (z >= maxZ) {
        this.selected = true;
        return true;
      }
    }
    this.selected = false;
    this.childVisible = true;
    for (const child of this.children) {
      child.update(params);
    }
    return true;
  }
  getSelected(result = []) {
    if (this.selected) {
      result.push(this);
    }
    if (this._children) {
      for (const node of this._children) {
        node.getSelected(result);
      }
    }
    return result;
  }
  insideBounds([minX, minY, maxX, maxY]) {
    const scale7 = Math.pow(2, this.z);
    const extent = TILE_SIZE2 / scale7;
    return this.x * extent < maxX && this.y * extent < maxY && (this.x + 1) * extent > minX && (this.y + 1) * extent > minY;
  }
  getBoundingVolume(zRange, worldOffset, project) {
    if (project) {
      const refPoints = this.z < 1 ? REF_POINTS_11 : this.z < 2 ? REF_POINTS_9 : REF_POINTS_5;
      const refPointPositions = [];
      for (const p of refPoints) {
        const lngLat = osmTile2lngLat(this.x + p[0], this.y + p[1], this.z);
        lngLat[2] = zRange[0];
        refPointPositions.push(project(lngLat));
        if (zRange[0] !== zRange[1]) {
          lngLat[2] = zRange[1];
          refPointPositions.push(project(lngLat));
        }
      }
      return makeOrientedBoundingBoxFromPoints(refPointPositions);
    }
    const scale7 = Math.pow(2, this.z);
    const extent = TILE_SIZE2 / scale7;
    const originX = this.x * extent + worldOffset * TILE_SIZE2;
    const originY = TILE_SIZE2 - (this.y + 1) * extent;
    return new AxisAlignedBoundingBox([originX, originY, zRange[0]], [originX + extent, originY + extent, zRange[1]]);
  }
};
function getOSMTileIndices(viewport, maxZ, zRange, bounds) {
  const project = viewport instanceof GlobeViewport && viewport.resolution ? (
    // eslint-disable-next-line @typescript-eslint/unbound-method
    viewport.projectPosition
  ) : null;
  const planes = Object.values(viewport.getFrustumPlanes()).map(({ normal, distance: distance3 }) => new Plane(normal.clone().negate(), distance3));
  const cullingVolume = new CullingVolume(planes);
  const unitsPerMeter = viewport.distanceScales.unitsPerMeter[2];
  const elevationMin = zRange && zRange[0] * unitsPerMeter || 0;
  const elevationMax = zRange && zRange[1] * unitsPerMeter || 0;
  const minZ = viewport instanceof web_mercator_viewport_default && viewport.pitch <= 60 ? maxZ : 0;
  if (bounds) {
    const [minLng, minLat, maxLng, maxLat] = bounds;
    const topLeft = lngLatToWorld([minLng, maxLat]);
    const bottomRight = lngLatToWorld([maxLng, minLat]);
    bounds = [topLeft[0], TILE_SIZE2 - topLeft[1], bottomRight[0], TILE_SIZE2 - bottomRight[1]];
  }
  const root = new OSMNode(0, 0, 0);
  const traversalParams = {
    viewport,
    project,
    cullingVolume,
    elevationBounds: [elevationMin, elevationMax],
    minZ,
    maxZ,
    bounds,
    // num. of worlds from the center. For repeated maps
    offset: 0
  };
  root.update(traversalParams);
  if (viewport instanceof web_mercator_viewport_default && viewport.subViewports && viewport.subViewports.length > 1) {
    traversalParams.offset = -1;
    while (root.update(traversalParams)) {
      if (--traversalParams.offset < -MAX_MAPS) {
        break;
      }
    }
    traversalParams.offset = 1;
    while (root.update(traversalParams)) {
      if (++traversalParams.offset > MAX_MAPS) {
        break;
      }
    }
  }
  return root.getSelected();
}

// node_modules/@deck.gl/geo-layers/dist/tileset-2d/utils.js
var TILE_SIZE3 = 512;
var DEFAULT_EXTENT = [-Infinity, -Infinity, Infinity, Infinity];
var urlType = {
  type: "object",
  value: null,
  validate: (value, propType) => propType.optional && value === null || typeof value === "string" || Array.isArray(value) && value.every((url) => typeof url === "string"),
  equal: (value1, value2) => {
    if (value1 === value2) {
      return true;
    }
    if (!Array.isArray(value1) || !Array.isArray(value2)) {
      return false;
    }
    const len4 = value1.length;
    if (len4 !== value2.length) {
      return false;
    }
    for (let i = 0; i < len4; i++) {
      if (value1[i] !== value2[i]) {
        return false;
      }
    }
    return true;
  }
};
function transformBox(bbox, modelMatrix2) {
  const transformedCoords = [
    // top-left
    modelMatrix2.transformAsPoint([bbox[0], bbox[1]]),
    // top-right
    modelMatrix2.transformAsPoint([bbox[2], bbox[1]]),
    // bottom-left
    modelMatrix2.transformAsPoint([bbox[0], bbox[3]]),
    // bottom-right
    modelMatrix2.transformAsPoint([bbox[2], bbox[3]])
  ];
  const transformedBox = [
    // Minimum x coord
    Math.min(...transformedCoords.map((i) => i[0])),
    // Minimum y coord
    Math.min(...transformedCoords.map((i) => i[1])),
    // Max x coord
    Math.max(...transformedCoords.map((i) => i[0])),
    // Max y coord
    Math.max(...transformedCoords.map((i) => i[1]))
  ];
  return transformedBox;
}
function stringHash(s) {
  return Math.abs(s.split("").reduce((a2, b2) => (a2 << 5) - a2 + b2.charCodeAt(0) | 0, 0));
}
function getURLFromTemplate(template, tile) {
  if (!template || !template.length) {
    return null;
  }
  const { index, id } = tile;
  if (Array.isArray(template)) {
    const i = stringHash(id) % template.length;
    template = template[i];
  }
  let url = template;
  for (const key of Object.keys(index)) {
    const regex = new RegExp(`{${key}}`, "g");
    url = url.replace(regex, String(index[key]));
  }
  if (Number.isInteger(index.y) && Number.isInteger(index.z)) {
    url = url.replace(/\{-y\}/g, String(Math.pow(2, index.z) - index.y - 1));
  }
  return url;
}
function getBoundingBox2(viewport, zRange, extent) {
  let bounds;
  if (zRange && zRange.length === 2) {
    const [minZ, maxZ] = zRange;
    const bounds0 = viewport.getBounds({ z: minZ });
    const bounds1 = viewport.getBounds({ z: maxZ });
    bounds = [
      Math.min(bounds0[0], bounds1[0]),
      Math.min(bounds0[1], bounds1[1]),
      Math.max(bounds0[2], bounds1[2]),
      Math.max(bounds0[3], bounds1[3])
    ];
  } else {
    bounds = viewport.getBounds();
  }
  if (!viewport.isGeospatial) {
    return [
      // Top corner should not be more then bottom corner in either direction
      Math.max(Math.min(bounds[0], extent[2]), extent[0]),
      Math.max(Math.min(bounds[1], extent[3]), extent[1]),
      // Bottom corner should not be less then top corner in either direction
      Math.min(Math.max(bounds[2], extent[0]), extent[2]),
      Math.min(Math.max(bounds[3], extent[1]), extent[3])
    ];
  }
  return [
    Math.max(bounds[0], extent[0]),
    Math.max(bounds[1], extent[1]),
    Math.min(bounds[2], extent[2]),
    Math.min(bounds[3], extent[3])
  ];
}
function getCullBounds({ viewport, z, cullRect }) {
  const subViewports = viewport.subViewports || [viewport];
  return subViewports.map((v2) => getCullBoundsInViewport(v2, z || 0, cullRect));
}
function getCullBoundsInViewport(viewport, z, cullRect) {
  if (!Array.isArray(z)) {
    const x = cullRect.x - viewport.x;
    const y = cullRect.y - viewport.y;
    const { width, height } = cullRect;
    const unprojectOption = { targetZ: z };
    const topLeft = viewport.unproject([x, y], unprojectOption);
    const topRight = viewport.unproject([x + width, y], unprojectOption);
    const bottomLeft = viewport.unproject([x, y + height], unprojectOption);
    const bottomRight = viewport.unproject([x + width, y + height], unprojectOption);
    return [
      Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),
      Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]),
      Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),
      Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])
    ];
  }
  const bounds0 = getCullBoundsInViewport(viewport, z[0], cullRect);
  const bounds1 = getCullBoundsInViewport(viewport, z[1], cullRect);
  return [
    Math.min(bounds0[0], bounds1[0]),
    Math.min(bounds0[1], bounds1[1]),
    Math.max(bounds0[2], bounds1[2]),
    Math.max(bounds0[3], bounds1[3])
  ];
}
function getIndexingCoords(bbox, scale7, modelMatrixInverse) {
  if (modelMatrixInverse) {
    const transformedTileIndex = transformBox(bbox, modelMatrixInverse).map((i) => i * scale7 / TILE_SIZE3);
    return transformedTileIndex;
  }
  return bbox.map((i) => i * scale7 / TILE_SIZE3);
}
function getScale(z, tileSize) {
  return Math.pow(2, z) * TILE_SIZE3 / tileSize;
}
function osmTile2lngLat(x, y, z) {
  const scale7 = getScale(z, TILE_SIZE3);
  const lng = x / scale7 * 360 - 180;
  const n = Math.PI - 2 * Math.PI * y / scale7;
  const lat = 180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
  return [lng, lat];
}
function tile2XY(x, y, z, tileSize) {
  const scale7 = getScale(z, tileSize);
  return [x / scale7 * TILE_SIZE3, y / scale7 * TILE_SIZE3];
}
function tileToBoundingBox(viewport, x, y, z, tileSize = TILE_SIZE3) {
  if (viewport.isGeospatial) {
    const [west, north] = osmTile2lngLat(x, y, z);
    const [east, south] = osmTile2lngLat(x + 1, y + 1, z);
    return { west, north, east, south };
  }
  const [left, top] = tile2XY(x, y, z, tileSize);
  const [right, bottom] = tile2XY(x + 1, y + 1, z, tileSize);
  return { left, top, right, bottom };
}
function getIdentityTileIndices(viewport, z, tileSize, extent, modelMatrixInverse) {
  const bbox = getBoundingBox2(viewport, null, extent);
  const scale7 = getScale(z, tileSize);
  const [minX, minY, maxX, maxY] = getIndexingCoords(bbox, scale7, modelMatrixInverse);
  const indices = [];
  for (let x = Math.floor(minX); x < maxX; x++) {
    for (let y = Math.floor(minY); y < maxY; y++) {
      indices.push({ x, y, z });
    }
  }
  return indices;
}
function getTileIndices({ viewport, maxZoom, minZoom, zRange, extent, tileSize = TILE_SIZE3, modelMatrix: modelMatrix2, modelMatrixInverse, zoomOffset = 0 }) {
  let z = viewport.isGeospatial ? Math.round(viewport.zoom + Math.log2(TILE_SIZE3 / tileSize)) + zoomOffset : Math.ceil(viewport.zoom) + zoomOffset;
  if (typeof minZoom === "number" && Number.isFinite(minZoom) && z < minZoom) {
    if (!extent) {
      return [];
    }
    z = minZoom;
  }
  if (typeof maxZoom === "number" && Number.isFinite(maxZoom) && z > maxZoom) {
    z = maxZoom;
  }
  let transformedExtent = extent;
  if (modelMatrix2 && modelMatrixInverse && extent && !viewport.isGeospatial) {
    transformedExtent = transformBox(extent, modelMatrix2);
  }
  return viewport.isGeospatial ? getOSMTileIndices(viewport, z, zRange, extent) : getIdentityTileIndices(viewport, z, tileSize, transformedExtent || DEFAULT_EXTENT, modelMatrixInverse);
}
function isURLTemplate(s) {
  return /(?=.*{z})(?=.*{x})(?=.*({y}|{-y}))/.test(s);
}
function isGeoBoundingBox(v2) {
  return Number.isFinite(v2.west) && Number.isFinite(v2.north) && Number.isFinite(v2.east) && Number.isFinite(v2.south);
}

// node_modules/@deck.gl/geo-layers/dist/tileset-2d/memoize.js
function memoize2(compute) {
  let cachedArgs = {};
  let cachedResult;
  return (args) => {
    for (const key in args) {
      if (!isEqual(args[key], cachedArgs[key])) {
        cachedResult = compute(args);
        cachedArgs = args;
        break;
      }
    }
    return cachedResult;
  };
}
function isEqual(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (Array.isArray(a2)) {
    const len4 = a2.length;
    if (!b2 || b2.length !== len4) {
      return false;
    }
    for (let i = 0; i < len4; i++) {
      if (a2[i] !== b2[i]) {
        return false;
      }
    }
    return true;
  }
  return false;
}

// node_modules/@deck.gl/geo-layers/dist/tileset-2d/tileset-2d.js
var TILE_STATE_VISITED = 1;
var TILE_STATE_VISIBLE = 2;
var STRATEGY_NEVER = "never";
var STRATEGY_REPLACE = "no-overlap";
var STRATEGY_DEFAULT = "best-available";
var DEFAULT_CACHE_SCALE = 5;
var STRATEGIES = {
  [STRATEGY_DEFAULT]: updateTileStateDefault,
  [STRATEGY_REPLACE]: updateTileStateReplace,
  [STRATEGY_NEVER]: () => {
  }
};
var DEFAULT_TILESET2D_PROPS = {
  extent: null,
  tileSize: 512,
  maxZoom: null,
  minZoom: null,
  maxCacheSize: null,
  maxCacheByteSize: null,
  refinementStrategy: "best-available",
  zRange: null,
  maxRequests: 6,
  debounceTime: 0,
  zoomOffset: 0,
  // onTileLoad: (tile: Tile2DHeader) => void,  // onTileUnload: (tile: Tile2DHeader) => void,  // onTileError: (error: any, tile: Tile2DHeader) => void,  /** Called when all tiles in the current viewport are loaded. */
  // onViewportLoad: ((tiles: Tile2DHeader<DataT>[]) => void) | null,
  onTileLoad: () => {
  },
  onTileUnload: () => {
  },
  onTileError: () => {
  }
};
var Tileset2D = class {
  /**
   * Takes in a function that returns tile data, a cache size, and a max and a min zoom level.
   * Cache size defaults to 5 * number of tiles in the current viewport
   */
  constructor(opts) {
    this._getCullBounds = memoize2(getCullBounds);
    this.opts = { ...DEFAULT_TILESET2D_PROPS, ...opts };
    this.setOptions(this.opts);
    this.onTileLoad = (tile) => {
      var _a, _b;
      (_b = (_a = this.opts).onTileLoad) == null ? void 0 : _b.call(_a, tile);
      if (this.opts.maxCacheByteSize !== null) {
        this._cacheByteSize += tile.byteLength;
        this._resizeCache();
      }
    };
    this._requestScheduler = new RequestScheduler({
      throttleRequests: this.opts.maxRequests > 0 || this.opts.debounceTime > 0,
      maxRequests: this.opts.maxRequests,
      debounceTime: this.opts.debounceTime
    });
    this._cache = /* @__PURE__ */ new Map();
    this._tiles = [];
    this._dirty = false;
    this._cacheByteSize = 0;
    this._viewport = null;
    this._zRange = null;
    this._selectedTiles = null;
    this._frameNumber = 0;
    this._modelMatrix = new Matrix4();
    this._modelMatrixInverse = new Matrix4();
  }
  /* Public API */
  get tiles() {
    return this._tiles;
  }
  get selectedTiles() {
    return this._selectedTiles;
  }
  get isLoaded() {
    return this._selectedTiles !== null && this._selectedTiles.every((tile) => tile.isLoaded);
  }
  get needsReload() {
    return this._selectedTiles !== null && this._selectedTiles.some((tile) => tile.needsReload);
  }
  setOptions(opts) {
    Object.assign(this.opts, opts);
    if (Number.isFinite(opts.maxZoom)) {
      this._maxZoom = Math.floor(opts.maxZoom);
    }
    if (Number.isFinite(opts.minZoom)) {
      this._minZoom = Math.ceil(opts.minZoom);
    }
  }
  // Clean up any outstanding tile requests.
  finalize() {
    for (const tile of this._cache.values()) {
      if (tile.isLoading) {
        tile.abort();
      }
    }
    this._cache.clear();
    this._tiles = [];
    this._selectedTiles = null;
  }
  reloadAll() {
    for (const id of this._cache.keys()) {
      const tile = this._cache.get(id);
      if (!this._selectedTiles || !this._selectedTiles.includes(tile)) {
        this._cache.delete(id);
      } else {
        tile.setNeedsReload();
      }
    }
  }
  /**
   * Update the cache with the given viewport and model matrix and triggers callback onUpdate.
   */
  update(viewport, { zRange, modelMatrix: modelMatrix2 } = {
    zRange: null,
    modelMatrix: null
  }) {
    const modelMatrixAsMatrix4 = modelMatrix2 ? new Matrix4(modelMatrix2) : new Matrix4();
    const isModelMatrixNew = !modelMatrixAsMatrix4.equals(this._modelMatrix);
    if (!this._viewport || !viewport.equals(this._viewport) || !equals(this._zRange, zRange) || isModelMatrixNew) {
      if (isModelMatrixNew) {
        this._modelMatrixInverse = modelMatrixAsMatrix4.clone().invert();
        this._modelMatrix = modelMatrixAsMatrix4;
      }
      this._viewport = viewport;
      this._zRange = zRange;
      const tileIndices = this.getTileIndices({
        viewport,
        maxZoom: this._maxZoom,
        minZoom: this._minZoom,
        zRange,
        modelMatrix: this._modelMatrix,
        modelMatrixInverse: this._modelMatrixInverse
      });
      this._selectedTiles = tileIndices.map((index) => this._getTile(index, true));
      if (this._dirty) {
        this._rebuildTree();
      }
    } else if (this.needsReload) {
      this._selectedTiles = this._selectedTiles.map((tile) => this._getTile(tile.index, true));
    }
    const changed = this.updateTileStates();
    this._pruneRequests();
    if (this._dirty) {
      this._resizeCache();
    }
    if (changed) {
      this._frameNumber++;
    }
    return this._frameNumber;
  }
  // eslint-disable-next-line complexity
  isTileVisible(tile, cullRect, modelMatrix2) {
    if (!tile.isVisible) {
      return false;
    }
    if (cullRect && this._viewport) {
      const boundsArr = this._getCullBounds({
        viewport: this._viewport,
        z: this._zRange,
        cullRect
      });
      let { bbox } = tile;
      for (const [minX, minY, maxX, maxY] of boundsArr) {
        let overlaps;
        if ("west" in bbox) {
          overlaps = bbox.west < maxX && bbox.east > minX && bbox.south < maxY && bbox.north > minY;
        } else {
          if (modelMatrix2 && !Matrix4.IDENTITY.equals(modelMatrix2)) {
            const [left, top, right, bottom] = transformBox([bbox.left, bbox.top, bbox.right, bbox.bottom], modelMatrix2);
            bbox = { left, top, right, bottom };
          }
          const y0 = Math.min(bbox.top, bbox.bottom);
          const y1 = Math.max(bbox.top, bbox.bottom);
          overlaps = bbox.left < maxX && bbox.right > minX && y0 < maxY && y1 > minY;
        }
        if (overlaps) {
          return true;
        }
      }
      return false;
    }
    return true;
  }
  /* Public interface for subclassing */
  /** Returns array of tile indices in the current viewport */
  getTileIndices({ viewport, maxZoom, minZoom, zRange, modelMatrix: modelMatrix2, modelMatrixInverse }) {
    const { tileSize, extent, zoomOffset } = this.opts;
    return getTileIndices({
      viewport,
      maxZoom,
      minZoom,
      zRange,
      tileSize,
      extent,
      modelMatrix: modelMatrix2,
      modelMatrixInverse,
      zoomOffset
    });
  }
  /** Returns unique string key for a tile index */
  getTileId(index) {
    return `${index.x}-${index.y}-${index.z}`;
  }
  /** Returns a zoom level for a tile index */
  getTileZoom(index) {
    return index.z;
  }
  /** Returns additional metadata to add to tile, bbox by default */
  getTileMetadata(index) {
    const { tileSize } = this.opts;
    return { bbox: tileToBoundingBox(this._viewport, index.x, index.y, index.z, tileSize) };
  }
  /** Returns index of the parent tile */
  getParentIndex(index) {
    const x = Math.floor(index.x / 2);
    const y = Math.floor(index.y / 2);
    const z = index.z - 1;
    return { x, y, z };
  }
  // Returns true if any tile's visibility changed
  updateTileStates() {
    const refinementStrategy = this.opts.refinementStrategy || STRATEGY_DEFAULT;
    const visibilities = new Array(this._cache.size);
    let i = 0;
    for (const tile of this._cache.values()) {
      visibilities[i++] = tile.isVisible;
      tile.isSelected = false;
      tile.isVisible = false;
    }
    for (const tile of this._selectedTiles) {
      tile.isSelected = true;
      tile.isVisible = true;
    }
    (typeof refinementStrategy === "function" ? refinementStrategy : STRATEGIES[refinementStrategy])(Array.from(this._cache.values()));
    i = 0;
    for (const tile of this._cache.values()) {
      if (visibilities[i++] !== tile.isVisible) {
        return true;
      }
    }
    return false;
  }
  _pruneRequests() {
    const { maxRequests = 0 } = this.opts;
    const abortCandidates = [];
    let ongoingRequestCount = 0;
    for (const tile of this._cache.values()) {
      if (tile.isLoading) {
        ongoingRequestCount++;
        if (!tile.isSelected && !tile.isVisible) {
          abortCandidates.push(tile);
        }
      }
    }
    while (maxRequests > 0 && ongoingRequestCount > maxRequests && abortCandidates.length > 0) {
      const tile = abortCandidates.shift();
      tile.abort();
      ongoingRequestCount--;
    }
  }
  // This needs to be called every time some tiles have been added/removed from cache
  _rebuildTree() {
    const { _cache } = this;
    for (const tile of _cache.values()) {
      tile.parent = null;
      if (tile.children) {
        tile.children.length = 0;
      }
    }
    for (const tile of _cache.values()) {
      const parent = this._getNearestAncestor(tile);
      tile.parent = parent;
      if (parent == null ? void 0 : parent.children) {
        parent.children.push(tile);
      }
    }
  }
  /**
   * Clear tiles that are not visible when the cache is full
   */
  /* eslint-disable complexity */
  _resizeCache() {
    var _a, _b;
    const { _cache, opts } = this;
    const maxCacheSize = opts.maxCacheSize ?? // @ts-expect-error called only when selectedTiles is initialized
    (opts.maxCacheByteSize !== null ? Infinity : DEFAULT_CACHE_SCALE * this.selectedTiles.length);
    const maxCacheByteSize = opts.maxCacheByteSize ?? Infinity;
    const overflown = _cache.size > maxCacheSize || this._cacheByteSize > maxCacheByteSize;
    if (overflown) {
      for (const [id, tile] of _cache) {
        if (!tile.isVisible && !tile.isSelected) {
          this._cacheByteSize -= opts.maxCacheByteSize !== null ? tile.byteLength : 0;
          _cache.delete(id);
          (_b = (_a = this.opts).onTileUnload) == null ? void 0 : _b.call(_a, tile);
        }
        if (_cache.size <= maxCacheSize && this._cacheByteSize <= maxCacheByteSize) {
          break;
        }
      }
      this._rebuildTree();
      this._dirty = true;
    }
    if (this._dirty) {
      this._tiles = Array.from(this._cache.values()).sort((t1, t2) => t1.zoom - t2.zoom);
      this._dirty = false;
    }
  }
  _getTile(index, create7) {
    const id = this.getTileId(index);
    let tile = this._cache.get(id);
    let needsReload = false;
    if (!tile && create7) {
      tile = new Tile2DHeader(index);
      Object.assign(tile, this.getTileMetadata(tile.index));
      Object.assign(tile, { id, zoom: this.getTileZoom(tile.index) });
      needsReload = true;
      this._cache.set(id, tile);
      this._dirty = true;
    } else if (tile && tile.needsReload) {
      needsReload = true;
    }
    if (tile && needsReload) {
      tile.loadData({
        getData: this.opts.getTileData,
        requestScheduler: this._requestScheduler,
        onLoad: this.onTileLoad,
        onError: this.opts.onTileError
      });
    }
    return tile;
  }
  _getNearestAncestor(tile) {
    const { _minZoom = 0 } = this;
    let index = tile.index;
    while (this.getTileZoom(index) > _minZoom) {
      index = this.getParentIndex(index);
      const parent = this._getTile(index);
      if (parent) {
        return parent;
      }
    }
    return null;
  }
};
function updateTileStateDefault(allTiles) {
  for (const tile of allTiles) {
    tile.state = 0;
  }
  for (const tile of allTiles) {
    if (tile.isSelected && !getPlaceholderInAncestors(tile)) {
      getPlaceholderInChildren(tile);
    }
  }
  for (const tile of allTiles) {
    tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);
  }
}
function updateTileStateReplace(allTiles) {
  for (const tile of allTiles) {
    tile.state = 0;
  }
  for (const tile of allTiles) {
    if (tile.isSelected) {
      getPlaceholderInAncestors(tile);
    }
  }
  const sortedTiles = Array.from(allTiles).sort((t1, t2) => t1.zoom - t2.zoom);
  for (const tile of sortedTiles) {
    tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);
    if (tile.children && (tile.isVisible || tile.state & TILE_STATE_VISITED)) {
      for (const child of tile.children) {
        child.state = TILE_STATE_VISITED;
      }
    } else if (tile.isSelected) {
      getPlaceholderInChildren(tile);
    }
  }
}
function getPlaceholderInAncestors(startTile) {
  let tile = startTile;
  while (tile) {
    if (tile.isLoaded || tile.content) {
      tile.state |= TILE_STATE_VISIBLE;
      return true;
    }
    tile = tile.parent;
  }
  return false;
}
function getPlaceholderInChildren(tile) {
  for (const child of tile.children) {
    if (child.isLoaded || child.content) {
      child.state |= TILE_STATE_VISIBLE;
    } else {
      getPlaceholderInChildren(child);
    }
  }
}

// node_modules/@deck.gl/geo-layers/dist/tile-layer/tile-layer.js
var defaultProps22 = {
  TilesetClass: Tileset2D,
  data: { type: "data", value: [] },
  dataComparator: urlType.equal,
  renderSubLayers: { type: "function", value: (props) => new geojson_layer_default(props) },
  getTileData: { type: "function", optional: true, value: null },
  // TODO - change to onViewportLoad to align with Tile3DLayer
  onViewportLoad: { type: "function", optional: true, value: null },
  onTileLoad: { type: "function", value: (tile) => {
  } },
  onTileUnload: { type: "function", value: (tile) => {
  } },
  // eslint-disable-next-line
  onTileError: { type: "function", value: (err) => console.error(err) },
  extent: { type: "array", optional: true, value: null, compare: true },
  tileSize: 512,
  maxZoom: null,
  minZoom: 0,
  maxCacheSize: null,
  maxCacheByteSize: null,
  refinementStrategy: STRATEGY_DEFAULT,
  zRange: null,
  maxRequests: 6,
  debounceTime: 0,
  zoomOffset: 0
};
var TileLayer = class extends composite_layer_default {
  initializeState() {
    this.state = {
      tileset: null,
      isLoaded: false
    };
  }
  finalizeState() {
    var _a, _b;
    (_b = (_a = this.state) == null ? void 0 : _a.tileset) == null ? void 0 : _b.finalize();
  }
  get isLoaded() {
    var _a, _b, _c;
    return Boolean((_c = (_b = (_a = this.state) == null ? void 0 : _a.tileset) == null ? void 0 : _b.selectedTiles) == null ? void 0 : _c.every((tile) => tile.isLoaded && tile.layers && tile.layers.every((layer) => layer.isLoaded)));
  }
  shouldUpdateState({ changeFlags }) {
    return changeFlags.somethingChanged;
  }
  updateState({ changeFlags }) {
    let { tileset } = this.state;
    const propsChanged = changeFlags.propsOrDataChanged || changeFlags.updateTriggersChanged;
    const dataChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getTileData);
    if (!tileset) {
      tileset = new this.props.TilesetClass(this._getTilesetOptions());
      this.setState({ tileset });
    } else if (propsChanged) {
      tileset.setOptions(this._getTilesetOptions());
      if (dataChanged) {
        tileset.reloadAll();
      } else {
        tileset.tiles.forEach((tile) => {
          tile.layers = null;
        });
      }
    }
    this._updateTileset();
  }
  _getTilesetOptions() {
    const { tileSize, maxCacheSize, maxCacheByteSize, refinementStrategy, extent, maxZoom, minZoom, maxRequests, debounceTime, zoomOffset } = this.props;
    return {
      maxCacheSize,
      maxCacheByteSize,
      maxZoom,
      minZoom,
      tileSize,
      refinementStrategy,
      extent,
      maxRequests,
      debounceTime,
      zoomOffset,
      getTileData: this.getTileData.bind(this),
      onTileLoad: this._onTileLoad.bind(this),
      onTileError: this._onTileError.bind(this),
      onTileUnload: this._onTileUnload.bind(this)
    };
  }
  _updateTileset() {
    const tileset = this.state.tileset;
    const { zRange, modelMatrix: modelMatrix2 } = this.props;
    const frameNumber = tileset.update(this.context.viewport, { zRange, modelMatrix: modelMatrix2 });
    const { isLoaded } = tileset;
    const loadingStateChanged = this.state.isLoaded !== isLoaded;
    const tilesetChanged = this.state.frameNumber !== frameNumber;
    if (isLoaded && (loadingStateChanged || tilesetChanged)) {
      this._onViewportLoad();
    }
    if (tilesetChanged) {
      this.setState({ frameNumber });
    }
    this.state.isLoaded = isLoaded;
  }
  _onViewportLoad() {
    const { tileset } = this.state;
    const { onViewportLoad } = this.props;
    if (onViewportLoad) {
      onViewportLoad(tileset.selectedTiles);
    }
  }
  _onTileLoad(tile) {
    this.props.onTileLoad(tile);
    tile.layers = null;
    this.setNeedsUpdate();
  }
  _onTileError(error, tile) {
    this.props.onTileError(error);
    tile.layers = null;
    this.setNeedsUpdate();
  }
  _onTileUnload(tile) {
    this.props.onTileUnload(tile);
  }
  // Methods for subclass to override
  getTileData(tile) {
    const { data, getTileData, fetch: fetch2 } = this.props;
    const { signal } = tile;
    tile.url = typeof data === "string" || Array.isArray(data) ? getURLFromTemplate(data, tile) : null;
    if (getTileData) {
      return getTileData(tile);
    }
    if (fetch2 && tile.url) {
      return fetch2(tile.url, { propName: "data", layer: this, signal });
    }
    return null;
  }
  renderSubLayers(props) {
    return this.props.renderSubLayers(props);
  }
  getSubLayerPropsByTile(tile) {
    return null;
  }
  getPickingInfo(params) {
    const sourceLayer = params.sourceLayer;
    const sourceTile = sourceLayer.props.tile;
    const info = params.info;
    if (info.picked) {
      info.tile = sourceTile;
    }
    info.sourceTile = sourceTile;
    info.sourceTileSubLayer = sourceLayer;
    return info;
  }
  _updateAutoHighlight(info) {
    info.sourceTileSubLayer.updateAutoHighlight(info);
  }
  renderLayers() {
    return this.state.tileset.tiles.map((tile) => {
      const subLayerProps = this.getSubLayerPropsByTile(tile);
      if (!tile.isLoaded && !tile.content) {
      } else if (!tile.layers) {
        const layers = this.renderSubLayers({
          ...this.props,
          ...this.getSubLayerProps({
            id: tile.id,
            updateTriggers: this.props.updateTriggers
          }),
          data: tile.content,
          _offset: 0,
          tile
        });
        tile.layers = flatten(layers, Boolean).map((layer) => layer.clone({
          tile,
          ...subLayerProps
        }));
      } else if (subLayerProps && tile.layers[0] && Object.keys(subLayerProps).some((propName) => tile.layers[0].props[propName] !== subLayerProps[propName])) {
        tile.layers = tile.layers.map((layer) => layer.clone(subLayerProps));
      }
      return tile.layers;
    });
  }
  filterSubLayer({ layer, cullRect }) {
    const { tile } = layer.props;
    const { modelMatrix: modelMatrix2 } = this.props;
    return this.state.tileset.isTileVisible(tile, cullRect, modelMatrix2 ? new Matrix4(modelMatrix2) : null);
  }
};
TileLayer.defaultProps = defaultProps22;
TileLayer.layerName = "TileLayer";
var tile_layer_default = TileLayer;

// node_modules/@deck.gl/geo-layers/dist/trips-layer/trips-layer-uniforms.js
var uniformBlock9 = `uniform tripsUniforms {
  bool fadeTrail;
  float trailLength;
  float currentTime;
} trips;
`;
var tripsUniforms = {
  name: "trips",
  vs: uniformBlock9,
  fs: uniformBlock9,
  uniformTypes: {
    fadeTrail: "f32",
    trailLength: "f32",
    currentTime: "f32"
  }
};

// node_modules/@deck.gl/geo-layers/dist/trips-layer/trips-layer.js
var defaultProps23 = {
  fadeTrail: true,
  trailLength: { type: "number", value: 120, min: 0 },
  currentTime: { type: "number", value: 0, min: 0 },
  getTimestamps: { type: "accessor", value: (d2) => d2.timestamps }
};
var TripsLayer = class extends path_layer_default {
  getShaders() {
    const shaders = super.getShaders();
    shaders.inject = {
      "vs:#decl": `in float instanceTimestamps;
in float instanceNextTimestamps;
out float vTime;
`,
      // Timestamp of the vertex
      "vs:#main-end": `vTime = instanceTimestamps + (instanceNextTimestamps - instanceTimestamps) * vPathPosition.y / vPathLength;
`,
      "fs:#decl": `in float vTime;
`,
      // Drop the segments outside of the time window
      "fs:#main-start": `if(vTime > trips.currentTime || (trips.fadeTrail && (vTime < trips.currentTime - trips.trailLength))) {
  discard;
}
`,
      // Fade the color (currentTime - 100%, end of trail - 0%)
      "fs:DECKGL_FILTER_COLOR": `if(trips.fadeTrail) {
  color.a *= 1.0 - (trips.currentTime - vTime) / trips.trailLength;
}
`
    };
    shaders.modules = [...shaders.modules, tripsUniforms];
    return shaders;
  }
  initializeState() {
    super.initializeState();
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      timestamps: {
        size: 1,
        accessor: "getTimestamps",
        shaderAttributes: {
          instanceTimestamps: {
            vertexOffset: 0
          },
          instanceNextTimestamps: {
            vertexOffset: 1
          }
        }
      }
    });
  }
  draw(params) {
    const { fadeTrail, trailLength, currentTime } = this.props;
    const tripsProps = { fadeTrail, trailLength, currentTime };
    const model = this.state.model;
    model.shaderInputs.setProps({ trips: tripsProps });
    super.draw(params);
  }
};
TripsLayer.layerName = "TripsLayer";
TripsLayer.defaultProps = defaultProps23;
var trips_layer_default = TripsLayer;

// node_modules/@deck.gl/geo-layers/dist/h3-layers/h3-hexagon-layer.js
var UPDATE_THRESHOLD_KM = 10;
function mergeTriggers(getHexagon, coverage) {
  let trigger;
  if (getHexagon === void 0 || getHexagon === null) {
    trigger = coverage;
  } else if (typeof getHexagon === "object") {
    trigger = { ...getHexagon, coverage };
  } else {
    trigger = { getHexagon, coverage };
  }
  return trigger;
}
var defaultProps24 = {
  ...polygon_layer_default.defaultProps,
  highPrecision: "auto",
  coverage: { type: "number", min: 0, max: 1, value: 1 },
  centerHexagon: null,
  getHexagon: { type: "accessor", value: (x) => x.hexagon },
  extruded: true
};
var H3HexagonLayer = class _H3HexagonLayer extends composite_layer_default {
  initializeState() {
    _H3HexagonLayer._checkH3Lib();
    this.state = {
      edgeLengthKM: 0,
      resolution: -1
    };
  }
  shouldUpdateState({ changeFlags }) {
    return this._shouldUseHighPrecision() ? changeFlags.propsOrDataChanged : changeFlags.somethingChanged;
  }
  updateState({ props, changeFlags }) {
    if (props.highPrecision !== true && (changeFlags.dataChanged || changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getHexagon)) {
      const dataProps = this._calculateH3DataProps();
      this.setState(dataProps);
    }
    this._updateVertices(this.context.viewport);
  }
  _calculateH3DataProps() {
    let resolution = -1;
    let hasPentagon = false;
    let hasMultipleRes = false;
    const { iterable, objectInfo } = createIterable(this.props.data);
    for (const object of iterable) {
      objectInfo.index++;
      const hexId = this.props.getHexagon(object, objectInfo);
      const hexResolution = getResolution2(hexId);
      if (resolution < 0) {
        resolution = hexResolution;
        if (!this.props.highPrecision)
          break;
      } else if (resolution !== hexResolution) {
        hasMultipleRes = true;
        break;
      }
      if (isPentagon(hexId)) {
        hasPentagon = true;
        break;
      }
    }
    return {
      resolution,
      edgeLengthKM: resolution >= 0 ? getHexagonEdgeLengthAvg(resolution, "km") : 0,
      hasMultipleRes,
      hasPentagon
    };
  }
  _shouldUseHighPrecision() {
    if (this.props.highPrecision === "auto") {
      const { resolution, hasPentagon, hasMultipleRes } = this.state;
      const { viewport } = this.context;
      return Boolean(viewport == null ? void 0 : viewport.resolution) || hasMultipleRes || hasPentagon || resolution >= 0 && resolution <= 5;
    }
    return this.props.highPrecision;
  }
  _updateVertices(viewport) {
    if (this._shouldUseHighPrecision()) {
      return;
    }
    const { resolution, edgeLengthKM, centerHex } = this.state;
    if (resolution < 0) {
      return;
    }
    const hex = this.props.centerHexagon || latLngToCell(viewport.latitude, viewport.longitude, resolution);
    if (centerHex === hex) {
      return;
    }
    if (centerHex) {
      try {
        const distance3 = gridDistance(centerHex, hex);
        if (distance3 * edgeLengthKM < UPDATE_THRESHOLD_KM) {
          return;
        }
      } catch {
      }
    }
    const { unitsPerMeter } = viewport.distanceScales;
    let vertices = h3ToPolygon(hex);
    const [centerLat, centerLng] = cellToLatLng(hex);
    const [centerX, centerY] = viewport.projectFlat([centerLng, centerLat]);
    vertices = vertices.map((p) => {
      const worldPosition = viewport.projectFlat(p);
      return [
        (worldPosition[0] - centerX) / unitsPerMeter[0],
        (worldPosition[1] - centerY) / unitsPerMeter[1]
      ];
    });
    this.setState({ centerHex: hex, vertices });
  }
  renderLayers() {
    return this._shouldUseHighPrecision() ? this._renderPolygonLayer() : this._renderColumnLayer();
  }
  _getForwardProps() {
    const { elevationScale, material, coverage, extruded, wireframe, stroked, filled, lineWidthUnits, lineWidthScale, lineWidthMinPixels, lineWidthMaxPixels, getFillColor, getElevation, getLineColor, getLineWidth, transitions, updateTriggers } = this.props;
    return {
      elevationScale,
      extruded,
      coverage,
      wireframe,
      stroked,
      filled,
      lineWidthUnits,
      lineWidthScale,
      lineWidthMinPixels,
      lineWidthMaxPixels,
      material,
      getElevation,
      getFillColor,
      getLineColor,
      getLineWidth,
      transitions,
      updateTriggers: {
        getFillColor: updateTriggers.getFillColor,
        getElevation: updateTriggers.getElevation,
        getLineColor: updateTriggers.getLineColor,
        getLineWidth: updateTriggers.getLineWidth
      }
    };
  }
  _renderPolygonLayer() {
    const { data, getHexagon, updateTriggers, coverage } = this.props;
    const SubLayerClass = this.getSubLayerClass("hexagon-cell-hifi", polygon_layer_default);
    const forwardProps2 = this._getForwardProps();
    forwardProps2.updateTriggers.getPolygon = mergeTriggers(updateTriggers.getHexagon, coverage);
    return new SubLayerClass(forwardProps2, this.getSubLayerProps({
      id: "hexagon-cell-hifi",
      updateTriggers: forwardProps2.updateTriggers
    }), {
      data,
      _normalize: false,
      _windingOrder: "CCW",
      positionFormat: "XY",
      getPolygon: (object, objectInfo) => {
        const hexagonId = getHexagon(object, objectInfo);
        return flattenPolygon(h3ToPolygon(hexagonId, coverage));
      }
    });
  }
  _renderColumnLayer() {
    const { data, getHexagon, updateTriggers } = this.props;
    const SubLayerClass = this.getSubLayerClass("hexagon-cell", column_layer_default);
    const forwardProps2 = this._getForwardProps();
    forwardProps2.updateTriggers.getPosition = updateTriggers.getHexagon;
    return new SubLayerClass(forwardProps2, this.getSubLayerProps({
      id: "hexagon-cell",
      flatShading: true,
      updateTriggers: forwardProps2.updateTriggers
    }), {
      data,
      diskResolution: 6,
      // generate an extruded hexagon as the base geometry
      radius: 1,
      vertices: this.state.vertices,
      getPosition: getHexagonCentroid.bind(null, getHexagon)
    });
  }
};
H3HexagonLayer.defaultProps = defaultProps24;
H3HexagonLayer.layerName = "H3HexagonLayer";
H3HexagonLayer._checkH3Lib = () => {
};
var h3_hexagon_layer_default = H3HexagonLayer;

// node_modules/@deck.gl/geo-layers/dist/h3-layers/h3-cluster-layer.js
var defaultProps25 = {
  getHexagons: { type: "accessor", value: (d2) => d2.hexagons }
};
var H3ClusterLayer = class extends GeoCellLayer_default {
  initializeState() {
    h3_hexagon_layer_default._checkH3Lib();
  }
  updateState({ props, changeFlags }) {
    if (changeFlags.dataChanged || changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getHexagons) {
      const { data, getHexagons } = props;
      const polygons = [];
      const { iterable, objectInfo } = createIterable(data);
      for (const object of iterable) {
        objectInfo.index++;
        const hexagons = getHexagons(object, objectInfo);
        const multiPolygon = cellsToMultiPolygon(hexagons, true);
        for (const polygon of multiPolygon) {
          for (const ring of polygon) {
            normalizeLongitudes2(ring);
          }
          polygons.push(this.getSubLayerRow({ polygon }, object, objectInfo.index));
        }
      }
      this.setState({ polygons });
    }
  }
  indexToBounds() {
    const { getElevation, getFillColor, getLineColor, getLineWidth } = this.props;
    return {
      data: this.state.polygons,
      getPolygon: (d2) => d2.polygon,
      getElevation: this.getSubLayerAccessor(getElevation),
      getFillColor: this.getSubLayerAccessor(getFillColor),
      getLineColor: this.getSubLayerAccessor(getLineColor),
      getLineWidth: this.getSubLayerAccessor(getLineWidth)
    };
  }
};
H3ClusterLayer.layerName = "H3ClusterLayer";
H3ClusterLayer.defaultProps = defaultProps25;
var h3_cluster_layer_default = H3ClusterLayer;

// node_modules/@deck.gl/mesh-layers/dist/utils/matrix.js
var RADIAN_PER_DEGREE = Math.PI / 180;
var modelMatrix = new Float32Array(16);
var valueArray = new Float32Array(12);
function calculateTransformMatrix(targetMatrix, orientation, scale7) {
  const pitch = orientation[0] * RADIAN_PER_DEGREE;
  const yaw = orientation[1] * RADIAN_PER_DEGREE;
  const roll = orientation[2] * RADIAN_PER_DEGREE;
  const sr = Math.sin(roll);
  const sp = Math.sin(pitch);
  const sw = Math.sin(yaw);
  const cr = Math.cos(roll);
  const cp = Math.cos(pitch);
  const cw = Math.cos(yaw);
  const scx = scale7[0];
  const scy = scale7[1];
  const scz = scale7[2];
  targetMatrix[0] = scx * cw * cp;
  targetMatrix[1] = scx * sw * cp;
  targetMatrix[2] = scx * -sp;
  targetMatrix[3] = scy * (-sw * cr + cw * sp * sr);
  targetMatrix[4] = scy * (cw * cr + sw * sp * sr);
  targetMatrix[5] = scy * cp * sr;
  targetMatrix[6] = scz * (sw * sr + cw * sp * cr);
  targetMatrix[7] = scz * (-cw * sr + sw * sp * cr);
  targetMatrix[8] = scz * cp * cr;
}
function getExtendedMat3FromMat4(mat4) {
  mat4[0] = mat4[0];
  mat4[1] = mat4[1];
  mat4[2] = mat4[2];
  mat4[3] = mat4[4];
  mat4[4] = mat4[5];
  mat4[5] = mat4[6];
  mat4[6] = mat4[8];
  mat4[7] = mat4[9];
  mat4[8] = mat4[10];
  mat4[9] = mat4[12];
  mat4[10] = mat4[13];
  mat4[11] = mat4[14];
  return mat4.subarray(0, 12);
}
var MATRIX_ATTRIBUTES = {
  size: 12,
  accessor: ["getOrientation", "getScale", "getTranslation", "getTransformMatrix"],
  shaderAttributes: {
    instanceModelMatrixCol0: {
      size: 3,
      elementOffset: 0
    },
    instanceModelMatrixCol1: {
      size: 3,
      elementOffset: 3
    },
    instanceModelMatrixCol2: {
      size: 3,
      elementOffset: 6
    },
    instanceTranslation: {
      size: 3,
      elementOffset: 9
    }
  },
  update(attribute, { startRow, endRow }) {
    const { data, getOrientation, getScale: getScale2, getTranslation, getTransformMatrix } = this.props;
    const arrayMatrix = Array.isArray(getTransformMatrix);
    const constantMatrix = arrayMatrix && getTransformMatrix.length === 16;
    const constantScale = Array.isArray(getScale2);
    const constantOrientation = Array.isArray(getOrientation);
    const constantTranslation = Array.isArray(getTranslation);
    const hasMatrix = constantMatrix || !arrayMatrix && Boolean(getTransformMatrix(data[0]));
    if (hasMatrix) {
      attribute.constant = constantMatrix;
    } else {
      attribute.constant = constantOrientation && constantScale && constantTranslation;
    }
    const instanceModelMatrixData = attribute.value;
    if (attribute.constant) {
      let matrix;
      if (hasMatrix) {
        modelMatrix.set(getTransformMatrix);
        matrix = getExtendedMat3FromMat4(modelMatrix);
      } else {
        matrix = valueArray;
        const orientation = getOrientation;
        const scale7 = getScale2;
        calculateTransformMatrix(matrix, orientation, scale7);
        matrix.set(getTranslation, 9);
      }
      attribute.value = new Float32Array(matrix);
    } else {
      let i = startRow * attribute.size;
      const { iterable, objectInfo } = createIterable(data, startRow, endRow);
      for (const object of iterable) {
        objectInfo.index++;
        let matrix;
        if (hasMatrix) {
          modelMatrix.set(constantMatrix ? getTransformMatrix : getTransformMatrix(object, objectInfo));
          matrix = getExtendedMat3FromMat4(modelMatrix);
        } else {
          matrix = valueArray;
          const orientation = constantOrientation ? getOrientation : getOrientation(object, objectInfo);
          const scale7 = constantScale ? getScale2 : getScale2(object, objectInfo);
          calculateTransformMatrix(matrix, orientation, scale7);
          matrix.set(constantTranslation ? getTranslation : getTranslation(object, objectInfo), 9);
        }
        instanceModelMatrixData[i++] = matrix[0];
        instanceModelMatrixData[i++] = matrix[1];
        instanceModelMatrixData[i++] = matrix[2];
        instanceModelMatrixData[i++] = matrix[3];
        instanceModelMatrixData[i++] = matrix[4];
        instanceModelMatrixData[i++] = matrix[5];
        instanceModelMatrixData[i++] = matrix[6];
        instanceModelMatrixData[i++] = matrix[7];
        instanceModelMatrixData[i++] = matrix[8];
        instanceModelMatrixData[i++] = matrix[9];
        instanceModelMatrixData[i++] = matrix[10];
        instanceModelMatrixData[i++] = matrix[11];
      }
    }
  }
};
function shouldComposeModelMatrix(viewport, coordinateSystem) {
  return coordinateSystem === COORDINATE_SYSTEM.CARTESIAN || coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS || coordinateSystem === COORDINATE_SYSTEM.DEFAULT && !viewport.isGeospatial;
}

// node_modules/@deck.gl/mesh-layers/dist/simple-mesh-layer/simple-mesh-layer-uniforms.js
var uniformBlock10 = `uniform simpleMeshUniforms {
  float sizeScale;
  bool composeModelMatrix;
  bool hasTexture;
  bool flatShading;
} simpleMesh;
`;
var simpleMeshUniforms = {
  name: "simpleMesh",
  vs: uniformBlock10,
  fs: uniformBlock10,
  uniformTypes: {
    sizeScale: "f32",
    composeModelMatrix: "f32",
    hasTexture: "f32",
    flatShading: "f32"
  }
};

// node_modules/@deck.gl/mesh-layers/dist/simple-mesh-layer/simple-mesh-layer-vertex.glsl.js
var simple_mesh_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME simple-mesh-layer-vs
in vec3 positions;
in vec3 normals;
in vec3 colors;
in vec2 texCoords;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec3 instanceModelMatrixCol0;
in vec3 instanceModelMatrixCol1;
in vec3 instanceModelMatrixCol2;
in vec3 instanceTranslation;
out vec2 vTexCoord;
out vec3 cameraPosition;
out vec3 normals_commonspace;
out vec4 position_commonspace;
out vec4 vColor;
void main(void) {
geometry.worldPosition = instancePositions;
geometry.uv = texCoords;
geometry.pickingColor = instancePickingColors;
vTexCoord = texCoords;
cameraPosition = project.cameraPosition;
vColor = vec4(colors * instanceColors.rgb, instanceColors.a);
mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);
vec3 pos = (instanceModelMatrix * positions) * simpleMesh.sizeScale + instanceTranslation;
if (simpleMesh.composeModelMatrix) {
DECKGL_FILTER_SIZE(pos, geometry);
normals_commonspace = project_normal(instanceModelMatrix * normals);
geometry.worldPosition += pos;
gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), position_commonspace);
geometry.position = position_commonspace;
}
else {
pos = project_size(pos);
DECKGL_FILTER_SIZE(pos, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, position_commonspace);
geometry.position = position_commonspace;
normals_commonspace = project_normal(instanceModelMatrix * normals);
}
geometry.normal = normals_commonspace;
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

// node_modules/@deck.gl/mesh-layers/dist/simple-mesh-layer/simple-mesh-layer-fragment.glsl.js
var simple_mesh_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME simple-mesh-layer-fs
precision highp float;
uniform sampler2D sampler;
in vec2 vTexCoord;
in vec3 cameraPosition;
in vec3 normals_commonspace;
in vec4 position_commonspace;
in vec4 vColor;
out vec4 fragColor;
void main(void) {
geometry.uv = vTexCoord;
vec3 normal;
if (simpleMesh.flatShading) {
normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
} else {
normal = normals_commonspace;
}
vec4 color = simpleMesh.hasTexture ? texture(sampler, vTexCoord) : vColor;
DECKGL_FILTER_COLOR(color, geometry);
vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);
fragColor = vec4(lightColor, color.a * layer.opacity);
}
`;

// node_modules/@deck.gl/mesh-layers/dist/simple-mesh-layer/simple-mesh-layer.js
function normalizeGeometryAttributes(attributes) {
  const positionAttribute = attributes.positions || attributes.POSITION;
  log_default.assert(positionAttribute, 'no "postions" or "POSITION" attribute in mesh');
  const vertexCount = positionAttribute.value.length / positionAttribute.size;
  let colorAttribute = attributes.COLOR_0 || attributes.colors;
  if (!colorAttribute) {
    colorAttribute = { size: 3, value: new Float32Array(vertexCount * 3).fill(1) };
  }
  let normalAttribute = attributes.NORMAL || attributes.normals;
  if (!normalAttribute) {
    normalAttribute = { size: 3, value: new Float32Array(vertexCount * 3).fill(0) };
  }
  let texCoordAttribute = attributes.TEXCOORD_0 || attributes.texCoords;
  if (!texCoordAttribute) {
    texCoordAttribute = { size: 2, value: new Float32Array(vertexCount * 2).fill(0) };
  }
  return {
    positions: positionAttribute,
    colors: colorAttribute,
    normals: normalAttribute,
    texCoords: texCoordAttribute
  };
}
function getGeometry(data) {
  if (data instanceof Geometry) {
    data.attributes = normalizeGeometryAttributes(data.attributes);
    return data;
  } else if (data.attributes) {
    return new Geometry({
      ...data,
      topology: "triangle-list",
      attributes: normalizeGeometryAttributes(data.attributes)
    });
  } else {
    return new Geometry({
      topology: "triangle-list",
      attributes: normalizeGeometryAttributes(data)
    });
  }
}
var DEFAULT_COLOR10 = [0, 0, 0, 255];
var defaultProps26 = {
  mesh: { type: "object", value: null, async: true },
  texture: { type: "image", value: null, async: true },
  sizeScale: { type: "number", value: 1, min: 0 },
  // _instanced is a hack to use world position instead of meter offsets in mesh
  // TODO - formalize API
  _instanced: true,
  // NOTE(Tarek): Quick and dirty wireframe. Just draws
  // the same mesh with LINE_STRIPS. Won't follow edges
  // of the original mesh.
  wireframe: false,
  // Optional material for 'lighting' shader module
  material: true,
  getPosition: { type: "accessor", value: (x) => x.position },
  getColor: { type: "accessor", value: DEFAULT_COLOR10 },
  // yaw, pitch and roll are in degrees
  // https://en.wikipedia.org/wiki/Euler_angles
  // [pitch, yaw, roll]
  getOrientation: { type: "accessor", value: [0, 0, 0] },
  getScale: { type: "accessor", value: [1, 1, 1] },
  getTranslation: { type: "accessor", value: [0, 0, 0] },
  // 4x4 matrix
  getTransformMatrix: { type: "accessor", value: [] },
  textureParameters: { type: "object", ignore: true, value: null }
};
var SimpleMeshLayer = class extends layer_default {
  getShaders() {
    return super.getShaders({
      vs: simple_mesh_layer_vertex_glsl_default,
      fs: simple_mesh_layer_fragment_glsl_default,
      modules: [project32_default, phongMaterial, picking_default, simpleMeshUniforms]
    });
  }
  getBounds() {
    var _a;
    if (this.props._instanced) {
      return super.getBounds();
    }
    let result = this.state.positionBounds;
    if (result) {
      return result;
    }
    const { mesh } = this.props;
    if (!mesh) {
      return null;
    }
    result = (_a = mesh.header) == null ? void 0 : _a.boundingBox;
    if (!result) {
      const { attributes } = getGeometry(mesh);
      attributes.POSITION = attributes.POSITION || attributes.positions;
      result = getMeshBoundingBox(attributes);
    }
    this.state.positionBounds = result;
    return result;
  }
  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instancePositions: {
        transition: true,
        type: "float64",
        fp64: this.use64bitPositions(),
        size: 3,
        accessor: "getPosition"
      },
      instanceColors: {
        type: "unorm8",
        transition: true,
        size: this.props.colorFormat.length,
        accessor: "getColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceModelMatrix: MATRIX_ATTRIBUTES
    });
    this.setState({
      // Avoid luma.gl's missing uniform warning
      // TODO - add feature to luma.gl to specify ignored uniforms?
      emptyTexture: this.context.device.createTexture({
        data: new Uint8Array(4),
        width: 1,
        height: 1
      })
    });
  }
  updateState(params) {
    var _a;
    super.updateState(params);
    const { props, oldProps, changeFlags } = params;
    if (props.mesh !== oldProps.mesh || changeFlags.extensionsChanged) {
      this.state.positionBounds = null;
      (_a = this.state.model) == null ? void 0 : _a.destroy();
      if (props.mesh) {
        this.state.model = this.getModel(props.mesh);
        const attributes = props.mesh.attributes || props.mesh;
        this.setState({
          hasNormals: Boolean(attributes.NORMAL || attributes.normals)
        });
      }
      this.getAttributeManager().invalidateAll();
    }
    if (props.texture !== oldProps.texture && props.texture instanceof Texture) {
      this.setTexture(props.texture);
    }
    if (this.state.model) {
      this.state.model.setTopology(this.props.wireframe ? "line-strip" : "triangle-list");
    }
  }
  finalizeState(context) {
    super.finalizeState(context);
    this.state.emptyTexture.delete();
  }
  draw({ uniforms }) {
    const { model } = this.state;
    if (!model) {
      return;
    }
    const { viewport, renderPass } = this.context;
    const { sizeScale, coordinateSystem, _instanced } = this.props;
    const simpleMeshProps = {
      sizeScale,
      composeModelMatrix: !_instanced || shouldComposeModelMatrix(viewport, coordinateSystem),
      flatShading: !this.state.hasNormals
    };
    model.shaderInputs.setProps({ simpleMesh: simpleMeshProps });
    model.draw(renderPass);
  }
  get isLoaded() {
    var _a;
    return Boolean(((_a = this.state) == null ? void 0 : _a.model) && super.isLoaded);
  }
  getModel(mesh) {
    const model = new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: getGeometry(mesh),
      isInstanced: true
    });
    const { texture } = this.props;
    const { emptyTexture } = this.state;
    const simpleMeshProps = {
      sampler: texture || emptyTexture,
      hasTexture: Boolean(texture)
    };
    model.shaderInputs.setProps({ simpleMesh: simpleMeshProps });
    return model;
  }
  setTexture(texture) {
    const { emptyTexture, model } = this.state;
    if (model) {
      const simpleMeshProps = {
        sampler: texture || emptyTexture,
        hasTexture: Boolean(texture)
      };
      model.shaderInputs.setProps({ simpleMesh: simpleMeshProps });
    }
  }
};
SimpleMeshLayer.defaultProps = defaultProps26;
SimpleMeshLayer.layerName = "SimpleMeshLayer";
var simple_mesh_layer_default = SimpleMeshLayer;

// node_modules/@luma.gl/gltf/dist/webgl-to-webgpu/convert-webgl-sampler.js
function convertSampler(gltfSampler) {
  return {
    addressModeU: convertSamplerWrapMode(gltfSampler.wrapS),
    addressModeV: convertSamplerWrapMode(gltfSampler.wrapT),
    magFilter: convertSamplerMagFilter(gltfSampler.magFilter),
    ...convertSamplerMinFilter(gltfSampler.minFilter)
  };
}
function convertSamplerWrapMode(mode) {
  switch (mode) {
    case 33071:
      return "clamp-to-edge";
    case 10497:
      return "repeat";
    case 33648:
      return "mirror-repeat";
    default:
      return void 0;
  }
}
function convertSamplerMagFilter(mode) {
  switch (mode) {
    case 9728:
      return "nearest";
    case 9729:
      return "linear";
    default:
      return void 0;
  }
}
function convertSamplerMinFilter(mode) {
  switch (mode) {
    case 9728:
      return { minFilter: "nearest" };
    case 9729:
      return { minFilter: "linear" };
    case 9984:
      return { minFilter: "nearest", mipmapFilter: "nearest" };
    case 9985:
      return { minFilter: "linear", mipmapFilter: "nearest" };
    case 9986:
      return { minFilter: "nearest", mipmapFilter: "linear" };
    case 9987:
      return { minFilter: "linear", mipmapFilter: "linear" };
    default:
      return {};
  }
}

// node_modules/@luma.gl/gltf/dist/parsers/parse-pbr-material.js
function parsePBRMaterial(device, material, attributes, options) {
  const parsedMaterial = {
    defines: {
      // TODO: Use EXT_sRGB if available (Standard in WebGL 2.0)
      MANUAL_SRGB: true,
      SRGB_FAST_APPROXIMATION: true
    },
    bindings: {},
    uniforms: {
      // TODO: find better values?
      camera: [0, 0, 0],
      // Model should override
      metallicRoughnessValues: [1, 1]
      // Default is 1 and 1
    },
    parameters: {},
    glParameters: {},
    generatedTextures: []
  };
  parsedMaterial.defines["USE_TEX_LOD"] = true;
  const { imageBasedLightingEnvironment } = options;
  if (imageBasedLightingEnvironment) {
    parsedMaterial.bindings.pbr_diffuseEnvSampler = imageBasedLightingEnvironment.diffuseEnvSampler.texture;
    parsedMaterial.bindings.pbr_specularEnvSampler = imageBasedLightingEnvironment.specularEnvSampler.texture;
    parsedMaterial.bindings.pbr_BrdfLUT = imageBasedLightingEnvironment.brdfLutTexture.texture;
    parsedMaterial.uniforms.scaleIBLAmbient = [1, 1];
  }
  if (options == null ? void 0 : options.pbrDebug) {
    parsedMaterial.defines["PBR_DEBUG"] = true;
    parsedMaterial.uniforms.scaleDiffBaseMR = [0, 0, 0, 0];
    parsedMaterial.uniforms.scaleFGDSpec = [0, 0, 0, 0];
  }
  if (attributes["NORMAL"])
    parsedMaterial.defines["HAS_NORMALS"] = true;
  if (attributes["TANGENT"] && (options == null ? void 0 : options.useTangents))
    parsedMaterial.defines["HAS_TANGENTS"] = true;
  if (attributes["TEXCOORD_0"])
    parsedMaterial.defines["HAS_UV"] = true;
  if (options == null ? void 0 : options.imageBasedLightingEnvironment)
    parsedMaterial.defines["USE_IBL"] = true;
  if (options == null ? void 0 : options.lights)
    parsedMaterial.defines["USE_LIGHTS"] = true;
  if (material) {
    parseMaterial(device, material, parsedMaterial);
  }
  return parsedMaterial;
}
function parseMaterial(device, material, parsedMaterial) {
  parsedMaterial.uniforms.unlit = Boolean(material.unlit);
  if (material.pbrMetallicRoughness) {
    parsePbrMetallicRoughness(device, material.pbrMetallicRoughness, parsedMaterial);
  }
  if (material.normalTexture) {
    addTexture(device, material.normalTexture, "pbr_normalSampler", "HAS_NORMALMAP", parsedMaterial);
    const { scale: scale7 = 1 } = material.normalTexture;
    parsedMaterial.uniforms.normalScale = scale7;
  }
  if (material.occlusionTexture) {
    addTexture(device, material.occlusionTexture, "pbr_occlusionSampler", "HAS_OCCLUSIONMAP", parsedMaterial);
    const { strength = 1 } = material.occlusionTexture;
    parsedMaterial.uniforms.occlusionStrength = strength;
  }
  if (material.emissiveTexture) {
    addTexture(device, material.emissiveTexture, "pbr_emissiveSampler", "HAS_EMISSIVEMAP", parsedMaterial);
    parsedMaterial.uniforms.emissiveFactor = material.emissiveFactor || [0, 0, 0];
  }
  switch (material.alphaMode || "MASK") {
    case "MASK":
      const { alphaCutoff = 0.5 } = material;
      parsedMaterial.defines["ALPHA_CUTOFF"] = true;
      parsedMaterial.uniforms.alphaCutoff = alphaCutoff;
      break;
    case "BLEND":
      log2.warn("glTF BLEND alphaMode might not work well because it requires mesh sorting")();
      parsedMaterial.parameters.blend = true;
      parsedMaterial.parameters.blendColorOperation = "add";
      parsedMaterial.parameters.blendColorSrcFactor = "src-alpha";
      parsedMaterial.parameters.blendColorDstFactor = "one-minus-src-alpha";
      parsedMaterial.parameters.blendAlphaOperation = "add";
      parsedMaterial.parameters.blendAlphaSrcFactor = "one";
      parsedMaterial.parameters.blendAlphaDstFactor = "one-minus-src-alpha";
      parsedMaterial.glParameters["blend"] = true;
      parsedMaterial.glParameters["blendEquation"] = 32774;
      parsedMaterial.glParameters["blendFunc"] = [
        770,
        771,
        1,
        771
      ];
      break;
  }
}
function parsePbrMetallicRoughness(device, pbrMetallicRoughness, parsedMaterial) {
  if (pbrMetallicRoughness.baseColorTexture) {
    addTexture(device, pbrMetallicRoughness.baseColorTexture, "pbr_baseColorSampler", "HAS_BASECOLORMAP", parsedMaterial);
  }
  parsedMaterial.uniforms.baseColorFactor = pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1];
  if (pbrMetallicRoughness.metallicRoughnessTexture) {
    addTexture(device, pbrMetallicRoughness.metallicRoughnessTexture, "pbr_metallicRoughnessSampler", "HAS_METALROUGHNESSMAP", parsedMaterial);
  }
  const { metallicFactor = 1, roughnessFactor = 1 } = pbrMetallicRoughness;
  parsedMaterial.uniforms.metallicRoughnessValues = [metallicFactor, roughnessFactor];
}
function addTexture(device, gltfTexture, uniformName, define2, parsedMaterial) {
  var _a;
  const image = gltfTexture.texture.source.image;
  let textureOptions;
  if (image.compressed) {
    textureOptions = image;
  } else {
    textureOptions = { data: image };
  }
  const gltfSampler = {
    wrapS: 10497,
    // default REPEAT S (U) wrapping mode.
    wrapT: 10497,
    // default REPEAT T (V) wrapping mode.
    ...(_a = gltfTexture == null ? void 0 : gltfTexture.texture) == null ? void 0 : _a.sampler
  };
  const texture = device.createTexture({
    id: gltfTexture.uniformName || gltfTexture.id,
    sampler: convertSampler(gltfSampler),
    ...textureOptions
  });
  parsedMaterial.bindings[uniformName] = texture;
  if (define2)
    parsedMaterial.defines[define2] = true;
  parsedMaterial.generatedTextures.push(texture);
}

// node_modules/@luma.gl/gltf/dist/webgl-to-webgpu/convert-webgl-topology.js
var GLEnum2;
(function(GLEnum3) {
  GLEnum3[GLEnum3["POINTS"] = 0] = "POINTS";
  GLEnum3[GLEnum3["LINES"] = 1] = "LINES";
  GLEnum3[GLEnum3["LINE_LOOP"] = 2] = "LINE_LOOP";
  GLEnum3[GLEnum3["LINE_STRIP"] = 3] = "LINE_STRIP";
  GLEnum3[GLEnum3["TRIANGLES"] = 4] = "TRIANGLES";
  GLEnum3[GLEnum3["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
  GLEnum3[GLEnum3["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
})(GLEnum2 || (GLEnum2 = {}));
function convertGLDrawModeToTopology(drawMode) {
  switch (drawMode) {
    case GLEnum2.POINTS:
      return "point-list";
    case GLEnum2.LINES:
      return "line-list";
    case GLEnum2.LINE_STRIP:
      return "line-strip";
    case GLEnum2.TRIANGLES:
      return "triangle-list";
    case GLEnum2.TRIANGLE_STRIP:
      return "triangle-strip";
    default:
      throw new Error(String(drawMode));
  }
}

// node_modules/@luma.gl/gltf/dist/gltf/create-gltf-model.js
var SHADER = (
  /* WGSL */
  `
layout(0) positions: vec4; // in vec4 POSITION;

  #ifdef HAS_NORMALS
    in vec4 normals; // in vec4 NORMAL;
  #endif

  #ifdef HAS_TANGENTS
    in vec4 TANGENT;
  #endif

  #ifdef HAS_UV
    // in vec2 TEXCOORD_0;
    in vec2 texCoords;
  #endif

@vertex
  void main(void) {
    vec4 _NORMAL = vec4(0.);
    vec4 _TANGENT = vec4(0.);
    vec2 _TEXCOORD_0 = vec2(0.);

    #ifdef HAS_NORMALS
      _NORMAL = normals;
    #endif

    #ifdef HAS_TANGENTS
      _TANGENT = TANGENT;
    #endif

    #ifdef HAS_UV
      _TEXCOORD_0 = texCoords;
    #endif

    pbr_setPositionNormalTangentUV(positions, _NORMAL, _TANGENT, _TEXCOORD_0);
    gl_Position = u_MVPMatrix * positions;
  }

@fragment
  out vec4 fragmentColor;

  void main(void) {
    vec3 pos = pbr_vPosition;
    fragmentColor = pbr_filterColor(vec4(1.0));
  }
`
);
var vs = (
  /* glsl */
  `#version 300 es

  // in vec4 POSITION;
  in vec4 positions;

  #ifdef HAS_NORMALS
    // in vec4 NORMAL;
    in vec4 normals;
  #endif

  #ifdef HAS_TANGENTS
    in vec4 TANGENT;
  #endif

  #ifdef HAS_UV
    // in vec2 TEXCOORD_0;
    in vec2 texCoords;
  #endif

  void main(void) {
    vec4 _NORMAL = vec4(0.);
    vec4 _TANGENT = vec4(0.);
    vec2 _TEXCOORD_0 = vec2(0.);

    #ifdef HAS_NORMALS
      _NORMAL = normals;
    #endif

    #ifdef HAS_TANGENTS
      _TANGENT = TANGENT;
    #endif

    #ifdef HAS_UV
      _TEXCOORD_0 = texCoords;
    #endif

    pbr_setPositionNormalTangentUV(positions, _NORMAL, _TANGENT, _TEXCOORD_0);
    gl_Position = pbrProjection.modelViewProjectionMatrix * positions;
  }
`
);
var fs = (
  /* glsl */
  `#version 300 es
  out vec4 fragmentColor;

  void main(void) {
    vec3 pos = pbr_vPosition;
    fragmentColor = pbr_filterColor(vec4(1.0));
  }
`
);
function createGLTFModel(device, options) {
  const { id, geometry, parsedPPBRMaterial, vertexCount, modelOptions = {} } = options;
  log2.info(4, "createGLTFModel defines: ", parsedPPBRMaterial.defines)();
  const managedResources = [];
  const parameters2 = {
    depthWriteEnabled: true,
    depthCompare: "less",
    depthFormat: "depth24plus",
    cullMode: "back"
  };
  const modelProps = {
    id,
    source: SHADER,
    vs,
    fs,
    geometry,
    topology: geometry.topology,
    vertexCount,
    modules: [pbrMaterial],
    ...modelOptions,
    defines: { ...parsedPPBRMaterial.defines, ...modelOptions.defines },
    parameters: { ...parameters2, ...parsedPPBRMaterial.parameters, ...modelOptions.parameters }
  };
  const model = new Model(device, modelProps);
  const { camera, ...pbrMaterialProps } = {
    ...parsedPPBRMaterial.uniforms,
    ...modelOptions.uniforms,
    ...parsedPPBRMaterial.bindings,
    ...modelOptions.bindings
  };
  model.shaderInputs.setProps({ pbrMaterial: pbrMaterialProps, pbrProjection: { camera } });
  return new ModelNode({ managedResources, model });
}

// node_modules/@luma.gl/gltf/dist/parsers/parse-gltf.js
var defaultOptions = {
  modelOptions: {},
  pbrDebug: false,
  imageBasedLightingEnvironment: void 0,
  lights: true,
  useTangents: false
};
function parseGLTF(device, gltf, options_ = {}) {
  const options = { ...defaultOptions, ...options_ };
  const sceneNodes = gltf.scenes.map((gltfScene) => createScene(device, gltfScene, gltf.nodes, options));
  return sceneNodes;
}
function createScene(device, gltfScene, gltfNodes, options) {
  const gltfSceneNodes = gltfScene.nodes || [];
  const nodes = gltfSceneNodes.map((node) => createNode(device, node, gltfNodes, options));
  const sceneNode = new GroupNode({
    id: gltfScene.name || gltfScene.id,
    children: nodes
  });
  return sceneNode;
}
function createNode(device, gltfNode, gltfNodes, options) {
  if (!gltfNode._node) {
    const gltfChildren = gltfNode.children || [];
    const children = gltfChildren.map((child) => createNode(device, child, gltfNodes, options));
    if (gltfNode.mesh) {
      children.push(createMesh2(device, gltfNode.mesh, options));
    }
    const node = new GroupNode({
      id: gltfNode.name || gltfNode.id,
      children
    });
    if (gltfNode.matrix) {
      node.setMatrix(gltfNode.matrix);
    } else {
      node.matrix.identity();
      if (gltfNode.translation) {
        node.matrix.translate(gltfNode.translation);
      }
      if (gltfNode.rotation) {
        const rotationMatrix = new Matrix4().fromQuaternion(gltfNode.rotation);
        node.matrix.multiplyRight(rotationMatrix);
      }
      if (gltfNode.scale) {
        node.matrix.scale(gltfNode.scale);
      }
    }
    gltfNode._node = node;
  }
  const topLevelNode = gltfNodes.find((node) => node.id === gltfNode.id);
  topLevelNode._node = gltfNode._node;
  return gltfNode._node;
}
function createMesh2(device, gltfMesh, options) {
  if (!gltfMesh._mesh) {
    const gltfPrimitives = gltfMesh.primitives || [];
    const primitives = gltfPrimitives.map((gltfPrimitive, i) => createPrimitive(device, gltfPrimitive, i, gltfMesh, options));
    const mesh = new GroupNode({
      id: gltfMesh.name || gltfMesh.id,
      children: primitives
    });
    gltfMesh._mesh = mesh;
  }
  return gltfMesh._mesh;
}
function createPrimitive(device, gltfPrimitive, i, gltfMesh, options) {
  const id = gltfPrimitive.name || `${gltfMesh.name || gltfMesh.id}-primitive-${i}`;
  const topology = convertGLDrawModeToTopology(gltfPrimitive.mode || 4);
  const vertexCount = gltfPrimitive.indices ? gltfPrimitive.indices.count : getVertexCount(gltfPrimitive.attributes);
  const geometry = createGeometry(id, gltfPrimitive, topology);
  const parsedPPBRMaterial = parsePBRMaterial(device, gltfPrimitive.material, geometry.attributes, options);
  const modelNode = createGLTFModel(device, {
    id,
    geometry: createGeometry(id, gltfPrimitive, topology),
    parsedPPBRMaterial,
    modelOptions: options.modelOptions,
    vertexCount
  });
  modelNode.bounds = [gltfPrimitive.attributes.POSITION.min, gltfPrimitive.attributes.POSITION.max];
  return modelNode;
}
function getVertexCount(attributes) {
  throw new Error("getVertexCount not implemented");
}
function createGeometry(id, gltfPrimitive, topology) {
  const attributes = {};
  for (const [attributeName, attribute] of Object.entries(gltfPrimitive.attributes)) {
    const { components, size, value } = attribute;
    attributes[attributeName] = { size: size ?? components, value };
  }
  return new Geometry({
    id,
    topology,
    indices: gltfPrimitive.indices.value,
    attributes
  });
}

// node_modules/@luma.gl/gltf/dist/gltf/animations/interpolate.js
var scratchQuaternion = new Quaternion();
function interpolate(time, { input, interpolation, output }, target, path) {
  const maxTime = input[input.length - 1];
  const animationTime = time % maxTime;
  const nextIndex = input.findIndex((t) => t >= animationTime);
  const previousIndex = Math.max(0, nextIndex - 1);
  if (!Array.isArray(target[path])) {
    switch (path) {
      case "translation":
        target[path] = [0, 0, 0];
        break;
      case "rotation":
        target[path] = [0, 0, 0, 1];
        break;
      case "scale":
        target[path] = [1, 1, 1];
        break;
      default:
        log2.warn(`Bad animation path ${path}`)();
    }
  }
  const previousTime = input[previousIndex];
  const nextTime = input[nextIndex];
  switch (interpolation) {
    case "STEP":
      stepInterpolate(target, path, output[previousIndex]);
      break;
    case "LINEAR":
      if (nextTime > previousTime) {
        const ratio = (animationTime - previousTime) / (nextTime - previousTime);
        linearInterpolate(target, path, output[previousIndex], output[nextIndex], ratio);
      }
      break;
    case "CUBICSPLINE":
      if (nextTime > previousTime) {
        const ratio = (animationTime - previousTime) / (nextTime - previousTime);
        const tDiff = nextTime - previousTime;
        const p0 = output[3 * previousIndex + 1];
        const outTangent0 = output[3 * previousIndex + 2];
        const inTangent1 = output[3 * nextIndex + 0];
        const p1 = output[3 * nextIndex + 1];
        cubicsplineInterpolate(target, path, { p0, outTangent0, inTangent1, p1, tDiff, ratio });
      }
      break;
    default:
      log2.warn(`Interpolation ${interpolation} not supported`)();
      break;
  }
}
function linearInterpolate(target, path, start, stop, ratio) {
  if (!target[path]) {
    throw new Error();
  }
  if (path === "rotation") {
    scratchQuaternion.slerp({ start, target: stop, ratio });
    for (let i = 0; i < scratchQuaternion.length; i++) {
      target[path][i] = scratchQuaternion[i];
    }
  } else {
    for (let i = 0; i < start.length; i++) {
      target[path][i] = ratio * stop[i] + (1 - ratio) * start[i];
    }
  }
}
function cubicsplineInterpolate(target, path, { p0, outTangent0, inTangent1, p1, tDiff, ratio: t }) {
  if (!target[path]) {
    throw new Error();
  }
  for (let i = 0; i < target[path].length; i++) {
    const m0 = outTangent0[i] * tDiff;
    const m1 = inTangent1[i] * tDiff;
    target[path][i] = (2 * Math.pow(t, 3) - 3 * Math.pow(t, 2) + 1) * p0[i] + (Math.pow(t, 3) - 2 * Math.pow(t, 2) + t) * m0 + (-2 * Math.pow(t, 3) + 3 * Math.pow(t, 2)) * p1[i] + (Math.pow(t, 3) - Math.pow(t, 2)) * m1;
  }
}
function stepInterpolate(target, path, value) {
  if (!target[path]) {
    throw new Error();
  }
  for (let i = 0; i < value.length; i++) {
    target[path][i] = value[i];
  }
}

// node_modules/@luma.gl/gltf/dist/gltf/gltf-animator.js
var GLTFSingleAnimator = class {
  constructor(props) {
    __publicField(this, "animation");
    __publicField(this, "startTime", 0);
    __publicField(this, "playing", true);
    __publicField(this, "speed", 1);
    var _a;
    this.animation = props.animation;
    (_a = this.animation).name || (_a.name = "unnamed");
    Object.assign(this, props);
  }
  setTime(timeMs) {
    if (!this.playing) {
      return;
    }
    const absTime = timeMs / 1e3;
    const time = (absTime - this.startTime) * this.speed;
    this.animation.channels.forEach(({ sampler, target, path }) => {
      interpolate(time, sampler, target, path);
      applyTranslationRotationScale(target, target._node);
    });
  }
};
var GLTFAnimator = class {
  constructor(props) {
    __publicField(this, "animations");
    this.animations = props.animations.map((animation, index) => {
      const name = animation.name || `Animation-${index}`;
      return new GLTFSingleAnimator({
        animation: { name, channels: animation.channels }
      });
    });
  }
  /** @deprecated Use .setTime(). Will be removed (deck.gl is using this) */
  animate(time) {
    log2.warn("GLTFAnimator#animate is deprecated. Use GLTFAnimator#setTime instead")();
    this.setTime(time);
  }
  setTime(time) {
    this.animations.forEach((animation) => animation.setTime(time));
  }
  getAnimations() {
    return this.animations;
  }
};
var scratchMatrix = new Matrix4();
function applyTranslationRotationScale(gltfNode, node) {
  node.matrix.identity();
  if (gltfNode.translation) {
    node.matrix.translate(gltfNode.translation);
  }
  if (gltfNode.rotation) {
    const rotationMatrix = scratchMatrix.fromQuaternion(gltfNode.rotation);
    node.matrix.multiplyRight(rotationMatrix);
  }
  if (gltfNode.scale) {
    node.matrix.scale(gltfNode.scale);
  }
}

// node_modules/@luma.gl/gltf/dist/webgl-to-webgpu/convert-webgl-attribute.js
var ATTRIBUTE_TYPE_TO_COMPONENTS = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
var ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
function accessorToTypedArray(accessor) {
  var _a;
  const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];
  const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];
  const length5 = components * accessor.count;
  const { buffer, byteOffset = 0 } = ((_a = accessor.bufferView) == null ? void 0 : _a.data) ?? {};
  const typedArray = new ArrayType(buffer, byteOffset + (accessor.byteOffset || 0), length5);
  return { typedArray, components };
}

// node_modules/@luma.gl/gltf/dist/parsers/parse-gltf-animations.js
function parseGLTFAnimations(gltf) {
  const gltfAnimations = gltf.animations || [];
  return gltfAnimations.map((animation, index) => {
    const name = animation.name || `Animation-${index}`;
    const samplers = animation.samplers.map(({ input, interpolation = "LINEAR", output }) => ({
      input: accessorToJsArray(gltf.accessors[input]),
      interpolation,
      output: accessorToJsArray(gltf.accessors[output])
    }));
    const channels = animation.channels.map(({ sampler, target }) => ({
      sampler: samplers[sampler],
      target: gltf.nodes[target.node ?? 0],
      path: target.path
    }));
    return { name, channels };
  });
}
function accessorToJsArray(accessor) {
  if (!accessor._animation) {
    const { typedArray: array, components } = accessorToTypedArray(accessor);
    if (components === 1) {
      accessor._animation = Array.from(array);
    } else {
      const slicedArray = [];
      for (let i = 0; i < array.length; i += components) {
        slicedArray.push(Array.from(array.slice(i, i + components)));
      }
      accessor._animation = slicedArray;
    }
  }
  return accessor._animation;
}

// node_modules/@luma.gl/gltf/dist/utils/deep-copy.js
function deepCopy(object) {
  if (ArrayBuffer.isView(object) || object instanceof ArrayBuffer || object instanceof ImageBitmap) {
    return object;
  }
  if (Array.isArray(object)) {
    return object.map(deepCopy);
  }
  if (object && typeof object === "object") {
    const result = {};
    for (const key in object) {
      result[key] = deepCopy(object[key]);
    }
    return result;
  }
  return object;
}

// node_modules/@luma.gl/gltf/dist/gltf/create-scenegraph-from-gltf.js
function createScenegraphsFromGLTF(device, gltf, options) {
  gltf = deepCopy(gltf);
  const scenes = parseGLTF(device, gltf, options);
  const animations = parseGLTFAnimations(gltf);
  const animator = new GLTFAnimator({ animations });
  return { scenes, animator };
}

// node_modules/@deck.gl/mesh-layers/dist/scenegraph-layer/gltf-utils.js
async function waitForGLTFAssets(gltfObjects) {
  const remaining = [];
  gltfObjects.scenes.forEach((scene) => {
    scene.traverse((modelNode) => {
    });
  });
  return await waitWhileCondition(() => remaining.some((uniform) => !uniform.loaded));
}
async function waitWhileCondition(condition) {
  while (condition()) {
    await new Promise((resolve) => requestAnimationFrame(resolve));
  }
}

// node_modules/@deck.gl/mesh-layers/dist/scenegraph-layer/scenegraph-layer-uniforms.js
var uniformBlock11 = `uniform scenegraphUniforms {
  float sizeScale;
  float sizeMinPixels;
  float sizeMaxPixels;
  mat4 sceneModelMatrix;
  bool composeModelMatrix;
} scenegraph;
`;
var scenegraphUniforms = {
  name: "scenegraph",
  vs: uniformBlock11,
  fs: uniformBlock11,
  uniformTypes: {
    sizeScale: "f32",
    sizeMinPixels: "f32",
    sizeMaxPixels: "f32",
    sceneModelMatrix: "mat4x4<f32>",
    composeModelMatrix: "f32"
  }
};

// node_modules/@deck.gl/mesh-layers/dist/scenegraph-layer/scenegraph-layer-vertex.glsl.js
var scenegraph_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME scenegraph-layer-vertex-shader
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec3 instanceModelMatrixCol0;
in vec3 instanceModelMatrixCol1;
in vec3 instanceModelMatrixCol2;
in vec3 instanceTranslation;
in vec3 positions;
#ifdef HAS_UV
in vec2 texCoords;
#endif
#ifdef LIGHTING_PBR
#ifdef HAS_NORMALS
in vec3 normals;
#endif
#endif
out vec4 vColor;
#ifndef LIGHTING_PBR
#ifdef HAS_UV
out vec2 vTEXCOORD_0;
#endif
#endif
void main(void) {
#if defined(HAS_UV) && !defined(LIGHTING_PBR)
vTEXCOORD_0 = texCoords;
geometry.uv = texCoords;
#endif
geometry.worldPosition = instancePositions;
geometry.pickingColor = instancePickingColors;
mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);
vec3 normal = vec3(0.0, 0.0, 1.0);
#ifdef LIGHTING_PBR
#ifdef HAS_NORMALS
normal = instanceModelMatrix * (scenegraph.sceneModelMatrix * vec4(normals, 0.0)).xyz;
#endif
#endif
float originalSize = project_size_to_pixel(scenegraph.sizeScale);
float clampedSize = clamp(originalSize, scenegraph.sizeMinPixels, scenegraph.sizeMaxPixels);
vec3 pos = (instanceModelMatrix * (scenegraph.sceneModelMatrix * vec4(positions, 1.0)).xyz) * scenegraph.sizeScale * (clampedSize / originalSize) + instanceTranslation;
if(scenegraph.composeModelMatrix) {
DECKGL_FILTER_SIZE(pos, geometry);
geometry.normal = project_normal(normal);
geometry.worldPosition += pos;
gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
}
else {
pos = project_size(pos);
DECKGL_FILTER_SIZE(pos, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, geometry.position);
geometry.normal = project_normal(normal);
}
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
#ifdef LIGHTING_PBR
pbr_vPosition = geometry.position.xyz;
#ifdef HAS_NORMALS
pbr_vNormal = geometry.normal;
#endif
#ifdef HAS_UV
pbr_vUV = texCoords;
#else
pbr_vUV = vec2(0., 0.);
#endif
geometry.uv = pbr_vUV;
#endif
vColor = instanceColors;
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

// node_modules/@deck.gl/mesh-layers/dist/scenegraph-layer/scenegraph-layer-fragment.glsl.js
var scenegraph_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME scenegraph-layer-fragment-shader
in vec4 vColor;
out vec4 fragColor;
#ifndef LIGHTING_PBR
#if defined(HAS_UV) && defined(HAS_BASECOLORMAP)
in vec2 vTEXCOORD_0;
uniform sampler2D pbr_baseColorSampler;
#endif
#endif
void main(void) {
#ifdef LIGHTING_PBR
fragColor = vColor * pbr_filterColor(vec4(0));
geometry.uv = pbr_vUV;
#else
#if defined(HAS_UV) && defined(HAS_BASECOLORMAP)
fragColor = vColor * texture(pbr_baseColorSampler, vTEXCOORD_0);
geometry.uv = vTEXCOORD_0;
#else
fragColor = vColor;
#endif
#endif
fragColor.a *= layer.opacity;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/mesh-layers/dist/scenegraph-layer/scenegraph-layer.js
var DEFAULT_COLOR11 = [255, 255, 255, 255];
var defaultProps27 = {
  scenegraph: { type: "object", value: null, async: true },
  getScene: (gltf) => {
    if (gltf && gltf.scenes) {
      return typeof gltf.scene === "object" ? gltf.scene : gltf.scenes[gltf.scene || 0];
    }
    return gltf;
  },
  getAnimator: (scenegraph) => scenegraph && scenegraph.animator,
  _animations: null,
  sizeScale: { type: "number", value: 1, min: 0 },
  sizeMinPixels: { type: "number", min: 0, value: 0 },
  sizeMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
  getPosition: { type: "accessor", value: (x) => x.position },
  getColor: { type: "accessor", value: DEFAULT_COLOR11 },
  // flat or pbr
  _lighting: "flat",
  // _lighting must be pbr for this to work
  _imageBasedLightingEnvironment: void 0,
  // yaw, pitch and roll are in degrees
  // https://en.wikipedia.org/wiki/Euler_angles
  // [pitch, yaw, roll]
  getOrientation: { type: "accessor", value: [0, 0, 0] },
  getScale: { type: "accessor", value: [1, 1, 1] },
  getTranslation: { type: "accessor", value: [0, 0, 0] },
  // 4x4 matrix
  getTransformMatrix: { type: "accessor", value: [] },
  loaders: [GLTFLoader]
};
var ScenegraphLayer = class extends layer_default {
  getShaders() {
    const defines = {};
    let pbr;
    if (this.props._lighting === "pbr") {
      pbr = pbrMaterial;
      defines.LIGHTING_PBR = 1;
    } else {
      pbr = { name: "pbrMaterial" };
    }
    const modules = [project32_default, picking_default, scenegraphUniforms, pbr];
    return super.getShaders({ defines, vs: scenegraph_layer_vertex_glsl_default, fs: scenegraph_layer_fragment_glsl_default, modules });
  }
  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        accessor: "getPosition",
        transition: true
      },
      instanceColors: {
        type: "unorm8",
        size: this.props.colorFormat.length,
        accessor: "getColor",
        defaultValue: DEFAULT_COLOR11,
        transition: true
      },
      instanceModelMatrix: MATRIX_ATTRIBUTES
    });
  }
  updateState(params) {
    super.updateState(params);
    const { props, oldProps } = params;
    if (props.scenegraph !== oldProps.scenegraph) {
      this._updateScenegraph();
    } else if (props._animations !== oldProps._animations) {
      this._applyAnimationsProp(this.state.animator, props._animations);
    }
  }
  finalizeState(context) {
    var _a;
    super.finalizeState(context);
    (_a = this.state.scenegraph) == null ? void 0 : _a.destroy();
  }
  get isLoaded() {
    var _a;
    return Boolean(((_a = this.state) == null ? void 0 : _a.scenegraph) && super.isLoaded);
  }
  _updateScenegraph() {
    var _a;
    const props = this.props;
    const { device } = this.context;
    let scenegraphData = null;
    if (props.scenegraph instanceof ScenegraphNode) {
      scenegraphData = { scenes: [props.scenegraph] };
    } else if (props.scenegraph && typeof props.scenegraph === "object") {
      const gltf = props.scenegraph;
      const processedGLTF = gltf.json ? postProcessGLTF(gltf) : gltf;
      const gltfObjects = createScenegraphsFromGLTF(device, processedGLTF, this._getModelOptions());
      scenegraphData = { gltf: processedGLTF, ...gltfObjects };
      waitForGLTFAssets(gltfObjects).then(() => {
        this.setNeedsRedraw();
      }).catch((ex) => {
        this.raiseError(ex, "loading glTF");
      });
    }
    const options = { layer: this, device: this.context.device };
    const scenegraph = props.getScene(scenegraphData, options);
    const animator = props.getAnimator(scenegraphData, options);
    if (scenegraph instanceof GroupNode) {
      (_a = this.state.scenegraph) == null ? void 0 : _a.destroy();
      this._applyAnimationsProp(animator, props._animations);
      const models = [];
      scenegraph.traverse((node) => {
        if (node instanceof ModelNode) {
          models.push(node.model);
        }
      });
      this.setState({ scenegraph, animator, models });
      this.getAttributeManager().invalidateAll();
    } else if (scenegraph !== null) {
      log_default.warn("invalid scenegraph:", scenegraph)();
    }
  }
  _applyAnimationsProp(animator, animationsProp) {
    if (!animator || !animationsProp) {
      return;
    }
    const animations = animator.getAnimations();
    Object.keys(animationsProp).sort().forEach((key) => {
      const value = animationsProp[key];
      if (key === "*") {
        animations.forEach((animation) => {
          Object.assign(animation, value);
        });
      } else if (Number.isFinite(Number(key))) {
        const number = Number(key);
        if (number >= 0 && number < animations.length) {
          Object.assign(animations[number], value);
        } else {
          log_default.warn(`animation ${key} not found`)();
        }
      } else {
        const findResult = animations.find(({ animation }) => animation.name === key);
        if (findResult) {
          Object.assign(findResult, value);
        } else {
          log_default.warn(`animation ${key} not found`)();
        }
      }
    });
  }
  _getModelOptions() {
    const { _imageBasedLightingEnvironment } = this.props;
    let env;
    if (_imageBasedLightingEnvironment) {
      if (typeof _imageBasedLightingEnvironment === "function") {
        env = _imageBasedLightingEnvironment({ gl: this.context.gl, layer: this });
      } else {
        env = _imageBasedLightingEnvironment;
      }
    }
    return {
      imageBasedLightingEnvironment: env,
      modelOptions: {
        id: this.props.id,
        isInstanced: true,
        bufferLayout: this.getAttributeManager().getBufferLayouts(),
        ...this.getShaders()
      },
      // tangents are not supported
      useTangents: false
    };
  }
  draw({ context }) {
    if (!this.state.scenegraph)
      return;
    if (this.props._animations && this.state.animator) {
      this.state.animator.animate(context.timeline.getTime());
      this.setNeedsRedraw();
    }
    const { viewport, renderPass } = this.context;
    const { sizeScale, sizeMinPixels, sizeMaxPixels, coordinateSystem } = this.props;
    const pbrProjectionProps = {
      camera: viewport.cameraPosition
    };
    const numInstances = this.getNumInstances();
    this.state.scenegraph.traverse((node, { worldMatrix }) => {
      if (node instanceof ModelNode) {
        const { model } = node;
        model.setInstanceCount(numInstances);
        const scenegraphProps = {
          sizeScale,
          sizeMinPixels,
          sizeMaxPixels,
          composeModelMatrix: shouldComposeModelMatrix(viewport, coordinateSystem),
          sceneModelMatrix: worldMatrix
        };
        model.shaderInputs.setProps({
          pbrProjection: pbrProjectionProps,
          scenegraph: scenegraphProps
        });
        model.draw(renderPass);
      }
    });
  }
};
ScenegraphLayer.defaultProps = defaultProps27;
ScenegraphLayer.layerName = "ScenegraphLayer";
var scenegraph_layer_default = ScenegraphLayer;

// node_modules/@deck.gl/geo-layers/dist/mesh-layer/mesh-layer-uniforms.js
var uniformBlock12 = `uniform meshUniforms {
  bool pickFeatureIds;
} mesh;
`;
var meshUniforms = {
  name: "mesh",
  vs: uniformBlock12,
  fs: uniformBlock12,
  uniformTypes: {
    pickFeatureIds: "f32"
  }
};

// node_modules/@deck.gl/geo-layers/dist/mesh-layer/mesh-layer-vertex.glsl.js
var mesh_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME simple-mesh-layer-vs
in vec3 positions;
in vec3 normals;
in vec3 colors;
in vec2 texCoords;
in vec4 uvRegions;
in vec3 featureIdsPickingColors;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec3 instanceModelMatrixCol0;
in vec3 instanceModelMatrixCol1;
in vec3 instanceModelMatrixCol2;
out vec2 vTexCoord;
out vec3 cameraPosition;
out vec3 normals_commonspace;
out vec4 position_commonspace;
out vec4 vColor;
vec2 applyUVRegion(vec2 uv) {
#ifdef HAS_UV_REGIONS
return fract(uv) * (uvRegions.zw - uvRegions.xy) + uvRegions.xy;
#else
return uv;
#endif
}
void main(void) {
vec2 uv = applyUVRegion(texCoords);
geometry.uv = uv;
if (mesh.pickFeatureIds) {
geometry.pickingColor = featureIdsPickingColors;
} else {
geometry.pickingColor = instancePickingColors;
}
mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);
vTexCoord = uv;
cameraPosition = project.cameraPosition;
vColor = vec4(colors * instanceColors.rgb, instanceColors.a);
vec3 pos = (instanceModelMatrix * positions) * simpleMesh.sizeScale;
vec3 projectedPosition = project_position(positions);
position_commonspace = vec4(projectedPosition, 1.0);
gl_Position = project_common_position_to_clipspace(position_commonspace);
geometry.position = position_commonspace;
normals_commonspace = project_normal(instanceModelMatrix * normals);
geometry.normal = normals_commonspace;
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
#ifdef MODULE_PBRMATERIAL
pbr_vPosition = geometry.position.xyz;
#ifdef HAS_NORMALS
pbr_vNormal = geometry.normal;
#endif
#ifdef HAS_UV
pbr_vUV = uv;
#else
pbr_vUV = vec2(0., 0.);
#endif
geometry.uv = pbr_vUV;
#endif
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

// node_modules/@deck.gl/geo-layers/dist/mesh-layer/mesh-layer-fragment.glsl.js
var mesh_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME simple-mesh-layer-fs
precision highp float;
uniform sampler2D sampler;
in vec2 vTexCoord;
in vec3 cameraPosition;
in vec3 normals_commonspace;
in vec4 position_commonspace;
in vec4 vColor;
out vec4 fragColor;
void main(void) {
#ifdef MODULE_PBRMATERIAL
fragColor = vColor * pbr_filterColor(vec4(0));
geometry.uv = pbr_vUV;
fragColor.a *= layer.opacity;
#else
geometry.uv = vTexCoord;
vec3 normal;
if (simpleMesh.flatShading) {
normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
} else {
normal = normals_commonspace;
}
vec4 color = simpleMesh.hasTexture ? texture(sampler, vTexCoord) : vColor;
vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);
fragColor = vec4(lightColor, color.a * layer.opacity);
#endif
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/geo-layers/dist/mesh-layer/mesh-layer.js
function validateGeometryAttributes(attributes) {
  const positionAttribute = attributes.positions || attributes.POSITION;
  const vertexCount = positionAttribute.value.length / positionAttribute.size;
  const hasColorAttribute = attributes.COLOR_0 || attributes.colors;
  if (!hasColorAttribute) {
    attributes.colors = {
      size: 4,
      value: new Uint8Array(vertexCount * 4).fill(255),
      normalized: true
    };
  }
}
var defaultProps28 = {
  pbrMaterial: { type: "object", value: null },
  featureIds: { type: "array", value: null, optional: true }
};
var MeshLayer = class extends simple_mesh_layer_default {
  getShaders() {
    const shaders = super.getShaders();
    const modules = shaders.modules;
    modules.push(pbrMaterial, meshUniforms);
    return { ...shaders, vs: mesh_layer_vertex_glsl_default, fs: mesh_layer_fragment_glsl_default };
  }
  initializeState() {
    const { featureIds } = this.props;
    super.initializeState();
    const attributeManager = this.getAttributeManager();
    if (featureIds) {
      attributeManager.add({
        featureIdsPickingColors: {
          type: "uint8",
          size: 3,
          noAlloc: true,
          // eslint-disable-next-line @typescript-eslint/unbound-method
          update: this.calculateFeatureIdsPickingColors
        }
      });
    }
  }
  updateState(params) {
    super.updateState(params);
    const { props, oldProps } = params;
    if (props.pbrMaterial !== oldProps.pbrMaterial) {
      this.updatePbrMaterialUniforms(props.pbrMaterial);
    }
  }
  draw(opts) {
    const { featureIds } = this.props;
    const { model } = this.state;
    if (!model) {
      return;
    }
    const meshProps = {
      pickFeatureIds: Boolean(featureIds)
    };
    const pbrProjectionProps = {
      camera: this.context.viewport.cameraPosition
    };
    model.shaderInputs.setProps({
      pbrProjection: pbrProjectionProps,
      mesh: meshProps
    });
    super.draw(opts);
  }
  getModel(mesh) {
    const { id } = this.props;
    const parsedPBRMaterial = this.parseMaterial(this.props.pbrMaterial, mesh);
    this.setState({ parsedPBRMaterial });
    const shaders = this.getShaders();
    validateGeometryAttributes(mesh.attributes);
    const model = new Model(this.context.device, {
      ...this.getShaders(),
      id,
      geometry: mesh,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      defines: {
        ...shaders.defines,
        ...parsedPBRMaterial == null ? void 0 : parsedPBRMaterial.defines,
        HAS_UV_REGIONS: mesh.attributes.uvRegions ? 1 : 0
      },
      parameters: parsedPBRMaterial == null ? void 0 : parsedPBRMaterial.parameters,
      isInstanced: true
    });
    return model;
  }
  updatePbrMaterialUniforms(material) {
    const { model } = this.state;
    if (model) {
      const { mesh } = this.props;
      const parsedPBRMaterial = this.parseMaterial(material, mesh);
      this.setState({ parsedPBRMaterial });
      const { pbr_baseColorSampler } = parsedPBRMaterial.bindings;
      const { emptyTexture } = this.state;
      const simpleMeshProps = {
        sampler: pbr_baseColorSampler || emptyTexture,
        hasTexture: Boolean(pbr_baseColorSampler)
      };
      const { camera, ...pbrMaterialProps } = {
        ...parsedPBRMaterial.bindings,
        ...parsedPBRMaterial.uniforms
      };
      model.shaderInputs.setProps({ simpleMesh: simpleMeshProps, pbrMaterial: pbrMaterialProps });
    }
  }
  parseMaterial(material, mesh) {
    const unlit = Boolean(material.pbrMetallicRoughness && material.pbrMetallicRoughness.baseColorTexture);
    return parsePBRMaterial(this.context.device, { unlit, ...material }, { NORMAL: mesh.attributes.normals, TEXCOORD_0: mesh.attributes.texCoords }, {
      pbrDebug: false,
      lights: true,
      useTangents: false
    });
  }
  calculateFeatureIdsPickingColors(attribute) {
    const featureIds = this.props.featureIds;
    const value = new Uint8ClampedArray(featureIds.length * attribute.size);
    const pickingColor = [];
    for (let index = 0; index < featureIds.length; index++) {
      this.encodePickingColor(featureIds[index], pickingColor);
      value[index * 3] = pickingColor[0];
      value[index * 3 + 1] = pickingColor[1];
      value[index * 3 + 2] = pickingColor[2];
    }
    attribute.value = value;
  }
  finalizeState(context) {
    var _a;
    super.finalizeState(context);
    (_a = this.state.parsedPBRMaterial) == null ? void 0 : _a.generatedTextures.forEach((texture) => texture.destroy());
    this.setState({ parsedPBRMaterial: null });
  }
};
MeshLayer.layerName = "MeshLayer";
MeshLayer.defaultProps = defaultProps28;
var mesh_layer_default = MeshLayer;

// node_modules/@deck.gl/geo-layers/dist/tile-3d-layer/tile-3d-layer.js
var SINGLE_DATA = [0];
var defaultProps29 = {
  getPointColor: { type: "accessor", value: [0, 0, 0, 255] },
  pointSize: 1,
  // Disable async data loading (handling it in _loadTileSet)
  data: "",
  loader: Tiles3DLoader,
  onTilesetLoad: { type: "function", value: (tileset3d) => {
  } },
  onTileLoad: { type: "function", value: (tileHeader) => {
  } },
  onTileUnload: { type: "function", value: (tileHeader) => {
  } },
  onTileError: { type: "function", value: (tile, message, url) => {
  } },
  _getMeshColor: { type: "function", value: (tileHeader) => [255, 255, 255] }
};
var Tile3DLayer = class extends composite_layer_default {
  initializeState() {
    if ("onTileLoadFail" in this.props) {
      log_default.removed("onTileLoadFail", "onTileError")();
    }
    this.state = {
      layerMap: {},
      tileset3d: null,
      activeViewports: {},
      lastUpdatedViewports: null
    };
  }
  get isLoaded() {
    var _a, _b;
    return Boolean(((_b = (_a = this.state) == null ? void 0 : _a.tileset3d) == null ? void 0 : _b.isLoaded()) && super.isLoaded);
  }
  shouldUpdateState({ changeFlags }) {
    return changeFlags.somethingChanged;
  }
  updateState({ props, oldProps, changeFlags }) {
    if (props.data && props.data !== oldProps.data) {
      this._loadTileset(props.data);
    }
    if (changeFlags.viewportChanged) {
      const { activeViewports } = this.state;
      const viewportsNumber = Object.keys(activeViewports).length;
      if (viewportsNumber) {
        this._updateTileset(activeViewports);
        this.state.lastUpdatedViewports = activeViewports;
        this.state.activeViewports = {};
      }
    }
    if (changeFlags.propsChanged) {
      const { layerMap } = this.state;
      for (const key in layerMap) {
        layerMap[key].needsUpdate = true;
      }
    }
  }
  activateViewport(viewport) {
    const { activeViewports, lastUpdatedViewports } = this.state;
    this.internalState.viewport = viewport;
    activeViewports[viewport.id] = viewport;
    const lastViewport = lastUpdatedViewports == null ? void 0 : lastUpdatedViewports[viewport.id];
    if (!lastViewport || !viewport.equals(lastViewport)) {
      this.setChangeFlags({ viewportChanged: true });
      this.setNeedsUpdate();
    }
  }
  getPickingInfo({ info, sourceLayer }) {
    const sourceTile = sourceLayer && sourceLayer.props.tile;
    if (info.picked) {
      info.object = sourceTile;
    }
    info.sourceTile = sourceTile;
    return info;
  }
  filterSubLayer({ layer, viewport }) {
    const { tile } = layer.props;
    const { id: viewportId } = viewport;
    return tile.selected && tile.viewportIds.includes(viewportId);
  }
  _updateAutoHighlight(info) {
    const sourceTile = info.sourceTile;
    const layerCache = this.state.layerMap[sourceTile == null ? void 0 : sourceTile.id];
    if (layerCache && layerCache.layer) {
      layerCache.layer.updateAutoHighlight(info);
    }
  }
  async _loadTileset(tilesetUrl) {
    const { loadOptions = {} } = this.props;
    const loaders = this.props.loader || this.props.loaders;
    const loader = Array.isArray(loaders) ? loaders[0] : loaders;
    const options = { loadOptions: { ...loadOptions } };
    let actualTilesetUrl = tilesetUrl;
    if (loader.preload) {
      const preloadOptions = await loader.preload(tilesetUrl, loadOptions);
      if (preloadOptions.url) {
        actualTilesetUrl = preloadOptions.url;
      }
      if (preloadOptions.headers) {
        options.loadOptions.fetch = {
          ...options.loadOptions.fetch,
          headers: preloadOptions.headers
        };
      }
      Object.assign(options, preloadOptions);
    }
    const tilesetJson = await load(actualTilesetUrl, loader, options.loadOptions);
    const tileset3d = new Tileset3D(tilesetJson, {
      onTileLoad: this._onTileLoad.bind(this),
      onTileUnload: this._onTileUnload.bind(this),
      onTileError: this.props.onTileError,
      ...options
    });
    this.setState({
      tileset3d,
      layerMap: {}
    });
    this._updateTileset(this.state.activeViewports);
    this.props.onTilesetLoad(tileset3d);
  }
  _onTileLoad(tileHeader) {
    const { lastUpdatedViewports } = this.state;
    this.props.onTileLoad(tileHeader);
    this._updateTileset(lastUpdatedViewports);
    this.setNeedsUpdate();
  }
  _onTileUnload(tileHeader) {
    delete this.state.layerMap[tileHeader.id];
    this.props.onTileUnload(tileHeader);
  }
  _updateTileset(viewports) {
    if (!viewports) {
      return;
    }
    const { tileset3d } = this.state;
    const { timeline } = this.context;
    const viewportsNumber = Object.keys(viewports).length;
    if (!timeline || !viewportsNumber || !tileset3d) {
      return;
    }
    tileset3d.selectTiles(Object.values(viewports)).then((frameNumber) => {
      const tilesetChanged = this.state.frameNumber !== frameNumber;
      if (tilesetChanged) {
        this.setState({ frameNumber });
      }
    });
  }
  _getSubLayer(tileHeader, oldLayer) {
    if (!tileHeader.content) {
      return null;
    }
    switch (tileHeader.type) {
      case TILE_TYPE.POINTCLOUD:
        return this._makePointCloudLayer(tileHeader, oldLayer);
      case TILE_TYPE.SCENEGRAPH:
        return this._make3DModelLayer(tileHeader);
      case TILE_TYPE.MESH:
        return this._makeSimpleMeshLayer(tileHeader, oldLayer);
      default:
        throw new Error(`Tile3DLayer: Failed to render layer of type ${tileHeader.content.type}`);
    }
  }
  _makePointCloudLayer(tileHeader, oldLayer) {
    const { attributes, pointCount, constantRGBA, cartographicOrigin, modelMatrix: modelMatrix2 } = tileHeader.content;
    const { positions, normals, colors } = attributes;
    if (!positions) {
      return null;
    }
    const data = oldLayer && oldLayer.props.data || {
      header: {
        vertexCount: pointCount
      },
      attributes: {
        POSITION: positions,
        NORMAL: normals,
        COLOR_0: colors
      }
    };
    const { pointSize, getPointColor } = this.props;
    const SubLayerClass = this.getSubLayerClass("pointcloud", point_cloud_layer_default);
    return new SubLayerClass({
      pointSize
    }, this.getSubLayerProps({
      id: "pointcloud"
    }), {
      id: `${this.id}-pointcloud-${tileHeader.id}`,
      tile: tileHeader,
      data,
      coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,
      coordinateOrigin: cartographicOrigin,
      modelMatrix: modelMatrix2,
      getColor: constantRGBA || getPointColor,
      _offset: 0
    });
  }
  _make3DModelLayer(tileHeader) {
    const { gltf, instances, cartographicOrigin, modelMatrix: modelMatrix2 } = tileHeader.content;
    const SubLayerClass = this.getSubLayerClass("scenegraph", scenegraph_layer_default);
    return new SubLayerClass({
      _lighting: "pbr"
    }, this.getSubLayerProps({
      id: "scenegraph"
    }), {
      id: `${this.id}-scenegraph-${tileHeader.id}`,
      tile: tileHeader,
      data: instances || SINGLE_DATA,
      scenegraph: gltf,
      coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,
      coordinateOrigin: cartographicOrigin,
      modelMatrix: modelMatrix2,
      getTransformMatrix: (instance) => instance.modelMatrix,
      getPosition: [0, 0, 0],
      _offset: 0
    });
  }
  _makeSimpleMeshLayer(tileHeader, oldLayer) {
    const content = tileHeader.content;
    const { attributes, indices, modelMatrix: modelMatrix2, cartographicOrigin, coordinateSystem = COORDINATE_SYSTEM.METER_OFFSETS, material, featureIds } = content;
    const { _getMeshColor } = this.props;
    const geometry = oldLayer && oldLayer.props.mesh || new Geometry({
      topology: "triangle-list",
      attributes: getMeshGeometry(attributes),
      indices
    });
    const SubLayerClass = this.getSubLayerClass("mesh", mesh_layer_default);
    return new SubLayerClass(this.getSubLayerProps({
      id: "mesh"
    }), {
      id: `${this.id}-mesh-${tileHeader.id}`,
      tile: tileHeader,
      mesh: geometry,
      data: SINGLE_DATA,
      getColor: _getMeshColor(tileHeader),
      pbrMaterial: material,
      modelMatrix: modelMatrix2,
      coordinateOrigin: cartographicOrigin,
      coordinateSystem,
      featureIds,
      _offset: 0
    });
  }
  renderLayers() {
    const { tileset3d, layerMap } = this.state;
    if (!tileset3d) {
      return null;
    }
    return tileset3d.tiles.map((tile) => {
      const layerCache = layerMap[tile.id] = layerMap[tile.id] || { tile };
      let { layer } = layerCache;
      if (tile.selected) {
        if (!layer) {
          layer = this._getSubLayer(tile);
        } else if (layerCache.needsUpdate) {
          layer = this._getSubLayer(tile, layer);
          layerCache.needsUpdate = false;
        }
      }
      layerCache.layer = layer;
      return layer;
    }).filter(Boolean);
  }
};
Tile3DLayer.defaultProps = defaultProps29;
Tile3DLayer.layerName = "Tile3DLayer";
var tile_3d_layer_default = Tile3DLayer;
function getMeshGeometry(contentAttributes) {
  const attributes = {};
  attributes.positions = {
    ...contentAttributes.positions,
    value: new Float32Array(contentAttributes.positions.value)
  };
  if (contentAttributes.normals) {
    attributes.normals = contentAttributes.normals;
  }
  if (contentAttributes.texCoords) {
    attributes.texCoords = contentAttributes.texCoords;
  }
  if (contentAttributes.colors) {
    attributes.colors = contentAttributes.colors;
  }
  if (contentAttributes.uvRegions) {
    attributes.uvRegions = contentAttributes.uvRegions;
  }
  return attributes;
}

// node_modules/@loaders.gl/terrain/dist/lib/decode-quantized-mesh.js
var QUANTIZED_MESH_HEADER = /* @__PURE__ */ new Map([
  ["centerX", Float64Array.BYTES_PER_ELEMENT],
  ["centerY", Float64Array.BYTES_PER_ELEMENT],
  ["centerZ", Float64Array.BYTES_PER_ELEMENT],
  ["minHeight", Float32Array.BYTES_PER_ELEMENT],
  ["maxHeight", Float32Array.BYTES_PER_ELEMENT],
  ["boundingSphereCenterX", Float64Array.BYTES_PER_ELEMENT],
  ["boundingSphereCenterY", Float64Array.BYTES_PER_ELEMENT],
  ["boundingSphereCenterZ", Float64Array.BYTES_PER_ELEMENT],
  ["boundingSphereRadius", Float64Array.BYTES_PER_ELEMENT],
  ["horizonOcclusionPointX", Float64Array.BYTES_PER_ELEMENT],
  ["horizonOcclusionPointY", Float64Array.BYTES_PER_ELEMENT],
  ["horizonOcclusionPointZ", Float64Array.BYTES_PER_ELEMENT]
]);
function decodeZigZag(value) {
  return value >> 1 ^ -(value & 1);
}
function decodeHeader(dataView) {
  let position = 0;
  const header = {};
  for (const [key, bytesCount] of QUANTIZED_MESH_HEADER) {
    const getter = bytesCount === 8 ? dataView.getFloat64 : dataView.getFloat32;
    header[key] = getter.call(dataView, position, true);
    position += bytesCount;
  }
  return { header, headerEndPosition: position };
}
function decodeVertexData(dataView, headerEndPosition) {
  let position = headerEndPosition;
  const elementsPerVertex = 3;
  const vertexCount = dataView.getUint32(position, true);
  const vertexData = new Uint16Array(vertexCount * elementsPerVertex);
  position += Uint32Array.BYTES_PER_ELEMENT;
  const bytesPerArrayElement = Uint16Array.BYTES_PER_ELEMENT;
  const elementArrayLength = vertexCount * bytesPerArrayElement;
  const uArrayStartPosition = position;
  const vArrayStartPosition = uArrayStartPosition + elementArrayLength;
  const heightArrayStartPosition = vArrayStartPosition + elementArrayLength;
  let u2 = 0;
  let v2 = 0;
  let height = 0;
  for (let i = 0; i < vertexCount; i++) {
    u2 += decodeZigZag(dataView.getUint16(uArrayStartPosition + bytesPerArrayElement * i, true));
    v2 += decodeZigZag(dataView.getUint16(vArrayStartPosition + bytesPerArrayElement * i, true));
    height += decodeZigZag(dataView.getUint16(heightArrayStartPosition + bytesPerArrayElement * i, true));
    vertexData[i] = u2;
    vertexData[i + vertexCount] = v2;
    vertexData[i + vertexCount * 2] = height;
  }
  position += elementArrayLength * 3;
  return { vertexData, vertexDataEndPosition: position };
}
function decodeIndex(buffer, position, indicesCount, bytesPerIndex, encoded = true) {
  let indices;
  if (bytesPerIndex === 2) {
    indices = new Uint16Array(buffer, position, indicesCount);
  } else {
    indices = new Uint32Array(buffer, position, indicesCount);
  }
  if (!encoded) {
    return indices;
  }
  let highest = 0;
  for (let i = 0; i < indices.length; ++i) {
    const code = indices[i];
    indices[i] = highest - code;
    if (code === 0) {
      ++highest;
    }
  }
  return indices;
}
function decodeTriangleIndices(dataView, vertexData, vertexDataEndPosition) {
  let position = vertexDataEndPosition;
  const elementsPerVertex = 3;
  const vertexCount = vertexData.length / elementsPerVertex;
  const bytesPerIndex = vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;
  if (position % bytesPerIndex !== 0) {
    position += bytesPerIndex - position % bytesPerIndex;
  }
  const triangleCount = dataView.getUint32(position, true);
  position += Uint32Array.BYTES_PER_ELEMENT;
  const triangleIndicesCount = triangleCount * 3;
  const triangleIndices = decodeIndex(dataView.buffer, position, triangleIndicesCount, bytesPerIndex);
  position += triangleIndicesCount * bytesPerIndex;
  return {
    triangleIndicesEndPosition: position,
    triangleIndices
  };
}
function decodeEdgeIndices(dataView, vertexData, triangleIndicesEndPosition) {
  let position = triangleIndicesEndPosition;
  const elementsPerVertex = 3;
  const vertexCount = vertexData.length / elementsPerVertex;
  const bytesPerIndex = vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;
  const westVertexCount = dataView.getUint32(position, true);
  position += Uint32Array.BYTES_PER_ELEMENT;
  const westIndices = decodeIndex(dataView.buffer, position, westVertexCount, bytesPerIndex, false);
  position += westVertexCount * bytesPerIndex;
  const southVertexCount = dataView.getUint32(position, true);
  position += Uint32Array.BYTES_PER_ELEMENT;
  const southIndices = decodeIndex(dataView.buffer, position, southVertexCount, bytesPerIndex, false);
  position += southVertexCount * bytesPerIndex;
  const eastVertexCount = dataView.getUint32(position, true);
  position += Uint32Array.BYTES_PER_ELEMENT;
  const eastIndices = decodeIndex(dataView.buffer, position, eastVertexCount, bytesPerIndex, false);
  position += eastVertexCount * bytesPerIndex;
  const northVertexCount = dataView.getUint32(position, true);
  position += Uint32Array.BYTES_PER_ELEMENT;
  const northIndices = decodeIndex(dataView.buffer, position, northVertexCount, bytesPerIndex, false);
  position += northVertexCount * bytesPerIndex;
  return {
    edgeIndicesEndPosition: position,
    westIndices,
    southIndices,
    eastIndices,
    northIndices
  };
}
function decodeVertexNormalsExtension(extensionDataView) {
  return new Uint8Array(extensionDataView.buffer, extensionDataView.byteOffset, extensionDataView.byteLength);
}
function decodeWaterMaskExtension(extensionDataView) {
  return extensionDataView.buffer.slice(extensionDataView.byteOffset, extensionDataView.byteOffset + extensionDataView.byteLength);
}
function decodeExtensions(dataView, indicesEndPosition) {
  const extensions = {};
  if (dataView.byteLength <= indicesEndPosition) {
    return { extensions, extensionsEndPosition: indicesEndPosition };
  }
  let position = indicesEndPosition;
  while (position < dataView.byteLength) {
    const extensionId = dataView.getUint8(position, true);
    position += Uint8Array.BYTES_PER_ELEMENT;
    const extensionLength = dataView.getUint32(position, true);
    position += Uint32Array.BYTES_PER_ELEMENT;
    const extensionView = new DataView(dataView.buffer, position, extensionLength);
    switch (extensionId) {
      case 1: {
        extensions.vertexNormals = decodeVertexNormalsExtension(extensionView);
        break;
      }
      case 2: {
        extensions.waterMask = decodeWaterMaskExtension(extensionView);
        break;
      }
      default: {
      }
    }
    position += extensionLength;
  }
  return { extensions, extensionsEndPosition: position };
}
var DECODING_STEPS = {
  header: 0,
  vertices: 1,
  triangleIndices: 2,
  edgeIndices: 3,
  extensions: 4
};
var DEFAULT_OPTIONS = {
  maxDecodingStep: DECODING_STEPS.extensions
};
function decode(data, userOptions) {
  const options = Object.assign({}, DEFAULT_OPTIONS, userOptions);
  const view = new DataView(data);
  const { header, headerEndPosition } = decodeHeader(view);
  if (options.maxDecodingStep < DECODING_STEPS.vertices) {
    return { header };
  }
  const { vertexData, vertexDataEndPosition } = decodeVertexData(view, headerEndPosition);
  if (options.maxDecodingStep < DECODING_STEPS.triangleIndices) {
    return { header, vertexData };
  }
  const { triangleIndices, triangleIndicesEndPosition } = decodeTriangleIndices(view, vertexData, vertexDataEndPosition);
  if (options.maxDecodingStep < DECODING_STEPS.edgeIndices) {
    return { header, vertexData, triangleIndices };
  }
  const { westIndices, southIndices, eastIndices, northIndices, edgeIndicesEndPosition } = decodeEdgeIndices(view, vertexData, triangleIndicesEndPosition);
  if (options.maxDecodingStep < DECODING_STEPS.extensions) {
    return {
      header,
      vertexData,
      triangleIndices,
      westIndices,
      northIndices,
      eastIndices,
      southIndices
    };
  }
  const { extensions } = decodeExtensions(view, edgeIndicesEndPosition);
  return {
    header,
    vertexData,
    triangleIndices,
    westIndices,
    northIndices,
    eastIndices,
    southIndices,
    extensions
  };
}

// node_modules/@loaders.gl/terrain/dist/lib/helpers/skirt.js
function addSkirt(attributes, triangles, skirtHeight, outsideIndices) {
  const outsideEdges = outsideIndices ? getOutsideEdgesFromIndices(outsideIndices, attributes.POSITION.value) : getOutsideEdgesFromTriangles(triangles);
  const newPosition = new attributes.POSITION.value.constructor(outsideEdges.length * 6);
  const newTexcoord0 = new attributes.TEXCOORD_0.value.constructor(outsideEdges.length * 4);
  const newTriangles = new triangles.constructor(outsideEdges.length * 6);
  for (let i = 0; i < outsideEdges.length; i++) {
    const edge = outsideEdges[i];
    updateAttributesForNewEdge({
      edge,
      edgeIndex: i,
      attributes,
      skirtHeight,
      newPosition,
      newTexcoord0,
      newTriangles
    });
  }
  attributes.POSITION.value = concatenateTypedArrays(attributes.POSITION.value, newPosition);
  attributes.TEXCOORD_0.value = concatenateTypedArrays(attributes.TEXCOORD_0.value, newTexcoord0);
  const resultTriangles = triangles instanceof Array ? triangles.concat(newTriangles) : concatenateTypedArrays(triangles, newTriangles);
  return {
    attributes,
    triangles: resultTriangles
  };
}
function getOutsideEdgesFromTriangles(triangles) {
  var _a, _b;
  const edges = [];
  for (let i = 0; i < triangles.length; i += 3) {
    edges.push([triangles[i], triangles[i + 1]]);
    edges.push([triangles[i + 1], triangles[i + 2]]);
    edges.push([triangles[i + 2], triangles[i]]);
  }
  edges.sort((a2, b2) => Math.min(...a2) - Math.min(...b2) || Math.max(...a2) - Math.max(...b2));
  const outsideEdges = [];
  let index = 0;
  while (index < edges.length) {
    if (edges[index][0] === ((_a = edges[index + 1]) == null ? void 0 : _a[1]) && edges[index][1] === ((_b = edges[index + 1]) == null ? void 0 : _b[0])) {
      index += 2;
    } else {
      outsideEdges.push(edges[index]);
      index++;
    }
  }
  return outsideEdges;
}
function getOutsideEdgesFromIndices(indices, position) {
  indices.westIndices.sort((a2, b2) => position[3 * a2 + 1] - position[3 * b2 + 1]);
  indices.eastIndices.sort((a2, b2) => position[3 * b2 + 1] - position[3 * a2 + 1]);
  indices.southIndices.sort((a2, b2) => position[3 * b2] - position[3 * a2]);
  indices.northIndices.sort((a2, b2) => position[3 * a2] - position[3 * b2]);
  const edges = [];
  for (const index in indices) {
    const indexGroup = indices[index];
    for (let i = 0; i < indexGroup.length - 1; i++) {
      edges.push([indexGroup[i], indexGroup[i + 1]]);
    }
  }
  return edges;
}
function updateAttributesForNewEdge({ edge, edgeIndex, attributes, skirtHeight, newPosition, newTexcoord0, newTriangles }) {
  const positionsLength = attributes.POSITION.value.length;
  const vertex1Offset = edgeIndex * 2;
  const vertex2Offset = edgeIndex * 2 + 1;
  newPosition.set(attributes.POSITION.value.subarray(edge[0] * 3, edge[0] * 3 + 3), vertex1Offset * 3);
  newPosition[vertex1Offset * 3 + 2] = newPosition[vertex1Offset * 3 + 2] - skirtHeight;
  newPosition.set(attributes.POSITION.value.subarray(edge[1] * 3, edge[1] * 3 + 3), vertex2Offset * 3);
  newPosition[vertex2Offset * 3 + 2] = newPosition[vertex2Offset * 3 + 2] - skirtHeight;
  newTexcoord0.set(attributes.TEXCOORD_0.value.subarray(edge[0] * 2, edge[0] * 2 + 2), vertex1Offset * 2);
  newTexcoord0.set(attributes.TEXCOORD_0.value.subarray(edge[1] * 2, edge[1] * 2 + 2), vertex2Offset * 2);
  const triangle1Offset = edgeIndex * 2 * 3;
  newTriangles[triangle1Offset] = edge[0];
  newTriangles[triangle1Offset + 1] = positionsLength / 3 + vertex2Offset;
  newTriangles[triangle1Offset + 2] = edge[1];
  newTriangles[triangle1Offset + 3] = positionsLength / 3 + vertex2Offset;
  newTriangles[triangle1Offset + 4] = edge[0];
  newTriangles[triangle1Offset + 5] = positionsLength / 3 + vertex1Offset;
}

// node_modules/@loaders.gl/terrain/dist/lib/parse-quantized-mesh.js
function parseQuantizedMesh(arrayBuffer, options = {}) {
  const { bounds } = options;
  const { header, vertexData, triangleIndices: originalTriangleIndices, westIndices, northIndices, eastIndices, southIndices } = decode(arrayBuffer, DECODING_STEPS.triangleIndices);
  let triangleIndices = originalTriangleIndices;
  let attributes = getMeshAttributes(vertexData, header, bounds);
  const boundingBox = getMeshBoundingBox(attributes);
  if (options == null ? void 0 : options.skirtHeight) {
    const { attributes: newAttributes, triangles: newTriangles } = addSkirt(attributes, triangleIndices, options.skirtHeight, {
      westIndices,
      northIndices,
      eastIndices,
      southIndices
    });
    attributes = newAttributes;
    triangleIndices = newTriangles;
  }
  return {
    // Data return by this loader implementation
    loaderData: {
      header: {}
    },
    header: {
      // @ts-ignore
      vertexCount: triangleIndices.length,
      boundingBox
    },
    // TODO
    schema: void 0,
    topology: "triangle-list",
    mode: 4,
    // TRIANGLES
    indices: { value: triangleIndices, size: 1 },
    attributes
  };
}
function getMeshAttributes(vertexData, header, bounds) {
  const { minHeight, maxHeight } = header;
  const [minX, minY, maxX, maxY] = bounds || [0, 0, 1, 1];
  const xScale = maxX - minX;
  const yScale = maxY - minY;
  const zScale = maxHeight - minHeight;
  const nCoords = vertexData.length / 3;
  const positions = new Float32Array(nCoords * 3);
  const texCoords = new Float32Array(nCoords * 2);
  for (let i = 0; i < nCoords; i++) {
    const x = vertexData[i] / 32767;
    const y = vertexData[i + nCoords] / 32767;
    const z = vertexData[i + nCoords * 2] / 32767;
    positions[3 * i + 0] = x * xScale + minX;
    positions[3 * i + 1] = y * yScale + minY;
    positions[3 * i + 2] = z * zScale + minHeight;
    texCoords[2 * i + 0] = x;
    texCoords[2 * i + 1] = y;
  }
  return {
    POSITION: { value: positions, size: 3 },
    TEXCOORD_0: { value: texCoords, size: 2 }
    // TODO: Parse normals if they exist in the file
    // NORMAL: {}, - optional, but creates the high poly look with lighting
  };
}

// node_modules/@mapbox/martini/index.js
var Martini = class {
  constructor(gridSize = 257) {
    this.gridSize = gridSize;
    const tileSize = gridSize - 1;
    if (tileSize & tileSize - 1) throw new Error(
      `Expected grid size to be 2^n+1, got ${gridSize}.`
    );
    this.numTriangles = tileSize * tileSize * 2 - 2;
    this.numParentTriangles = this.numTriangles - tileSize * tileSize;
    this.indices = new Uint32Array(this.gridSize * this.gridSize);
    this.coords = new Uint16Array(this.numTriangles * 4);
    for (let i = 0; i < this.numTriangles; i++) {
      let id = i + 2;
      let ax = 0, ay = 0, bx = 0, by = 0, cx = 0, cy = 0;
      if (id & 1) {
        bx = by = cx = tileSize;
      } else {
        ax = ay = cy = tileSize;
      }
      while ((id >>= 1) > 1) {
        const mx = ax + bx >> 1;
        const my = ay + by >> 1;
        if (id & 1) {
          bx = ax;
          by = ay;
          ax = cx;
          ay = cy;
        } else {
          ax = bx;
          ay = by;
          bx = cx;
          by = cy;
        }
        cx = mx;
        cy = my;
      }
      const k = i * 4;
      this.coords[k + 0] = ax;
      this.coords[k + 1] = ay;
      this.coords[k + 2] = bx;
      this.coords[k + 3] = by;
    }
  }
  createTile(terrain) {
    return new Tile(terrain, this);
  }
};
var Tile = class {
  constructor(terrain, martini) {
    const size = martini.gridSize;
    if (terrain.length !== size * size) throw new Error(
      `Expected terrain data of length ${size * size} (${size} x ${size}), got ${terrain.length}.`
    );
    this.terrain = terrain;
    this.martini = martini;
    this.errors = new Float32Array(terrain.length);
    this.update();
  }
  update() {
    const { numTriangles, numParentTriangles, coords, gridSize: size } = this.martini;
    const { terrain, errors } = this;
    for (let i = numTriangles - 1; i >= 0; i--) {
      const k = i * 4;
      const ax = coords[k + 0];
      const ay = coords[k + 1];
      const bx = coords[k + 2];
      const by = coords[k + 3];
      const mx = ax + bx >> 1;
      const my = ay + by >> 1;
      const cx = mx + my - ay;
      const cy = my + ax - mx;
      const interpolatedHeight = (terrain[ay * size + ax] + terrain[by * size + bx]) / 2;
      const middleIndex = my * size + mx;
      const middleError = Math.abs(interpolatedHeight - terrain[middleIndex]);
      errors[middleIndex] = Math.max(errors[middleIndex], middleError);
      if (i < numParentTriangles) {
        const leftChildIndex = (ay + cy >> 1) * size + (ax + cx >> 1);
        const rightChildIndex = (by + cy >> 1) * size + (bx + cx >> 1);
        errors[middleIndex] = Math.max(errors[middleIndex], errors[leftChildIndex], errors[rightChildIndex]);
      }
    }
  }
  getMesh(maxError = 0) {
    const { gridSize: size, indices } = this.martini;
    const { errors } = this;
    let numVertices = 0;
    let numTriangles = 0;
    const max3 = size - 1;
    indices.fill(0);
    function countElements(ax, ay, bx, by, cx, cy) {
      const mx = ax + bx >> 1;
      const my = ay + by >> 1;
      if (Math.abs(ax - cx) + Math.abs(ay - cy) > 1 && errors[my * size + mx] > maxError) {
        countElements(cx, cy, ax, ay, mx, my);
        countElements(bx, by, cx, cy, mx, my);
      } else {
        indices[ay * size + ax] = indices[ay * size + ax] || ++numVertices;
        indices[by * size + bx] = indices[by * size + bx] || ++numVertices;
        indices[cy * size + cx] = indices[cy * size + cx] || ++numVertices;
        numTriangles++;
      }
    }
    countElements(0, 0, max3, max3, max3, 0);
    countElements(max3, max3, 0, 0, 0, max3);
    const vertices = new Uint16Array(numVertices * 2);
    const triangles = new Uint32Array(numTriangles * 3);
    let triIndex = 0;
    function processTriangle(ax, ay, bx, by, cx, cy) {
      const mx = ax + bx >> 1;
      const my = ay + by >> 1;
      if (Math.abs(ax - cx) + Math.abs(ay - cy) > 1 && errors[my * size + mx] > maxError) {
        processTriangle(cx, cy, ax, ay, mx, my);
        processTriangle(bx, by, cx, cy, mx, my);
      } else {
        const a2 = indices[ay * size + ax] - 1;
        const b2 = indices[by * size + bx] - 1;
        const c2 = indices[cy * size + cx] - 1;
        vertices[2 * a2] = ax;
        vertices[2 * a2 + 1] = ay;
        vertices[2 * b2] = bx;
        vertices[2 * b2 + 1] = by;
        vertices[2 * c2] = cx;
        vertices[2 * c2 + 1] = cy;
        triangles[triIndex++] = a2;
        triangles[triIndex++] = b2;
        triangles[triIndex++] = c2;
      }
    }
    processTriangle(0, 0, max3, max3, max3, 0);
    processTriangle(max3, max3, 0, 0, 0, max3);
    return { vertices, triangles };
  }
};

// node_modules/@loaders.gl/terrain/dist/lib/delatin/index.js
var Delatin = class {
  constructor(data, width, height = width) {
    this.data = data;
    this.width = width;
    this.height = height;
    this.coords = [];
    this.triangles = [];
    this._halfedges = [];
    this._candidates = [];
    this._queueIndices = [];
    this._queue = [];
    this._errors = [];
    this._rms = [];
    this._pending = [];
    this._pendingLen = 0;
    this._rmsSum = 0;
    const x1 = width - 1;
    const y1 = height - 1;
    const p0 = this._addPoint(0, 0);
    const p1 = this._addPoint(x1, 0);
    const p2 = this._addPoint(0, y1);
    const p3 = this._addPoint(x1, y1);
    const t0 = this._addTriangle(p3, p0, p2, -1, -1, -1);
    this._addTriangle(p0, p3, p1, t0, -1, -1);
    this._flush();
  }
  // refine the mesh until its maximum error gets below the given one
  run(maxError = 1) {
    while (this.getMaxError() > maxError) {
      this.refine();
    }
  }
  // refine the mesh with a single point
  refine() {
    this._step();
    this._flush();
  }
  // max error of the current mesh
  getMaxError() {
    return this._errors[0];
  }
  // root-mean-square deviation of the current mesh
  getRMSD() {
    return this._rmsSum > 0 ? Math.sqrt(this._rmsSum / (this.width * this.height)) : 0;
  }
  // height value at a given position
  heightAt(x, y) {
    return this.data[this.width * y + x];
  }
  // rasterize and queue all triangles that got added or updated in _step
  _flush() {
    const coords = this.coords;
    for (let i = 0; i < this._pendingLen; i++) {
      const t = this._pending[i];
      const a2 = 2 * this.triangles[t * 3 + 0];
      const b2 = 2 * this.triangles[t * 3 + 1];
      const c2 = 2 * this.triangles[t * 3 + 2];
      this._findCandidate(coords[a2], coords[a2 + 1], coords[b2], coords[b2 + 1], coords[c2], coords[c2 + 1], t);
    }
    this._pendingLen = 0;
  }
  // rasterize a triangle, find its max error, and queue it for processing
  _findCandidate(p0x, p0y, p1x, p1y, p2x, p2y, t) {
    const minX = Math.min(p0x, p1x, p2x);
    const minY = Math.min(p0y, p1y, p2y);
    const maxX = Math.max(p0x, p1x, p2x);
    const maxY = Math.max(p0y, p1y, p2y);
    let w00 = orient(p1x, p1y, p2x, p2y, minX, minY);
    let w01 = orient(p2x, p2y, p0x, p0y, minX, minY);
    let w02 = orient(p0x, p0y, p1x, p1y, minX, minY);
    const a01 = p1y - p0y;
    const b01 = p0x - p1x;
    const a12 = p2y - p1y;
    const b12 = p1x - p2x;
    const a20 = p0y - p2y;
    const b20 = p2x - p0x;
    const a2 = orient(p0x, p0y, p1x, p1y, p2x, p2y);
    const z0 = this.heightAt(p0x, p0y) / a2;
    const z1 = this.heightAt(p1x, p1y) / a2;
    const z2 = this.heightAt(p2x, p2y) / a2;
    let maxError = 0;
    let mx = 0;
    let my = 0;
    let rms = 0;
    for (let y = minY; y <= maxY; y++) {
      let dx = 0;
      if (w00 < 0 && a12 !== 0) {
        dx = Math.max(dx, Math.floor(-w00 / a12));
      }
      if (w01 < 0 && a20 !== 0) {
        dx = Math.max(dx, Math.floor(-w01 / a20));
      }
      if (w02 < 0 && a01 !== 0) {
        dx = Math.max(dx, Math.floor(-w02 / a01));
      }
      let w0 = w00 + a12 * dx;
      let w1 = w01 + a20 * dx;
      let w2 = w02 + a01 * dx;
      let wasInside = false;
      for (let x = minX + dx; x <= maxX; x++) {
        if (w0 >= 0 && w1 >= 0 && w2 >= 0) {
          wasInside = true;
          const z = z0 * w0 + z1 * w1 + z2 * w2;
          const dz = Math.abs(z - this.heightAt(x, y));
          rms += dz * dz;
          if (dz > maxError) {
            maxError = dz;
            mx = x;
            my = y;
          }
        } else if (wasInside) {
          break;
        }
        w0 += a12;
        w1 += a20;
        w2 += a01;
      }
      w00 += b12;
      w01 += b20;
      w02 += b01;
    }
    if (mx === p0x && my === p0y || mx === p1x && my === p1y || mx === p2x && my === p2y) {
      maxError = 0;
    }
    this._candidates[2 * t] = mx;
    this._candidates[2 * t + 1] = my;
    this._rms[t] = rms;
    this._queuePush(t, maxError, rms);
  }
  // process the next triangle in the queue, splitting it with a new point
  _step() {
    const t = this._queuePop();
    const e0 = t * 3 + 0;
    const e1 = t * 3 + 1;
    const e2 = t * 3 + 2;
    const p0 = this.triangles[e0];
    const p1 = this.triangles[e1];
    const p2 = this.triangles[e2];
    const ax = this.coords[2 * p0];
    const ay = this.coords[2 * p0 + 1];
    const bx = this.coords[2 * p1];
    const by = this.coords[2 * p1 + 1];
    const cx = this.coords[2 * p2];
    const cy = this.coords[2 * p2 + 1];
    const px = this._candidates[2 * t];
    const py = this._candidates[2 * t + 1];
    const pn = this._addPoint(px, py);
    if (orient(ax, ay, bx, by, px, py) === 0) {
      this._handleCollinear(pn, e0);
    } else if (orient(bx, by, cx, cy, px, py) === 0) {
      this._handleCollinear(pn, e1);
    } else if (orient(cx, cy, ax, ay, px, py) === 0) {
      this._handleCollinear(pn, e2);
    } else {
      const h0 = this._halfedges[e0];
      const h1 = this._halfedges[e1];
      const h2 = this._halfedges[e2];
      const t0 = this._addTriangle(p0, p1, pn, h0, -1, -1, e0);
      const t1 = this._addTriangle(p1, p2, pn, h1, -1, t0 + 1);
      const t2 = this._addTriangle(p2, p0, pn, h2, t0 + 2, t1 + 1);
      this._legalize(t0);
      this._legalize(t1);
      this._legalize(t2);
    }
  }
  // add coordinates for a new vertex
  _addPoint(x, y) {
    const i = this.coords.length >> 1;
    this.coords.push(x, y);
    return i;
  }
  // add or update a triangle in the mesh
  _addTriangle(a2, b2, c2, ab, bc, ca, e2 = this.triangles.length) {
    const t = e2 / 3;
    this.triangles[e2 + 0] = a2;
    this.triangles[e2 + 1] = b2;
    this.triangles[e2 + 2] = c2;
    this._halfedges[e2 + 0] = ab;
    this._halfedges[e2 + 1] = bc;
    this._halfedges[e2 + 2] = ca;
    if (ab >= 0) {
      this._halfedges[ab] = e2 + 0;
    }
    if (bc >= 0) {
      this._halfedges[bc] = e2 + 1;
    }
    if (ca >= 0) {
      this._halfedges[ca] = e2 + 2;
    }
    this._candidates[2 * t + 0] = 0;
    this._candidates[2 * t + 1] = 0;
    this._queueIndices[t] = -1;
    this._rms[t] = 0;
    this._pending[this._pendingLen++] = t;
    return e2;
  }
  _legalize(a2) {
    const b2 = this._halfedges[a2];
    if (b2 < 0) {
      return;
    }
    const a0 = a2 - a2 % 3;
    const b0 = b2 - b2 % 3;
    const al = a0 + (a2 + 1) % 3;
    const ar = a0 + (a2 + 2) % 3;
    const bl = b0 + (b2 + 2) % 3;
    const br = b0 + (b2 + 1) % 3;
    const p0 = this.triangles[ar];
    const pr = this.triangles[a2];
    const pl = this.triangles[al];
    const p1 = this.triangles[bl];
    const coords = this.coords;
    if (!inCircle(coords[2 * p0], coords[2 * p0 + 1], coords[2 * pr], coords[2 * pr + 1], coords[2 * pl], coords[2 * pl + 1], coords[2 * p1], coords[2 * p1 + 1])) {
      return;
    }
    const hal = this._halfedges[al];
    const har = this._halfedges[ar];
    const hbl = this._halfedges[bl];
    const hbr = this._halfedges[br];
    this._queueRemove(a0 / 3);
    this._queueRemove(b0 / 3);
    const t0 = this._addTriangle(p0, p1, pl, -1, hbl, hal, a0);
    const t1 = this._addTriangle(p1, p0, pr, t0, har, hbr, b0);
    this._legalize(t0 + 1);
    this._legalize(t1 + 2);
  }
  // handle a case where new vertex is on the edge of a triangle
  _handleCollinear(pn, a2) {
    const a0 = a2 - a2 % 3;
    const al = a0 + (a2 + 1) % 3;
    const ar = a0 + (a2 + 2) % 3;
    const p0 = this.triangles[ar];
    const pr = this.triangles[a2];
    const pl = this.triangles[al];
    const hal = this._halfedges[al];
    const har = this._halfedges[ar];
    const b2 = this._halfedges[a2];
    if (b2 < 0) {
      const t02 = this._addTriangle(pn, p0, pr, -1, har, -1, a0);
      const t12 = this._addTriangle(p0, pn, pl, t02, -1, hal);
      this._legalize(t02 + 1);
      this._legalize(t12 + 2);
      return;
    }
    const b0 = b2 - b2 % 3;
    const bl = b0 + (b2 + 2) % 3;
    const br = b0 + (b2 + 1) % 3;
    const p1 = this.triangles[bl];
    const hbl = this._halfedges[bl];
    const hbr = this._halfedges[br];
    this._queueRemove(b0 / 3);
    const t0 = this._addTriangle(p0, pr, pn, har, -1, -1, a0);
    const t1 = this._addTriangle(pr, p1, pn, hbr, -1, t0 + 1, b0);
    const t2 = this._addTriangle(p1, pl, pn, hbl, -1, t1 + 1);
    const t3 = this._addTriangle(pl, p0, pn, hal, t0 + 2, t2 + 1);
    this._legalize(t0);
    this._legalize(t1);
    this._legalize(t2);
    this._legalize(t3);
  }
  // priority queue methods
  _queuePush(t, error, rms) {
    const i = this._queue.length;
    this._queueIndices[t] = i;
    this._queue.push(t);
    this._errors.push(error);
    this._rmsSum += rms;
    this._queueUp(i);
  }
  _queuePop() {
    const n = this._queue.length - 1;
    this._queueSwap(0, n);
    this._queueDown(0, n);
    return this._queuePopBack();
  }
  _queuePopBack() {
    const t = this._queue.pop();
    this._errors.pop();
    this._rmsSum -= this._rms[t];
    this._queueIndices[t] = -1;
    return t;
  }
  _queueRemove(t) {
    const i = this._queueIndices[t];
    if (i < 0) {
      const it = this._pending.indexOf(t);
      if (it !== -1) {
        this._pending[it] = this._pending[--this._pendingLen];
      } else {
        throw new Error("Broken triangulation (something went wrong).");
      }
      return;
    }
    const n = this._queue.length - 1;
    if (n !== i) {
      this._queueSwap(i, n);
      if (!this._queueDown(i, n)) {
        this._queueUp(i);
      }
    }
    this._queuePopBack();
  }
  _queueLess(i, j) {
    return this._errors[i] > this._errors[j];
  }
  _queueSwap(i, j) {
    const pi = this._queue[i];
    const pj = this._queue[j];
    this._queue[i] = pj;
    this._queue[j] = pi;
    this._queueIndices[pi] = j;
    this._queueIndices[pj] = i;
    const e2 = this._errors[i];
    this._errors[i] = this._errors[j];
    this._errors[j] = e2;
  }
  _queueUp(j0) {
    let j = j0;
    while (true) {
      const i = j - 1 >> 1;
      if (i === j || !this._queueLess(j, i)) {
        break;
      }
      this._queueSwap(i, j);
      j = i;
    }
  }
  _queueDown(i0, n) {
    let i = i0;
    while (true) {
      const j1 = 2 * i + 1;
      if (j1 >= n || j1 < 0) {
        break;
      }
      const j2 = j1 + 1;
      let j = j1;
      if (j2 < n && this._queueLess(j2, j1)) {
        j = j2;
      }
      if (!this._queueLess(j, i)) {
        break;
      }
      this._queueSwap(i, j);
      i = j;
    }
    return i > i0;
  }
};
function orient(ax, ay, bx, by, cx, cy) {
  return (bx - cx) * (ay - cy) - (by - cy) * (ax - cx);
}
function inCircle(ax, ay, bx, by, cx, cy, px, py) {
  const dx = ax - px;
  const dy = ay - py;
  const ex = bx - px;
  const ey = by - py;
  const fx = cx - px;
  const fy = cy - py;
  const ap = dx * dx + dy * dy;
  const bp = ex * ex + ey * ey;
  const cp = fx * fx + fy * fy;
  return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;
}

// node_modules/@loaders.gl/terrain/dist/lib/parse-terrain.js
function makeTerrainMeshFromImage(terrainImage, terrainOptions) {
  const { meshMaxError, bounds, elevationDecoder } = terrainOptions;
  const { data, width, height } = terrainImage;
  let terrain;
  let mesh;
  switch (terrainOptions.tesselator) {
    case "martini":
      terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);
      mesh = getMartiniTileMesh(meshMaxError, width, terrain);
      break;
    case "delatin":
      terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);
      mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);
      break;
    // auto
    default:
      if (width === height && !(height & width - 1)) {
        terrain = getTerrain(data, width, height, elevationDecoder, "martini");
        mesh = getMartiniTileMesh(meshMaxError, width, terrain);
      } else {
        terrain = getTerrain(data, width, height, elevationDecoder, "delatin");
        mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);
      }
      break;
  }
  const { vertices } = mesh;
  let { triangles } = mesh;
  let attributes = getMeshAttributes2(vertices, terrain, width, height, bounds);
  const boundingBox = getMeshBoundingBox(attributes);
  if (terrainOptions.skirtHeight) {
    const { attributes: newAttributes, triangles: newTriangles } = addSkirt(attributes, triangles, terrainOptions.skirtHeight);
    attributes = newAttributes;
    triangles = newTriangles;
  }
  return {
    // Data return by this loader implementation
    loaderData: {
      header: {}
    },
    header: {
      vertexCount: triangles.length,
      boundingBox
    },
    mode: 4,
    // TRIANGLES
    indices: { value: Uint32Array.from(triangles), size: 1 },
    attributes
  };
}
function getMartiniTileMesh(meshMaxError, width, terrain) {
  const gridSize = width + 1;
  const martini = new Martini(gridSize);
  const tile = martini.createTile(terrain);
  const { vertices, triangles } = tile.getMesh(meshMaxError);
  return { vertices, triangles };
}
function getDelatinTileMesh(meshMaxError, width, height, terrain) {
  const tin = new Delatin(terrain, width + 1, height + 1);
  tin.run(meshMaxError);
  const { coords, triangles } = tin;
  const vertices = coords;
  return { vertices, triangles };
}
function getTerrain(imageData, width, height, elevationDecoder, tesselator) {
  const { rScaler, bScaler, gScaler, offset } = elevationDecoder;
  const terrain = new Float32Array((width + 1) * (height + 1));
  for (let i = 0, y = 0; y < height; y++) {
    for (let x = 0; x < width; x++, i++) {
      const k = i * 4;
      const r = imageData[k + 0];
      const g = imageData[k + 1];
      const b2 = imageData[k + 2];
      terrain[i + y] = r * rScaler + g * gScaler + b2 * bScaler + offset;
    }
  }
  if (tesselator === "martini") {
    for (let i = (width + 1) * width, x = 0; x < width; x++, i++) {
      terrain[i] = terrain[i - width - 1];
    }
    for (let i = height, y = 0; y < height + 1; y++, i += height + 1) {
      terrain[i] = terrain[i - 1];
    }
  }
  return terrain;
}
function getMeshAttributes2(vertices, terrain, width, height, bounds) {
  const gridSize = width + 1;
  const numOfVerticies = vertices.length / 2;
  const positions = new Float32Array(numOfVerticies * 3);
  const texCoords = new Float32Array(numOfVerticies * 2);
  const [minX, minY, maxX, maxY] = bounds || [0, 0, width, height];
  const xScale = (maxX - minX) / width;
  const yScale = (maxY - minY) / height;
  for (let i = 0; i < numOfVerticies; i++) {
    const x = vertices[i * 2];
    const y = vertices[i * 2 + 1];
    const pixelIdx = y * gridSize + x;
    positions[3 * i + 0] = x * xScale + minX;
    positions[3 * i + 1] = -y * yScale + maxY;
    positions[3 * i + 2] = terrain[pixelIdx];
    texCoords[2 * i + 0] = x / width;
    texCoords[2 * i + 1] = y / height;
  }
  return {
    POSITION: { value: positions, size: 3 },
    TEXCOORD_0: { value: texCoords, size: 2 }
    // NORMAL: {}, - optional, but creates the high poly look with lighting
  };
}

// node_modules/@loaders.gl/terrain/dist/lib/utils/version.js
var VERSION4 = true ? "4.3.3" : "latest";

// node_modules/@loaders.gl/terrain/dist/terrain-loader.js
var TerrainLoader = {
  dataType: null,
  batchType: null,
  name: "Terrain",
  id: "terrain",
  module: "terrain",
  version: VERSION4,
  worker: true,
  extensions: ["png", "pngraw", "jpg", "jpeg", "gif", "webp", "bmp"],
  mimeTypes: ["image/png", "image/jpeg", "image/gif", "image/webp", "image/bmp"],
  options: {
    terrain: {
      tesselator: "auto",
      bounds: void 0,
      meshMaxError: 10,
      elevationDecoder: {
        rScaler: 1,
        gScaler: 0,
        bScaler: 0,
        offset: 0
      },
      skirtHeight: void 0
    }
  }
};

// node_modules/@loaders.gl/terrain/dist/quantized-mesh-loader.js
var QuantizedMeshLoader = {
  dataType: null,
  // Mesh,
  batchType: null,
  name: "Quantized Mesh",
  id: "quantized-mesh",
  module: "terrain",
  version: VERSION4,
  worker: true,
  extensions: ["terrain"],
  mimeTypes: ["application/vnd.quantized-mesh"],
  options: {
    "quantized-mesh": {
      bounds: [0, 0, 1, 1],
      skirtHeight: null
    }
  }
};

// node_modules/@loaders.gl/terrain/dist/index.js
var TerrainLoader2 = {
  ...TerrainLoader,
  parse: parseTerrain
};
async function parseTerrain(arrayBuffer, options, context) {
  const loadImageOptions = {
    ...options,
    mimeType: "application/x.image",
    image: { ...options == null ? void 0 : options.image, type: "data" }
  };
  const image = await parseFromContext(arrayBuffer, [], loadImageOptions, context);
  const terrainOptions = { ...TerrainLoader2.options.terrain, ...options == null ? void 0 : options.terrain };
  return makeTerrainMeshFromImage(image, terrainOptions);
}
var QuantizedMeshLoader2 = {
  ...QuantizedMeshLoader,
  parseSync: (arrayBuffer, options) => parseQuantizedMesh(arrayBuffer, options == null ? void 0 : options["quantized-mesh"]),
  parse: async (arrayBuffer, options) => parseQuantizedMesh(arrayBuffer, options == null ? void 0 : options["quantized-mesh"])
};

// node_modules/@deck.gl/geo-layers/dist/terrain-layer/terrain-layer.js
var DUMMY_DATA = [1];
var defaultProps30 = {
  ...tile_layer_default.defaultProps,
  // Image url that encodes height data
  elevationData: urlType,
  // Image url to use as texture
  texture: { ...urlType, optional: true },
  // Martini error tolerance in meters, smaller number -> more detailed mesh
  meshMaxError: { type: "number", value: 4 },
  // Bounding box of the terrain image, [minX, minY, maxX, maxY] in world coordinates
  bounds: { type: "array", value: null, optional: true, compare: true },
  // Color to use if texture is unavailable
  color: { type: "color", value: [255, 255, 255] },
  // Object to decode height data, from (r, g, b) to height in meters
  elevationDecoder: {
    type: "object",
    value: {
      rScaler: 1,
      gScaler: 0,
      bScaler: 0,
      offset: 0
    }
  },
  // Supply url to local terrain worker bundle. Only required if running offline and cannot access CDN.
  workerUrl: "",
  // Same as SimpleMeshLayer wireframe
  wireframe: false,
  material: true,
  loaders: [TerrainLoader]
};
function urlTemplateToUpdateTrigger(template) {
  if (Array.isArray(template)) {
    return template.join(";");
  }
  return template || "";
}
var TerrainLayer = class extends composite_layer_default {
  updateState({ props, oldProps }) {
    const elevationDataChanged = props.elevationData !== oldProps.elevationData;
    if (elevationDataChanged) {
      const { elevationData } = props;
      const isTiled = elevationData && (Array.isArray(elevationData) || isTileSetURL(elevationData));
      this.setState({ isTiled });
    }
    const shouldReload = elevationDataChanged || props.meshMaxError !== oldProps.meshMaxError || props.elevationDecoder !== oldProps.elevationDecoder || props.bounds !== oldProps.bounds;
    if (!this.state.isTiled && shouldReload) {
      const terrain = this.loadTerrain(props);
      this.setState({ terrain });
    }
    if (props.workerUrl) {
      log_default.removed("workerUrl", "loadOptions.terrain.workerUrl")();
    }
  }
  loadTerrain({ elevationData, bounds, elevationDecoder, meshMaxError, signal }) {
    if (!elevationData) {
      return null;
    }
    let loadOptions = this.getLoadOptions();
    loadOptions = {
      ...loadOptions,
      terrain: {
        skirtHeight: this.state.isTiled ? meshMaxError * 2 : 0,
        ...loadOptions == null ? void 0 : loadOptions.terrain,
        bounds,
        meshMaxError,
        elevationDecoder
      }
    };
    const { fetch: fetch2 } = this.props;
    return fetch2(elevationData, { propName: "elevationData", layer: this, loadOptions, signal });
  }
  getTiledTerrainData(tile) {
    const { elevationData, fetch: fetch2, texture, elevationDecoder, meshMaxError } = this.props;
    const { viewport } = this.context;
    const dataUrl = getURLFromTemplate(elevationData, tile);
    const textureUrl = texture && getURLFromTemplate(texture, tile);
    const { signal } = tile;
    let bottomLeft = [0, 0];
    let topRight = [0, 0];
    if (viewport.isGeospatial) {
      const bbox = tile.bbox;
      bottomLeft = viewport.projectFlat([bbox.west, bbox.south]);
      topRight = viewport.projectFlat([bbox.east, bbox.north]);
    } else {
      const bbox = tile.bbox;
      bottomLeft = [bbox.left, bbox.bottom];
      topRight = [bbox.right, bbox.top];
    }
    const bounds = [bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]];
    const terrain = this.loadTerrain({
      elevationData: dataUrl,
      bounds,
      elevationDecoder,
      meshMaxError,
      signal
    });
    const surface = textureUrl ? (
      // If surface image fails to load, the tile should still be displayed
      fetch2(textureUrl, { propName: "texture", layer: this, loaders: [], signal }).catch((_) => null)
    ) : Promise.resolve(null);
    return Promise.all([terrain, surface]);
  }
  renderSubLayers(props) {
    const SubLayerClass = this.getSubLayerClass("mesh", simple_mesh_layer_default);
    const { color, wireframe, material } = this.props;
    const { data } = props;
    if (!data) {
      return null;
    }
    const [mesh, texture] = data;
    return new SubLayerClass(props, {
      data: DUMMY_DATA,
      mesh,
      texture,
      _instanced: false,
      coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,
      getPosition: (d2) => [0, 0, 0],
      getColor: color,
      wireframe,
      material
    });
  }
  // Update zRange of viewport
  onViewportLoad(tiles) {
    if (!tiles) {
      return;
    }
    const { zRange } = this.state;
    const ranges = tiles.map((tile) => tile.content).filter(Boolean).map((arr) => {
      const bounds = arr[0].header.boundingBox;
      return bounds.map((bound) => bound[2]);
    });
    if (ranges.length === 0) {
      return;
    }
    const minZ = Math.min(...ranges.map((x) => x[0]));
    const maxZ = Math.max(...ranges.map((x) => x[1]));
    if (!zRange || minZ < zRange[0] || maxZ > zRange[1]) {
      this.setState({ zRange: [minZ, maxZ] });
    }
  }
  renderLayers() {
    const { color, material, elevationData, texture, wireframe, meshMaxError, elevationDecoder, tileSize, maxZoom, minZoom, extent, maxRequests, onTileLoad, onTileUnload, onTileError, maxCacheSize, maxCacheByteSize, refinementStrategy } = this.props;
    if (this.state.isTiled) {
      return new tile_layer_default(this.getSubLayerProps({
        id: "tiles"
      }), {
        getTileData: this.getTiledTerrainData.bind(this),
        renderSubLayers: this.renderSubLayers.bind(this),
        updateTriggers: {
          getTileData: {
            elevationData: urlTemplateToUpdateTrigger(elevationData),
            texture: urlTemplateToUpdateTrigger(texture),
            meshMaxError,
            elevationDecoder
          }
        },
        onViewportLoad: this.onViewportLoad.bind(this),
        zRange: this.state.zRange || null,
        tileSize,
        maxZoom,
        minZoom,
        extent,
        maxRequests,
        onTileLoad,
        onTileUnload,
        onTileError,
        maxCacheSize,
        maxCacheByteSize,
        refinementStrategy
      });
    }
    if (!elevationData) {
      return null;
    }
    const SubLayerClass = this.getSubLayerClass("mesh", simple_mesh_layer_default);
    return new SubLayerClass(this.getSubLayerProps({
      id: "mesh"
    }), {
      data: DUMMY_DATA,
      mesh: this.state.terrain,
      texture,
      _instanced: false,
      getPosition: (d2) => [0, 0, 0],
      getColor: color,
      material,
      wireframe
    });
  }
};
TerrainLayer.defaultProps = defaultProps30;
TerrainLayer.layerName = "TerrainLayer";
var terrain_layer_default = TerrainLayer;
var isTileSetURL = (url) => url.includes("{x}") && (url.includes("{y}") || url.includes("{-y}"));

// node_modules/@deck.gl/extensions/dist/brushing/shader-module.js
var uniformBlock13 = (
  /* glsl */
  `uniform brushingUniforms {
  bool enabled;
  highp int target;
  vec2 mousePos;
  float radius;
} brushing;
`
);
var vertex = (
  /* glsl */
  `
  in vec2 brushingTargets;

  out float brushing_isVisible;

  bool brushing_isPointInRange(vec2 position) {
    if (!brushing.enabled) {
      return true;
    }
    vec2 source_commonspace = project_position(position);
    vec2 target_commonspace = project_position(brushing.mousePos);
    float distance = length((target_commonspace - source_commonspace) / project.commonUnitsPerMeter.xy);

    return distance <= brushing.radius;
  }

  bool brushing_arePointsInRange(vec2 sourcePos, vec2 targetPos) {
    return brushing_isPointInRange(sourcePos) || brushing_isPointInRange(targetPos);
  }

  void brushing_setVisible(bool visible) {
    brushing_isVisible = float(visible);
  }
`
);
var vs2 = `
${uniformBlock13}
${vertex}
`;
var fragment = (
  /* glsl */
  `
  in float brushing_isVisible;
`
);
var fs2 = `
${uniformBlock13}
${fragment}
`;
var TARGET = {
  source: 0,
  target: 1,
  custom: 2,
  source_target: 3
};
var inject = {
  "vs:DECKGL_FILTER_GL_POSITION": (
    /* glsl */
    `
    vec2 brushingTarget;
    vec2 brushingSource;
    if (brushing.target == 3) {
      brushingTarget = geometry.worldPositionAlt.xy;
      brushingSource = geometry.worldPosition.xy;
    } else if (brushing.target == 0) {
      brushingTarget = geometry.worldPosition.xy;
    } else if (brushing.target == 1) {
      brushingTarget = geometry.worldPositionAlt.xy;
    } else {
      brushingTarget = brushingTargets;
    }
    bool visible;
    if (brushing.target == 3) {
      visible = brushing_arePointsInRange(brushingSource, brushingTarget);
    } else {
      visible = brushing_isPointInRange(brushingTarget);
    }
    brushing_setVisible(visible);
  `
  ),
  "fs:DECKGL_FILTER_COLOR": `
    if (brushing.enabled && brushing_isVisible < 0.5) {
      discard;
    }
  `
};
var shader_module_default = {
  name: "brushing",
  dependencies: [project_default],
  vs: vs2,
  fs: fs2,
  inject,
  getUniforms: (opts) => {
    if (!opts || !("viewport" in opts)) {
      return {};
    }
    const { brushingEnabled = true, brushingRadius = 1e4, brushingTarget = "source", mousePosition, viewport } = opts;
    return {
      enabled: Boolean(brushingEnabled && mousePosition && viewport.containsPixel(mousePosition)),
      radius: brushingRadius,
      target: TARGET[brushingTarget] || 0,
      mousePos: mousePosition ? viewport.unproject([mousePosition.x - viewport.x, mousePosition.y - viewport.y]) : [0, 0]
    };
  },
  uniformTypes: {
    enabled: "i32",
    target: "i32",
    mousePos: "vec2<f32>",
    radius: "f32"
  }
};

// node_modules/@deck.gl/extensions/dist/brushing/brushing-extension.js
var defaultProps31 = {
  getBrushingTarget: { type: "accessor", value: [0, 0] },
  brushingTarget: "source",
  brushingEnabled: true,
  brushingRadius: 1e4
};
var BrushingExtension = class extends layer_extension_default {
  getShaders() {
    return {
      modules: [shader_module_default]
    };
  }
  initializeState(context, extension) {
    const attributeManager = this.getAttributeManager();
    if (attributeManager) {
      attributeManager.add({
        brushingTargets: {
          size: 2,
          stepMode: "dynamic",
          accessor: "getBrushingTarget"
        }
      });
    }
    const onMouseMove = () => {
      var _a;
      (_a = this.getCurrentLayer()) == null ? void 0 : _a.setNeedsRedraw();
    };
    this.state.onMouseMove = onMouseMove;
    if (context.deck) {
      context.deck.eventManager.on({
        pointermove: onMouseMove,
        pointerleave: onMouseMove
      });
    }
  }
  finalizeState(context, extension) {
    if (context.deck) {
      const onMouseMove = this.state.onMouseMove;
      context.deck.eventManager.off({
        pointermove: onMouseMove,
        pointerleave: onMouseMove
      });
    }
  }
  draw(params, extension) {
    const { viewport, mousePosition } = params.context;
    const { brushingEnabled, brushingRadius, brushingTarget } = this.props;
    const brushingProps = {
      viewport,
      mousePosition,
      brushingEnabled,
      brushingRadius,
      brushingTarget
    };
    this.setShaderModuleProps({ brushing: brushingProps });
  }
};
BrushingExtension.defaultProps = defaultProps31;
BrushingExtension.extensionName = "BrushingExtension";

// node_modules/@deck.gl/extensions/dist/data-filter/shader-module.js
var uniformBlock14 = (
  /* glsl */
  `uniform dataFilterUniforms {
  bool useSoftMargin;
  bool enabled;
  bool transformSize;
  bool transformColor;
#ifdef DATAFILTER_TYPE
  DATAFILTER_TYPE min;
  DATAFILTER_TYPE softMin;
  DATAFILTER_TYPE softMax;
  DATAFILTER_TYPE max;
#ifdef DATAFILTER_DOUBLE
  DATAFILTER_TYPE min64High;
  DATAFILTER_TYPE max64High;
#endif
#endif
#ifdef DATACATEGORY_TYPE
  highp uvec4 categoryBitMask;
#endif
} dataFilter;
`
);
var vertex2 = (
  /* glsl */
  `
#ifdef DATAFILTER_TYPE
  in DATAFILTER_TYPE filterValues;
#ifdef DATAFILTER_DOUBLE
  in DATAFILTER_TYPE filterValues64Low;
#endif
#endif

#ifdef DATACATEGORY_TYPE
  in DATACATEGORY_TYPE filterCategoryValues;
#endif

out float dataFilter_value;

float dataFilter_reduceValue(float value) {
  return value;
}
float dataFilter_reduceValue(vec2 value) {
  return min(value.x, value.y);
}
float dataFilter_reduceValue(vec3 value) {
  return min(min(value.x, value.y), value.z);
}
float dataFilter_reduceValue(vec4 value) {
  return min(min(value.x, value.y), min(value.z, value.w));
}

#ifdef DATAFILTER_TYPE
  void dataFilter_setValue(DATAFILTER_TYPE valueFromMin, DATAFILTER_TYPE valueFromMax) {
    if (dataFilter.useSoftMargin) {
      // smoothstep results are undefined if edge0 ≥ edge1
      // Fallback to ignore filterSoftRange if it is truncated by filterRange
      DATAFILTER_TYPE leftInRange = mix(
        smoothstep(dataFilter.min, dataFilter.softMin, valueFromMin),
        step(dataFilter.min, valueFromMin),
        step(dataFilter.softMin, dataFilter.min)
      );
      DATAFILTER_TYPE rightInRange = mix(
        1.0 - smoothstep(dataFilter.softMax, dataFilter.max, valueFromMax),
        step(valueFromMax, dataFilter.max),
        step(dataFilter.max, dataFilter.softMax)
      );
      dataFilter_value = dataFilter_reduceValue(leftInRange * rightInRange);
    } else {
      dataFilter_value = dataFilter_reduceValue(
        step(dataFilter.min, valueFromMin) * step(valueFromMax, dataFilter.max)
      );
    }
  }
#endif

#ifdef DATACATEGORY_TYPE
  void dataFilter_setCategoryValue(DATACATEGORY_TYPE category) {
    #if DATACATEGORY_CHANNELS == 1 // One 128-bit mask
    uint dataFilter_masks = dataFilter.categoryBitMask[category / 32u];
    #elif DATACATEGORY_CHANNELS == 2 // Two 64-bit masks
    uvec2 dataFilter_masks = uvec2(
      dataFilter.categoryBitMask[category.x / 32u],
      dataFilter.categoryBitMask[category.y / 32u + 2u]
    );
    #elif DATACATEGORY_CHANNELS == 3 // Three 32-bit masks
    uvec3 dataFilter_masks = dataFilter.categoryBitMask.xyz;
    #else // Four 32-bit masks
    uvec4 dataFilter_masks = dataFilter.categoryBitMask;
    #endif

    // Shift mask and extract relevant bits
    DATACATEGORY_TYPE dataFilter_bits = DATACATEGORY_TYPE(dataFilter_masks) >> (category & 31u);
    dataFilter_bits &= 1u;

    #if DATACATEGORY_CHANNELS == 1
    if(dataFilter_bits == 0u) dataFilter_value = 0.0;
    #else
    if(any(equal(dataFilter_bits, DATACATEGORY_TYPE(0u)))) dataFilter_value = 0.0;
    #endif
  }
#endif
`
);
var vs3 = `
${uniformBlock14}
${vertex2}
`;
var fragment2 = (
  /* glsl */
  `
in float dataFilter_value;
`
);
var fs3 = `
${uniformBlock14}
${fragment2}
`;
function getUniforms(opts) {
  if (!opts || !("extensions" in opts)) {
    return {};
  }
  const { filterRange = [-1, 1], filterEnabled = true, filterTransformSize = true, filterTransformColor = true, categoryBitMask } = opts;
  const filterSoftRange = opts.filterSoftRange || filterRange;
  return {
    ...Number.isFinite(filterRange[0]) ? {
      min: filterRange[0],
      softMin: filterSoftRange[0],
      softMax: filterSoftRange[1],
      max: filterRange[1]
    } : {
      min: filterRange.map((r) => r[0]),
      softMin: filterSoftRange.map((r) => r[0]),
      softMax: filterSoftRange.map((r) => r[1]),
      max: filterRange.map((r) => r[1])
    },
    enabled: filterEnabled,
    useSoftMargin: Boolean(opts.filterSoftRange),
    transformSize: filterEnabled && filterTransformSize,
    transformColor: filterEnabled && filterTransformColor,
    ...categoryBitMask && { categoryBitMask }
  };
}
function getUniforms64(opts) {
  if (!opts || !("extensions" in opts)) {
    return {};
  }
  const uniforms = getUniforms(opts);
  if (Number.isFinite(uniforms.min)) {
    const min64High = Math.fround(uniforms.min);
    uniforms.min -= min64High;
    uniforms.softMin -= min64High;
    uniforms.min64High = min64High;
    const max64High = Math.fround(uniforms.max);
    uniforms.max -= max64High;
    uniforms.softMax -= max64High;
    uniforms.max64High = max64High;
  } else {
    const min64High = uniforms.min.map(Math.fround);
    uniforms.min = uniforms.min.map((x, i) => x - min64High[i]);
    uniforms.softMin = uniforms.softMin.map((x, i) => x - min64High[i]);
    uniforms.min64High = min64High;
    const max64High = uniforms.max.map(Math.fround);
    uniforms.max = uniforms.max.map((x, i) => x - max64High[i]);
    uniforms.softMax = uniforms.softMax.map((x, i) => x - max64High[i]);
    uniforms.max64High = max64High;
  }
  return uniforms;
}
var inject2 = {
  "vs:#main-start": (
    /* glsl */
    `
    dataFilter_value = 1.0;
    if (dataFilter.enabled) {
      #ifdef DATAFILTER_TYPE
        #ifdef DATAFILTER_DOUBLE
          dataFilter_setValue(
            filterValues - dataFilter.min64High + filterValues64Low,
            filterValues - dataFilter.max64High + filterValues64Low
          );
        #else
          dataFilter_setValue(filterValues, filterValues);
        #endif
      #endif

      #ifdef DATACATEGORY_TYPE
        dataFilter_setCategoryValue(filterCategoryValues);
      #endif
    }
  `
  ),
  "vs:#main-end": (
    /* glsl */
    `
    if (dataFilter_value == 0.0) {
      gl_Position = vec4(0.);
    }
  `
  ),
  "vs:DECKGL_FILTER_SIZE": (
    /* glsl */
    `
    if (dataFilter.transformSize) {
      size = size * dataFilter_value;
    }
  `
  ),
  "fs:DECKGL_FILTER_COLOR": (
    /* glsl */
    `
    if (dataFilter_value == 0.0) discard;
    if (dataFilter.transformColor) {
      color.a *= dataFilter_value;
    }
  `
  )
};
function uniformTypesFromOptions(opts) {
  const { categorySize, filterSize, fp64: fp642 } = opts;
  const uniformTypes = {
    useSoftMargin: "i32",
    enabled: "i32",
    transformSize: "i32",
    transformColor: "i32"
  };
  if (filterSize) {
    const uniformFormat = filterSize === 1 ? "f32" : `vec${filterSize}<f32>`;
    uniformTypes.min = uniformFormat;
    uniformTypes.softMin = uniformFormat;
    uniformTypes.softMax = uniformFormat;
    uniformTypes.max = uniformFormat;
    if (fp642) {
      uniformTypes.min64High = uniformFormat;
      uniformTypes.max64High = uniformFormat;
    }
  }
  if (categorySize) {
    uniformTypes.categoryBitMask = "vec4<i32>";
  }
  return uniformTypes;
}
var dataFilter = {
  name: "dataFilter",
  vs: vs3,
  fs: fs3,
  inject: inject2,
  getUniforms,
  uniformTypesFromOptions
};
var dataFilter64 = {
  name: "dataFilter",
  vs: vs3,
  fs: fs3,
  inject: inject2,
  getUniforms: getUniforms64,
  uniformTypesFromOptions
};

// node_modules/@deck.gl/extensions/dist/data-filter/aggregator.js
var AGGREGATE_VS = `#version 300 es
#define SHADER_NAME data-filter-vertex-shader

#ifdef FLOAT_TARGET
  in float filterIndices;
  in float filterPrevIndices;
#else
  in vec2 filterIndices;
  in vec2 filterPrevIndices;
#endif

out vec4 vColor;
const float component = 1.0 / 255.0;

void main() {
  #ifdef FLOAT_TARGET
    dataFilter_value *= float(filterIndices != filterPrevIndices);
    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);
    vColor = vec4(0.0, 0.0, 0.0, 1.0);
  #else
    // Float texture is not supported: pack result into 4 channels x 256 px x 64px
    dataFilter_value *= float(filterIndices.x != filterPrevIndices.x);
    float col = filterIndices.x;
    float row = filterIndices.y * 4.0;
    float channel = floor(row);
    row = fract(row);
    vColor = component * vec4(bvec4(channel == 0.0, channel == 1.0, channel == 2.0, channel == 3.0));
    gl_Position = vec4(col * 2.0 - 1.0, row * 2.0 - 1.0, 0.0, 1.0);
  #endif
  gl_PointSize = 1.0;
}
`;
var AGGREGATE_FS = `#version 300 es
#define SHADER_NAME data-filter-fragment-shader
precision highp float;

in vec4 vColor;

out vec4 fragColor;

void main() {
  if (dataFilter_value < 0.5) {
    discard;
  }
  fragColor = vColor;
}
`;
var FLOAT_TARGET_FEATURES = [
  "float32-renderable-webgl",
  // ability to render to float texture
  "texture-blend-float-webgl"
  // ability to blend when rendering to float texture
];
function supportsFloatTarget(device) {
  return FLOAT_TARGET_FEATURES.every((feature2) => device.features.has(feature2));
}
function getFramebuffer(device, useFloatTarget) {
  if (useFloatTarget) {
    return device.createFramebuffer({
      width: 1,
      height: 1,
      colorAttachments: [
        device.createTexture({
          format: "rgba32float",
          dimension: "2d",
          width: 1,
          height: 1
        })
      ]
    });
  }
  return device.createFramebuffer({
    width: 256,
    height: 64,
    colorAttachments: [
      device.createTexture({ format: "rgba8unorm", dimension: "2d", width: 256, height: 64 })
    ]
  });
}
function getModel(device, bufferLayout, shaderOptions, useFloatTarget) {
  shaderOptions.defines.NON_INSTANCED_MODEL = 1;
  if (useFloatTarget) {
    shaderOptions.defines.FLOAT_TARGET = 1;
  }
  return new Model(device, {
    id: "data-filter-aggregation-model",
    vertexCount: 1,
    isInstanced: false,
    topology: "point-list",
    disableWarnings: true,
    vs: AGGREGATE_VS,
    fs: AGGREGATE_FS,
    bufferLayout,
    ...shaderOptions
  });
}
var parameters = {
  blend: true,
  blendColorSrcFactor: "one",
  blendColorDstFactor: "one",
  blendAlphaSrcFactor: "one",
  blendAlphaDstFactor: "one",
  blendColorOperation: "add",
  blendAlphaOperation: "add",
  depthCompare: "never"
};

// node_modules/@deck.gl/extensions/dist/data-filter/data-filter-extension.js
var defaultProps32 = {
  getFilterValue: { type: "accessor", value: 0 },
  getFilterCategory: { type: "accessor", value: 0 },
  onFilteredItemsChange: { type: "function", value: null, optional: true },
  filterEnabled: true,
  filterRange: [-1, 1],
  filterSoftRange: null,
  filterCategories: [0],
  filterTransformSize: true,
  filterTransformColor: true
};
var defaultOptions2 = {
  categorySize: 0,
  filterSize: 1,
  fp64: false,
  countItems: false
};
var CATEGORY_TYPE_FROM_SIZE = {
  1: "uint",
  2: "uvec2",
  3: "uvec3",
  4: "uvec4"
};
var DATA_TYPE_FROM_SIZE = {
  1: "float",
  2: "vec2",
  3: "vec3",
  4: "vec4"
};
var DataFilterExtension = class extends layer_extension_default {
  constructor(opts = {}) {
    super({ ...defaultOptions2, ...opts });
  }
  getShaders(extension) {
    const { categorySize, filterSize, fp64: fp642 } = extension.opts;
    const defines = {};
    if (categorySize) {
      defines.DATACATEGORY_TYPE = CATEGORY_TYPE_FROM_SIZE[categorySize];
      defines.DATACATEGORY_CHANNELS = categorySize;
    }
    if (filterSize) {
      defines.DATAFILTER_TYPE = DATA_TYPE_FROM_SIZE[filterSize];
      defines.DATAFILTER_DOUBLE = Boolean(fp642);
    }
    const module = fp642 ? dataFilter64 : dataFilter;
    module.uniformTypes = module.uniformTypesFromOptions(extension.opts);
    return { modules: [module], defines };
  }
  initializeState(context, extension) {
    const attributeManager = this.getAttributeManager();
    const { categorySize, filterSize, fp64: fp642 } = extension.opts;
    if (attributeManager) {
      if (filterSize) {
        attributeManager.add({
          filterValues: {
            size: filterSize,
            type: fp642 ? "float64" : "float32",
            stepMode: "dynamic",
            accessor: "getFilterValue"
          }
        });
      }
      if (categorySize) {
        attributeManager.add({
          filterCategoryValues: {
            size: categorySize,
            stepMode: "dynamic",
            accessor: "getFilterCategory",
            type: "uint32",
            transform: categorySize === 1 ? (d2) => extension._getCategoryKey.call(this, d2, 0) : (d2) => d2.map((x, i) => extension._getCategoryKey.call(this, x, i))
          }
        });
      }
    }
    const { device } = this.context;
    if (attributeManager && extension.opts.countItems) {
      const useFloatTarget = supportsFloatTarget(device);
      attributeManager.add({
        filterVertexIndices: {
          size: useFloatTarget ? 1 : 2,
          vertexOffset: 1,
          type: "unorm8",
          accessor: (object, { index }) => {
            const i = object && object.__source ? object.__source.index : index;
            return useFloatTarget ? (i + 1) % 255 : [(i + 1) % 255, Math.floor(i / 255) % 255];
          },
          shaderAttributes: {
            filterPrevIndices: {
              vertexOffset: 0
            },
            filterIndices: {
              vertexOffset: 1
            }
          }
        }
      });
      const filterFBO = getFramebuffer(device, useFloatTarget);
      const filterModel = getModel(device, attributeManager.getBufferLayouts({ isInstanced: false }), extension.getShaders.call(this, extension), useFloatTarget);
      this.setState({ filterFBO, filterModel });
    }
  }
  // eslint-disable-next-line complexity
  updateState({ props, oldProps, changeFlags }, extension) {
    var _a, _b;
    const attributeManager = this.getAttributeManager();
    const { categorySize } = extension.opts;
    if (this.state.filterModel) {
      const filterNeedsUpdate = (
        // attributeManager must be defined for filterModel to be set
        ((_a = attributeManager.attributes.filterValues) == null ? void 0 : _a.needsUpdate()) || ((_b = attributeManager.attributes.filterCategoryValues) == null ? void 0 : _b.needsUpdate()) || props.filterEnabled !== oldProps.filterEnabled || props.filterRange !== oldProps.filterRange || props.filterSoftRange !== oldProps.filterSoftRange || props.filterCategories !== oldProps.filterCategories
      );
      if (filterNeedsUpdate) {
        this.setState({ filterNeedsUpdate });
      }
    }
    if (attributeManager == null ? void 0 : attributeManager.attributes.filterCategoryValues) {
      const categoryBitMaskNeedsUpdate = attributeManager.attributes.filterCategoryValues.needsUpdate() || !deepEqual(props.filterCategories, oldProps.filterCategories, 2);
      if (categoryBitMaskNeedsUpdate) {
        this.setState({ categoryBitMask: null });
      }
      const resetCategories = changeFlags.dataChanged;
      if (resetCategories) {
        this.setState({
          categoryMap: Array(categorySize).fill(0).map(() => ({}))
        });
        attributeManager.attributes.filterCategoryValues.setNeedsUpdate("categoryMap");
      }
    }
  }
  // eslint-disable-next-line max-statements
  draw(params, extension) {
    const filterFBO = this.state.filterFBO;
    const filterModel = this.state.filterModel;
    const filterNeedsUpdate = this.state.filterNeedsUpdate;
    if (!this.state.categoryBitMask) {
      extension._updateCategoryBitMask.call(this, params, extension);
    }
    const { onFilteredItemsChange, extensions, filterEnabled, filterRange, filterSoftRange, filterTransformSize, filterTransformColor, filterCategories } = this.props;
    const dataFilterProps = {
      extensions,
      filterEnabled,
      filterRange,
      filterSoftRange,
      filterTransformSize,
      filterTransformColor,
      filterCategories
    };
    if (this.state.categoryBitMask) {
      dataFilterProps.categoryBitMask = this.state.categoryBitMask;
    }
    this.setShaderModuleProps({ dataFilter: dataFilterProps });
    if (filterNeedsUpdate && onFilteredItemsChange && filterModel) {
      const attributeManager = this.getAttributeManager();
      const { attributes: { filterValues, filterCategoryValues, filterVertexIndices } } = attributeManager;
      filterModel.setVertexCount(this.getNumInstances());
      const attributes = {
        ...filterValues == null ? void 0 : filterValues.getValue(),
        ...filterCategoryValues == null ? void 0 : filterCategoryValues.getValue(),
        ...filterVertexIndices == null ? void 0 : filterVertexIndices.getValue()
      };
      filterModel.setAttributes(attributes);
      filterModel.shaderInputs.setProps({
        dataFilter: dataFilterProps
      });
      const viewport = [0, 0, filterFBO.width, filterFBO.height];
      const renderPass = filterModel.device.beginRenderPass({
        id: "data-filter-aggregation",
        framebuffer: filterFBO,
        parameters: { viewport },
        clearColor: [0, 0, 0, 0]
      });
      filterModel.setParameters(parameters);
      filterModel.draw(renderPass);
      renderPass.end();
      const color = filterModel.device.readPixelsToArrayWebGL(filterFBO);
      let count = 0;
      for (let i = 0; i < color.length; i++) {
        count += color[i];
      }
      onFilteredItemsChange({ id: this.id, count });
      this.state.filterNeedsUpdate = false;
    }
  }
  finalizeState() {
    const filterFBO = this.state.filterFBO;
    const filterModel = this.state.filterModel;
    filterFBO == null ? void 0 : filterFBO.destroy();
    filterModel == null ? void 0 : filterModel.destroy();
  }
  /**
   * Updates the bitmask used on the GPU to perform the filter based on the
   * `filterCategories` prop. The mapping between categories and bit in the bitmask
   * is performed by `_getCategoryKey()`
   */
  _updateCategoryBitMask(params, extension) {
    const { categorySize } = extension.opts;
    if (!categorySize)
      return;
    const { filterCategories } = this.props;
    const categoryBitMask = new Uint32Array([0, 0, 0, 0]);
    const categoryFilters = categorySize === 1 ? [filterCategories] : filterCategories;
    const maxCategories = categorySize === 1 ? 128 : categorySize === 2 ? 64 : 32;
    for (let c2 = 0; c2 < categoryFilters.length; c2++) {
      const categoryFilter = categoryFilters[c2];
      for (const category of categoryFilter) {
        const key = extension._getCategoryKey.call(this, category, c2);
        if (key < maxCategories) {
          const channel = c2 * (maxCategories / 32) + Math.floor(key / 32);
          categoryBitMask[channel] += Math.pow(2, key % 32);
        } else {
          log_default.warn(`Exceeded maximum number of categories (${maxCategories})`)();
        }
      }
    }
    this.state.categoryBitMask = categoryBitMask;
  }
  /**
   * Returns an index of bit in the bitmask for a given category. If the category has
   * not yet been assigned a bit, a new one is assigned.
   */
  _getCategoryKey(category, channel) {
    const categoryMap = this.state.categoryMap[channel];
    if (!(category in categoryMap)) {
      categoryMap[category] = Object.keys(categoryMap).length;
    }
    return categoryMap[category];
  }
};
DataFilterExtension.defaultProps = defaultProps32;
DataFilterExtension.extensionName = "DataFilterExtension";

// node_modules/@deck.gl/extensions/dist/fp64/project64.glsl.js
var project64_glsl_default = `const vec2 WORLD_SCALE_FP64 = vec2(81.4873275756836, 0.0000032873668232014097);
uniform project64Uniforms {
vec2 scale;
mat4 viewProjectionMatrix;
mat4 viewProjectionMatrix64Low;
} project64;
void mercatorProject_fp64(vec4 lnglat_fp64, out vec2 out_val[2]) {
#if defined(NVIDIA_FP64_WORKAROUND)
out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64 * ONE);
#else
out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64);
#endif
out_val[1] = sum_fp64(PI_FP64,
log_fp64(tan_fp64(sum_fp64(PI_4_FP64, radians_fp64(lnglat_fp64.zw) / 2.0))));
return;
}
void project_position_fp64(vec4 position_fp64, out vec2 out_val[2]) {
vec2 pos_fp64[2];
mercatorProject_fp64(position_fp64, pos_fp64);
out_val[0] = mul_fp64(pos_fp64[0], WORLD_SCALE_FP64);
out_val[1] = mul_fp64(pos_fp64[1], WORLD_SCALE_FP64);
return;
}
void project_position_fp64(vec2 position, vec2 position64xyLow, out vec2 out_val[2]) {
vec4 position64xy = vec4(
position.x, position64xyLow.x,
position.y, position64xyLow.y);
project_position_fp64(position64xy, out_val);
}
vec4 project_common_position_to_clipspace_fp64(vec2 vertex_pos_modelspace[4]) {
vec2 vertex_pos_clipspace[4];
vec2 viewProjectionMatrixFP64[16];
for (int i = 0; i < 4; i++) {
for (int j = 0; j < 4; j++) {
viewProjectionMatrixFP64[4 * i + j] = vec2(
project64.viewProjectionMatrix[j][i],
project64.viewProjectionMatrix64Low[j][i]
);
}
}
mat4_vec4_mul_fp64(viewProjectionMatrixFP64, vertex_pos_modelspace,
vertex_pos_clipspace);
return vec4(
vertex_pos_clipspace[0].x,
vertex_pos_clipspace[1].x,
vertex_pos_clipspace[2].x,
vertex_pos_clipspace[3].x
);
}
vec4 project_position_to_clipspace(
vec3 position, vec3 position64xyLow, vec3 offset, out vec4 commonPosition
) {
vec2 offset64[4];
vec4_fp64(vec4(offset, 0.0), offset64);
float z = project_size(position.z);
vec2 projectedPosition64xy[2];
project_position_fp64(position.xy, position64xyLow.xy, projectedPosition64xy);
vec2 commonPosition64[4];
commonPosition64[0] = sum_fp64(offset64[0], projectedPosition64xy[0]);
commonPosition64[1] = sum_fp64(offset64[1], projectedPosition64xy[1]);
commonPosition64[2] = sum_fp64(offset64[2], vec2(z, 0.0));
commonPosition64[3] = vec2(1.0, 0.0);
commonPosition = vec4(projectedPosition64xy[0].x, projectedPosition64xy[1].x, z, 1.0);
return project_common_position_to_clipspace_fp64(commonPosition64);
}
vec4 project_position_to_clipspace(
vec3 position, vec3 position64xyLow, vec3 offset
) {
vec4 commonPosition;
return project_position_to_clipspace(
position, position64xyLow, offset, commonPosition
);
}
`;

// node_modules/@deck.gl/extensions/dist/fp64/project64.js
var { fp64ify, fp64ifyMatrix4 } = fp64;
var project64_default = {
  name: "project64",
  dependencies: [project_default, fp64],
  vs: project64_glsl_default,
  getUniforms: getUniforms2,
  uniformTypes: {
    scale: "vec2<f32>",
    // Cannot pass as vec2[16], so instead split into 2 mat4x4
    viewProjectionMatrix: "mat4x4<f32>",
    viewProjectionMatrix64Low: "mat4x4<f32>"
  }
};
var getMemoizedUniforms = memoize(calculateUniforms);
function getUniforms2(opts) {
  if (opts && "viewport" in opts) {
    const { viewProjectionMatrix, scale: scale7 } = opts.viewport;
    return getMemoizedUniforms({ viewProjectionMatrix, scale: scale7 });
  }
  return {};
}
function calculateUniforms({ viewProjectionMatrix, scale: scale7 }) {
  const glViewProjectionMatrixFP64 = fp64ifyMatrix4(viewProjectionMatrix);
  const viewProjectionMatrix64High = new Float32Array(16);
  const viewProjectionMatrix64Low = new Float32Array(16);
  for (let i = 0; i < 4; i++) {
    for (let j = 0; j < 4; j++) {
      const from = 4 * i + j;
      const to = 4 * j + i;
      viewProjectionMatrix64High[to] = glViewProjectionMatrixFP64[2 * from];
      viewProjectionMatrix64Low[to] = glViewProjectionMatrixFP64[2 * from + 1];
    }
  }
  return {
    scale: fp64ify(scale7),
    viewProjectionMatrix: [...viewProjectionMatrix64High],
    viewProjectionMatrix64Low: [...viewProjectionMatrix64Low]
  };
}

// node_modules/@deck.gl/extensions/dist/fp64/fp64-extension.js
var Fp64Extension = class extends layer_extension_default {
  getShaders() {
    const { coordinateSystem } = this.props;
    if (coordinateSystem !== COORDINATE_SYSTEM.LNGLAT && coordinateSystem !== COORDINATE_SYSTEM.DEFAULT) {
      throw new Error("fp64: coordinateSystem must be LNGLAT");
    }
    return {
      modules: [project64_default]
    };
  }
  draw(params, extension) {
    const { viewport } = params.context;
    this.setShaderModuleProps({ project64: { viewport } });
  }
};
Fp64Extension.extensionName = "Fp64Extension";

// node_modules/@deck.gl/extensions/dist/path-style/shaders.glsl.js
var dashShaders = {
  inject: {
    "vs:#decl": `
in vec2 instanceDashArrays;
in float instanceDashOffsets;
out vec2 vDashArray;
out float vDashOffset;
`,
    "vs:#main-end": `
vDashArray = instanceDashArrays;
vDashOffset = instanceDashOffsets / width.x;
`,
    "fs:#decl": `
uniform pathStyleUniforms {
float dashAlignMode;
bool dashGapPickable;
} pathStyle;
in vec2 vDashArray;
in float vDashOffset;
`,
    // if given position is in the gap part of the dashed line
    // dashArray.x: solid stroke length, relative to width
    // dashArray.y: gap length, relative to width
    // alignMode:
    // 0 - no adjustment
    // o----     ----     ----     ---- o----     -o----     ----     o
    // 1 - stretch to fit, draw half dash at each end for nicer joints
    // o--    ----    ----    ----    --o--      --o--     ----     --o
    "fs:#main-start": `
float solidLength = vDashArray.x;
float gapLength = vDashArray.y;
float unitLength = solidLength + gapLength;
float offset;
if (unitLength > 0.0) {
if (pathStyle.dashAlignMode == 0.0) {
offset = vDashOffset;
} else {
unitLength = vPathLength / round(vPathLength / unitLength);
offset = solidLength / 2.0;
}
float unitOffset = mod(vPathPosition.y + offset, unitLength);
if (gapLength > 0.0 && unitOffset > solidLength) {
if (path.capType <= 0.5) {
if (!(pathStyle.dashGapPickable && bool(picking.isActive))) {
discard;
}
} else {
float distToEnd = length(vec2(
min(unitOffset - solidLength, unitLength - unitOffset),
vPathPosition.x
));
if (distToEnd > 1.0) {
if (!(pathStyle.dashGapPickable && bool(picking.isActive))) {
discard;
}
}
}
}
}
`
  }
};
var offsetShaders = {
  inject: {
    "vs:#decl": `
in float instanceOffsets;
`,
    "vs:DECKGL_FILTER_SIZE": `
float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;
size *= offsetWidth;
`,
    "vs:#main-end": `
float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;
float offsetDir = sign(instanceOffsets);
vPathPosition.x = (vPathPosition.x + offsetDir) * offsetWidth - offsetDir;
vPathPosition.y *= offsetWidth;
vPathLength *= offsetWidth;
`,
    "fs:#main-start": `
float isInside;
isInside = step(-1.0, vPathPosition.x) * step(vPathPosition.x, 1.0);
if (isInside == 0.0) {
discard;
}
`
  }
};

// node_modules/@deck.gl/extensions/dist/path-style/path-style-extension.js
var defaultProps33 = {
  getDashArray: { type: "accessor", value: [0, 0] },
  getOffset: { type: "accessor", value: 0 },
  dashJustified: false,
  dashGapPickable: false
};
var PathStyleExtension = class extends layer_extension_default {
  constructor({ dash = false, offset = false, highPrecisionDash = false } = {}) {
    super({ dash: dash || highPrecisionDash, offset, highPrecisionDash });
  }
  isEnabled(layer) {
    return "pathTesselator" in layer.state;
  }
  getShaders(extension) {
    if (!extension.isEnabled(this)) {
      return null;
    }
    let result = {};
    if (extension.opts.dash) {
      result = mergeShaders(result, dashShaders);
    }
    if (extension.opts.offset) {
      result = mergeShaders(result, offsetShaders);
    }
    const { inject: inject6 } = result;
    const pathStyle = {
      name: "pathStyle",
      inject: inject6,
      uniformTypes: {
        dashAlignMode: "f32",
        dashGapPickable: "i32"
      }
    };
    return {
      modules: [pathStyle]
    };
  }
  initializeState(context, extension) {
    const attributeManager = this.getAttributeManager();
    if (!attributeManager || !extension.isEnabled(this)) {
      return;
    }
    if (extension.opts.dash) {
      attributeManager.addInstanced({
        instanceDashArrays: { size: 2, accessor: "getDashArray" },
        instanceDashOffsets: extension.opts.highPrecisionDash ? {
          size: 1,
          accessor: "getPath",
          transform: extension.getDashOffsets.bind(this)
        } : {
          size: 1,
          update: (attribute) => {
            attribute.constant = true;
            attribute.value = [0];
          }
        }
      });
    }
    if (extension.opts.offset) {
      attributeManager.addInstanced({
        instanceOffsets: { size: 1, accessor: "getOffset" }
      });
    }
  }
  updateState(params, extension) {
    if (!extension.isEnabled(this)) {
      return;
    }
    if (extension.opts.dash) {
      const pathStyleProps = {
        dashAlignMode: this.props.dashJustified ? 1 : 0,
        dashGapPickable: Boolean(this.props.dashGapPickable)
      };
      this.setShaderModuleProps({ pathStyle: pathStyleProps });
    }
  }
  getDashOffsets(path) {
    const result = [0];
    const positionSize = this.props.positionFormat === "XY" ? 2 : 3;
    const isNested2 = Array.isArray(path[0]);
    const geometrySize = isNested2 ? path.length : path.length / positionSize;
    let p;
    let prevP;
    for (let i = 0; i < geometrySize - 1; i++) {
      p = isNested2 ? path[i] : path.slice(i * positionSize, i * positionSize + positionSize);
      p = this.projectPosition(p);
      if (i > 0) {
        result[i] = result[i - 1] + vec3_exports.dist(prevP, p);
      }
      prevP = p;
    }
    result[geometrySize - 1] = 0;
    return result;
  }
};
PathStyleExtension.defaultProps = defaultProps33;
PathStyleExtension.extensionName = "PathStyleExtension";

// node_modules/@deck.gl/extensions/dist/fill-style/shader-module.js
var uniformBlock15 = (
  /* glsl */
  `uniform fillUniforms {
  vec2 patternTextureSize;
  bool patternEnabled;
  bool patternMask;
  vec2 uvCoordinateOrigin;
  vec2 uvCoordinateOrigin64Low;
} fill;
`
);
var patternVs = (
  /* glsl */
  `
in vec4 fillPatternFrames;
in float fillPatternScales;
in vec2 fillPatternOffsets;

out vec2 fill_uv;
out vec4 fill_patternBounds;
out vec4 fill_patternPlacement;
`
);
var vs4 = `
${uniformBlock15}
${patternVs}
`;
var patternFs = (
  /* glsl */
  `
uniform sampler2D fill_patternTexture;

in vec4 fill_patternBounds;
in vec4 fill_patternPlacement;
in vec2 fill_uv;

const float FILL_UV_SCALE = 512.0 / 40000000.0;
`
);
var fs4 = `
${uniformBlock15}
${patternFs}
`;
var inject3 = {
  "vs:DECKGL_FILTER_GL_POSITION": (
    /* glsl */
    `
    fill_uv = geometry.position.xy;
  `
  ),
  "vs:DECKGL_FILTER_COLOR": (
    /* glsl */
    `
    if (fill.patternEnabled) {
      fill_patternBounds = fillPatternFrames / vec4(fill.patternTextureSize, fill.patternTextureSize);
      fill_patternPlacement.xy = fillPatternOffsets;
      fill_patternPlacement.zw = fillPatternScales * fillPatternFrames.zw;
    }
  `
  ),
  "fs:DECKGL_FILTER_COLOR": (
    /* glsl */
    `
    if (fill.patternEnabled) {
      vec2 scale = FILL_UV_SCALE * fill_patternPlacement.zw;
      vec2 patternUV = mod(mod(fill.uvCoordinateOrigin, scale) + fill.uvCoordinateOrigin64Low + fill_uv, scale) / scale;
      patternUV = mod(fill_patternPlacement.xy + patternUV, 1.0);

      vec2 texCoords = fill_patternBounds.xy + fill_patternBounds.zw * patternUV;

      vec4 patternColor = texture(fill_patternTexture, texCoords);
      color.a *= patternColor.a;
      if (!fill.patternMask) {
        color.rgb = patternColor.rgb;
      }
    }
  `
  )
};
function getPatternUniforms(opts) {
  if (!opts) {
    return {};
  }
  const uniforms = {};
  if ("fillPatternTexture" in opts) {
    const { fillPatternTexture } = opts;
    uniforms.fill_patternTexture = fillPatternTexture;
    uniforms.patternTextureSize = [fillPatternTexture.width, fillPatternTexture.height];
  }
  if ("project" in opts) {
    const { fillPatternMask = true, fillPatternEnabled = true } = opts;
    const projectUniforms = project_default.getUniforms(opts.project);
    const { commonOrigin: coordinateOriginCommon } = projectUniforms;
    const coordinateOriginCommon64Low = [
      fp64LowPart(coordinateOriginCommon[0]),
      fp64LowPart(coordinateOriginCommon[1])
    ];
    uniforms.uvCoordinateOrigin = coordinateOriginCommon.slice(0, 2);
    uniforms.uvCoordinateOrigin64Low = coordinateOriginCommon64Low;
    uniforms.patternMask = fillPatternMask;
    uniforms.patternEnabled = fillPatternEnabled;
  }
  return uniforms;
}
var patternShaders = {
  name: "fill",
  vs: vs4,
  fs: fs4,
  inject: inject3,
  dependencies: [project_default],
  getUniforms: getPatternUniforms,
  uniformTypes: {
    patternTextureSize: "vec2<f32>",
    patternEnabled: "i32",
    patternMask: "i32",
    uvCoordinateOrigin: "vec2<f32>",
    uvCoordinateOrigin64Low: "vec2<f32>"
  }
};

// node_modules/@deck.gl/extensions/dist/fill-style/fill-style-extension.js
var defaultProps34 = {
  fillPatternEnabled: true,
  fillPatternAtlas: {
    type: "image",
    value: null,
    async: true,
    parameters: { lodMaxClamp: 0 }
  },
  fillPatternMapping: { type: "object", value: {}, async: true },
  fillPatternMask: true,
  getFillPattern: { type: "accessor", value: (d2) => d2.pattern },
  getFillPatternScale: { type: "accessor", value: 1 },
  getFillPatternOffset: { type: "accessor", value: [0, 0] }
};
var FillStyleExtension = class extends layer_extension_default {
  constructor({ pattern = false } = {}) {
    super({ pattern });
  }
  isEnabled(layer) {
    return layer.getAttributeManager() !== null && !("pathTesselator" in layer.state);
  }
  getShaders(extension) {
    if (!extension.isEnabled(this)) {
      return null;
    }
    return {
      modules: [extension.opts.pattern && patternShaders].filter(Boolean)
    };
  }
  initializeState(context, extension) {
    if (!extension.isEnabled(this)) {
      return;
    }
    const attributeManager = this.getAttributeManager();
    if (extension.opts.pattern) {
      attributeManager.add({
        fillPatternFrames: {
          size: 4,
          stepMode: "dynamic",
          accessor: "getFillPattern",
          transform: extension.getPatternFrame.bind(this)
        },
        fillPatternScales: {
          size: 1,
          stepMode: "dynamic",
          accessor: "getFillPatternScale",
          defaultValue: 1
        },
        fillPatternOffsets: {
          size: 2,
          stepMode: "dynamic",
          accessor: "getFillPatternOffset"
        }
      });
    }
    this.setState({
      emptyTexture: this.context.device.createTexture({
        data: new Uint8Array(4),
        width: 1,
        height: 1
      })
    });
  }
  updateState({ props, oldProps }, extension) {
    if (!extension.isEnabled(this)) {
      return;
    }
    if (props.fillPatternMapping && props.fillPatternMapping !== oldProps.fillPatternMapping) {
      this.getAttributeManager().invalidate("getFillPattern");
    }
  }
  draw(params, extension) {
    if (!extension.isEnabled(this)) {
      return;
    }
    const { fillPatternAtlas, fillPatternEnabled, fillPatternMask } = this.props;
    const fillProps = {
      project: params.shaderModuleProps.project,
      fillPatternEnabled,
      fillPatternMask,
      fillPatternTexture: fillPatternAtlas || this.state.emptyTexture
    };
    this.setShaderModuleProps({ fill: fillProps });
  }
  finalizeState() {
    const emptyTexture = this.state.emptyTexture;
    emptyTexture == null ? void 0 : emptyTexture.delete();
  }
  getPatternFrame(name) {
    const { fillPatternMapping } = this.getCurrentLayer().props;
    const def = fillPatternMapping && fillPatternMapping[name];
    return def ? [def.x, def.y, def.width, def.height] : [0, 0, 0, 0];
  }
};
FillStyleExtension.defaultProps = defaultProps34;
FillStyleExtension.extensionName = "FillStyleExtension";

// node_modules/@deck.gl/extensions/dist/clip/clip-extension.js
var defaultProps35 = {
  clipBounds: [0, 0, 1, 1],
  clipByInstance: void 0
};
var shaderFunction = (
  /* glsl */
  `
uniform clipUniforms {
  vec4 bounds;
} clip;

bool clip_isInBounds(vec2 position) {
  return position.x >= clip.bounds[0] && position.y >= clip.bounds[1] && position.x < clip.bounds[2] && position.y < clip.bounds[3];
}
`
);
var shaderModuleVs = {
  name: "clip",
  vs: shaderFunction,
  uniformTypes: {
    bounds: "vec4<f32>"
  }
};
var injectionVs = {
  "vs:#decl": (
    /* glsl */
    `
out float clip_isVisible;
`
  ),
  "vs:DECKGL_FILTER_GL_POSITION": (
    /* glsl */
    `
  clip_isVisible = float(clip_isInBounds(geometry.worldPosition.xy));
`
  ),
  "fs:#decl": (
    /* glsl */
    `
in float clip_isVisible;
`
  ),
  "fs:DECKGL_FILTER_COLOR": (
    /* glsl */
    `
  if (clip_isVisible < 0.5) discard;
`
  )
};
var shaderModuleFs = {
  name: "clip",
  fs: shaderFunction,
  uniformTypes: {
    bounds: "vec4<f32>"
  }
};
var injectionFs = {
  "vs:#decl": (
    /* glsl */
    `
out vec2 clip_commonPosition;
`
  ),
  "vs:DECKGL_FILTER_GL_POSITION": (
    /* glsl */
    `
  clip_commonPosition = geometry.position.xy;
`
  ),
  "fs:#decl": (
    /* glsl */
    `
in vec2 clip_commonPosition;
`
  ),
  "fs:DECKGL_FILTER_COLOR": (
    /* glsl */
    `
  if (!clip_isInBounds(clip_commonPosition)) discard;
`
  )
};
var ClipExtension = class extends layer_extension_default {
  getShaders() {
    let clipByInstance = "instancePositions" in this.getAttributeManager().attributes;
    if (this.props.clipByInstance !== void 0) {
      clipByInstance = Boolean(this.props.clipByInstance);
    }
    this.state.clipByInstance = clipByInstance;
    return clipByInstance ? {
      modules: [shaderModuleVs],
      inject: injectionVs
    } : {
      modules: [shaderModuleFs],
      inject: injectionFs
    };
  }
  /* eslint-disable camelcase */
  draw() {
    const { clipBounds } = this.props;
    const clipProps = {};
    if (this.state.clipByInstance) {
      clipProps.bounds = clipBounds;
    } else {
      const corner0 = this.projectPosition([clipBounds[0], clipBounds[1], 0]);
      const corner1 = this.projectPosition([clipBounds[2], clipBounds[3], 0]);
      clipProps.bounds = [
        Math.min(corner0[0], corner1[0]),
        Math.min(corner0[1], corner1[1]),
        Math.max(corner0[0], corner1[0]),
        Math.max(corner0[1], corner1[1])
      ];
    }
    this.setShaderModuleProps({ clip: clipProps });
  }
};
ClipExtension.defaultProps = defaultProps35;
ClipExtension.extensionName = "ClipExtension";
var clip_extension_default = ClipExtension;

// node_modules/@deck.gl/extensions/dist/collision-filter/shader-module.js
var vs5 = (
  /* glsl */
  `
in float collisionPriorities;

uniform sampler2D collision_texture;

uniform collisionUniforms {
  bool sort;
  bool enabled;
} collision;

vec2 collision_getCoords(vec4 position) {
  vec4 collision_clipspace = project_common_position_to_clipspace(position);
  return (1.0 + collision_clipspace.xy / collision_clipspace.w) / 2.0;
}

float collision_match(vec2 tex, vec3 pickingColor) {
  vec4 collision_pickingColor = texture(collision_texture, tex);
  float delta = dot(abs(collision_pickingColor.rgb - pickingColor), vec3(1.0));
  float e = 0.001;
  return step(delta, e);
}

float collision_isVisible(vec2 texCoords, vec3 pickingColor) {
  if (!collision.enabled) {
    return 1.0;
  }

  // Visibility test, sample area of 5x5 pixels in order to fade in/out.
  // Due to the locality, the lookups will be cached
  // This reduces the flicker present when objects are shown/hidden
  const int N = 2;
  float accumulator = 0.0;
  vec2 step = vec2(1.0 / project.viewportSize);

  const float floatN = float(N);
  vec2 delta = -floatN * step;
  for(int i = -N; i <= N; i++) {
    delta.x = -step.x * floatN;
    for(int j = -N; j <= N; j++) {
      accumulator += collision_match(texCoords + delta, pickingColor);
      delta.x += step.x;
    }
    delta.y += step.y;
  }

  float W = 2.0 * floatN + 1.0;
  return pow(accumulator / (W * W), 2.2);
}
`
);
var inject4 = {
  "vs:#decl": (
    /* glsl */
    `
  float collision_fade = 1.0;
`
  ),
  "vs:DECKGL_FILTER_GL_POSITION": (
    /* glsl */
    `
  if (collision.sort) {
    float collisionPriority = collisionPriorities;
    position.z = -0.001 * collisionPriority * position.w; // Support range -1000 -> 1000
  }

  if (collision.enabled) {
    vec4 collision_common_position = project_position(vec4(geometry.worldPosition, 1.0));
    vec2 collision_texCoords = collision_getCoords(collision_common_position);
    collision_fade = collision_isVisible(collision_texCoords, geometry.pickingColor / 255.0);
    if (collision_fade < 0.0001) {
      // Position outside clip space bounds to discard
      position = vec4(0.0, 0.0, 2.0, 1.0);
    }
  }
  `
  ),
  "vs:DECKGL_FILTER_COLOR": (
    /* glsl */
    `
  color.a *= collision_fade;
  `
  )
};
var getCollisionUniforms = (opts) => {
  if (!opts || !("dummyCollisionMap" in opts)) {
    return {};
  }
  const { enabled, collisionFBO, drawToCollisionMap, dummyCollisionMap } = opts;
  return {
    enabled: enabled && !drawToCollisionMap,
    sort: Boolean(drawToCollisionMap),
    collision_texture: !drawToCollisionMap && collisionFBO ? collisionFBO.colorAttachments[0] : dummyCollisionMap
  };
};
var shader_module_default2 = {
  name: "collision",
  dependencies: [project_default],
  vs: vs5,
  inject: inject4,
  getUniforms: getCollisionUniforms,
  uniformTypes: {
    sort: "i32",
    enabled: "i32"
  }
};

// node_modules/@deck.gl/extensions/dist/collision-filter/collision-filter-pass.js
var CollisionFilterPass = class extends LayersPass {
  renderCollisionMap(target, options) {
    const padding = 1;
    const clearColor = [0, 0, 0, 0];
    const scissorRect = [padding, padding, target.width - 2 * padding, target.height - 2 * padding];
    this.render({ ...options, clearColor, scissorRect, target, pass: "collision" });
  }
  getLayerParameters(layer, layerIndex, viewport) {
    return {
      ...layer.props.parameters,
      blend: false,
      depthWriteEnabled: true,
      depthCompare: "less-equal"
    };
  }
  getShaderModuleProps() {
    return {
      collision: {
        drawToCollisionMap: true
      },
      picking: {
        isActive: 1,
        isAttribute: false
      },
      lighting: { enabled: false }
    };
  }
};

// node_modules/@deck.gl/extensions/dist/collision-filter/collision-filter-effect.js
var DOWNSCALE = 2;
var CollisionFilterEffect = class {
  constructor() {
    this.id = "collision-filter-effect";
    this.props = null;
    this.useInPicking = true;
    this.order = 1;
    this.channels = {};
    this.collisionFBOs = {};
  }
  setup(context) {
    this.context = context;
    const { device } = context;
    this.dummyCollisionMap = device.createTexture({ width: 1, height: 1 });
    this.collisionFilterPass = new CollisionFilterPass(device, { id: "default-collision-filter" });
  }
  preRender({ effects: allEffects, layers, layerFilter, viewports, onViewportActive, views, isPicking, preRenderStats = {} }) {
    var _a;
    const { device } = this.context;
    if (isPicking) {
      return;
    }
    const collisionLayers = layers.filter(
      // @ts-ignore
      ({ props: { visible, collisionEnabled } }) => visible && collisionEnabled
    );
    if (collisionLayers.length === 0) {
      this.channels = {};
      return;
    }
    const effects = allEffects == null ? void 0 : allEffects.filter((e2) => e2.useInPicking && preRenderStats[e2.id]);
    const maskEffectRendered = (_a = preRenderStats["mask-effect"]) == null ? void 0 : _a.didRender;
    const channels = this._groupByCollisionGroup(device, collisionLayers);
    const viewport = viewports[0];
    const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport) || maskEffectRendered;
    for (const collisionGroup in channels) {
      const collisionFBO = this.collisionFBOs[collisionGroup];
      const renderInfo = channels[collisionGroup];
      const [width, height] = device.canvasContext.getPixelSize();
      collisionFBO.resize({
        width: width / DOWNSCALE,
        height: height / DOWNSCALE
      });
      this._render(renderInfo, {
        effects,
        layerFilter,
        onViewportActive,
        views,
        viewport,
        viewportChanged
      });
    }
  }
  _render(renderInfo, { effects, layerFilter, onViewportActive, views, viewport, viewportChanged }) {
    const { collisionGroup } = renderInfo;
    const oldRenderInfo = this.channels[collisionGroup];
    if (!oldRenderInfo) {
      return;
    }
    const needsRender = viewportChanged || // If render info is new
    renderInfo === oldRenderInfo || // If sublayers have changed
    !deepEqual(oldRenderInfo.layers, renderInfo.layers, 1) || // If a sublayer's bounds have been updated
    renderInfo.layerBounds.some((b2, i) => !equals(b2, oldRenderInfo.layerBounds[i])) || // If a sublayer's isLoaded state has been updated
    renderInfo.allLayersLoaded !== oldRenderInfo.allLayersLoaded || // Some prop is in transition
    renderInfo.layers.some((layer) => layer.props.transitions);
    this.channels[collisionGroup] = renderInfo;
    if (needsRender) {
      this.lastViewport = viewport;
      const collisionFBO = this.collisionFBOs[collisionGroup];
      this.collisionFilterPass.renderCollisionMap(collisionFBO, {
        pass: "collision-filter",
        isPicking: true,
        layers: renderInfo.layers,
        effects,
        layerFilter,
        viewports: viewport ? [viewport] : [],
        onViewportActive,
        views,
        shaderModuleProps: {
          collision: {
            enabled: true,
            // To avoid feedback loop forming between Framebuffer and active Texture.
            dummyCollisionMap: this.dummyCollisionMap
          },
          project: {
            // @ts-expect-error TODO - assuming WebGL context
            devicePixelRatio: collisionFBO.device.canvasContext.getDevicePixelRatio() / DOWNSCALE
          }
        }
      });
    }
  }
  /**
   * Group layers by collisionGroup
   * Returns a map from collisionGroup to render info
   */
  _groupByCollisionGroup(device, collisionLayers) {
    const channelMap = {};
    for (const layer of collisionLayers) {
      const collisionGroup = layer.props.collisionGroup;
      let channelInfo = channelMap[collisionGroup];
      if (!channelInfo) {
        channelInfo = { collisionGroup, layers: [], layerBounds: [], allLayersLoaded: true };
        channelMap[collisionGroup] = channelInfo;
      }
      channelInfo.layers.push(layer);
      channelInfo.layerBounds.push(layer.getBounds());
      if (!layer.isLoaded) {
        channelInfo.allLayersLoaded = false;
      }
    }
    for (const collisionGroup of Object.keys(channelMap)) {
      if (!this.collisionFBOs[collisionGroup]) {
        this.createFBO(device, collisionGroup);
      }
      if (!this.channels[collisionGroup]) {
        this.channels[collisionGroup] = channelMap[collisionGroup];
      }
    }
    for (const collisionGroup of Object.keys(this.collisionFBOs)) {
      if (!channelMap[collisionGroup]) {
        this.destroyFBO(collisionGroup);
      }
    }
    return channelMap;
  }
  getShaderModuleProps(layer) {
    const { collisionGroup, collisionEnabled } = layer.props;
    const { collisionFBOs, dummyCollisionMap } = this;
    const collisionFBO = collisionFBOs[collisionGroup];
    const enabled = collisionEnabled && Boolean(collisionFBO);
    return {
      collision: {
        enabled,
        collisionFBO,
        dummyCollisionMap
      }
    };
  }
  cleanup() {
    if (this.dummyCollisionMap) {
      this.dummyCollisionMap.delete();
      this.dummyCollisionMap = void 0;
    }
    this.channels = {};
    for (const collisionGroup of Object.keys(this.collisionFBOs)) {
      this.destroyFBO(collisionGroup);
    }
    this.collisionFBOs = {};
    this.lastViewport = void 0;
  }
  createFBO(device, collisionGroup) {
    const { width, height } = device.getDefaultCanvasContext().canvas;
    const collisionMap = device.createTexture({
      format: "rgba8unorm",
      width,
      height,
      sampler: {
        minFilter: "nearest",
        magFilter: "nearest",
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge"
      }
    });
    const depthStencilAttachment = device.createTexture({
      format: "depth16unorm",
      width,
      height
    });
    this.collisionFBOs[collisionGroup] = device.createFramebuffer({
      id: `collision-${collisionGroup}`,
      width,
      height,
      colorAttachments: [collisionMap],
      depthStencilAttachment
    });
  }
  destroyFBO(collisionGroup) {
    var _a, _b;
    const fbo = this.collisionFBOs[collisionGroup];
    (_a = fbo.colorAttachments[0]) == null ? void 0 : _a.destroy();
    (_b = fbo.depthStencilAttachment) == null ? void 0 : _b.destroy();
    fbo.destroy();
    delete this.collisionFBOs[collisionGroup];
  }
};

// node_modules/@deck.gl/extensions/dist/collision-filter/collision-filter-extension.js
var defaultProps36 = {
  getCollisionPriority: { type: "accessor", value: 0 },
  collisionEnabled: true,
  collisionGroup: { type: "string", value: "default" },
  collisionTestProps: {}
};
var CollisionFilterExtension = class extends layer_extension_default {
  getShaders() {
    return { modules: [shader_module_default2] };
  }
  /* eslint-disable camelcase */
  draw({ shaderModuleProps }) {
    var _a;
    if ((_a = shaderModuleProps.collision) == null ? void 0 : _a.drawToCollisionMap) {
      this.props = this.clone(this.props.collisionTestProps).props;
    }
  }
  initializeState(context, extension) {
    var _a;
    if (this.getAttributeManager() === null) {
      return;
    }
    (_a = this.context.deck) == null ? void 0 : _a._addDefaultEffect(new CollisionFilterEffect());
    const attributeManager = this.getAttributeManager();
    attributeManager.add({
      collisionPriorities: {
        size: 1,
        stepMode: "dynamic",
        accessor: "getCollisionPriority"
      }
    });
  }
  getNeedsPickingBuffer() {
    return this.props.collisionEnabled;
  }
};
CollisionFilterExtension.defaultProps = defaultProps36;
CollisionFilterExtension.extensionName = "CollisionFilterExtension";

// node_modules/@deck.gl/extensions/dist/mask/shader-module.js
var uniformBlock16 = (
  /* glsl */
  `uniform maskUniforms {
  vec4 bounds;
  highp int channel;
  bool enabled;
  bool inverted;
  bool maskByInstance;
} mask;
`
);
var vertex3 = (
  /* glsl */
  `
vec2 mask_getCoords(vec4 position) {
  return (position.xy - mask.bounds.xy) / (mask.bounds.zw - mask.bounds.xy);
}
`
);
var vs6 = `
${uniformBlock16}
${vertex3}
`;
var fragment3 = (
  /* glsl */
  `
uniform sampler2D mask_texture;

bool mask_isInBounds(vec2 texCoords) {
  if (!mask.enabled) {
    return true;
  }
  vec4 maskColor = texture(mask_texture, texCoords);
  float maskValue = 1.0;
  if (mask.channel == 0) {
    maskValue = maskColor.r;
  } else if (mask.channel == 1) {
    maskValue = maskColor.g;
  } else if (mask.channel == 2) {
    maskValue = maskColor.b;
  } else if (mask.channel == 3) {
    maskValue = maskColor.a;
  }

  if (mask.inverted) {
    return maskValue >= 0.5;
  } else {
    return maskValue < 0.5;
  }
}
`
);
var fs5 = `
${uniformBlock16}
${fragment3}
`;
var inject5 = {
  "vs:#decl": (
    /* glsl */
    `
out vec2 mask_texCoords;
`
  ),
  "vs:#main-end": (
    /* glsl */
    `
   vec4 mask_common_position;
   if (mask.maskByInstance) {
     mask_common_position = project_position(vec4(geometry.worldPosition, 1.0));
   } else {
     mask_common_position = geometry.position;
   }
   mask_texCoords = mask_getCoords(mask_common_position);
`
  ),
  "fs:#decl": (
    /* glsl */
    `
in vec2 mask_texCoords;
`
  ),
  "fs:#main-start": (
    /* glsl */
    `
  if (mask.enabled) {
    bool mask = mask_isInBounds(mask_texCoords);

    // Debug: show extent of render target
    // fragColor = vec4(mask_texCoords, 0.0, 1.0);
    // fragColor = texture(mask_texture, mask_texCoords);

    if (!mask) discard;
  }
`
  )
};
var getMaskUniforms = (opts) => {
  if (opts && "maskMap" in opts) {
    return {
      mask_texture: opts.maskMap
    };
  }
  return opts || {};
};
var shader_module_default3 = {
  name: "mask",
  dependencies: [project_default],
  vs: vs6,
  fs: fs5,
  inject: inject5,
  getUniforms: getMaskUniforms,
  uniformTypes: {
    bounds: "vec4<f32>",
    channel: "i32",
    enabled: "i32",
    inverted: "i32",
    maskByInstance: "i32"
  }
};

// node_modules/@deck.gl/extensions/dist/mask/mask-pass.js
var MASK_BLENDING = {
  blendColorOperation: "subtract",
  blendColorSrcFactor: "zero",
  blendColorDstFactor: "one",
  blendAlphaOperation: "subtract",
  blendAlphaSrcFactor: "zero",
  blendAlphaDstFactor: "one"
};
var MaskPass = class extends LayersPass {
  constructor(device, props) {
    super(device, props);
    const { mapSize = 2048 } = props;
    this.maskMap = device.createTexture({
      format: "rgba8unorm",
      width: mapSize,
      height: mapSize,
      sampler: {
        minFilter: "linear",
        magFilter: "linear",
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge"
      }
    });
    this.fbo = device.createFramebuffer({
      id: "maskmap",
      width: mapSize,
      height: mapSize,
      colorAttachments: [this.maskMap]
    });
  }
  render(options) {
    const colorMask = 2 ** options.channel;
    const clearColor = [255, 255, 255, 255];
    super.render({ ...options, clearColor, colorMask, target: this.fbo, pass: "mask" });
  }
  getLayerParameters(layer, layerIndex, viewport) {
    return {
      ...layer.props.parameters,
      blend: true,
      depthCompare: "always",
      ...MASK_BLENDING
    };
  }
  shouldDrawLayer(layer) {
    return layer.props.operation.includes("mask");
  }
  delete() {
    this.fbo.delete();
    this.maskMap.delete();
  }
};

// node_modules/@deck.gl/extensions/dist/utils/projection-utils.js
function joinLayerBounds(layers, viewport) {
  const bounds = [Infinity, Infinity, -Infinity, -Infinity];
  for (const layer of layers) {
    const layerBounds = layer.getBounds();
    if (layerBounds) {
      const bottomLeftCommon = layer.projectPosition(layerBounds[0], { viewport, autoOffset: false });
      const topRightCommon = layer.projectPosition(layerBounds[1], { viewport, autoOffset: false });
      bounds[0] = Math.min(bounds[0], bottomLeftCommon[0]);
      bounds[1] = Math.min(bounds[1], bottomLeftCommon[1]);
      bounds[2] = Math.max(bounds[2], topRightCommon[0]);
      bounds[3] = Math.max(bounds[3], topRightCommon[1]);
    }
  }
  if (Number.isFinite(bounds[0])) {
    return bounds;
  }
  return null;
}
var MAX_VIEWPORT_SIZE = 2048;
function makeViewport(opts) {
  const { bounds, viewport, border = 0 } = opts;
  const { isGeospatial } = viewport;
  if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) {
    return null;
  }
  const centerWorld = viewport.unprojectPosition([
    (bounds[0] + bounds[2]) / 2,
    (bounds[1] + bounds[3]) / 2,
    0
  ]);
  let { width, height, zoom } = opts;
  if (zoom === void 0) {
    width = width - border * 2;
    height = height - border * 2;
    const scale7 = Math.min(width / (bounds[2] - bounds[0]), height / (bounds[3] - bounds[1]));
    zoom = Math.min(Math.log2(scale7), 20);
  } else if (!width || !height) {
    const scale7 = 2 ** zoom;
    width = Math.round(Math.abs(bounds[2] - bounds[0]) * scale7);
    height = Math.round(Math.abs(bounds[3] - bounds[1]) * scale7);
    const maxSize = MAX_VIEWPORT_SIZE - border * 2;
    if (width > maxSize || height > maxSize) {
      const r = maxSize / Math.max(width, height);
      width = Math.round(width * r);
      height = Math.round(height * r);
      zoom += Math.log2(r);
    }
  }
  return isGeospatial ? new web_mercator_viewport_default({
    id: viewport.id,
    x: border,
    y: border,
    width,
    height,
    longitude: centerWorld[0],
    latitude: centerWorld[1],
    zoom,
    orthographic: true
  }) : new OrthographicViewport({
    id: viewport.id,
    x: border,
    y: border,
    width,
    height,
    target: centerWorld,
    zoom,
    flipY: false
  });
}
function getViewportBounds(viewport, zRange) {
  let viewportBoundsWorld;
  if (zRange && zRange.length === 2) {
    const [minZ, maxZ] = zRange;
    const bounds0 = viewport.getBounds({ z: minZ });
    const bounds1 = viewport.getBounds({ z: maxZ });
    viewportBoundsWorld = [
      Math.min(bounds0[0], bounds1[0]),
      Math.min(bounds0[1], bounds1[1]),
      Math.max(bounds0[2], bounds1[2]),
      Math.max(bounds0[3], bounds1[3])
    ];
  } else {
    viewportBoundsWorld = viewport.getBounds();
  }
  const viewportBottomLeftCommon = viewport.projectPosition(viewportBoundsWorld.slice(0, 2));
  const viewportTopRightCommon = viewport.projectPosition(viewportBoundsWorld.slice(2, 4));
  return [
    viewportBottomLeftCommon[0],
    viewportBottomLeftCommon[1],
    viewportTopRightCommon[0],
    viewportTopRightCommon[1]
  ];
}
function getRenderBounds(layerBounds, viewport, zRange) {
  if (!layerBounds) {
    return [0, 0, 1, 1];
  }
  const viewportBounds = getViewportBounds(viewport, zRange);
  const paddedBounds = doubleBounds(viewportBounds);
  if (layerBounds[2] - layerBounds[0] <= paddedBounds[2] - paddedBounds[0] && layerBounds[3] - layerBounds[1] <= paddedBounds[3] - paddedBounds[1]) {
    return layerBounds;
  }
  return [
    Math.max(layerBounds[0], paddedBounds[0]),
    Math.max(layerBounds[1], paddedBounds[1]),
    Math.min(layerBounds[2], paddedBounds[2]),
    Math.min(layerBounds[3], paddedBounds[3])
  ];
}
function doubleBounds(bounds) {
  const dx = bounds[2] - bounds[0];
  const dy = bounds[3] - bounds[1];
  const centerX = (bounds[0] + bounds[2]) / 2;
  const centerY = (bounds[1] + bounds[3]) / 2;
  return [centerX - dx, centerY - dy, centerX + dx, centerY + dy];
}

// node_modules/@deck.gl/extensions/dist/mask/mask-effect.js
var MaskEffect = class {
  constructor() {
    this.id = "mask-effect";
    this.props = null;
    this.useInPicking = true;
    this.order = 0;
    this.channels = [];
    this.masks = null;
  }
  setup({ device }) {
    this.dummyMaskMap = device.createTexture({
      width: 1,
      height: 1
    });
    this.maskPass = new MaskPass(device, { id: "default-mask" });
    this.maskMap = this.maskPass.maskMap;
  }
  preRender({ layers, layerFilter, viewports, onViewportActive, views, isPicking }) {
    let didRender = false;
    if (isPicking) {
      return { didRender };
    }
    const maskLayers = layers.filter((l) => l.props.visible && l.props.operation.includes("mask"));
    if (maskLayers.length === 0) {
      this.masks = null;
      this.channels.length = 0;
      return { didRender };
    }
    this.masks = {};
    const channelMap = this._sortMaskChannels(maskLayers);
    const viewport = viewports[0];
    const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport);
    if (viewport.resolution !== void 0) {
      log_default.warn("MaskExtension is not supported in GlobeView")();
      return { didRender };
    }
    for (const maskId in channelMap) {
      const result = this._renderChannel(channelMap[maskId], {
        layerFilter,
        onViewportActive,
        views,
        viewport,
        viewportChanged
      });
      didRender || (didRender = result);
    }
    return { didRender };
  }
  /* eslint-disable-next-line complexity */
  _renderChannel(channelInfo, { layerFilter, onViewportActive, views, viewport, viewportChanged }) {
    let didRender = false;
    const oldChannelInfo = this.channels[channelInfo.index];
    if (!oldChannelInfo) {
      return didRender;
    }
    const maskChanged = (
      // If a channel is new
      channelInfo === oldChannelInfo || // If sublayers have changed
      channelInfo.layers.length !== oldChannelInfo.layers.length || channelInfo.layers.some((layer, i) => (
        // Layer instance is updated
        // Layer props might have changed
        // Undetermined props could have an effect on the output geometry of a mask layer,
        // for example getRadius+updateTriggers, radiusScale, modelMatrix
        layer !== oldChannelInfo.layers[i] || // Some prop is in transition
        layer.props.transitions
      )) || // If a sublayer's positions have been updated, the cached bounds will change shallowly
      channelInfo.layerBounds.some((b2, i) => b2 !== oldChannelInfo.layerBounds[i])
    );
    channelInfo.bounds = oldChannelInfo.bounds;
    channelInfo.maskBounds = oldChannelInfo.maskBounds;
    this.channels[channelInfo.index] = channelInfo;
    if (maskChanged || viewportChanged) {
      this.lastViewport = viewport;
      const layerBounds = joinLayerBounds(channelInfo.layers, viewport);
      channelInfo.bounds = layerBounds && getRenderBounds(layerBounds, viewport);
      if (maskChanged || !equals(channelInfo.bounds, oldChannelInfo.bounds)) {
        const { maskPass, maskMap } = this;
        const maskViewport = layerBounds && makeViewport({
          bounds: channelInfo.bounds,
          viewport,
          width: maskMap.width,
          height: maskMap.height,
          border: 1
        });
        channelInfo.maskBounds = maskViewport ? maskViewport.getBounds() : [0, 0, 1, 1];
        maskPass.render({
          pass: "mask",
          channel: channelInfo.index,
          layers: channelInfo.layers,
          layerFilter,
          viewports: maskViewport ? [maskViewport] : [],
          onViewportActive,
          views,
          shaderModuleProps: {
            project: {
              devicePixelRatio: 1
            }
          }
        });
        didRender = true;
      }
    }
    this.masks[channelInfo.id] = {
      index: channelInfo.index,
      bounds: channelInfo.maskBounds,
      coordinateOrigin: channelInfo.coordinateOrigin,
      coordinateSystem: channelInfo.coordinateSystem
    };
    return didRender;
  }
  /**
   * Find a channel to render each mask into
   * If a maskId already exists, diff and update the existing channel
   * Otherwise replace a removed mask
   * Otherwise create a new channel
   * Returns a map from mask layer id to channel info
   */
  _sortMaskChannels(maskLayers) {
    const channelMap = {};
    let channelCount = 0;
    for (const layer of maskLayers) {
      const { id } = layer.root;
      let channelInfo = channelMap[id];
      if (!channelInfo) {
        if (++channelCount > 4) {
          log_default.warn("Too many mask layers. The max supported is 4")();
          continue;
        }
        channelInfo = {
          id,
          index: this.channels.findIndex((c2) => (c2 == null ? void 0 : c2.id) === id),
          layers: [],
          layerBounds: [],
          coordinateOrigin: layer.root.props.coordinateOrigin,
          coordinateSystem: layer.root.props.coordinateSystem
        };
        channelMap[id] = channelInfo;
      }
      channelInfo.layers.push(layer);
      channelInfo.layerBounds.push(layer.getBounds());
    }
    for (let i = 0; i < 4; i++) {
      const channelInfo = this.channels[i];
      if (!channelInfo || !(channelInfo.id in channelMap)) {
        this.channels[i] = null;
      }
    }
    for (const maskId in channelMap) {
      const channelInfo = channelMap[maskId];
      if (channelInfo.index < 0) {
        channelInfo.index = this.channels.findIndex((c2) => !c2);
        this.channels[channelInfo.index] = channelInfo;
      }
    }
    return channelMap;
  }
  getShaderModuleProps() {
    return {
      mask: {
        maskMap: this.masks ? this.maskMap : this.dummyMaskMap,
        maskChannels: this.masks
      }
    };
  }
  cleanup() {
    if (this.dummyMaskMap) {
      this.dummyMaskMap.delete();
      this.dummyMaskMap = void 0;
    }
    if (this.maskPass) {
      this.maskPass.delete();
      this.maskPass = void 0;
      this.maskMap = void 0;
    }
    this.lastViewport = void 0;
    this.masks = null;
    this.channels.length = 0;
  }
};

// node_modules/@deck.gl/extensions/dist/mask/mask-extension.js
var defaultProps37 = {
  maskId: "",
  maskByInstance: void 0,
  maskInverted: false
};
var MaskExtension = class extends layer_extension_default {
  initializeState() {
    var _a;
    (_a = this.context.deck) == null ? void 0 : _a._addDefaultEffect(new MaskEffect());
  }
  getShaders() {
    let maskByInstance = "instancePositions" in this.getAttributeManager().attributes;
    if (this.props.maskByInstance !== void 0) {
      maskByInstance = Boolean(this.props.maskByInstance);
    }
    this.state.maskByInstance = maskByInstance;
    return {
      modules: [shader_module_default3]
    };
  }
  /* eslint-disable camelcase */
  draw({ context, shaderModuleProps }) {
    const maskProps = {};
    maskProps.maskByInstance = Boolean(this.state.maskByInstance);
    const { maskId, maskInverted } = this.props;
    const { maskChannels } = shaderModuleProps.mask || {};
    const { viewport } = context;
    if (maskChannels && maskChannels[maskId]) {
      const { index, bounds, coordinateOrigin: fromCoordinateOrigin } = maskChannels[maskId];
      let { coordinateSystem: fromCoordinateSystem } = maskChannels[maskId];
      maskProps.enabled = true;
      maskProps.channel = index;
      maskProps.inverted = maskInverted;
      if (fromCoordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
        fromCoordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;
      }
      const opts = { modelMatrix: null, fromCoordinateOrigin, fromCoordinateSystem };
      const bl = this.projectPosition([bounds[0], bounds[1], 0], opts);
      const tr = this.projectPosition([bounds[2], bounds[3], 0], opts);
      maskProps.bounds = [bl[0], bl[1], tr[0], tr[1]];
    } else {
      if (maskId) {
        log_default.warn(`Could not find a mask layer with id: ${maskId}`)();
      }
      maskProps.enabled = false;
    }
    this.setShaderModuleProps({ mask: maskProps });
  }
};
MaskExtension.defaultProps = defaultProps37;
MaskExtension.extensionName = "MaskExtension";

// node_modules/@deck.gl/extensions/dist/terrain/shader-module.js
var TERRAIN_MODE = {
  NONE: 0,
  /** A terrain layer rendering encoded ground elevation into the height map */
  WRITE_HEIGHT_MAP: 1,
  /** An offset layer reading encoded ground elevation from the height map */
  USE_HEIGHT_MAP: 2,
  /** A terrain layer rendering to screen, using the cover fbo overlaid with its own texture */
  USE_COVER: 3,
  /** A terrain layer rendering to screen, using the cover fbo as texture */
  USE_COVER_ONLY: 4,
  /** Draped layer is rendered into a texture, and never to screen */
  SKIP: 5
};
var TERRAIN_MODE_CONSTANTS = Object.keys(TERRAIN_MODE).map((key) => `const float TERRAIN_MODE_${key} = ${TERRAIN_MODE[key]}.0;`).join("\n");
var uniformBlock17 = (
  // eslint-disable-next-line prefer-template
  TERRAIN_MODE_CONSTANTS + /* glsl */
  `
uniform terrainUniforms {
  float mode;
  vec4 bounds;
} terrain;

uniform sampler2D terrain_map;
`
);
var terrainModule = {
  name: "terrain",
  dependencies: [project_default],
  // eslint-disable-next-line prefer-template
  vs: uniformBlock17 + /* glsl */
  "out vec3 commonPos;",
  // eslint-disable-next-line prefer-template
  fs: uniformBlock17 + /* glsl */
  "in vec3 commonPos;",
  inject: {
    "vs:#main-start": (
      /* glsl */
      `
if (terrain.mode == TERRAIN_MODE_SKIP) {
  gl_Position = vec4(0.0);
  return;
}
`
    ),
    "vs:DECKGL_FILTER_GL_POSITION": (
      /* glsl */
      `
commonPos = geometry.position.xyz;
if (terrain.mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {
  vec2 texCoords = (commonPos.xy - terrain.bounds.xy) / terrain.bounds.zw;
  position = vec4(texCoords * 2.0 - 1.0, 0.0, 1.0);
  commonPos.z += project.commonOrigin.z;
}
if (terrain.mode == TERRAIN_MODE_USE_HEIGHT_MAP) {
  vec3 anchor = geometry.worldPosition;
  anchor.z = 0.0;
  vec3 anchorCommon = project_position(anchor);
  vec2 texCoords = (anchorCommon.xy - terrain.bounds.xy) / terrain.bounds.zw;
  if (texCoords.x >= 0.0 && texCoords.y >= 0.0 && texCoords.x <= 1.0 && texCoords.y <= 1.0) {
    float terrainZ = texture(terrain_map, texCoords).r;
    geometry.position.z += terrainZ;
    position = project_common_position_to_clipspace(geometry.position);
  }
}
    `
    ),
    "fs:#main-start": (
      /* glsl */
      `
if (terrain.mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {
  fragColor = vec4(commonPos.z, 0.0, 0.0, 1.0);
  return;
}
    `
    ),
    "fs:DECKGL_FILTER_COLOR": (
      /* glsl */
      `
if ((terrain.mode == TERRAIN_MODE_USE_COVER) || (terrain.mode == TERRAIN_MODE_USE_COVER_ONLY)) {
  vec2 texCoords = (commonPos.xy - terrain.bounds.xy) / terrain.bounds.zw;
  vec4 pixel = texture(terrain_map, texCoords);
  if (terrain.mode == TERRAIN_MODE_USE_COVER_ONLY) {
    color = pixel;
  } else {
    // pixel is premultiplied
    color = pixel + color * (1.0 - pixel.a);
  }
  return;
}
    `
    )
  },
  // eslint-disable-next-line complexity
  getUniforms: (opts = {}) => {
    if ("dummyHeightMap" in opts) {
      const { drawToTerrainHeightMap, heightMap, heightMapBounds, dummyHeightMap, terrainCover, useTerrainHeightMap, terrainSkipRender } = opts;
      const projectUniforms = project_default.getUniforms(opts.project);
      const { commonOrigin } = projectUniforms;
      let mode = terrainSkipRender ? TERRAIN_MODE.SKIP : TERRAIN_MODE.NONE;
      let sampler = dummyHeightMap;
      let bounds = null;
      if (drawToTerrainHeightMap) {
        mode = TERRAIN_MODE.WRITE_HEIGHT_MAP;
        bounds = heightMapBounds;
      } else if (useTerrainHeightMap && heightMap) {
        mode = TERRAIN_MODE.USE_HEIGHT_MAP;
        sampler = heightMap;
        bounds = heightMapBounds;
      } else if (terrainCover) {
        const fbo = opts.isPicking ? terrainCover.getPickingFramebuffer() : terrainCover.getRenderFramebuffer();
        sampler = fbo == null ? void 0 : fbo.colorAttachments[0].texture;
        if (opts.isPicking) {
          mode = TERRAIN_MODE.SKIP;
        }
        if (sampler) {
          mode = mode === TERRAIN_MODE.SKIP ? TERRAIN_MODE.USE_COVER_ONLY : TERRAIN_MODE.USE_COVER;
          bounds = terrainCover.bounds;
        } else {
          sampler = dummyHeightMap;
        }
      }
      return {
        mode,
        terrain_map: sampler,
        // Convert bounds to the common space, as [minX, minY, width, height]
        bounds: bounds ? [
          bounds[0] - commonOrigin[0],
          bounds[1] - commonOrigin[1],
          bounds[2] - bounds[0],
          bounds[3] - bounds[1]
        ] : [0, 0, 0, 0]
      };
    }
    return {};
  },
  uniformTypes: {
    mode: "f32",
    bounds: "vec4<f32>"
  }
};

// node_modules/@deck.gl/extensions/dist/terrain/utils.js
function createRenderTarget(device, opts) {
  return device.createFramebuffer({
    id: opts.id,
    colorAttachments: [
      device.createTexture({
        id: opts.id,
        ...opts.float && {
          format: "rgba32float",
          type: 5126
        },
        dimension: "2d",
        width: 1,
        height: 1,
        sampler: opts.interpolate === false ? {
          minFilter: "nearest",
          magFilter: "nearest"
        } : {
          minFilter: "linear",
          magFilter: "linear"
        }
      })
    ]
  });
}

// node_modules/@deck.gl/extensions/dist/terrain/terrain-cover.js
var TerrainCover = class {
  constructor(targetLayer) {
    this.isDirty = true;
    this.renderViewport = null;
    this.bounds = null;
    this.layers = [];
    this.targetBounds = null;
    this.targetBoundsCommon = null;
    this.targetLayer = targetLayer;
    this.tile = getTile(targetLayer);
  }
  get id() {
    return this.targetLayer.id;
  }
  /** returns true if the target layer is still in use (i.e. not finalized) */
  get isActive() {
    return Boolean(this.targetLayer.getCurrentLayer());
  }
  shouldUpdate({ targetLayer, viewport, layers, layerNeedsRedraw }) {
    if (targetLayer) {
      this.targetLayer = targetLayer;
    }
    const sizeChanged = viewport ? this._updateViewport(viewport) : false;
    let layersChanged = layers ? this._updateLayers(layers) : false;
    if (layerNeedsRedraw) {
      for (const id of this.layers) {
        if (layerNeedsRedraw[id]) {
          layersChanged = true;
          break;
        }
      }
    }
    return layersChanged || sizeChanged;
  }
  /** Compare layers with the last version. Only rerender if necessary. */
  _updateLayers(layers) {
    let needsRedraw = false;
    layers = this.tile ? getIntersectingLayers(this.tile, layers) : layers;
    if (layers.length !== this.layers.length) {
      needsRedraw = true;
    } else {
      for (let i = 0; i < layers.length; i++) {
        const id = layers[i].id;
        if (id !== this.layers[i]) {
          needsRedraw = true;
          break;
        }
      }
    }
    if (needsRedraw) {
      this.layers = layers.map((layer) => layer.id);
    }
    return needsRedraw;
  }
  /** Compare viewport and terrain bounds with the last version. Only rerender if necesary. */
  // eslint-disable-next-line max-statements
  _updateViewport(viewport) {
    var _a;
    const targetLayer = this.targetLayer;
    let shouldRedraw = false;
    if (this.tile && "boundingBox" in this.tile) {
      if (!this.targetBounds) {
        shouldRedraw = true;
        this.targetBounds = this.tile.boundingBox;
        const bottomLeftCommon = viewport.projectPosition(this.targetBounds[0]);
        const topRightCommon = viewport.projectPosition(this.targetBounds[1]);
        this.targetBoundsCommon = [
          bottomLeftCommon[0],
          bottomLeftCommon[1],
          topRightCommon[0],
          topRightCommon[1]
        ];
      }
    } else if (this.targetBounds !== targetLayer.getBounds()) {
      shouldRedraw = true;
      this.targetBounds = targetLayer.getBounds();
      this.targetBoundsCommon = joinLayerBounds([targetLayer], viewport);
    }
    if (!this.targetBoundsCommon) {
      return false;
    }
    const newZoom = Math.ceil(viewport.zoom + 0.5);
    if (this.tile) {
      this.bounds = this.targetBoundsCommon;
    } else {
      const oldZoom = (_a = this.renderViewport) == null ? void 0 : _a.zoom;
      shouldRedraw = shouldRedraw || newZoom !== oldZoom;
      const newBounds = getRenderBounds(this.targetBoundsCommon, viewport);
      const oldBounds = this.bounds;
      shouldRedraw = shouldRedraw || !oldBounds || newBounds.some((x, i) => x !== oldBounds[i]);
      this.bounds = newBounds;
    }
    if (shouldRedraw) {
      this.renderViewport = makeViewport({
        bounds: this.bounds,
        zoom: newZoom,
        viewport
      });
    }
    return shouldRedraw;
  }
  getRenderFramebuffer() {
    if (!this.renderViewport || this.layers.length === 0) {
      return null;
    }
    if (!this.fbo) {
      this.fbo = createRenderTarget(this.targetLayer.context.device, { id: this.id });
    }
    return this.fbo;
  }
  getPickingFramebuffer() {
    if (!this.renderViewport || this.layers.length === 0 && !this.targetLayer.props.pickable) {
      return null;
    }
    if (!this.pickingFbo) {
      this.pickingFbo = createRenderTarget(this.targetLayer.context.device, {
        id: `${this.id}-picking`,
        interpolate: false
      });
    }
    return this.pickingFbo;
  }
  filterLayers(layers) {
    return layers.filter(({ id }) => this.layers.includes(id));
  }
  delete() {
    const { fbo, pickingFbo } = this;
    if (fbo) {
      fbo.colorAttachments[0].destroy();
      fbo.destroy();
    }
    if (pickingFbo) {
      pickingFbo.colorAttachments[0].destroy();
      pickingFbo.destroy();
    }
  }
};
function getIntersectingLayers(sourceTile, layers) {
  return layers.filter((layer) => {
    const tile = getTile(layer);
    if (tile) {
      return intersect2(sourceTile.boundingBox, tile.boundingBox);
    }
    return true;
  });
}
function getTile(layer) {
  while (layer) {
    const { tile } = layer.props;
    if (tile) {
      return tile;
    }
    layer = layer.parent;
  }
  return null;
}
function intersect2(b1, b2) {
  if (b1 && b2) {
    return b1[0][0] < b2[1][0] && b2[0][0] < b1[1][0] && b1[0][1] < b2[1][1] && b2[0][1] < b1[1][1];
  }
  return false;
}

// node_modules/@deck.gl/extensions/dist/terrain/terrain-pass.js
var TERRAIN_BLENDING = {
  blendColorOperation: "max",
  blendColorSrcFactor: "one",
  blendColorDstFactor: "one",
  blendAlphaOperation: "max",
  blendAlphaSrcFactor: "one",
  blendAlphaDstFactor: "one"
};
var TerrainPass = class extends LayersPass {
  getRenderableLayers(viewport, opts) {
    const { layers } = opts;
    const result = [];
    const drawParamsByIndex = this._getDrawLayerParams(viewport, opts, true);
    for (let i = 0; i < layers.length; i++) {
      const layer = layers[i];
      if (!layer.isComposite && drawParamsByIndex[i].shouldDrawLayer) {
        result.push(layer);
      }
    }
    return result;
  }
  renderHeightMap(heightMap, opts) {
    const target = heightMap.getRenderFramebuffer();
    const viewport = heightMap.renderViewport;
    if (!target || !viewport) {
      return;
    }
    target.resize(viewport);
    this.render({
      ...opts,
      target,
      pass: "terrain-height-map",
      layers: opts.layers,
      viewports: [viewport],
      effects: [],
      clearColor: [0, 0, 0, 0]
    });
  }
  renderTerrainCover(terrainCover, opts) {
    const target = terrainCover.getRenderFramebuffer();
    const viewport = terrainCover.renderViewport;
    if (!target || !viewport) {
      return;
    }
    const layers = terrainCover.filterLayers(opts.layers);
    target.resize(viewport);
    this.render({
      ...opts,
      target,
      pass: `terrain-cover-${terrainCover.id}`,
      layers,
      effects: [],
      viewports: [viewport],
      clearColor: [0, 0, 0, 0]
    });
  }
  getLayerParameters(layer, layerIndex, viewport) {
    return {
      ...layer.props.parameters,
      blend: true,
      depthCompare: "always",
      ...layer.props.operation.includes("terrain") && TERRAIN_BLENDING
    };
  }
  getShaderModuleProps(layer, effects, otherShaderModuleProps) {
    return {
      terrain: {
        project: otherShaderModuleProps.project
      }
    };
  }
};

// node_modules/@deck.gl/extensions/dist/terrain/terrain-picking-pass.js
var TerrainPickingPass = class extends PickLayersPass {
  constructor() {
    super(...arguments);
    this.drawParameters = {};
  }
  getRenderableLayers(viewport, opts) {
    const { layers } = opts;
    const result = [];
    this.drawParameters = {};
    this._resetColorEncoder(opts.pickZ);
    const drawParamsByIndex = this._getDrawLayerParams(viewport, opts);
    for (let i = 0; i < layers.length; i++) {
      const layer = layers[i];
      if (!layer.isComposite && drawParamsByIndex[i].shouldDrawLayer) {
        result.push(layer);
        this.drawParameters[layer.id] = drawParamsByIndex[i].layerParameters;
      }
    }
    return result;
  }
  renderTerrainCover(terrainCover, opts) {
    const target = terrainCover.getPickingFramebuffer();
    const viewport = terrainCover.renderViewport;
    if (!target || !viewport) {
      return;
    }
    const layers = terrainCover.filterLayers(opts.layers);
    const terrainLayer = terrainCover.targetLayer;
    if (terrainLayer.props.pickable) {
      layers.unshift(terrainLayer);
    }
    target.resize(viewport);
    this.render({
      ...opts,
      pickingFBO: target,
      pass: `terrain-cover-picking-${terrainCover.id}`,
      layers,
      effects: [],
      viewports: [viewport],
      // Disable the default culling because TileLayer would cull sublayers based on the screen viewport,
      // not the viewport of the terrain cover. Culling is already done by `terrainCover.filterLayers`
      cullRect: void 0,
      deviceRect: viewport,
      pickZ: false
    });
  }
  getLayerParameters(layer, layerIndex, viewport) {
    let parameters2;
    if (this.drawParameters[layer.id]) {
      parameters2 = this.drawParameters[layer.id];
    } else {
      parameters2 = super.getLayerParameters(layer, layerIndex, viewport);
      parameters2.blend = true;
    }
    return { ...parameters2, depthCompare: "always" };
  }
  getShaderModuleProps(layer, effects, otherShaderModuleProps) {
    const base = super.getShaderModuleProps(layer, effects, otherShaderModuleProps);
    return {
      ...base,
      terrain: {
        project: otherShaderModuleProps.project
      }
    };
  }
};

// node_modules/@deck.gl/extensions/dist/terrain/height-map-builder.js
var MAP_MAX_SIZE = 2048;
var HeightMapBuilder = class {
  static isSupported(device) {
    return device.isTextureFormatRenderable("rgba32float");
  }
  constructor(device) {
    this.renderViewport = null;
    this.bounds = null;
    this.layers = [];
    this.layersBounds = [];
    this.layersBoundsCommon = null;
    this.lastViewport = null;
    this.device = device;
  }
  /** Returns the height map framebuffer for read/write access.
   * Returns null when the texture is invalid.
   */
  getRenderFramebuffer() {
    if (!this.renderViewport) {
      return null;
    }
    if (!this.fbo) {
      this.fbo = createRenderTarget(this.device, { id: "height-map", float: true });
    }
    return this.fbo;
  }
  /** Called every render cycle to check if the framebuffer needs update */
  shouldUpdate({ layers, viewport }) {
    const layersChanged = layers.length !== this.layers.length || layers.some((layer, i) => (
      // Layer instance is updated
      // Layer props might have changed
      // Undetermined props could have an effect on the output geometry of a terrain source,
      // for example getElevation+updateTriggers, elevationScale, modelMatrix
      layer !== this.layers[i] || // Some prop is in transition
      layer.props.transitions || // Layer's geometry bounds have changed
      layer.getBounds() !== this.layersBounds[i]
    ));
    if (layersChanged) {
      this.layers = layers;
      this.layersBounds = layers.map((layer) => layer.getBounds());
      this.layersBoundsCommon = joinLayerBounds(layers, viewport);
    }
    const viewportChanged = !this.lastViewport || !viewport.equals(this.lastViewport);
    if (!this.layersBoundsCommon) {
      this.renderViewport = null;
    } else if (layersChanged || viewportChanged) {
      const bounds = getRenderBounds(this.layersBoundsCommon, viewport);
      if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) {
        this.renderViewport = null;
        return false;
      }
      this.bounds = bounds;
      this.lastViewport = viewport;
      const scale7 = viewport.scale;
      const pixelWidth = (bounds[2] - bounds[0]) * scale7;
      const pixelHeight = (bounds[3] - bounds[1]) * scale7;
      this.renderViewport = pixelWidth > 0 || pixelHeight > 0 ? makeViewport({
        // It's not important whether the geometry is visible in this viewport, because
        // vertices will not use the standard project_to_clipspace in the DRAW_TO_HEIGHT_MAP shader
        // However the viewport must have the same center and zoom as the screen viewport
        // So that projection uniforms used for calculating z are the same
        bounds: [
          viewport.center[0] - 1,
          viewport.center[1] - 1,
          viewport.center[0] + 1,
          viewport.center[1] + 1
        ],
        zoom: viewport.zoom,
        width: Math.min(pixelWidth, MAP_MAX_SIZE),
        height: Math.min(pixelHeight, MAP_MAX_SIZE),
        viewport
      }) : null;
      return true;
    }
    return false;
  }
  delete() {
    if (this.fbo) {
      this.fbo.colorAttachments[0].delete();
      this.fbo.delete();
    }
  }
};

// node_modules/@deck.gl/extensions/dist/terrain/terrain-effect.js
var TerrainEffect = class {
  constructor() {
    this.id = "terrain-effect";
    this.props = null;
    this.useInPicking = true;
    this.isPicking = false;
    this.isDrapingEnabled = false;
    this.terrainCovers = /* @__PURE__ */ new Map();
  }
  setup({ device, deck }) {
    this.dummyHeightMap = device.createTexture({
      width: 1,
      height: 1,
      data: new Uint8Array([0, 0, 0, 0])
    });
    this.terrainPass = new TerrainPass(device, { id: "terrain" });
    this.terrainPickingPass = new TerrainPickingPass(device, { id: "terrain-picking" });
    if (HeightMapBuilder.isSupported(device)) {
      this.heightMap = new HeightMapBuilder(device);
    } else {
      log_default.warn("Terrain offset mode is not supported by this browser")();
    }
    deck._addDefaultShaderModule(terrainModule);
  }
  preRender(opts) {
    if (opts.pickZ) {
      this.isDrapingEnabled = false;
      return;
    }
    const { viewports } = opts;
    const isPicking = opts.pass.startsWith("picking");
    this.isPicking = isPicking;
    this.isDrapingEnabled = true;
    const viewport = viewports[0];
    const layers = (isPicking ? this.terrainPickingPass : this.terrainPass).getRenderableLayers(viewport, opts);
    const terrainLayers = layers.filter((l) => l.props.operation.includes("terrain"));
    if (terrainLayers.length === 0) {
      return;
    }
    if (!isPicking) {
      const offsetLayers = layers.filter((l) => l.state.terrainDrawMode === "offset");
      if (offsetLayers.length > 0) {
        this._updateHeightMap(terrainLayers, viewport, opts);
      }
    }
    const drapeLayers = layers.filter((l) => l.state.terrainDrawMode === "drape");
    this._updateTerrainCovers(terrainLayers, drapeLayers, viewport, opts);
  }
  getShaderModuleProps(layer, otherShaderModuleProps) {
    var _a, _b, _c;
    const { terrainDrawMode } = layer.state;
    return {
      terrain: {
        project: otherShaderModuleProps.project,
        isPicking: this.isPicking,
        heightMap: ((_b = (_a = this.heightMap) == null ? void 0 : _a.getRenderFramebuffer()) == null ? void 0 : _b.colorAttachments[0].texture) || null,
        heightMapBounds: (_c = this.heightMap) == null ? void 0 : _c.bounds,
        dummyHeightMap: this.dummyHeightMap,
        terrainCover: this.isDrapingEnabled ? this.terrainCovers.get(layer.id) : null,
        useTerrainHeightMap: terrainDrawMode === "offset",
        terrainSkipRender: terrainDrawMode === "drape" || !layer.props.operation.includes("draw")
      }
    };
  }
  cleanup({ deck }) {
    if (this.dummyHeightMap) {
      this.dummyHeightMap.delete();
      this.dummyHeightMap = void 0;
    }
    if (this.heightMap) {
      this.heightMap.delete();
      this.heightMap = void 0;
    }
    for (const terrainCover of this.terrainCovers.values()) {
      terrainCover.delete();
    }
    this.terrainCovers.clear();
    deck._removeDefaultShaderModule(terrainModule);
  }
  _updateHeightMap(terrainLayers, viewport, opts) {
    if (!this.heightMap) {
      return;
    }
    const shouldUpdate = this.heightMap.shouldUpdate({ layers: terrainLayers, viewport });
    if (!shouldUpdate) {
      return;
    }
    this.terrainPass.renderHeightMap(this.heightMap, {
      ...opts,
      layers: terrainLayers,
      shaderModuleProps: {
        terrain: {
          heightMapBounds: this.heightMap.bounds,
          dummyHeightMap: this.dummyHeightMap,
          drawToTerrainHeightMap: true
        },
        project: {
          devicePixelRatio: 1
        }
      }
    });
  }
  _updateTerrainCovers(terrainLayers, drapeLayers, viewport, opts) {
    const layerNeedsRedraw = {};
    for (const layer of drapeLayers) {
      if (layer.state.terrainCoverNeedsRedraw) {
        layerNeedsRedraw[layer.id] = true;
        layer.state.terrainCoverNeedsRedraw = false;
      }
    }
    for (const terrainCover of this.terrainCovers.values()) {
      terrainCover.isDirty = terrainCover.isDirty || terrainCover.shouldUpdate({ layerNeedsRedraw });
    }
    for (const layer of terrainLayers) {
      this._updateTerrainCover(layer, drapeLayers, viewport, opts);
    }
    if (!this.isPicking) {
      this._pruneTerrainCovers();
    }
  }
  _updateTerrainCover(terrainLayer, drapeLayers, viewport, opts) {
    const renderPass = this.isPicking ? this.terrainPickingPass : this.terrainPass;
    let terrainCover = this.terrainCovers.get(terrainLayer.id);
    if (!terrainCover) {
      terrainCover = new TerrainCover(terrainLayer);
      this.terrainCovers.set(terrainLayer.id, terrainCover);
    }
    try {
      const isDirty = terrainCover.shouldUpdate({
        targetLayer: terrainLayer,
        viewport,
        layers: drapeLayers
      });
      if (this.isPicking || terrainCover.isDirty || isDirty) {
        renderPass.renderTerrainCover(terrainCover, {
          ...opts,
          layers: drapeLayers,
          shaderModuleProps: {
            terrain: {
              dummyHeightMap: this.dummyHeightMap,
              terrainSkipRender: false
            },
            project: {
              devicePixelRatio: 1
            }
          }
        });
        if (!this.isPicking) {
          terrainCover.isDirty = false;
        }
      }
    } catch (err) {
      terrainLayer.raiseError(err, `Error rendering terrain cover ${terrainCover.id}`);
    }
  }
  _pruneTerrainCovers() {
    const idsToRemove = [];
    for (const [id, terrainCover] of this.terrainCovers) {
      if (!terrainCover.isActive) {
        idsToRemove.push(id);
      }
    }
    for (const id of idsToRemove) {
      this.terrainCovers.delete(id);
    }
  }
};

// node_modules/@deck.gl/extensions/dist/terrain/terrain-extension.js
var defaultProps38 = {
  terrainDrawMode: void 0
};
var TerrainExtension = class extends layer_extension_default {
  getShaders() {
    return {
      modules: [terrainModule]
    };
  }
  initializeState() {
    var _a;
    (_a = this.context.deck) == null ? void 0 : _a._addDefaultEffect(new TerrainEffect());
  }
  updateState(params) {
    var _a;
    const { props, oldProps } = params;
    if (this.state.terrainDrawMode && props.terrainDrawMode === oldProps.terrainDrawMode && // @ts-ignore `extruded` may not exist in props
    props.extruded === oldProps.extruded) {
      return;
    }
    let { terrainDrawMode } = props;
    if (!terrainDrawMode) {
      const is3d = this.props.extruded;
      const attributes = (_a = this.getAttributeManager()) == null ? void 0 : _a.attributes;
      const hasAnchor = attributes && "instancePositions" in attributes;
      terrainDrawMode = is3d || hasAnchor ? "offset" : "drape";
    }
    this.setState({ terrainDrawMode });
  }
  onNeedsRedraw() {
    const state = this.state;
    if (state.terrainDrawMode === "drape") {
      state.terrainCoverNeedsRedraw = true;
    }
  }
};
TerrainExtension.defaultProps = defaultProps38;
TerrainExtension.extensionName = "TerrainExtension";

// node_modules/@loaders.gl/gis/dist/lib/binary-features/flat-geojson-to-binary.js
function flatGeojsonToBinary(features2, geometryInfo, options) {
  const propArrayTypes = extractNumericPropTypes(features2);
  const numericPropKeys = Object.keys(propArrayTypes).filter((k) => propArrayTypes[k] !== Array);
  return fillArrays(features2, {
    propArrayTypes,
    ...geometryInfo
  }, {
    numericPropKeys: options && options.numericPropKeys || numericPropKeys,
    PositionDataType: options ? options.PositionDataType : Float32Array,
    triangulate: options ? options.triangulate : true
  });
}
function extractNumericPropTypes(features2) {
  const propArrayTypes = {};
  for (const feature2 of features2) {
    if (feature2.properties) {
      for (const key in feature2.properties) {
        const val = feature2.properties[key];
        propArrayTypes[key] = deduceArrayType(val, propArrayTypes[key]);
      }
    }
  }
  return propArrayTypes;
}
function fillArrays(features2, geometryInfo, options) {
  const { pointPositionsCount, pointFeaturesCount, linePositionsCount, linePathsCount, lineFeaturesCount, polygonPositionsCount, polygonObjectsCount, polygonRingsCount, polygonFeaturesCount, propArrayTypes, coordLength } = geometryInfo;
  const { numericPropKeys = [], PositionDataType = Float32Array, triangulate = true } = options;
  const hasGlobalId = features2[0] && "id" in features2[0];
  const GlobalFeatureIdsDataType = features2.length > 65535 ? Uint32Array : Uint16Array;
  const points = {
    type: "Point",
    positions: new PositionDataType(pointPositionsCount * coordLength),
    globalFeatureIds: new GlobalFeatureIdsDataType(pointPositionsCount),
    featureIds: pointFeaturesCount > 65535 ? new Uint32Array(pointPositionsCount) : new Uint16Array(pointPositionsCount),
    numericProps: {},
    properties: [],
    fields: []
  };
  const lines = {
    type: "LineString",
    pathIndices: linePositionsCount > 65535 ? new Uint32Array(linePathsCount + 1) : new Uint16Array(linePathsCount + 1),
    positions: new PositionDataType(linePositionsCount * coordLength),
    globalFeatureIds: new GlobalFeatureIdsDataType(linePositionsCount),
    featureIds: lineFeaturesCount > 65535 ? new Uint32Array(linePositionsCount) : new Uint16Array(linePositionsCount),
    numericProps: {},
    properties: [],
    fields: []
  };
  const polygons = {
    type: "Polygon",
    polygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonObjectsCount + 1) : new Uint16Array(polygonObjectsCount + 1),
    primitivePolygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonRingsCount + 1) : new Uint16Array(polygonRingsCount + 1),
    positions: new PositionDataType(polygonPositionsCount * coordLength),
    globalFeatureIds: new GlobalFeatureIdsDataType(polygonPositionsCount),
    featureIds: polygonFeaturesCount > 65535 ? new Uint32Array(polygonPositionsCount) : new Uint16Array(polygonPositionsCount),
    numericProps: {},
    properties: [],
    fields: []
  };
  if (triangulate) {
    polygons.triangles = [];
  }
  for (const object of [points, lines, polygons]) {
    for (const propName of numericPropKeys) {
      const T = propArrayTypes[propName];
      object.numericProps[propName] = new T(object.positions.length / coordLength);
    }
  }
  lines.pathIndices[linePathsCount] = linePositionsCount;
  polygons.polygonIndices[polygonObjectsCount] = polygonPositionsCount;
  polygons.primitivePolygonIndices[polygonRingsCount] = polygonPositionsCount;
  const indexMap = {
    pointPosition: 0,
    pointFeature: 0,
    linePosition: 0,
    linePath: 0,
    lineFeature: 0,
    polygonPosition: 0,
    polygonObject: 0,
    polygonRing: 0,
    polygonFeature: 0,
    feature: 0
  };
  for (const feature2 of features2) {
    const geometry = feature2.geometry;
    const properties = feature2.properties || {};
    switch (geometry.type) {
      case "Point":
        handlePoint(geometry, points, indexMap, coordLength, properties);
        points.properties.push(keepStringProperties(properties, numericPropKeys));
        if (hasGlobalId) {
          points.fields.push({ id: feature2.id });
        }
        indexMap.pointFeature++;
        break;
      case "LineString":
        handleLineString(geometry, lines, indexMap, coordLength, properties);
        lines.properties.push(keepStringProperties(properties, numericPropKeys));
        if (hasGlobalId) {
          lines.fields.push({ id: feature2.id });
        }
        indexMap.lineFeature++;
        break;
      case "Polygon":
        handlePolygon(geometry, polygons, indexMap, coordLength, properties);
        polygons.properties.push(keepStringProperties(properties, numericPropKeys));
        if (hasGlobalId) {
          polygons.fields.push({ id: feature2.id });
        }
        indexMap.polygonFeature++;
        break;
      default:
        throw new Error("Invalid geometry type");
    }
    indexMap.feature++;
  }
  return makeAccessorObjects(points, lines, polygons, coordLength);
}
function handlePoint(geometry, points, indexMap, coordLength, properties) {
  points.positions.set(geometry.data, indexMap.pointPosition * coordLength);
  const nPositions = geometry.data.length / coordLength;
  fillNumericProperties(points, properties, indexMap.pointPosition, nPositions);
  points.globalFeatureIds.fill(indexMap.feature, indexMap.pointPosition, indexMap.pointPosition + nPositions);
  points.featureIds.fill(indexMap.pointFeature, indexMap.pointPosition, indexMap.pointPosition + nPositions);
  indexMap.pointPosition += nPositions;
}
function handleLineString(geometry, lines, indexMap, coordLength, properties) {
  lines.positions.set(geometry.data, indexMap.linePosition * coordLength);
  const nPositions = geometry.data.length / coordLength;
  fillNumericProperties(lines, properties, indexMap.linePosition, nPositions);
  lines.globalFeatureIds.fill(indexMap.feature, indexMap.linePosition, indexMap.linePosition + nPositions);
  lines.featureIds.fill(indexMap.lineFeature, indexMap.linePosition, indexMap.linePosition + nPositions);
  for (let i = 0, il = geometry.indices.length; i < il; ++i) {
    const start = geometry.indices[i];
    const end = i === il - 1 ? geometry.data.length : geometry.indices[i + 1];
    lines.pathIndices[indexMap.linePath++] = indexMap.linePosition;
    indexMap.linePosition += (end - start) / coordLength;
  }
}
function handlePolygon(geometry, polygons, indexMap, coordLength, properties) {
  polygons.positions.set(geometry.data, indexMap.polygonPosition * coordLength);
  const nPositions = geometry.data.length / coordLength;
  fillNumericProperties(polygons, properties, indexMap.polygonPosition, nPositions);
  polygons.globalFeatureIds.fill(indexMap.feature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);
  polygons.featureIds.fill(indexMap.polygonFeature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);
  for (let l = 0, ll = geometry.indices.length; l < ll; ++l) {
    const startPosition = indexMap.polygonPosition;
    polygons.polygonIndices[indexMap.polygonObject++] = startPosition;
    const areas = geometry.areas[l];
    const indices = geometry.indices[l];
    const nextIndices = geometry.indices[l + 1];
    for (let i = 0, il = indices.length; i < il; ++i) {
      const start = indices[i];
      const end = i === il - 1 ? (
        // last line, so either read to:
        nextIndices === void 0 ? geometry.data.length : nextIndices[0]
      ) : indices[i + 1];
      polygons.primitivePolygonIndices[indexMap.polygonRing++] = indexMap.polygonPosition;
      indexMap.polygonPosition += (end - start) / coordLength;
    }
    const endPosition = indexMap.polygonPosition;
    triangulatePolygon(polygons, areas, indices, { startPosition, endPosition, coordLength });
  }
}
function triangulatePolygon(polygons, areas, indices, { startPosition, endPosition, coordLength }) {
  if (!polygons.triangles) {
    return;
  }
  const start = startPosition * coordLength;
  const end = endPosition * coordLength;
  const polygonPositions = polygons.positions.subarray(start, end);
  const offset = indices[0];
  const holes = indices.slice(1).map((n) => (n - offset) / coordLength);
  const triangles = earcut(polygonPositions, holes, coordLength, areas);
  for (let t = 0, tl = triangles.length; t < tl; ++t) {
    polygons.triangles.push(startPosition + triangles[t]);
  }
}
function wrapProps(obj, size) {
  const returnObj = {};
  for (const key in obj) {
    returnObj[key] = { value: obj[key], size };
  }
  return returnObj;
}
function makeAccessorObjects(points, lines, polygons, coordLength) {
  const binaryFeatures = {
    shape: "binary-feature-collection",
    points: {
      ...points,
      positions: { value: points.positions, size: coordLength },
      globalFeatureIds: { value: points.globalFeatureIds, size: 1 },
      featureIds: { value: points.featureIds, size: 1 },
      numericProps: wrapProps(points.numericProps, 1)
    },
    lines: {
      ...lines,
      positions: { value: lines.positions, size: coordLength },
      pathIndices: { value: lines.pathIndices, size: 1 },
      globalFeatureIds: { value: lines.globalFeatureIds, size: 1 },
      featureIds: { value: lines.featureIds, size: 1 },
      numericProps: wrapProps(lines.numericProps, 1)
    },
    polygons: {
      ...polygons,
      positions: { value: polygons.positions, size: coordLength },
      polygonIndices: { value: polygons.polygonIndices, size: 1 },
      primitivePolygonIndices: { value: polygons.primitivePolygonIndices, size: 1 },
      globalFeatureIds: { value: polygons.globalFeatureIds, size: 1 },
      featureIds: { value: polygons.featureIds, size: 1 },
      numericProps: wrapProps(polygons.numericProps, 1)
    }
    // triangles not expected
  };
  if (binaryFeatures.polygons && polygons.triangles) {
    binaryFeatures.polygons.triangles = { value: new Uint32Array(polygons.triangles), size: 1 };
  }
  return binaryFeatures;
}
function fillNumericProperties(object, properties, index, length5) {
  for (const numericPropName in object.numericProps) {
    if (numericPropName in properties) {
      const value = properties[numericPropName];
      object.numericProps[numericPropName].fill(value, index, index + length5);
    }
  }
}
function keepStringProperties(properties, numericKeys) {
  const props = {};
  for (const key in properties) {
    if (!numericKeys.includes(key)) {
      props[key] = properties[key];
    }
  }
  return props;
}
function deduceArrayType(x, constructor) {
  if (constructor === Array || !Number.isFinite(x)) {
    return Array;
  }
  return constructor === Float64Array || Math.fround(x) !== x ? Float64Array : Float32Array;
}

// node_modules/@loaders.gl/gis/dist/lib/binary-features/binary-to-geojson.js
function binaryToGeojson(data, options) {
  const globalFeatureId = options == null ? void 0 : options.globalFeatureId;
  if (globalFeatureId !== void 0) {
    return getSingleFeature(data, globalFeatureId);
  }
  return parseFeatures(data, options == null ? void 0 : options.type);
}
function getSingleFeature(data, globalFeatureId) {
  const dataArray = normalizeInput(data);
  for (const data2 of dataArray) {
    let lastIndex = 0;
    let lastValue = data2.featureIds.value[0];
    for (let i = 0; i < data2.featureIds.value.length; i++) {
      const currValue = data2.featureIds.value[i];
      if (currValue === lastValue) {
        continue;
      }
      if (globalFeatureId === data2.globalFeatureIds.value[lastIndex]) {
        return parseFeature(data2, lastIndex, i);
      }
      lastIndex = i;
      lastValue = currValue;
    }
    if (globalFeatureId === data2.globalFeatureIds.value[lastIndex]) {
      return parseFeature(data2, lastIndex, data2.featureIds.value.length);
    }
  }
  throw new Error(`featureId:${globalFeatureId} not found`);
}
function parseFeatures(data, type) {
  const dataArray = normalizeInput(data, type);
  return parseFeatureCollection(dataArray);
}
function binaryToGeometry(data, startIndex, endIndex) {
  switch (data.type) {
    case "Point":
      return pointToGeoJson(data, startIndex, endIndex);
    case "LineString":
      return lineStringToGeoJson(data, startIndex, endIndex);
    case "Polygon":
      return polygonToGeoJson(data, startIndex, endIndex);
    default:
      const unexpectedInput = data;
      throw new Error(`Unsupported geometry type: ${unexpectedInput == null ? void 0 : unexpectedInput.type}`);
  }
}
function normalizeInput(data, type) {
  const features2 = [];
  if (data.points) {
    data.points.type = "Point";
    features2.push(data.points);
  }
  if (data.lines) {
    data.lines.type = "LineString";
    features2.push(data.lines);
  }
  if (data.polygons) {
    data.polygons.type = "Polygon";
    features2.push(data.polygons);
  }
  return features2;
}
function parseFeatureCollection(dataArray) {
  const features2 = [];
  for (const data of dataArray) {
    if (data.featureIds.value.length === 0) {
      continue;
    }
    let lastIndex = 0;
    let lastValue = data.featureIds.value[0];
    for (let i = 0; i < data.featureIds.value.length; i++) {
      const currValue = data.featureIds.value[i];
      if (currValue === lastValue) {
        continue;
      }
      features2.push(parseFeature(data, lastIndex, i));
      lastIndex = i;
      lastValue = currValue;
    }
    features2.push(parseFeature(data, lastIndex, data.featureIds.value.length));
  }
  return features2;
}
function parseFeature(data, startIndex, endIndex) {
  const geometry = binaryToGeometry(data, startIndex, endIndex);
  const properties = parseProperties(data, startIndex, endIndex);
  const fields = parseFields(data, startIndex, endIndex);
  return { type: "Feature", geometry, properties, ...fields };
}
function parseFields(data, startIndex = 0, endIndex) {
  return data.fields && data.fields[data.featureIds.value[startIndex]];
}
function parseProperties(data, startIndex = 0, endIndex) {
  const properties = Object.assign({}, data.properties[data.featureIds.value[startIndex]]);
  for (const key in data.numericProps) {
    properties[key] = data.numericProps[key].value[startIndex];
  }
  return properties;
}
function polygonToGeoJson(data, startIndex = -Infinity, endIndex = Infinity) {
  const { positions } = data;
  const polygonIndices = data.polygonIndices.value.filter((x) => x >= startIndex && x <= endIndex);
  const primitivePolygonIndices = data.primitivePolygonIndices.value.filter((x) => x >= startIndex && x <= endIndex);
  const multi = polygonIndices.length > 2;
  if (!multi) {
    const coordinates2 = [];
    for (let i = 0; i < primitivePolygonIndices.length - 1; i++) {
      const startRingIndex = primitivePolygonIndices[i];
      const endRingIndex = primitivePolygonIndices[i + 1];
      const ringCoordinates = ringToGeoJson(positions, startRingIndex, endRingIndex);
      coordinates2.push(ringCoordinates);
    }
    return { type: "Polygon", coordinates: coordinates2 };
  }
  const coordinates = [];
  for (let i = 0; i < polygonIndices.length - 1; i++) {
    const startPolygonIndex = polygonIndices[i];
    const endPolygonIndex = polygonIndices[i + 1];
    const polygonCoordinates = polygonToGeoJson(data, startPolygonIndex, endPolygonIndex).coordinates;
    coordinates.push(polygonCoordinates);
  }
  return { type: "MultiPolygon", coordinates };
}
function lineStringToGeoJson(data, startIndex = -Infinity, endIndex = Infinity) {
  const { positions } = data;
  const pathIndices = data.pathIndices.value.filter((x) => x >= startIndex && x <= endIndex);
  const multi = pathIndices.length > 2;
  if (!multi) {
    const coordinates2 = ringToGeoJson(positions, pathIndices[0], pathIndices[1]);
    return { type: "LineString", coordinates: coordinates2 };
  }
  const coordinates = [];
  for (let i = 0; i < pathIndices.length - 1; i++) {
    const ringCoordinates = ringToGeoJson(positions, pathIndices[i], pathIndices[i + 1]);
    coordinates.push(ringCoordinates);
  }
  return { type: "MultiLineString", coordinates };
}
function pointToGeoJson(data, startIndex, endIndex) {
  const { positions } = data;
  const coordinates = ringToGeoJson(positions, startIndex, endIndex);
  const multi = coordinates.length > 1;
  if (multi) {
    return { type: "MultiPoint", coordinates };
  }
  return { type: "Point", coordinates: coordinates[0] };
}
function ringToGeoJson(positions, startIndex, endIndex) {
  startIndex = startIndex || 0;
  endIndex = endIndex || positions.value.length / positions.size;
  const ringCoordinates = [];
  for (let j = startIndex; j < endIndex; j++) {
    const coord = Array();
    for (let k = j * positions.size; k < (j + 1) * positions.size; k++) {
      coord.push(Number(positions.value[k]));
    }
    ringCoordinates.push(coord);
  }
  return ringCoordinates;
}

// node_modules/@loaders.gl/mvt/dist/lib/parse-mvt.js
var import_pbf = __toESM(require_pbf(), 1);

// node_modules/@loaders.gl/mvt/dist/lib/utils/geometry-utils.js
function signedArea(ring) {
  let sum = 0;
  for (let i = 0, j = ring.length - 1, p1, p2; i < ring.length; j = i++) {
    p1 = ring[i];
    p2 = ring[j];
    sum += (p2[0] - p1[0]) * (p1[1] + p2[1]);
  }
  return sum;
}
function convertToLocalCoordinates(coordinates, extent) {
  if (Array.isArray(coordinates[0])) {
    for (const subcoords of coordinates) {
      convertToLocalCoordinates(subcoords, extent);
    }
    return;
  }
  const p = coordinates;
  p[0] /= extent;
  p[1] /= extent;
}
function convertToLocalCoordinatesFlat(data, extent) {
  for (let i = 0; i < data.length; ++i) {
    data[i] /= extent;
  }
}
function projectToLngLat(line, tileIndex, extent) {
  if (typeof line[0][0] !== "number") {
    for (const point2 of line) {
      projectToLngLat(point2, tileIndex, extent);
    }
    return;
  }
  const size = extent * Math.pow(2, tileIndex.z);
  const x0 = extent * tileIndex.x;
  const y0 = extent * tileIndex.y;
  for (let j = 0; j < line.length; j++) {
    const p = line[j];
    p[0] = (p[0] + x0) * 360 / size - 180;
    const y2 = 180 - (p[1] + y0) * 360 / size;
    p[1] = 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;
  }
}
function projectToLngLatFlat(data, tileIndex, extent) {
  const { x, y, z } = tileIndex;
  const size = extent * Math.pow(2, z);
  const x0 = extent * x;
  const y0 = extent * y;
  for (let j = 0, jl = data.length; j < jl; j += 2) {
    data[j] = (data[j] + x0) * 360 / size - 180;
    const y2 = 180 - (data[j + 1] + y0) * 360 / size;
    data[j + 1] = 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;
  }
}
function classifyRings(rings) {
  const len4 = rings.length;
  if (len4 <= 1)
    return [rings];
  const polygons = [];
  let polygon;
  let ccw;
  for (let i = 0; i < len4; i++) {
    const area2 = signedArea(rings[i]);
    if (area2 === 0)
      continue;
    if (ccw === void 0)
      ccw = area2 < 0;
    if (ccw === area2 < 0) {
      if (polygon)
        polygons.push(polygon);
      polygon = [rings[i]];
    } else if (polygon)
      polygon.push(rings[i]);
  }
  if (polygon)
    polygons.push(polygon);
  return polygons;
}
function classifyRingsFlat(geom) {
  const len4 = geom.indices.length;
  const type = "Polygon";
  if (len4 <= 1) {
    return {
      type,
      data: geom.data,
      areas: [[getPolygonSignedArea(geom.data)]],
      indices: [geom.indices]
    };
  }
  const areas = [];
  const polygons = [];
  let ringAreas = [];
  let polygon = [];
  let ccw;
  let offset = 0;
  for (let endIndex, i = 0, startIndex; i < len4; i++) {
    startIndex = geom.indices[i] - offset;
    endIndex = geom.indices[i + 1] - offset || geom.data.length;
    const shape = geom.data.slice(startIndex, endIndex);
    const area2 = getPolygonSignedArea(shape);
    if (area2 === 0) {
      const before = geom.data.slice(0, startIndex);
      const after = geom.data.slice(endIndex);
      geom.data = before.concat(after);
      offset += endIndex - startIndex;
      continue;
    }
    if (ccw === void 0)
      ccw = area2 < 0;
    if (ccw === area2 < 0) {
      if (polygon.length) {
        areas.push(ringAreas);
        polygons.push(polygon);
      }
      polygon = [startIndex];
      ringAreas = [area2];
    } else {
      ringAreas.push(area2);
      polygon.push(startIndex);
    }
  }
  if (ringAreas)
    areas.push(ringAreas);
  if (polygon.length)
    polygons.push(polygon);
  return { type, areas, indices: polygons, data: geom.data };
}

// node_modules/@loaders.gl/mvt/dist/lib/vector-tile/vector-tile-feature.js
var VectorTileFeature = class {
  // eslint-disable-next-line max-params
  constructor(pbf, end, extent, keys, values, geometryInfo) {
    __publicField(this, "properties");
    __publicField(this, "extent");
    __publicField(this, "type");
    __publicField(this, "id");
    __publicField(this, "_pbf");
    __publicField(this, "_geometry");
    __publicField(this, "_keys");
    __publicField(this, "_values");
    __publicField(this, "_geometryInfo");
    this.properties = {};
    this.extent = extent;
    this.type = 0;
    this.id = null;
    this._pbf = pbf;
    this._geometry = -1;
    this._keys = keys;
    this._values = values;
    this._geometryInfo = geometryInfo;
    pbf.readFields(readFeature, this, end);
  }
  toGeoJSONFeature(coordinates, tileIndex) {
    const coords = this.loadGeometry();
    switch (coordinates) {
      case "wgs84":
        return _toGeoJSONFeature(this, coords, (line) => projectToLngLat(line, tileIndex, this.extent));
      default:
        return _toGeoJSONFeature(this, coords, convertToLocalCoordinates);
    }
  }
  /**
   *
   * @param options
   * @returns
   */
  toBinaryFeature(coordinates, tileIndex) {
    const geom = this.loadFlatGeometry();
    switch (coordinates) {
      case "wgs84":
        return this._toBinaryCoordinates(geom, (coords) => projectToLngLatFlat(coords, tileIndex, this.extent));
      default:
        return this._toBinaryCoordinates(geom, convertToLocalCoordinatesFlat);
    }
  }
  /** Read a bounding box from the feature */
  // eslint-disable-next-line max-statements
  bbox() {
    const pbf = this._pbf;
    pbf.pos = this._geometry;
    const end = pbf.readVarint() + pbf.pos;
    let cmd = 1;
    let length5 = 0;
    let x = 0;
    let y = 0;
    let x1 = Infinity;
    let x2 = -Infinity;
    let y1 = Infinity;
    let y2 = -Infinity;
    while (pbf.pos < end) {
      if (length5 <= 0) {
        const cmdLen = pbf.readVarint();
        cmd = cmdLen & 7;
        length5 = cmdLen >> 3;
      }
      length5--;
      if (cmd === 1 || cmd === 2) {
        x += pbf.readSVarint();
        y += pbf.readSVarint();
        if (x < x1)
          x1 = x;
        if (x > x2)
          x2 = x;
        if (y < y1)
          y1 = y;
        if (y > y2)
          y2 = y;
      } else if (cmd !== 7) {
        throw new Error(`unknown command ${cmd}`);
      }
    }
    return [x1, y1, x2, y2];
  }
  // BINARY HELPERS
  /**
   *
   * @param transform
   * @returns result
   */
  _toBinaryCoordinates(geom, transform2) {
    let geometry;
    transform2(geom.data, this.extent);
    const coordLength = 2;
    switch (this.type) {
      case 1:
        this._geometryInfo.pointFeaturesCount++;
        this._geometryInfo.pointPositionsCount += geom.indices.length;
        geometry = { type: "Point", ...geom };
        break;
      case 2:
        this._geometryInfo.lineFeaturesCount++;
        this._geometryInfo.linePathsCount += geom.indices.length;
        this._geometryInfo.linePositionsCount += geom.data.length / coordLength;
        geometry = { type: "LineString", ...geom };
        break;
      case 3:
        geometry = classifyRingsFlat(geom);
        this._geometryInfo.polygonFeaturesCount++;
        this._geometryInfo.polygonObjectsCount += geometry.indices.length;
        for (const indices of geometry.indices) {
          this._geometryInfo.polygonRingsCount += indices.length;
        }
        this._geometryInfo.polygonPositionsCount += geometry.data.length / coordLength;
        break;
      default:
        throw new Error(`Invalid geometry type: ${this.type}`);
    }
    const result = { type: "Feature", geometry, properties: this.properties };
    if (this.id !== null) {
      result.id = this.id;
    }
    return result;
  }
  // GEOJSON HELPER
  // eslint-disable-next-line complexity, max-statements
  loadGeometry() {
    const pbf = this._pbf;
    pbf.pos = this._geometry;
    const end = pbf.readVarint() + pbf.pos;
    let cmd = 1;
    let length5 = 0;
    let x = 0;
    let y = 0;
    const lines = [];
    let line;
    while (pbf.pos < end) {
      if (length5 <= 0) {
        const cmdLen = pbf.readVarint();
        cmd = cmdLen & 7;
        length5 = cmdLen >> 3;
      }
      length5--;
      switch (cmd) {
        case 1:
        case 2:
          x += pbf.readSVarint();
          y += pbf.readSVarint();
          if (cmd === 1) {
            if (line)
              lines.push(line);
            line = [];
          }
          if (line)
            line.push([x, y]);
          break;
        case 7:
          if (line) {
            line.push(line[0].slice());
          }
          break;
        default:
          throw new Error(`unknown command ${cmd}`);
      }
    }
    if (line)
      lines.push(line);
    return lines;
  }
  /**
   * Expands the protobuf data to an intermediate Flat GeoJSON
   * data format, which maps closely to the binary data buffers.
   * It is similar to GeoJSON, but rather than storing the coordinates
   * in multidimensional arrays, we have a 1D `data` with all the
   * coordinates, and then index into this using the `indices`
   * parameter, e.g.
   *
   * geometry: {
   *   type: 'Point', data: [1,2], indices: [0]
   * }
   * geometry: {
   *   type: 'LineString', data: [1,2,3,4,...], indices: [0]
   * }
   * geometry: {
   *   type: 'Polygon', data: [1,2,3,4,...], indices: [[0, 2]]
   * }
   * Thus the indices member lets us look up the relevant range
   * from the data array.
   * The Multi* versions of the above types share the same data
   * structure, just with multiple elements in the indices array
   */
  // eslint-disable-next-line complexity, max-statements
  loadFlatGeometry() {
    const pbf = this._pbf;
    pbf.pos = this._geometry;
    const endPos = pbf.readVarint() + pbf.pos;
    let cmd = 1;
    let cmdLen;
    let length5 = 0;
    let x = 0;
    let y = 0;
    let i = 0;
    const indices = [];
    const data = [];
    while (pbf.pos < endPos) {
      if (length5 <= 0) {
        cmdLen = pbf.readVarint();
        cmd = cmdLen & 7;
        length5 = cmdLen >> 3;
      }
      length5--;
      if (cmd === 1 || cmd === 2) {
        x += pbf.readSVarint();
        y += pbf.readSVarint();
        if (cmd === 1) {
          indices.push(i);
        }
        data.push(x, y);
        i += 2;
      } else if (cmd === 7) {
        if (i > 0) {
          const start = indices[indices.length - 1];
          data.push(data[start], data[start + 1]);
          i += 2;
        }
      } else {
        throw new Error(`unknown command ${cmd}`);
      }
    }
    return { data, indices };
  }
};
__publicField(VectorTileFeature, "types", ["Unknown", "Point", "LineString", "Polygon"]);
function _toGeoJSONFeature(vtFeature, coords, transform2) {
  let type = VectorTileFeature.types[vtFeature.type];
  let i;
  let j;
  let coordinates;
  switch (vtFeature.type) {
    case 1:
      const points = [];
      for (i = 0; i < coords.length; i++) {
        points[i] = coords[i][0];
      }
      coordinates = points;
      transform2(coordinates, vtFeature.extent);
      break;
    case 2:
      coordinates = coords;
      for (i = 0; i < coordinates.length; i++) {
        transform2(coordinates[i], vtFeature.extent);
      }
      break;
    case 3:
      coordinates = classifyRings(coords);
      for (i = 0; i < coordinates.length; i++) {
        for (j = 0; j < coordinates[i].length; j++) {
          transform2(coordinates[i][j], vtFeature.extent);
        }
      }
      break;
    default:
      throw new Error("illegal vector tile type");
  }
  if (coordinates.length === 1) {
    coordinates = coordinates[0];
  } else {
    type = `Multi${type}`;
  }
  const result = {
    type: "Feature",
    geometry: {
      type,
      coordinates
    },
    properties: vtFeature.properties
  };
  if (vtFeature.id !== null) {
    result.properties || (result.properties = {});
    result.properties.id = vtFeature.id;
  }
  return result;
}
function readFeature(tag, feature2, pbf) {
  if (feature2 && pbf) {
    if (tag === 1)
      feature2.id = pbf.readVarint();
    else if (tag === 2)
      readTag(pbf, feature2);
    else if (tag === 3)
      feature2.type = pbf.readVarint();
    else if (tag === 4)
      feature2._geometry = pbf.pos;
  }
}
function readTag(pbf, feature2) {
  const end = pbf.readVarint() + pbf.pos;
  while (pbf.pos < end) {
    const key = feature2._keys[pbf.readVarint()];
    const value = feature2._values[pbf.readVarint()];
    feature2.properties[key] = value;
  }
}

// node_modules/@loaders.gl/mvt/dist/lib/vector-tile/vector-tile-layer.js
var VectorTileLayer = class {
  constructor(pbf, end) {
    __publicField(this, "version");
    __publicField(this, "name");
    __publicField(this, "extent");
    __publicField(this, "length");
    __publicField(this, "_pbf");
    __publicField(this, "_keys");
    __publicField(this, "_values");
    __publicField(this, "_features");
    this.version = 1;
    this.name = "";
    this.extent = 4096;
    this.length = 0;
    this._pbf = pbf;
    this._keys = [];
    this._values = [];
    this._features = [];
    pbf.readFields(readLayer, this, end);
    this.length = this._features.length;
  }
  /**
   * return feature `i` from this layer as a `VectorTileFeature`
   * @param index
   * @returns feature
   */
  getGeoJSONFeature(i) {
    if (i < 0 || i >= this._features.length) {
      throw new Error("feature index out of bounds");
    }
    this._pbf.pos = this._features[i];
    const end = this._pbf.readVarint() + this._pbf.pos;
    return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);
  }
  /**
   * return binary feature `i` from this layer as a `VectorTileFeature`
   *
   * @param index
   * @param geometryInfo
   * @returns binary feature
   */
  getBinaryFeature(i, geometryInfo) {
    if (i < 0 || i >= this._features.length) {
      throw new Error("feature index out of bounds");
    }
    this._pbf.pos = this._features[i];
    const end = this._pbf.readVarint() + this._pbf.pos;
    return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values, geometryInfo);
  }
};
function readLayer(tag, layer, pbf) {
  if (layer && pbf) {
    if (tag === 15)
      layer.version = pbf.readVarint();
    else if (tag === 1)
      layer.name = pbf.readString();
    else if (tag === 5)
      layer.extent = pbf.readVarint();
    else if (tag === 2)
      layer._features.push(pbf.pos);
    else if (tag === 3)
      layer._keys.push(pbf.readString());
    else if (tag === 4)
      layer._values.push(readValueMessage(pbf));
  }
}
function readValueMessage(pbf) {
  let value = null;
  const end = pbf.readVarint() + pbf.pos;
  while (pbf.pos < end) {
    const tag = pbf.readVarint() >> 3;
    value = tag === 1 ? pbf.readString() : tag === 2 ? pbf.readFloat() : tag === 3 ? pbf.readDouble() : tag === 4 ? pbf.readVarint64() : tag === 5 ? pbf.readVarint() : tag === 6 ? pbf.readSVarint() : tag === 7 ? pbf.readBoolean() : null;
  }
  return value;
}

// node_modules/@loaders.gl/mvt/dist/lib/vector-tile/vector-tile.js
var VectorTile = class {
  constructor(pbf, end) {
    __publicField(this, "layers");
    this.layers = pbf.readFields(readTile, {}, end);
  }
};
function readTile(tag, layers, pbf) {
  if (tag === 3) {
    if (pbf) {
      const layer = new VectorTileLayer(pbf, pbf.readVarint() + pbf.pos);
      if (layer.length && layers) {
        layers[layer.name] = layer;
      }
    }
  }
}

// node_modules/@loaders.gl/mvt/dist/lib/parse-mvt.js
function parseMVT(arrayBuffer, options) {
  var _a, _b;
  const mvtOptions = checkOptions(options);
  const shape = ((_a = options == null ? void 0 : options.gis) == null ? void 0 : _a.format) || ((_b = options == null ? void 0 : options.mvt) == null ? void 0 : _b.shape) || (options == null ? void 0 : options.shape);
  switch (shape) {
    case "columnar-table":
      return { shape: "columnar-table", data: parseToBinary(arrayBuffer, mvtOptions) };
    case "geojson-table": {
      const table = {
        shape: "geojson-table",
        type: "FeatureCollection",
        features: parseToGeojsonFeatures(arrayBuffer, mvtOptions)
      };
      return table;
    }
    case "geojson":
      return parseToGeojsonFeatures(arrayBuffer, mvtOptions);
    case "binary-geometry":
      return parseToBinary(arrayBuffer, mvtOptions);
    case "binary":
      return parseToBinary(arrayBuffer, mvtOptions);
    default:
      throw new Error(shape || "undefined shape");
  }
}
function parseToBinary(arrayBuffer, options) {
  const [flatGeoJsonFeatures, geometryInfo] = parseToFlatGeoJson(arrayBuffer, options);
  const binaryData = flatGeojsonToBinary(flatGeoJsonFeatures, geometryInfo);
  binaryData.byteLength = arrayBuffer.byteLength;
  return binaryData;
}
function parseToFlatGeoJson(arrayBuffer, options) {
  const features2 = [];
  const geometryInfo = {
    coordLength: 2,
    pointPositionsCount: 0,
    pointFeaturesCount: 0,
    linePositionsCount: 0,
    linePathsCount: 0,
    lineFeaturesCount: 0,
    polygonPositionsCount: 0,
    polygonObjectsCount: 0,
    polygonRingsCount: 0,
    polygonFeaturesCount: 0
  };
  if (arrayBuffer.byteLength <= 0) {
    return [features2, geometryInfo];
  }
  const tile = new VectorTile(new import_pbf.default(arrayBuffer));
  const selectedLayers = options && Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);
  selectedLayers.forEach((layerName) => {
    const vectorTileLayer = tile.layers[layerName];
    if (!vectorTileLayer) {
      return;
    }
    for (let i = 0; i < vectorTileLayer.length; i++) {
      const vectorTileFeature = vectorTileLayer.getBinaryFeature(i, geometryInfo);
      const decodedFeature = getDecodedFeatureBinary(vectorTileFeature, options, layerName);
      features2.push(decodedFeature);
    }
  });
  return [features2, geometryInfo];
}
function parseToGeojsonFeatures(arrayBuffer, options) {
  if (arrayBuffer.byteLength <= 0) {
    return [];
  }
  const features2 = [];
  const tile = new VectorTile(new import_pbf.default(arrayBuffer));
  const selectedLayers = Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);
  selectedLayers.forEach((layerName) => {
    const vectorTileLayer = tile.layers[layerName];
    if (!vectorTileLayer) {
      return;
    }
    for (let i = 0; i < vectorTileLayer.length; i++) {
      const vectorTileFeature = vectorTileLayer.getGeoJSONFeature(i);
      const decodedFeature = getDecodedFeature(vectorTileFeature, options, layerName);
      features2.push(decodedFeature);
    }
  });
  return features2;
}
function checkOptions(options) {
  var _a;
  if (!(options == null ? void 0 : options.mvt)) {
    throw new Error("mvt options required");
  }
  if (((_a = options.mvt) == null ? void 0 : _a.coordinates) === "wgs84" && !options.mvt.tileIndex) {
    throw new Error("MVT Loader: WGS84 coordinates need tileIndex property");
  }
  if (options.gis) {
    log.warn('MVTLoader: "options.gis" is deprecated, use "options.mvt.shape" instead')();
  }
  return options.mvt;
}
function getDecodedFeature(feature2, options, layerName) {
  const decodedFeature = feature2.toGeoJSONFeature(options.coordinates || "local", options.tileIndex);
  if (options.layerProperty) {
    decodedFeature.properties || (decodedFeature.properties = {});
    decodedFeature.properties[options.layerProperty] = layerName;
  }
  return decodedFeature;
}
function getDecodedFeatureBinary(feature2, options, layerName) {
  const decodedFeature = feature2.toBinaryFeature(options.coordinates || "local", options.tileIndex);
  if (options.layerProperty && decodedFeature.properties) {
    decodedFeature.properties[options.layerProperty] = layerName;
  }
  return decodedFeature;
}

// node_modules/@loaders.gl/mvt/dist/mvt-loader.js
var VERSION5 = true ? "4.3.3" : "latest";
var MVTWorkerLoader = {
  dataType: null,
  batchType: null,
  name: "Mapbox Vector Tile",
  id: "mvt",
  module: "mvt",
  version: VERSION5,
  // Note: ArcGIS uses '.pbf' extension and 'application/octet-stream'
  extensions: ["mvt", "pbf"],
  mimeTypes: [
    // https://www.iana.org/assignments/media-types/application/vnd.mapbox-vector-tile
    "application/vnd.mapbox-vector-tile",
    "application/x-protobuf"
    // 'application/octet-stream'
  ],
  worker: true,
  category: "geometry",
  options: {
    mvt: {
      shape: "geojson",
      coordinates: "local",
      layerProperty: "layerName",
      layers: void 0,
      tileIndex: void 0
    }
  }
};
var MVTLoader = {
  ...MVTWorkerLoader,
  parse: async (arrayBuffer, options) => parseMVT(arrayBuffer, options),
  parseSync: parseMVT,
  binary: true
};

// node_modules/@loaders.gl/mvt/dist/mvt-source.js
var xRegex = new RegExp("{x}", "g");
var yRegex = new RegExp("{y}", "g");
var zRegex = new RegExp("{z}", "g");

// node_modules/@loaders.gl/mvt/dist/lib/vector-tiler/proto-tile.js
function createProtoTile(features2, z, tx, ty, options) {
  const tolerance = z === options.maxZoom ? 0 : options.tolerance / ((1 << z) * options.extent);
  const tile = {
    protoFeatures: [],
    sourceFeatures: null,
    numPoints: 0,
    numSimplified: 0,
    numFeatures: features2.length,
    x: tx,
    y: ty,
    z,
    transformed: false,
    minX: 2,
    minY: 1,
    maxX: -1,
    maxY: 0
  };
  for (const feature2 of features2) {
    addProtoFeature(tile, feature2, tolerance, options);
  }
  return tile;
}
function addProtoFeature(tile, feature2, tolerance, options) {
  const geometry = feature2.geometry;
  const type = feature2.type;
  const simplifiedGeometry = [];
  tile.minX = Math.min(tile.minX, feature2.minX);
  tile.minY = Math.min(tile.minY, feature2.minY);
  tile.maxX = Math.max(tile.maxX, feature2.maxX);
  tile.maxY = Math.max(tile.maxY, feature2.maxY);
  let simplifiedType;
  switch (type) {
    case "Point":
    case "MultiPoint":
      simplifiedType = 1;
      for (let i = 0; i < geometry.length; i += 3) {
        simplifiedGeometry.push(geometry[i], geometry[i + 1]);
        tile.numPoints++;
        tile.numSimplified++;
      }
      break;
    case "LineString":
      simplifiedType = 2;
      addProtoLine(simplifiedGeometry, geometry, tile, tolerance, false, false);
      break;
    case "MultiLineString":
      simplifiedType = 2;
      for (let i = 0; i < geometry.length; i++) {
        addProtoLine(simplifiedGeometry, geometry[i], tile, tolerance, false, i === 0);
      }
      break;
    case "Polygon":
      simplifiedType = 3;
      for (let i = 0; i < geometry.length; i++) {
        addProtoLine(simplifiedGeometry, geometry[i], tile, tolerance, true, i === 0);
      }
      break;
    case "MultiPolygon":
      simplifiedType = 3;
      for (let k = 0; k < geometry.length; k++) {
        const polygon = geometry[k];
        for (let i = 0; i < polygon.length; i++) {
          addProtoLine(simplifiedGeometry, polygon[i], tile, tolerance, true, i === 0);
        }
      }
      break;
    default:
      throw new Error(`Unknown geometry type: ${type}`);
  }
  if (simplifiedGeometry.length) {
    let tags = feature2.tags || null;
    if (type === "LineString" && options.lineMetrics) {
      tags = {};
      for (const key in feature2.tags) {
        tags[key] = feature2.tags[key];
      }
      tags.mapbox_clip_start = geometry.start / geometry.size;
      tags.mapbox_clip_end = geometry.end / geometry.size;
    }
    const tileFeature = {
      geometry: simplifiedGeometry,
      simplifiedType,
      // @ts-expect-error
      tags
    };
    if (feature2.id !== null) {
      tileFeature.id = feature2.id;
    }
    tile.protoFeatures.push(tileFeature);
  }
}
function addProtoLine(result, geometry, tile, tolerance, isPolygon, isOuter) {
  const sqTolerance = tolerance * tolerance;
  if (tolerance > 0 && geometry.size < (isPolygon ? sqTolerance : tolerance)) {
    tile.numPoints += geometry.length / 3;
    return;
  }
  const ring = [];
  for (let i = 0; i < geometry.length; i += 3) {
    if (tolerance === 0 || geometry[i + 2] > sqTolerance) {
      tile.numSimplified++;
      ring.push(geometry[i], geometry[i + 1]);
    }
    tile.numPoints++;
  }
  if (isPolygon)
    rewind(ring, isOuter);
  result.push(ring);
}
function rewind(ring, clockwise) {
  let area2 = 0;
  for (let i = 0, j = ring.length - 2; i < ring.length; j = i, i += 2) {
    area2 += (ring[i] - ring[j]) * (ring[i + 1] + ring[j + 1]);
  }
  if (area2 > 0 === clockwise) {
    for (let i = 0, len4 = ring.length; i < len4 / 2; i += 2) {
      const x = ring[i];
      const y = ring[i + 1];
      ring[i] = ring[len4 - 2 - i];
      ring[i + 1] = ring[len4 - 1 - i];
      ring[len4 - 2 - i] = x;
      ring[len4 - 1 - i] = y;
    }
  }
}

// node_modules/@loaders.gl/mvt/dist/lib/vector-tiler/transform-tile.js
function transformTile(protoTile, extent) {
  if (protoTile.transformed) {
    return protoTile;
  }
  const z2 = 1 << protoTile.z;
  const tx = protoTile.x;
  const ty = protoTile.y;
  for (const protoFeature of protoTile.protoFeatures) {
    const geom = protoFeature.geometry;
    const simplifiedType = protoFeature.simplifiedType;
    protoFeature.geometry = [];
    if (simplifiedType === 1) {
      for (let j = 0; j < geom.length; j += 2) {
        protoFeature.geometry.push(transformPoint(geom[j], geom[j + 1], extent, z2, tx, ty));
      }
    } else {
      for (let j = 0; j < geom.length; j++) {
        const ring = [];
        for (let k = 0; k < geom[j].length; k += 2) {
          ring.push(transformPoint(geom[j][k], geom[j][k + 1], extent, z2, tx, ty));
        }
        protoFeature.geometry.push(ring);
      }
    }
  }
  protoTile.transformed = true;
  return protoTile;
}
function transformPoint(x, y, extent, z2, tx, ty) {
  return [Math.round(extent * (x * z2 - tx)), Math.round(extent * (y * z2 - ty))];
}

// node_modules/@loaders.gl/mvt/dist/lib/vector-tiler/tile-to-geojson.js
function convertTileToGeoJSON(protoTile, props) {
  const features2 = [];
  for (const rawFeature of protoTile.protoFeatures) {
    if (!rawFeature || !rawFeature.geometry) {
      continue;
    }
    let type;
    let coordinates;
    switch (rawFeature.simplifiedType) {
      case 1:
        if (rawFeature.geometry.length === 1) {
          type = "Point";
          coordinates = rawFeature.geometry[0];
        } else {
          type = "MultiPoint";
          coordinates = rawFeature.geometry;
        }
        break;
      case 2:
        if (rawFeature.geometry.length === 1) {
          type = "LineString";
          coordinates = rawFeature.geometry[0];
        } else {
          type = "MultiLineString";
          coordinates = rawFeature.geometry;
        }
        break;
      case 3:
        if (rawFeature.geometry.length > 1) {
          type = "MultiPolygon";
          coordinates = [rawFeature.geometry];
        } else {
          type = "Polygon";
          coordinates = rawFeature.geometry;
        }
        break;
      default:
        throw new Error(`${rawFeature.simplifiedType}is not a valid simplified type`);
    }
    switch (props.coordinates) {
      case "EPSG:4326":
      case "wgs84":
        projectToLngLat(coordinates, props.tileIndex, props.extent);
        break;
      default:
        convertToLocalCoordinates(coordinates, props.extent);
        break;
    }
    const feature2 = {
      type: "Feature",
      geometry: {
        type,
        coordinates
      },
      properties: rawFeature.tags || {},
      id: rawFeature.id
    };
    features2.push(feature2);
  }
  if (features2.length === 0) {
    return null;
  }
  const table = {
    shape: "geojson-table",
    type: "FeatureCollection",
    features: features2
  };
  return table;
}

// node_modules/@loaders.gl/mvt/dist/lib/vector-tiler/features/proto-feature.js
function createProtoFeature(id, type, geometry, tags) {
  const feature2 = {
    // eslint-disable-next-line
    id: id == null ? null : id,
    type,
    simplifiedType: void 0,
    // TODO
    geometry,
    tags,
    minX: Infinity,
    minY: Infinity,
    maxX: -Infinity,
    maxY: -Infinity
  };
  switch (type) {
    case "Point":
    case "MultiPoint":
    case "LineString":
      calcLineBBox(feature2, geometry);
      break;
    case "MultiLineString":
      for (const line of geometry) {
        calcLineBBox(feature2, line);
      }
      break;
    case "Polygon":
      calcLineBBox(feature2, geometry[0]);
      break;
    case "MultiPolygon":
      for (const polygon of geometry) {
        calcLineBBox(feature2, polygon[0]);
      }
      break;
    default:
      throw new Error(String(type));
  }
  return feature2;
}
function calcLineBBox(feature2, geometry) {
  for (let i = 0; i < geometry.length; i += 3) {
    feature2.minX = Math.min(feature2.minX, geometry[i]);
    feature2.minY = Math.min(feature2.minY, geometry[i + 1]);
    feature2.maxX = Math.max(feature2.maxX, geometry[i]);
    feature2.maxY = Math.max(feature2.maxY, geometry[i + 1]);
  }
}

// node_modules/@loaders.gl/mvt/dist/lib/vector-tiler/features/simplify-path.js
function simplifyPath(coords, first, last, sqTolerance) {
  let maxSqDist = sqTolerance;
  const mid = last - first >> 1;
  let minPosToMid = last - first;
  let index;
  const ax = coords[first];
  const ay = coords[first + 1];
  const bx = coords[last];
  const by = coords[last + 1];
  for (let i = first + 3; i < last; i += 3) {
    const d2 = getSqSegDist(coords[i], coords[i + 1], ax, ay, bx, by);
    if (d2 > maxSqDist) {
      index = i;
      maxSqDist = d2;
    } else if (d2 === maxSqDist) {
      const posToMid = Math.abs(i - mid);
      if (posToMid < minPosToMid) {
        index = i;
        minPosToMid = posToMid;
      }
    }
  }
  if (maxSqDist > sqTolerance) {
    if (index - first > 3)
      simplifyPath(coords, first, index, sqTolerance);
    coords[index + 2] = maxSqDist;
    if (last - index > 3)
      simplifyPath(coords, index, last, sqTolerance);
  }
}
function getSqSegDist(px, py, x, y, bx, by) {
  let dx = bx - x;
  let dy = by - y;
  if (dx !== 0 || dy !== 0) {
    const t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      x = bx;
      y = by;
    } else if (t > 0) {
      x += dx * t;
      y += dy * t;
    }
  }
  dx = px - x;
  dy = py - y;
  return dx * dx + dy * dy;
}

// node_modules/@loaders.gl/mvt/dist/lib/vector-tiler/features/convert-feature.js
function convertFeaturesToProtoFeature(data, options) {
  const protoFeatures = [];
  switch (data.type) {
    case "FeatureCollection":
      let i = 0;
      for (const feature2 of data.features) {
        protoFeatures.push(convertFeature(feature2, options, i++));
      }
      break;
    case "Feature":
      protoFeatures.push(convertFeature(data, options));
      break;
    default:
      protoFeatures.push(convertFeature({ geometry: data }, options));
  }
  return protoFeatures;
}
function convertFeature(geojson, options, index) {
  if (!geojson.geometry) {
    return;
  }
  const coords = geojson.geometry.coordinates;
  const type = geojson.geometry.type;
  const tolerance = Math.pow(options.tolerance / ((1 << options.maxZoom) * options.extent), 2);
  let geometry = [];
  let id = geojson.id;
  if (options.promoteId) {
    id = geojson.properties[options.promoteId];
  } else if (options.generateId) {
    id = index || 0;
  }
  switch (type) {
    case "Point":
      convertPoint(coords, geometry);
      break;
    case "MultiPoint":
      for (const p of coords) {
        convertPoint(p, geometry);
      }
      break;
    case "LineString":
      convertLine(coords, geometry, tolerance, false);
      break;
    case "MultiLineString":
      if (options.lineMetrics) {
        for (const line of coords) {
          geometry = [];
          convertLine(line, geometry, tolerance, false);
          features.push(createProtoFeature(id, "LineString", geometry, geojson.properties));
        }
        return;
        convertLines(coords, geometry, tolerance, false);
      }
      break;
    case "Polygon":
      convertLines(coords, geometry, tolerance, true);
      break;
    case "MultiPolygon":
      for (const polygon of coords) {
        const newPolygon = [];
        convertLines(polygon, newPolygon, tolerance, true);
        geometry.push(newPolygon);
      }
      break;
    case "GeometryCollection":
      for (const singleGeometry of geojson.geometry.geometries) {
        convertFeature(features, {
          id,
          geometry: singleGeometry,
          properties: geojson.properties
        }, options, index);
      }
      break;
    default:
      throw new Error("Input data is not a valid GeoJSON object.");
  }
  return createProtoFeature(id, type, geometry, geojson.properties);
}
function convertPoint(coords, out) {
  out.push(projectX(coords[0]), projectY(coords[1]), 0);
}
function convertLine(ring, out, tolerance, isPolygon) {
  let x0, y0;
  let size = 0;
  for (let j = 0; j < ring.length; j++) {
    const x = projectX(ring[j][0]);
    const y = projectY(ring[j][1]);
    out.push(x, y, 0);
    if (j > 0) {
      if (isPolygon) {
        size += (x0 * y - x * y0) / 2;
      } else {
        size += Math.sqrt(Math.pow(x - x0, 2) + Math.pow(y - y0, 2));
      }
    }
    x0 = x;
    y0 = y;
  }
  const last = out.length - 3;
  out[2] = 1;
  simplifyPath(out, 0, last, tolerance);
  out[last + 2] = 1;
  out.size = Math.abs(size);
  out.start = 0;
  out.end = out.size;
}
function convertLines(rings, out, tolerance, isPolygon) {
  for (let i = 0; i < rings.length; i++) {
    const geom = [];
    convertLine(rings[i], geom, tolerance, isPolygon);
    out.push(geom);
  }
}
function projectX(x) {
  return x / 360 + 0.5;
}
function projectY(y) {
  const sin = Math.sin(y * Math.PI / 180);
  const y2 = 0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI;
  return y2 < 0 ? 0 : y2 > 1 ? 1 : y2;
}

// node_modules/@loaders.gl/mvt/dist/lib/vector-tiler/features/clip-features.js
function clipFeatures(features2, scale7, k1, k2, axis, minAll, maxAll, options) {
  k1 /= scale7;
  k2 /= scale7;
  if (minAll >= k1 && maxAll < k2) {
    return features2;
  } else if (maxAll < k1 || minAll >= k2) {
    return null;
  }
  const clipped = [];
  for (const feature2 of features2) {
    const geometry = feature2.geometry;
    let type = feature2.type;
    const min3 = axis === 0 ? feature2.minX : feature2.minY;
    const max3 = axis === 0 ? feature2.maxX : feature2.maxY;
    if (min3 >= k1 && max3 < k2) {
      clipped.push(feature2);
      continue;
    } else if (max3 < k1 || min3 >= k2) {
      continue;
    }
    let newGeometry = [];
    if (type === "Point" || type === "MultiPoint") {
      clipPoints(geometry, newGeometry, k1, k2, axis);
    } else if (type === "LineString") {
      clipLine(geometry, newGeometry, k1, k2, axis, false, options.lineMetrics);
    } else if (type === "MultiLineString") {
      clipLines(geometry, newGeometry, k1, k2, axis, false);
    } else if (type === "Polygon") {
      clipLines(geometry, newGeometry, k1, k2, axis, true);
    } else if (type === "MultiPolygon") {
      for (const polygon of geometry) {
        const newPolygon = [];
        clipLines(polygon, newPolygon, k1, k2, axis, true);
        if (newPolygon.length) {
          newGeometry.push(newPolygon);
        }
      }
    }
    if (newGeometry.length) {
      if (options.lineMetrics && type === "LineString") {
        for (const line of newGeometry) {
          clipped.push(createProtoFeature(feature2.id, type, line, feature2.tags));
        }
        continue;
      }
      if (type === "LineString" || type === "MultiLineString") {
        if (newGeometry.length === 1) {
          type = "LineString";
          newGeometry = newGeometry[0];
        } else {
          type = "MultiLineString";
        }
      }
      if (type === "Point" || type === "MultiPoint") {
        type = newGeometry.length === 3 ? "Point" : "MultiPoint";
      }
      clipped.push(createProtoFeature(feature2.id, type, newGeometry, feature2.tags));
    }
  }
  return clipped.length ? clipped : null;
}
function clipPoints(geom, newGeom, k1, k2, axis) {
  for (let i = 0; i < geom.length; i += 3) {
    const a2 = geom[i + axis];
    if (a2 >= k1 && a2 <= k2) {
      addPoint(newGeom, geom[i], geom[i + 1], geom[i + 2]);
    }
  }
}
function clipLine(geom, newGeom, k1, k2, axis, isPolygon, trackMetrics) {
  let slice = newSlice(geom);
  const intersect3 = axis === 0 ? intersectX : intersectY;
  let len4 = geom.start;
  let segLen;
  let t;
  for (let i = 0; i < geom.length - 3; i += 3) {
    const ax2 = geom[i];
    const ay2 = geom[i + 1];
    const az2 = geom[i + 2];
    const bx = geom[i + 3];
    const by = geom[i + 4];
    const a3 = axis === 0 ? ax2 : ay2;
    const b2 = axis === 0 ? bx : by;
    let exited = false;
    if (trackMetrics) {
      segLen = Math.sqrt(Math.pow(ax2 - bx, 2) + Math.pow(ay2 - by, 2));
    }
    if (a3 < k1) {
      if (b2 > k1) {
        t = intersect3(slice, ax2, ay2, bx, by, k1);
        if (trackMetrics) {
          slice.start = len4 + segLen * t;
        }
      }
    } else if (a3 > k2) {
      if (b2 < k2) {
        t = intersect3(slice, ax2, ay2, bx, by, k2);
        if (trackMetrics) {
          slice.start = len4 + segLen * t;
        }
      }
    } else {
      addPoint(slice, ax2, ay2, az2);
    }
    if (b2 < k1 && a3 >= k1) {
      t = intersect3(slice, ax2, ay2, bx, by, k1);
      exited = true;
    }
    if (b2 > k2 && a3 <= k2) {
      t = intersect3(slice, ax2, ay2, bx, by, k2);
      exited = true;
    }
    if (!isPolygon && exited) {
      if (trackMetrics) {
        slice.end = len4 + segLen * t;
      }
      newGeom.push(slice);
      slice = newSlice(geom);
    }
    if (trackMetrics) {
      len4 += segLen;
    }
  }
  let last = geom.length - 3;
  const ax = geom[last];
  const ay = geom[last + 1];
  const az = geom[last + 2];
  const a2 = axis === 0 ? ax : ay;
  if (a2 >= k1 && a2 <= k2)
    addPoint(slice, ax, ay, az);
  last = slice.length - 3;
  if (isPolygon && last >= 3 && (slice[last] !== slice[0] || slice[last + 1] !== slice[1])) {
    addPoint(slice, slice[0], slice[1], slice[2]);
  }
  if (slice.length) {
    newGeom.push(slice);
  }
}
function newSlice(line) {
  const slice = [];
  slice.size = line.size;
  slice.start = line.start;
  slice.end = line.end;
  return slice;
}
function clipLines(geom, newGeom, k1, k2, axis, isPolygon) {
  for (const line of geom) {
    clipLine(line, newGeom, k1, k2, axis, isPolygon, false);
  }
}
function addPoint(out, x, y, z) {
  out.push(x, y, z);
}
function intersectX(out, ax, ay, bx, by, x) {
  const t = (x - ax) / (bx - ax);
  addPoint(out, x, ay + (by - ay) * t, 1);
  return t;
}
function intersectY(out, ax, ay, bx, by, y) {
  const t = (y - ay) / (by - ay);
  addPoint(out, ax + (bx - ax) * t, y, 1);
  return t;
}

// node_modules/@loaders.gl/mvt/dist/lib/vector-tiler/features/wrap-features.js
function wrapFeatures(features2, options) {
  const buffer = options.buffer / options.extent;
  let merged = features2;
  const left = clipFeatures(features2, 1, -1 - buffer, buffer, 0, -1, 2, options);
  const right = clipFeatures(features2, 1, 1 - buffer, 2 + buffer, 0, -1, 2, options);
  if (left || right) {
    merged = clipFeatures(features2, 1, -buffer, 1 + buffer, 0, -1, 2, options) || [];
    if (left) {
      merged = shiftFeatureCoords(left, 1).concat(merged);
    }
    if (right) {
      merged = merged.concat(shiftFeatureCoords(right, -1));
    }
  }
  return merged;
}
function shiftFeatureCoords(features2, offset) {
  const newFeatures = [];
  for (let i = 0; i < features2.length; i++) {
    const feature2 = features2[i];
    const type = feature2.type;
    let newGeometry;
    switch (type) {
      case "Point":
      case "MultiPoint":
      case "LineString":
        newGeometry = shiftCoords(feature2.geometry, offset);
        break;
      case "MultiLineString":
      case "Polygon":
        newGeometry = [];
        for (const line of feature2.geometry) {
          newGeometry.push(shiftCoords(line, offset));
        }
        break;
      case "MultiPolygon":
        newGeometry = [];
        for (const polygon of feature2.geometry) {
          const newPolygon = [];
          for (const line of polygon) {
            newPolygon.push(shiftCoords(line, offset));
          }
          newGeometry.push(newPolygon);
        }
        break;
      default:
        throw new Error(String(type));
    }
    newFeatures.push(createProtoFeature(feature2.id, type, newGeometry, feature2.tags));
  }
  return newFeatures;
}
function shiftCoords(points, offset) {
  const newPoints = [];
  newPoints.size = points.size;
  if (points.start !== void 0) {
    newPoints.start = points.start;
    newPoints.end = points.end;
  }
  for (let i = 0; i < points.length; i += 3) {
    newPoints.push(points[i] + offset, points[i + 1], points[i + 2]);
  }
  return newPoints;
}

// node_modules/@loaders.gl/mvt/dist/table-tile-source.js
var TableTileSource = {
  name: "TableTiler",
  id: "table-tiler",
  version: "0.0.0",
  extensions: ["mvt"],
  mimeTypes: ["application/octet-stream"],
  options: {
    table: {
      coordinates: "local",
      promoteId: void 0,
      maxZoom: 14,
      indexMaxZoom: 5,
      maxPointsPerTile: 1e4,
      tolerance: 3,
      extent: 4096,
      buffer: 64,
      generateId: void 0
    }
  },
  type: "table",
  testURL: (url) => url.endsWith(".geojson"),
  createDataSource(url, options) {
    var _a, _b;
    const needsLoading = typeof url === "string" || url instanceof Blob;
    const loader = (_b = (_a = options == null ? void 0 : options.table) == null ? void 0 : _a.loaders) == null ? void 0 : _b[0];
    const tablePromise = needsLoading ? loadTable(url, loader) : url;
    return new DynamicVectorTileSource(tablePromise, options);
  }
  // @ts-expect-error
};
async function loadTable(url, loader) {
  if (typeof url === "string") {
    const response = await fetch(url);
    const data2 = await response.arrayBuffer();
    return await loader.parse(data2);
  }
  const data = await url.arrayBuffer();
  return await loader.parse(data);
}
var _DynamicVectorTileSource = class _DynamicVectorTileSource {
  constructor(table, props) {
    /** Stats for this DynamicVectorTileSource */
    __publicField(this, "stats", new Stats({
      id: "table-tile-source",
      stats: [new Stat("tiles", "count"), new Stat("features", "count")]
    }));
    /** MIME type of the tiles emitted by this tile source */
    __publicField(this, "mimeType", "application/vnd.mapbox-vector-tile");
    __publicField(this, "localCoordinates", true);
    /** The props that this tile source was created with */
    // @ts-expect-error
    __publicField(this, "props");
    /* Schema of the data */
    __publicField(this, "schema", null);
    /** Map of generated tiles, indexed by stringified tile coordinates */
    __publicField(this, "tiles", {});
    /** Array of tile coordinates */
    __publicField(this, "tileCoords", []);
    /** Input data has loaded, initial top-level tiling is done, sync methods can now be called */
    __publicField(this, "ready");
    /** Metadata for the tile source (generated TileJSON/tilestats */
    __publicField(this, "metadata");
    this.props = { ...TableTileSource.options.table, ...props == null ? void 0 : props.table };
    this.getTileData = this.getTileData.bind(this);
    this.ready = this.initializeTilesAsync(table);
    this.metadata = this.getMetadata();
  }
  async initializeTilesAsync(tablePromise) {
    const table = await tablePromise;
    this.schema = deduceTableSchema(table);
    this.createRootTiles(table);
  }
  async getMetadata() {
    await this.ready;
    return { schema: this.schema, minZoom: 0, maxZoom: this.props.maxZoom };
  }
  async getSchema() {
    await this.ready;
    return this.schema;
  }
  /**
   * Get a tile at the specified index
   * @param tileIndex z, x, y of tile
   * @returns
   */
  async getVectorTile(tileIndex) {
    await this.ready;
    const table = this.getTileSync(tileIndex);
    log.info(2, "getVectorTile", tileIndex, table)();
    return table;
  }
  async getTile(tileIndex) {
    await this.ready;
    return this.getTileSync(tileIndex);
  }
  async getTileData(tileParams) {
    const { x, y, z } = tileParams.index;
    const tile = await this.getVectorTile({ x, y, z });
    return (tile == null ? void 0 : tile.features) || [];
  }
  // Implementation
  /**
   * Synchronously request a tile
   * @note Application must await `source.ready` before calling sync methods.
   */
  getTileSync(tileIndex) {
    const protoTile = this.getProtoTile(tileIndex);
    if (!protoTile) {
      return null;
    }
    return convertTileToGeoJSON(protoTile, {
      coordinates: this.props.coordinates,
      tileIndex,
      extent: this.props.extent
    });
  }
  /**
   * Create the initial tiles
   * @note the tiles stores all the features together with additional data
   */
  createRootTiles(table) {
    if (this.props.maxZoom < 0 || this.props.maxZoom > 24) {
      throw new Error("maxZoom should be in the 0-24 range");
    }
    if (this.props.promoteId && this.props.generateId) {
      throw new Error("promoteId and generateId cannot be used together.");
    }
    log.log(1, "DynamicVectorTileSource creating root tiles", this.props)();
    log.time(1, "preprocess table")();
    let features2 = convertFeaturesToProtoFeature(table, this.props);
    log.timeEnd(1, "preprocess table")();
    log.time(1, "generate tiles")();
    features2 = wrapFeatures(features2, this.props);
    if (features2.length === 0) {
      log.log(1, "DynamicVectorTileSource: no features generated")();
      return;
    }
    this.splitTile(features2, 0, 0, 0);
    const rootTile = this.tiles[0];
    log.log(1, `root tile features: ${rootTile.numFeatures}, points: ${rootTile.numPoints}`)();
    log.timeEnd(1, "generate tiles")();
    log.log(1, `DynamicVectorTileSource: tiles generated: ${this.stats.get("total").count}`, this.stats)();
  }
  /**
   * Return geojsonvt-style "half formed" vector tile
   * @note Application must await `source.ready` before calling sync methods.
   */
  // eslint-disable-next-line complexity, max-statements
  getProtoTile(tileIndex) {
    const { z, y } = tileIndex;
    let { x } = tileIndex;
    const { extent } = this.props;
    if (z < 0 || z > 24) {
      return null;
    }
    const z2 = 1 << z;
    x = x + z2 & z2 - 1;
    const id = toID(z, x, y);
    if (this.tiles[id]) {
      return transformTile(this.tiles[id], extent);
    }
    log.log(log, "drilling down to z%d-%d-%d", z, x, y)();
    let z0 = z;
    let x0 = x;
    let y0 = y;
    let parent;
    while (!parent && z0 > 0) {
      z0--;
      x0 = x0 >> 1;
      y0 = y0 >> 1;
      parent = this.tiles[toID(z0, x0, y0)];
    }
    if (!parent || !parent.sourceFeatures) {
      return null;
    }
    log.log(1, "found parent tile z%d-%d-%d", z0, x0, y0)();
    log.time(1, "drilling down")();
    this.splitTile(parent.sourceFeatures, z0, x0, y0, z, x, y);
    log.timeEnd(1, "drilling down")();
    return this.tiles[id] ? transformTile(this.tiles[id], extent) : null;
  }
  /**
   * splits features from a parent tile to sub-tiles.
   * @param z, x, and y are the coordinates of the parent tile
   * @param cz, cx, and cy are the coordinates of the target tile
   *
   * If no target tile is specified, splitting stops when we reach the maximum
   * zoom or the number of points is low as specified in the props.
   */
  // eslint-disable-next-line max-params, max-statements, complexity
  splitTile(features2, z, x, y, cz, cx, cy) {
    const stack = [features2, z, x, y];
    while (stack.length) {
      y = stack.pop();
      x = stack.pop();
      z = stack.pop();
      features2 = stack.pop();
      const z2 = 1 << z;
      const id = toID(z, x, y);
      let tile = this.tiles[id];
      if (!tile) {
        log.time(2, "tile creation")();
        tile = this.tiles[id] = createProtoTile(features2, z, x, y, this.props);
        this.tileCoords.push({ z, x, y });
        const key = `z${z}`;
        let stat = this.stats.get(key, "count");
        stat.incrementCount();
        stat = this.stats.get("total");
        stat.incrementCount();
        stat = _DynamicVectorTileSource.stats.get(key, "count");
        stat.incrementCount();
        stat = _DynamicVectorTileSource.stats.get("total");
        stat.incrementCount();
        log.log(2, "tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", z, x, y, tile.numFeatures, tile.numPoints, tile.numSimplified)();
        log.timeEnd(2, "tile creation")();
      }
      tile.sourceFeatures = features2;
      if (cz === void 0) {
        if (z === this.props.indexMaxZoom || tile.numPoints <= this.props.maxPointsPerTile) {
          continue;
        }
      } else if (z === this.props.maxZoom || z === cz) {
        continue;
      } else if (cz !== void 0) {
        const zoomSteps = cz - z;
        if (x !== cx >> zoomSteps || y !== cy >> zoomSteps) {
          continue;
        }
      }
      tile.sourceFeatures = null;
      if (features2.length === 0)
        continue;
      log.time(2, "clipping tile")();
      const k1 = 0.5 * this.props.buffer / this.props.extent;
      const k2 = 0.5 - k1;
      const k3 = 0.5 + k1;
      const k4 = 1 + k1;
      let tl = null;
      let bl = null;
      let tr = null;
      let br = null;
      let left = clipFeatures(features2, z2, x - k1, x + k3, 0, tile.minX, tile.maxX, this.props);
      let right = clipFeatures(features2, z2, x + k2, x + k4, 0, tile.minX, tile.maxX, this.props);
      features2 = null;
      if (left) {
        tl = clipFeatures(left, z2, y - k1, y + k3, 1, tile.minY, tile.maxY, this.props);
        bl = clipFeatures(left, z2, y + k2, y + k4, 1, tile.minY, tile.maxY, this.props);
        left = null;
      }
      if (right) {
        tr = clipFeatures(right, z2, y - k1, y + k3, 1, tile.minY, tile.maxY, this.props);
        br = clipFeatures(right, z2, y + k2, y + k4, 1, tile.minY, tile.maxY, this.props);
        right = null;
      }
      log.timeEnd(2, "clipping tile")();
      stack.push(tl || [], z + 1, x * 2, y * 2);
      stack.push(bl || [], z + 1, x * 2, y * 2 + 1);
      stack.push(tr || [], z + 1, x * 2 + 1, y * 2);
      stack.push(br || [], z + 1, x * 2 + 1, y * 2 + 1);
    }
  }
};
/** Global stats for all DynamicVectorTileSources */
__publicField(_DynamicVectorTileSource, "stats", new Stats({
  id: "table-tile-source-all",
  stats: [new Stat("count", "tiles"), new Stat("count", "features")]
}));
var DynamicVectorTileSource = _DynamicVectorTileSource;
function toID(z, x, y) {
  return ((1 << z) * y + x) * 32 + z;
}

// node_modules/@deck.gl/geo-layers/dist/mvt-layer/coordinate-transform.js
var availableTransformations = {
  Point,
  MultiPoint,
  LineString,
  MultiLineString,
  Polygon: Polygon2,
  MultiPolygon
};
function Point([pointX, pointY], [nw, se], viewport) {
  const x = lerp(nw[0], se[0], pointX);
  const y = lerp(nw[1], se[1], pointY);
  return viewport.unprojectFlat([x, y]);
}
function getPoints(geometry, bbox, viewport) {
  return geometry.map((g) => Point(g, bbox, viewport));
}
function MultiPoint(multiPoint, bbox, viewport) {
  return getPoints(multiPoint, bbox, viewport);
}
function LineString(line, bbox, viewport) {
  return getPoints(line, bbox, viewport);
}
function MultiLineString(multiLineString, bbox, viewport) {
  return multiLineString.map((lineString2) => LineString(lineString2, bbox, viewport));
}
function Polygon2(polygon, bbox, viewport) {
  return polygon.map((polygonRing) => getPoints(polygonRing, bbox, viewport));
}
function MultiPolygon(multiPolygon, bbox, viewport) {
  return multiPolygon.map((polygon) => Polygon2(polygon, bbox, viewport));
}
function transform(geometry, bbox, viewport) {
  const nw = viewport.projectFlat([bbox.west, bbox.north]);
  const se = viewport.projectFlat([bbox.east, bbox.south]);
  const projectedBbox = [nw, se];
  return {
    ...geometry,
    coordinates: availableTransformations[geometry.type](geometry.coordinates, projectedBbox, viewport)
  };
}

// node_modules/@deck.gl/geo-layers/dist/mvt-layer/find-index-binary.js
var GEOM_TYPES = ["points", "lines", "polygons"];
function findIndexBinary(data, uniqueIdProperty, featureId, layerName) {
  for (const gt of GEOM_TYPES) {
    const index = data[gt] && findIndexByType(data[gt], uniqueIdProperty, featureId, layerName);
    if (index >= 0) {
      return index;
    }
  }
  return -1;
}
function findIndexByType(geomData, uniqueIdProperty, featureId, layerName) {
  const featureIds = geomData.featureIds.value;
  if (!featureIds.length) {
    return -1;
  }
  let startFeatureIndex = 0;
  let endFeatureIndex = featureIds[featureIds.length - 1] + 1;
  if (layerName) {
    const layerRange = getLayerRange(geomData, layerName);
    if (layerRange) {
      startFeatureIndex = layerRange[0];
      endFeatureIndex = layerRange[1] + 1;
    } else {
      return -1;
    }
  }
  let featureIndex = -1;
  if (uniqueIdProperty in geomData.numericProps) {
    const vertexIndex = geomData.numericProps[uniqueIdProperty].value.findIndex((x, i) => x === featureId && featureIds[i] >= startFeatureIndex && featureIds[i] < endFeatureIndex);
    return vertexIndex >= 0 ? geomData.globalFeatureIds.value[vertexIndex] : -1;
  } else if (uniqueIdProperty) {
    featureIndex = findIndex(geomData.properties, (elem) => elem[uniqueIdProperty] === featureId, startFeatureIndex, endFeatureIndex);
  } else if (geomData.fields) {
    featureIndex = findIndex(geomData.fields, (elem) => elem.id === featureId, startFeatureIndex, endFeatureIndex);
  }
  return featureIndex >= 0 ? getGlobalFeatureId(geomData, featureIndex) : -1;
}
function getLayerRange(geomData, layerName) {
  if (!geomData.__layers) {
    const layerNames = {};
    const { properties } = geomData;
    for (let i = 0; i < properties.length; i++) {
      const { layerName: key } = properties[i];
      if (!key) {
      } else if (layerNames[key]) {
        layerNames[key][1] = i;
      } else {
        layerNames[key] = [i, i];
      }
    }
    geomData.__layers = layerNames;
  }
  return geomData.__layers[layerName];
}
function getGlobalFeatureId(geomData, featureIndex) {
  if (!geomData.__ids) {
    const result = [];
    const featureIds = geomData.featureIds.value;
    const globalFeatureIds = geomData.globalFeatureIds.value;
    for (let i = 0; i < featureIds.length; i++) {
      result[featureIds[i]] = globalFeatureIds[i];
    }
    geomData.__ids = result;
  }
  return geomData.__ids[featureIndex];
}
function findIndex(array, predicate, startIndex, endIndex) {
  for (let i = startIndex; i < endIndex; i++) {
    if (predicate(array[i], i)) {
      return i;
    }
  }
  return -1;
}

// node_modules/@deck.gl/geo-layers/dist/mvt-layer/mvt-layer.js
var WORLD_SIZE = 512;
var defaultProps39 = {
  ...geojson_layer_default.defaultProps,
  data: urlType,
  onDataLoad: { type: "function", value: null, optional: true, compare: false },
  uniqueIdProperty: "",
  highlightedFeatureId: null,
  loaders: [MVTWorkerLoader],
  binary: true
};
var MVTLayer = class extends tile_layer_default {
  initializeState() {
    super.initializeState();
    const binary = this.context.viewport.resolution !== void 0 ? false : this.props.binary;
    this.setState({
      binary,
      data: null,
      tileJSON: null,
      hoveredFeatureId: null,
      hoveredFeatureLayerName: null
    });
  }
  get isLoaded() {
    var _a;
    return Boolean(((_a = this.state) == null ? void 0 : _a.data) && super.isLoaded);
  }
  updateState({ props, oldProps, context, changeFlags }) {
    var _a;
    if (changeFlags.dataChanged) {
      this._updateTileData();
    }
    if ((_a = this.state) == null ? void 0 : _a.data) {
      super.updateState({ props, oldProps, context, changeFlags });
      this._setWGS84PropertyForTiles();
    }
    const { highlightColor } = props;
    if (highlightColor !== oldProps.highlightColor && Array.isArray(highlightColor)) {
      this.setState({ highlightColor });
    }
  }
  /* eslint-disable complexity */
  async _updateTileData() {
    let data = this.props.data;
    let tileJSON = null;
    if (typeof data === "string" && !isURLTemplate(data)) {
      const { onDataLoad, fetch: fetch2 } = this.props;
      this.setState({ data: null, tileJSON: null });
      try {
        tileJSON = await fetch2(data, { propName: "data", layer: this, loaders: [] });
      } catch (error) {
        this.raiseError(error, "loading TileJSON");
        data = null;
      }
      if (onDataLoad) {
        onDataLoad(tileJSON, { propName: "data", layer: this });
      }
    } else if (data && typeof data === "object" && "tilejson" in data) {
      tileJSON = data;
    }
    if (tileJSON) {
      data = tileJSON.tiles;
    }
    this.setState({ data, tileJSON });
  }
  _getTilesetOptions() {
    const opts = super._getTilesetOptions();
    const tileJSON = this.state.tileJSON;
    const { minZoom, maxZoom } = this.props;
    if (tileJSON) {
      if (Number.isFinite(tileJSON.minzoom) && tileJSON.minzoom > minZoom) {
        opts.minZoom = tileJSON.minzoom;
      }
      if (Number.isFinite(tileJSON.maxzoom) && (!Number.isFinite(maxZoom) || tileJSON.maxzoom < maxZoom)) {
        opts.maxZoom = tileJSON.maxzoom;
      }
    }
    return opts;
  }
  /* eslint-disable complexity */
  renderLayers() {
    var _a;
    if (!((_a = this.state) == null ? void 0 : _a.data))
      return null;
    return super.renderLayers();
  }
  getTileData(loadProps) {
    const { data, binary } = this.state;
    const { index, signal } = loadProps;
    const url = getURLFromTemplate(data, loadProps);
    if (!url) {
      return Promise.reject("Invalid URL");
    }
    let loadOptions = this.getLoadOptions();
    const { fetch: fetch2 } = this.props;
    loadOptions = {
      ...loadOptions,
      mimeType: "application/x-protobuf",
      mvt: {
        ...loadOptions == null ? void 0 : loadOptions.mvt,
        coordinates: this.context.viewport.resolution ? "wgs84" : "local",
        tileIndex: index
        // Local worker debug
        // workerUrl: `modules/mvt/dist/mvt-loader.worker.js`
        // Set worker to null to skip web workers
        // workerUrl: null
      },
      gis: binary ? { format: "binary" } : {}
    };
    return fetch2(url, { propName: "data", layer: this, loadOptions, signal });
  }
  renderSubLayers(props) {
    const { x, y, z } = props.tile.index;
    const worldScale = Math.pow(2, z);
    const xScale = WORLD_SIZE / worldScale;
    const yScale = -xScale;
    const xOffset = WORLD_SIZE * x / worldScale;
    const yOffset = WORLD_SIZE * (1 - y / worldScale);
    const modelMatrix2 = new Matrix4().scale([xScale, yScale, 1]);
    props.autoHighlight = false;
    if (!this.context.viewport.resolution) {
      props.modelMatrix = modelMatrix2;
      props.coordinateOrigin = [xOffset, yOffset, 0];
      props.coordinateSystem = COORDINATE_SYSTEM.CARTESIAN;
      props.extensions = [...props.extensions || [], new clip_extension_default()];
    }
    const subLayers = super.renderSubLayers(props);
    if (this.state.binary && !(subLayers instanceof geojson_layer_default)) {
      log_default.warn("renderSubLayers() must return GeoJsonLayer when using binary:true")();
    }
    return subLayers;
  }
  _updateAutoHighlight(info) {
    const { uniqueIdProperty } = this.props;
    const { hoveredFeatureId, hoveredFeatureLayerName } = this.state;
    const hoveredFeature = info.object;
    let newHoveredFeatureId = null;
    let newHoveredFeatureLayerName = null;
    if (hoveredFeature) {
      newHoveredFeatureId = getFeatureUniqueId(hoveredFeature, uniqueIdProperty);
      newHoveredFeatureLayerName = getFeatureLayerName(hoveredFeature);
    }
    let { highlightColor } = this.props;
    if (typeof highlightColor === "function") {
      highlightColor = highlightColor(info);
    }
    if (hoveredFeatureId !== newHoveredFeatureId || hoveredFeatureLayerName !== newHoveredFeatureLayerName) {
      this.setState({
        highlightColor,
        hoveredFeatureId: newHoveredFeatureId,
        hoveredFeatureLayerName: newHoveredFeatureLayerName
      });
    }
  }
  _isWGS84() {
    return Boolean(this.context.viewport.resolution);
  }
  getPickingInfo(params) {
    const info = super.getPickingInfo(params);
    if (this.state.binary && info.index !== -1) {
      const { data } = params.sourceLayer.props;
      info.object = binaryToGeojson(data, {
        globalFeatureId: info.index
      });
    }
    if (info.object && !this._isWGS84()) {
      info.object = transformTileCoordsToWGS84(
        info.object,
        info.tile.bbox,
        // eslint-disable-line
        this.context.viewport
      );
    }
    return info;
  }
  getSubLayerPropsByTile(tile) {
    return {
      highlightedObjectIndex: this.getHighlightedObjectIndex(tile),
      highlightColor: this.state.highlightColor
    };
  }
  getHighlightedObjectIndex(tile) {
    const { hoveredFeatureId, hoveredFeatureLayerName, binary } = this.state;
    const { uniqueIdProperty, highlightedFeatureId } = this.props;
    const data = tile.content;
    const isHighlighted = isFeatureIdDefined(highlightedFeatureId);
    const isFeatureIdPresent = isFeatureIdDefined(hoveredFeatureId) || isHighlighted;
    if (!isFeatureIdPresent) {
      return -1;
    }
    const featureIdToHighlight = isHighlighted ? highlightedFeatureId : hoveredFeatureId;
    if (Array.isArray(data)) {
      return data.findIndex((feature2) => {
        const isMatchingId = getFeatureUniqueId(feature2, uniqueIdProperty) === featureIdToHighlight;
        const isMatchingLayer = isHighlighted || getFeatureLayerName(feature2) === hoveredFeatureLayerName;
        return isMatchingId && isMatchingLayer;
      });
    } else if (data && binary) {
      return findIndexBinary(data, uniqueIdProperty, featureIdToHighlight, isHighlighted ? "" : hoveredFeatureLayerName);
    }
    return -1;
  }
  _pickObjects(maxObjects) {
    const { deck, viewport } = this.context;
    const width = viewport.width;
    const height = viewport.height;
    const x = viewport.x;
    const y = viewport.y;
    const layerIds = [this.id];
    return deck.pickObjects({ x, y, width, height, layerIds, maxObjects });
  }
  /** Get the rendered features in the current viewport. */
  getRenderedFeatures(maxFeatures = null) {
    const features2 = this._pickObjects(maxFeatures);
    const featureCache = /* @__PURE__ */ new Set();
    const renderedFeatures = [];
    for (const f of features2) {
      const featureId = getFeatureUniqueId(f.object, this.props.uniqueIdProperty);
      if (featureId === void 0) {
        renderedFeatures.push(f.object);
      } else if (!featureCache.has(featureId)) {
        featureCache.add(featureId);
        renderedFeatures.push(f.object);
      }
    }
    return renderedFeatures;
  }
  _setWGS84PropertyForTiles() {
    const propName = "dataInWGS84";
    const tileset = this.state.tileset;
    tileset.selectedTiles.forEach((tile) => {
      if (!tile.hasOwnProperty(propName)) {
        Object.defineProperty(tile, propName, {
          get: () => {
            if (!tile.content) {
              return null;
            }
            if (this.state.binary && Array.isArray(tile.content) && !tile.content.length) {
              return [];
            }
            const { bbox } = tile;
            if (tile._contentWGS84 === void 0 && isGeoBoundingBox(bbox)) {
              const content = this.state.binary ? binaryToGeojson(tile.content) : tile.content;
              tile._contentWGS84 = content.map((feature2) => transformTileCoordsToWGS84(feature2, bbox, this.context.viewport));
            }
            return tile._contentWGS84;
          }
        });
      }
    });
  }
};
MVTLayer.layerName = "MVTLayer";
MVTLayer.defaultProps = defaultProps39;
var mvt_layer_default = MVTLayer;
function getFeatureUniqueId(feature2, uniqueIdProperty) {
  if (feature2.properties && uniqueIdProperty) {
    return feature2.properties[uniqueIdProperty];
  }
  if ("id" in feature2) {
    return feature2.id;
  }
  return void 0;
}
function getFeatureLayerName(feature2) {
  var _a;
  return ((_a = feature2.properties) == null ? void 0 : _a.layerName) || null;
}
function isFeatureIdDefined(value) {
  return value !== void 0 && value !== null && value !== "";
}
function transformTileCoordsToWGS84(object, bbox, viewport) {
  const feature2 = {
    ...object,
    geometry: {
      type: object.geometry.type
    }
  };
  Object.defineProperty(feature2.geometry, "coordinates", {
    get: () => {
      const wgs84Geom = transform(object.geometry, bbox, viewport);
      return wgs84Geom.coordinates;
    }
  });
  return feature2;
}

// node_modules/@deck.gl/geo-layers/dist/geohash-layer/geohash-utils.js
var BASE32_CODES = "0123456789bcdefghjkmnpqrstuvwxyz";
var BASE32_CODES_DICT = {};
for (let i = 0; i < BASE32_CODES.length; i++) {
  BASE32_CODES_DICT[BASE32_CODES.charAt(i)] = i;
}
var MIN_LAT = -90;
var MAX_LAT = 90;
var MIN_LON = -180;
var MAX_LON = 180;
function getGeohashBounds(geohash) {
  let isLon = true;
  let maxLat = MAX_LAT;
  let minLat = MIN_LAT;
  let maxLon = MAX_LON;
  let minLon = MIN_LON;
  let mid;
  let hashValue = 0;
  for (let i = 0, l = geohash.length; i < l; i++) {
    const code = geohash[i].toLowerCase();
    hashValue = BASE32_CODES_DICT[code];
    for (let bits = 4; bits >= 0; bits--) {
      const bit = hashValue >> bits & 1;
      if (isLon) {
        mid = (maxLon + minLon) / 2;
        if (bit === 1) {
          minLon = mid;
        } else {
          maxLon = mid;
        }
      } else {
        mid = (maxLat + minLat) / 2;
        if (bit === 1) {
          minLat = mid;
        } else {
          maxLat = mid;
        }
      }
      isLon = !isLon;
    }
  }
  return [minLat, minLon, maxLat, maxLon];
}
function getGeohashPolygon(geohash) {
  const [s, w2, n, e2] = getGeohashBounds(geohash);
  return [e2, n, e2, s, w2, s, w2, n, e2, n];
}

// node_modules/@deck.gl/geo-layers/dist/geohash-layer/geohash-layer.js
var defaultProps40 = {
  getGeohash: { type: "accessor", value: (d2) => d2.geohash }
};
var GeohashLayer = class extends GeoCellLayer_default {
  indexToBounds() {
    const { data, getGeohash } = this.props;
    return {
      data,
      _normalize: false,
      positionFormat: "XY",
      getPolygon: (x, objectInfo) => getGeohashPolygon(getGeohash(x, objectInfo))
    };
  }
};
GeohashLayer.layerName = "GeohashLayer";
GeohashLayer.defaultProps = defaultProps40;
var geohash_layer_default = GeohashLayer;
export {
  a5_layer_default as A5Layer,
  geohash_layer_default as GeohashLayer,
  great_circle_layer_default as GreatCircleLayer,
  h3_cluster_layer_default as H3ClusterLayer,
  h3_hexagon_layer_default as H3HexagonLayer,
  mvt_layer_default as MVTLayer,
  quadkey_layer_default as QuadkeyLayer,
  s2_layer_default as S2Layer,
  terrain_layer_default as TerrainLayer,
  tile_3d_layer_default as Tile3DLayer,
  tile_layer_default as TileLayer,
  trips_layer_default as TripsLayer,
  GeoCellLayer_default as _GeoCellLayer,
  Tile2DHeader as _Tile2DHeader,
  Tileset2D as _Tileset2D,
  WMSLayer as _WMSLayer,
  getURLFromTemplate as _getURLFromTemplate
};
/*! Bundled license information:

long/dist/long.js:
  (**
   * @license long.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
   * Released under the Apache License, Version 2.0
   * see: https://github.com/dcodeIO/long.js for details
   *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=@deck__gl_geo-layers.js.map
